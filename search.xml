<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÁõ∏ÂÖ≥ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F11%2FLagrange%2F</url>
    <content type="text"><![CDATA[ÊäÄÂ∑ß ÊèèËø∞ÊñπÂºè Â∞ΩÈáè‰ΩøÁî®Â§çÂêàÈÄÜÁöÑÊ¶ÇÂøµÊù•ÊèèËø∞ÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºåËøôÊ†∑ÂèØ‰ª•ÁúÅÂéªÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ ÂÆö‰πâËÆ∞Âè∑ \(F(x)^{-1}\) Ë°®Á§∫ \(F(x)\) ÁöÑÂ§çÂêàÈÄÜ (Ê≥®ÊÑè‰∏çË¶Å‰∏éÂÄíÊï∞Ê∑∑Ê∑Ü)Ôºå‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÊãâÊ†ºÊúóÊó•ÂèçÊºîÂÖ¨ÂºèÂèØ‰ª•Ë°®Á§∫‰∏∫ \[ [x^n]F(x)^{-1} = \frac 1 n[x^{-1}] \frac 1 {F^n(x)} \\\\ [x^n]G(F(x)^{-1}) = \frac 1 n [x^{-1}] \frac{G&#39;(x)}{F^n(x)} \] ÈÄöËøá‰∏éÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÂá†‰πéÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑËØÅÊòéÊñπÊ≥ïÂèØ‰ª•ËØÅÊòéÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÁöÑ‰∏Ä‰∏™Êâ©Â±ïÔºöËã• \(F(G(x)) = H(x)\)ÔºåÂàô \([x^n]F(x) = \frac 1 n [x^{-1}] \frac{H&#39;(x)}{G^n(x)}\)„ÄÇÁ¨¨‰∫å‰∏™ÂºèÂ≠ê‰∏éËøô‰∏ÄÁªìËÆ∫ÊòØÁ≠â‰ª∑ÁöÑÔºå‰ΩÜÊòØÂª∫ËÆÆÂ∞ΩÂèØËÉΩ‰ΩøÁî®Á¨¨‰∫å‰∏™ÂºèÂ≠êËÄå‰∏çË¶Å‰ΩøÁî®Ëøô‰∏™ÁªìËÆ∫„ÄÇ Êé®ÂØºÊäÄÂ∑ß Èô§‰∫ÜÁßªÈ°πÁ≠âÂèòÂΩ¢‰πãÂ§ñÔºåËøòÂèØ‰ª•Âà©Áî®Â§çÂêàËøõË°åÂåñÁÆÄ„ÄÇÁî®Â§çÂêàÂåñÁÆÄÊó∂Ê≥®ÊÑèË¶ÅÁÅµÊ¥ª‰ΩøÁî®Â∑¶Âè≥ÈÄÜÔºåÂç≥ÁÅµÊ¥ª‰ΩøÁî® \(A(x) = B(x) \Rightarrow F(A(x))= F(B(x))\) Âíå \(A(x) = B(x) \Rightarrow A(F(x)) = B(F(x))\)ÔºåÈÅøÂÖç‰∏ÄÁõ¥Âè™ÊÉ≥Âà∞ÂÖ∂‰∏≠‰∏ÄÁßçÁöÑÊÉÖÂÜµ„ÄÇ ÂØπ‰∫é \(F(G(x)) = H(x)\)ÔºåÁü• \(H(x), F(x)\) Ê±Ç \([x^n] G(x)\) ÁöÑÊÉÖÂÜµÔºåÁõÆÂâçÊöÇ‰∏çÁü•Êúâ‰ªÄ‰πàÂ•ΩÁöÑÂÅöÊ≥ïÔºå‰ΩÜÊòØÂØπ‰∫é‰∏Ä‰∫õ \(H(x)\) ‰∏é \(G(x)\) ÊúâËæÉ‰∏∫ÁÆÄÂçïÁöÑÂÖ≥Á≥ªÁöÑÈóÆÈ¢òÊòØÂèØÂÅöÁöÑ„ÄÇ ‰æãÂ¶Ç \(F(G(x)) = xG(x) \Rightarrow F(G(G^{-1}(x))) = G^{-1}(x)G(G^{-1}(x)) \Rightarrow F(x) = x G^{-1}(x)\)ÔºåÂç≥ \(G\) ÊòØ \(\frac {F(x)} x\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5827] ÁÇπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F11%2FLuogu5827%2F</url>
    <content type="text"><![CDATA[ÂàöÂºÄÂßã‰ª•‰∏∫ÂíåËæπÂèåÊ≤°Âï•Â∑ÆÂà´..ÁªìÊûúÂêéÊù•Êêû‰∫ÜÂ•Ω‰πÖ„ÄÇ UPDÔºöÂ•ΩÂÉèÂ≠òÂú®Êõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ï„ÄÇ ÂÅöÊ≥ï ËÆæ \(n\) ‰∏™ÁÇπÁöÑÁÇπÂèåËøûÈÄöÂõæÊúâ \(f_n\) ‰∏™ÔºåËøûÈÄöÂõæÊúâ \(g_n\) ‰∏™ÔºåÂÆÉ‰ª¨ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÈí¶ÂÆöÊ†π) Êàë‰ª¨ËÆ§‰∏∫‰∏Ä‰∏™ÁÇπÁöÑÂõæ‰∏çÁÇπÂèåËøûÈÄöÔºå‰∏îËøô‰∏Ä‰∏™ÁÇπ‰∏∫Ââ≤ÁÇπ„ÄÇÁî±‰∫éÈ¢òÁõÆÈáå‰∏Ä‰∏™ÁÇπÊòØÁÆóÁÇπÂèåËøûÈÄöÂõæÁöÑÔºåË¶ÅÁâπÂà§‰∏ã„ÄÇ ËÆæ \(n\) ‰∏™ÁÇπÁöÑÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæ‰∏™Êï∞‰∏∫ \(b_n\)ÔºåÂÖ∂ EGF ‰∏∫ \(B(x)\)„ÄÇÊ†πÊçÆÂâ≤ÁÇπÁöÑÂÆö‰πâÔºåÂéªÊéâÊ†π‰πãÂêéÁöÑÁÇπÊûÑÊàê‰∏Ä‰∏™ËøûÈÄöÂõæÔºåÊâÄ‰ª• \(b_n = \frac n {n!}(2^{n-1}-1)(n-1)!g_{n-1}=(2^{n-1}-1)g_{n-1}\ (n \ge 2)\)„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåÂåÖÂê´‰∏çÊòØÂâ≤ÁÇπÁöÑÁÇπÁöÑÁÇπÂèåÊòØÂîØ‰∏ÄÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Êûö‰∏æÂåÖÂê´Ê†πÁöÑÁÇπÂèåÁöÑÂ§ßÂ∞èÊù•ËÆ°ÁÆó \(B(x)\)„ÄÇËÆæ \(H(x) = G&#39;(x)\) (ÂØπ EGF Ê±ÇÂØºÁõ∏ÂΩì‰∫éÂπ≥Áßª‰∫Ü)ÔºåÂåÖÂê´Ê†πÁöÑÁÇπÂèåÂ§ßÂ∞è‰∏∫ \(n\) ‰∏îÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(n\frac{f_n}{n!}x^n H^{n-1}(x)\) (ËÄÉËôëÂÜ≥ÂÆöÊ†πÔºåÁÑ∂ÂêéÂÜ≥ÂÆöËøô‰∏™ÁÇπÂèå‰∏≠Èô§‰∫ÜÊ†π‰ª•Â§ñÊØè‰∏™ÁÇπÊåÇÁöÑËøûÈÄöÂõæ)„ÄÇ ËÆæ \(C(x) = \frac{B(x)}x\)ÔºåÂàô \[ B(x) = \sum_{n \ge 1} n\frac{f_n}{n!} x^n H^{n-1}(x) = xF&#39;(xH(x)) \\\\ xC(x) = xF&#39;(xH(x)) \\\\ C(x) = F&#39;(xH(x)) \] ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \[ [x^n] F(x) = \frac 1 n[x^{n-1}] F&#39;(x)=\frac 1 {n(n-1)}[x^{-1}]\frac{C&#39;(x)}{(xH(x))^{n-1}} \] ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; const int N = 100000; poly tmp(N + 1); for (int i = 0; i &lt;= N; i++) &#123; tmp.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnT = polyLn(tmp); poly G(N + 1); for (int i = 1; i &lt;= N; i++) &#123; // G.a[i] = 1LL * lnT.a[i] * i % mod; G.a[i] = lnT.a[i]; &#125; poly H(N); for (int i = 0; i &lt; N; i++) &#123; H.a[i] = 1LL * (i + 1) * G.a[i+1] % mod; &#125; poly B(N+1); int _ = 1; for (int i = 1; i &lt;= N; i++) &#123; B.a[i] = 1LL * (_ - 1) * G.a[i-1] % mod; _ = 1LL * _ * 2 % mod; &#125; poly C(N); for (int i = 0; i &lt; N; i++) &#123; C.a[i] = B.a[i+1]; &#125; poly lnH = polyLn(H); poly dC(N-1); for (int i = 0; i &lt; N-1; i++) &#123; dC.a[i] = 1LL * C.a[i+1] * (i+1) % mod; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); if (n == 1) &#123; puts("1"); continue; &#125; poly nH = poly(n); for (int i = 0; i &lt; n; i++) &#123; nH.a[i] = 1LL * lnH.a[i] * (mod - (n - 1)) % mod; &#125; poly res = polyExp(nH) * dC; int ans = 1LL * res.a[n - 2] * qpow(n - 1, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5828] ËæπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F10%2FLuogu5828%2F</url>
    <content type="text"><![CDATA[‰πãÂâçËØïÂõæÈÄöËøáÁî®Ê†ëÁöÑÁîüÊàêÂáΩÊï∞Â§çÂêàËæπÂèåÁöÑÁîüÊàêÂáΩÊï∞Êù•ÂæóÂà∞Á≠îÊ°à...‰ΩÜÊòØÈóÆÈ¢ò‰ºº‰πéÁ≠â‰ª∑‰∫éÂ∑≤Áü• \(F(x), H(x)\)Ôºå\(F(G(x)) = H(x)\)ÔºåÊ±Ç \([x^n] G(x)\)„ÄÇÊàë‰∏çÊòØÂæà‰ºöÔºåÂ¶ÇÊûúÊúâ‰∫∫‰ºöÁöÑËØùÊ±ÇÊïôÊàë‰∏Ä‰∏ã /kel„ÄÇ ‰∏ãÈù¢ÂÜôÁöÑÊòØÈ¢òËß£ÂÅöÊ≥ï„ÄÇ UPDÔºöÊ†ëÁöÑÁîüÊàêÂáΩÊï∞ÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁúãÂÅö‰∏Ä‰∏™ÊãâÊ†ºÊúóÊó•ÂèçÊºîÁöÑÁªìÊûú..ÊâÄ‰ª•ÊÑüÊÄßÁêÜËß£‰∏Ä‰∏ãÂèØ‰ª•ÁªïËøá‰∏äÈù¢ÈÇ£‰∏™ÂºèÂ≠êÊòØ‰∏Ä‰∏™ÂæàËá™ÁÑ∂ÁöÑ‰∏úË•ø„ÄÇ(Á∫ØÂ±ûËÉ°Ë®Ä‰π±ËØ≠) ÂÅöÊ≥ï ËÆæÊúâÊ†πËæπÂèåÂíåÊúâÊ†πËøûÈÄöÂõæ (ÊúâÊ†πÂ∞±ÊòØÈí¶ÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπ‰ΩúÊ†π) ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÂåÖÂê´Á©∫Âõæ) ‰ºóÊâÄÂë®Áü•ÔºåËÆæÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(H(x)\)ÔºåÂàôËøûÈÄöÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(\ln H(x)\)ÔºåÊâÄ‰ª• \(G(x) = \frac {xH&#39;(x)} {H(x)}\) (‰∏çÁî®ÁúüÁöÑÊåâÁÖßËøô‰∏™ÂºèÂ≠êÂéªÁÆóÔºåÂ∞±ÊòØÁ¨¨ \(i\) È°π‰πò‰ª• \(i\) ÁöÑÊÑèÊÄù)„ÄÇ ËÄÉËôëÊ†πÊâÄÂú®ÁöÑËæπÂèåÊÅ∞Â•Ω‰∏∫ \(n\) ÁöÑËøûÈÄöÂõæÊï∞ÔºåËøôÊ†∑ÁöÑËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ÊòØ \(x^n f_n \sum_k n^k \frac{G^k(x)}{k!}=x^nf_n\exp(nG(x))\)„ÄÇ ÊâÄ‰ª•Êúâ \(G(x) = \sum_{n \ge 1} f_n (x\exp G(x))^n=F(x\exp G(x))\)„ÄÇ ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \([x^n] F(x) = \frac 1 n[x^{-1}]\frac {G&#39;(x)}{(x\exp G(x))^n}\) ÊàëÈÄâÊã©Ë¥¥Êùø üíäüíäüíä ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; poly G, dG; &#123; int n = 100000; poly H(n + 1); for (int i = 0; i &lt;= n; i++) &#123; H.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnH = polyLn(H); G = poly(n + 1); for (int i = 1; i &lt;= n; i++) &#123; G.a[i] = 1LL * lnH.a[i] * i % mod; &#125; dG = poly(n); for (int i = 0; i &lt; n; i++) &#123; dG.a[i] = 1LL * G.a[i+1] * (i+1) % mod; &#125; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); poly nG = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nG.a[i] = 1LL * G.a[i] * (mod - n) % mod; &#125; poly res = polyExp(nG) * dG; int ans = 1LL * res.a[n-1] * qpow(n, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3684] Â§ßÊúãÂèãÂíåÂ§öÂèâÊ†ë]]></title>
    <url>%2F2020%2F05%2F10%2Fbzoj3684%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÁÇπÊùÉ‰∏∫ \(k\) ÁöÑÊ†ëÊúâ \(a_k\) Ê£µÔºåËÆæ \(A(x) = \sum_{i\ge 1} a_i x^i\) ËÆæ \(D(x) = \sum x^{d_i}\) Êúâ \(A(x) = D(A(x)) + x\)„ÄÇËÆæ \(C(x) = x - D(x)\)ÔºåÂàô \(C(A(x)) = x\) ÂÖ∂‰∏≠ \(C\) Âíå \(A\) ÈÉΩÊòØÊ≤°ÊúâÂ∏∏Êï∞È°π‰∏î‰∏ÄÊ¨°È°π‰∏∫ \(1\) ÁöÑÂ§öÈ°πÂºè„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \([x^s] A(x)\)Ôºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºö\([x^s] A(x) = \frac 1 s [x^{-1}] \frac 1 {C^s(x)}\) ËÆæ \(C(x) = xP(x)\)ÔºåÂàô \([x^s]A(x) = \frac 1 s [x^{s-1}] \frac 1 {P^s(x)}\) Ê±Ç‰∏™ÈÄÜÁÑ∂ÂêéÂ§öÈ°πÂºèÂø´ÈÄüÂπÇ‰∏Ä‰∏ãÂç≥ÂèØÔºå‰πüÂèØ‰ª•ÂÖà \(\ln\) ÂÜç \(\exp\)„ÄÇ BZOJ ‰∏äÂø´ÈÄüÂπÇ T ‰∫ÜÔºå‰ΩÜÊòØË¥¥‰∫Ü‰∏™ÊùøÂ≠êÊîπÊàê \(\ln\) + \(\exp\) Â∞±Ëøá‰∫ÜÔºåÁúã‰∫ÜÁ°ÆÂÆûÊòØÊØîÂø´ÈÄüÂπÇÂø´ÁöÑ„ÄÇ (BZOJ Á°ÆÂÆûÂ§™ÊÖ¢‰∫Ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 950009857;const int maxn = 100010;int g = 0;int s, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int wl[21];vector&lt;int&gt; vp;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int checkg(int g) &#123; int ok = 1; for (int i = 0; i &lt; vp.size(); i++) &#123; int p = vp[i]; if (qpow(g, (mod - 1) / p) == 1) &#123; ok = 0; &#125; &#125; return ok;&#125;struct poly &#123; int *a, len; poly (int len_=0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int _wl = wl[++ _]; for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = mo(v1 + v2); a[s + i + (len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL * w * _wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * inv * a[i] % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l - i]); &#125; &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int _l = 0; while ((1 &lt;&lt; _l) &lt; ret.len) &#123; ++ _l; &#125; int l = (1 &lt;&lt; _l); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, _l, 1), ntt(wb, _l, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, _l, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly qpow(poly p, int x) &#123; int l = p.len; poly ret(1); ret.a[0] = 1; while (x) &#123; if (x &amp; 1) &#123; ret = ret * p; ret.len = l; &#125; x &gt;&gt;= 1; p = p * p; p.len = l; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0 (tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; v0.a[0] = (v0.a[0] + mod - 2) % mod; for (int i = 0; i &lt; p.len; i++) &#123; v0.a[i] = (mod - v0.a[i]) % mod; &#125; v0.len = p.len; poly v1 = v0 * r0; v1.len = p.len; return v1;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;int main() &#123; &#123; int _ = mod - 1; for (int i = 2; i * i &lt;= _; i++) &#123; if (_ % i == 0) &#123; vp.push_back(i); while (_ % i == 0) &#123; _ /= i; &#125; &#125; &#125; if (_ &gt; 1) &#123; vp.push_back(_); &#125; for (int i = 2; i &lt;= mod; i++) &#123; if (checkg(i)) &#123; g = i; break; &#125; &#125; &#125; for (int i = 0; i &lt;= 20; i++) &#123; wl[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; scanf("%d%d", &amp;s, &amp;m); poly P(s); for (int i = 1; i &lt;= m; i++) &#123; int x = 0; scanf("%d", &amp;x); P.a[x - 1] = mod - 1; &#125; P.a[0] = 1; poly lnP = polyLn(P); int t = (mod - s) % mod; for (int i = 0; i &lt; lnP.len; i++) &#123; lnP.a[i] = 1LL * lnP.a[i] * t % mod; &#125; poly res = polyExp(lnP); int ans = 1LL * qpow(s, mod-2) * res.a[s-1] % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(C(x) = \sum x^{c_i}\)Ôºå\(a_i\) ÊòØÊùÉÂÄºÂíå‰∏∫ \(i\) ÁöÑ‰∫åÂèâÊ†ëÊï∞Èáè (ÁâπÂà´Âú∞ÔºåÁ©∫‰∫åÂèâÊ†ëÁÆó‰Ωú‰∏ÄÁßçÊùÉÂÄºÂíå‰∏∫ \(0\) ÁöÑ‰∫åÂèâÊ†ë)Ôºå\(A(x) = \sum_{i \ge 0} a_ix^i\)„ÄÇ Âàô \(A(x) = A^2(x)C(x)+ 1\)Ôºå\(C(x)A^2(x)-A(x)+1=0\)„ÄÇÁî±‰∏ÄÂÖÉ‰∫åÊ¨°ÊñπÁ®ãÊ±ÇÊ†πÂÖ¨ÂºèÂæó \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)ÔºåÁî±‰∫éÂàÜÊØçÊ≤°ÊúâÂ∏∏Êï∞È°πÔºåËøôÈáåÂ∫îËØ•ÂèñË¥üÂè∑„ÄÇ ‰∫éÊòØÂ§öÈ°πÂºèÂºÄÊ†π‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇ(Âõ†‰∏∫ \([x^0] (1-4C(x)) = 1\)ÔºåÂè™Â≠òÂú®‰∏§‰∏™ÁöÑÂ§öÈ°πÂºè \(F(x)\) Êª°Ë∂≥ \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)Ôºå‰∏ÄÊ≠£‰∏ÄË¥ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[Á•û‰ªôÈ¢òÔºå‰πãÂâçÂê¨‰∫∫ÊèêËøá„ÄÇ‰ΩÜÊòØÂá∏ÊÄßÂÆåÂÖ®‰∏ç‰ºöËØÅÔºå‰ºö‰∫Ü‰πãÂêéË°•‰∏ä QwQ„ÄÇ ÂÅöÊ≥ï ÊòæÁÑ∂‰Ωø \(\sum s_i^2\) ÂèñÂà∞ÊúÄÂ∞èÂÄºÁöÑÂàíÂàÜ‰∏ÄÂÆöÊª°Ë∂≥Êù°‰ª∂„ÄÇ ÊâÄ‰ª•‰∫åÂàÜÊñúÁéáÊ±ÇÂá∫ \(\sum s_i^2\) ÊúÄÂ∞èÁöÑÂ∫èÂàóÂ∞±Ë°å‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éÊàëÊ∞¥Âπ≥Â§™‰ΩéÊôÆÂèäÁªÑÁü•ËØÜÁÇπÈÉΩÊ≤°ÊéåÊè°Ôºå‰ªäÂ§©Áªà‰∫éÊêûÊáÇ‰∫Ü‰∏ÄÁÇπÊâÄ‰ª•ÊâìÁÆóËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢ËÆ®ËÆ∫ÁöÑÈÉΩÊòØÊó†ÂêëÂõæÔºåÁî±‰∫éËøûÈÄöÂùóÈó¥Áã¨Á´ãÔºåÊàë‰ª¨Âè™ËÄÉËôëËøûÈÄöÂõæÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûúÁÇπÊï∞‰∏∫ \(1\)ÔºåÂú®Êüê‰∫õÈóÆÈ¢ò‰∏ãÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Âè™ËÄÉËôëÁÇπÊï∞‰∏ç‰∏∫ \(1\) ÁöÑÊÉÖÂÜµ„ÄÇ ÂÆö‰πâ 1 ÂØπ‰∫é‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\)ÔºåÂ¶ÇÊûú‰ªé \(G\) Âà†ÂéªÁÇπ \(u\) ÂíåÊâÄÊúâ‰∏éÂÆÉÁõ∏ÈÇªÁöÑËæπÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄöÔºåÂ∞±Áß∞ \(u\) ÊòØ \(G\) ÁöÑ‰∏Ä‰∏™Ââ≤ÁÇπ„ÄÇ ÂÆö‰πâ 2 Ëã•ËøûÈÄöÂõæ \(G\) ‰∏≠‰∏çÂ≠òÂú®Ââ≤ÁÇπÔºåÂàôÁß∞ \(G\) ÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂõæ„ÄÇ ÂÆö‰πâ 3 Áß∞ËøûÈÄöÂõæ \(G\) ÁöÑÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂõæÂ≠êÂõæ‰∏∫ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇ ÊÄßË¥® 1 ‰∏§‰∏™‰∏çÂêåÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑ‰∫§Ëá≥Â§öÂåÖÂê´‰∏Ä‰∏™ÁÇπ„ÄÇ ËØÅÊòé ÂÅáËÆæ‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè \(A\) Âíå \(B\) Êúâ‰∫§ÔºåËÆæËøô‰∏§‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂπ∂‰∏∫ \(H\)ÔºåÊ†πÊçÆÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂÆö‰πâÔºå\(H\) ‰∏ÄÂÆö‰∏çÊòØÁÇπÂèåËøûÈÄöÂõæÔºåÊâÄ‰ª•Â≠òÂú®‰∏Ä‰∏™ÁÇπ \(u\)Ôºå‰ªé \(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂêéÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄö„ÄÇ\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæÂç≥‰∏∫ \(A\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) Âíå \(B\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) ÂæóÂà∞ÁöÑÂõæÁöÑÂπ∂„ÄÇÂ¶ÇÊûú \(A\) Âíå \(B\) ÁöÑ‰∫§Â§ß‰∫é \(1\)ÔºåÁî±‰∫é‰∏§‰∏™Êúâ‰∫§ÁöÑËøûÈÄöÂõæÁöÑÂπ∂‰ªç‰∏∫ËøûÈÄöÂõæÔºå\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæ‰πüÊòØËøûÈÄöÂõæÔºåËøôÂ∞±ÂØºÂá∫‰∫ÜÁüõÁõæ„ÄÇ ÊÄßË¥® 2 Âú®‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\) ‰∏≠ÔºåÂØπ‰∫é‰ªªÊÑè‰∏ÄÊù°Ëæπ \(e\)ÔºåÊÅ∞Êúâ‰∏Ä‰∏™ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÂåÖÂê´Ëæπ \(e\)„ÄÇ ËØÅÊòé Ëæπ \(e\) ÁöÑ‰∏§‰∏™È°∂ÁÇπÁöÑÂØºÂá∫Â≠êÂõæÂ∞±ÊòØ‰∏Ä‰∏™ \(G\) ÁöÑÂ§ßÂ∞è‰∏∫ \(2\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª•‰πü‰∏ÄÂÆöÂ≠òÂú®ÂåÖÂê´Ëæπ \(e\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÁî±ÊÄßË¥® 1 ÂèØÁü•‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏çÂèØËÉΩÂåÖÂê´Âêå‰∏ÄÊù°Ëæπ„ÄÇ Áî±‰∫éÁÇπÂèåËøûÈÄöÂàÜÈáèÊòØËøûÈÄöÁöÑÔºåÂè™Ë¶ÅÁ°ÆÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâËæπÔºåÁÇπ‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÂõæ \(G\) ÁöÑÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÊûÑÊàêËæπÈõÜÁöÑ‰∏Ä‰∏™ÂàíÂàÜ„ÄÇ Âú®Âõæ‰∏ä‰Ωú DFSÔºåÂèñ‰∏ÄÊ£µ‰ª• \(r\) ‰∏∫Ê†πÁöÑ DFS Ê†ëÔºåËÆæÁÇπ \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´ËÆøÈóÆÊó∂Èó¥‰∏∫ \(dfn_u\)Ôºå\(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÈÄöËøá‰∏ÄÊù°ËøîÁ•ñËæπËÉΩÂ§üÂà∞ËææÁöÑ dfn ÊúÄÂ∞èÁöÑÁÇπÁöÑ dfn ‰∏é \(dfn_u\) ÁöÑÊúÄÂ∞èÂÄº‰∏∫ \(low_u\) (Ê≥®ÊÑèËøîÁ•ñËæπÊåáÁöÑÊòØÈùûÊ†ëËæπÔºå‰∏çÂåÖÂê´ \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÔºåÂÆûÁé∞Êó∂Ë¶ÅÁâπÂà§)„ÄÇ ËÆæÁÇπ \(u\) Âú®ËøôÊ£µ DFS Ê†ë‰∏äÁöÑÁà∂‰∫≤‰∏∫ \(fa(u)\)„ÄÇ ÂØπ‰∫éÁÇπ \(u \neq r, fa(u) \neq r\)ÔºåÂ¶ÇÊûú \(low_u &lt; dfn_{fa(u)}\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ÁÇπ \(u, fa(u), fa(fa(u))\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºå‰ªéËÄå \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÂíå \(fa(u)\) Âà∞Áà∂‰∫≤ÁöÑËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ Âú® DFS ÁöÑËøáÁ®ã‰∏≠ÔºåÊØèÁªèËøá‰∏ÄÊù°Ê†ëËæπÂ∞±ÊääËøôÊù°Ê†ëËæπÊîæÂÖ•‰∏Ä‰∏™Ê†à‰∏≠„ÄÇÂú®ÁÇπ \(u\) ÂõûÊ∫ØÊó∂ÔºåÊ£ÄÊü•‰∏Ä‰∏ãÊòØÂê¶Êúâ \(low_u \ge dfn_{fa(u)}\) (Â¶ÇÊûúÊòØÊ†πÁöÑËØù‰∏çÁî®Ê£ÄÊü•‰∫Ü)„ÄÇ ËÄÉËôëÁ¨¨‰∏ÄÊ¨°Êª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂõûÊ∫ØÔºåÊ≠§Êó∂ÁÇπ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπÈÉΩÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÔºåÂõ†Ê≠§Â≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæ„ÄÇÂõ†‰∏∫‰∏çÂ≠òÂú®Ë∑®Ëøá \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÁöÑÈùûÊ†ëËæπÔºåËøô‰∏™ÁÇπÂèåËøûÈÄöÂ≠êÂõæÊòØ‰∏Ä‰∏™ÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª• \(u\) ÁöÑÂ≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊàë‰ª¨ÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÁÇπ‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂Âêé‰ªéÊ†à‰∏≠ÂºπÂá∫ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπ„ÄÇ Âú®‰πãÂêéÁöÑÂõûÊ∫Ø‰∏≠ÔºåÂ¶ÇÊûúÊª°Ë∂≥ \(low_u \ge dfn_{fa(u)}\)ÔºåÈÇ£‰πàÊ≠§Êó∂Ê†à‰∏≠ÊâÄÊúâÊ†ëËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠Ôºå‰∏îËøô‰∫õËæπÁöÑÊâÄÊúâÁ´ØÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰øùÂ≠ò‰∏ãÊù•ÁÑ∂ÂêéÊääÊ†à‰∏≠ÊâÄÊúâ \(u\) Â≠êÊ†ë‰∏≠ÁöÑËæπÂºπÂá∫Âç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n+m)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫‰∫ÜÊØè‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁÇπÈõÜ„ÄÇ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑËæπÂ∞±ÊòØËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÂÜÖÈÉ®ÁöÑÊ†ëËæπÂä†‰∏äËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâÁÇπÁöÑËøîÁ•ñËæπÔºåËøôÂæàÂÆπÊòìÂ§ÑÁêÜ„ÄÇÔºàÊ≥®ÊÑèËøôÈáåËøîÁ•ñËæπÁöÑÂÆö‰πâÊòØ‰ªéÊüê‰∏™ÁÇπÂá∫ÂèëÂà∞ÂÆÉÁ•ñÂÖàÁöÑÈùûÊ†ëËæπÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÊØèÊù°ÈùûÊ†ëËæπÊòØÊÅ∞Â•Ω‰∏Ä‰∏™ÁÇπÁöÑËøîÁ•ñËæπÔºâ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏Ä‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°àÊï∞Á≠â‰∫éÂêÑ‰∏™ÁÇπÂèåÁöÑÊüìËâ≤ÊñπÊ°àÊï∞‰πòÁßØÈô§‰ª•È¢úËâ≤Êï∞ÁöÑ(ÁÇπÂèåÊï∞ - ËøûÈÄöÂùóÊï∞)Ê¨°ÊñπÔºàËÄÉËôëÂØπÊØè‰∏™ËøûÈÄöÂùóÂú®ÂúÜÊñπÊ†ë‰∏ä‰ªé‰∏äÂæÄ‰∏ãÂØπÊØè‰∏™ÁÇπÂèåÊüìËâ≤Ôºâ„ÄÇ Ê†πÊçÆÈ¢òÁõÆ‰∏≠ÁöÑÊù°‰ª∂Ôºå‰∏Ä‰∏™ÁÇπÂèåÁöÑÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøá \(7\)ÔºåÊö¥ÂäõÊûö‰∏æÈõÜÂêàÂàíÂàÜÂèØ‰ª•Ê±ÇÂá∫‰∏Ä‰∏™ÁÇπÂèåÁöÑËâ≤Â§öÈ°πÂºèÔºåÂàÜÊ≤ª fft ‰∏Ä‰∏ãÂç≥ÂèØÂæóÂà∞ÁªôÂÆöÁöÑÂõæÁöÑËâ≤Â§öÈ°πÂºèÔºåÁÑ∂ÂêéÂ§öÁÇπÊ±ÇÂÄº‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ (‰∏∫Âï•‰∏ÄÂÆöË¶ÅÁªôÂêÑÁßçÊüìËâ≤ÊñπÊ°àÊï∞È¢òÂ•ó‰∏™Â§öÁÇπÊ±ÇÂÄº...Â•ΩÊó†ËÅä) ÂÆåÂÖ®‰∏ç‰ºöÂÜôÁÇπÂèå..Ë∞É‰∫Ü‰∏ÄÂ§©„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// Á¨¨‰∏ÄÁ±ªÊñØÁâπÊûóÊï∞int S[10][10];// ‰∏ãÈôçÂπÇÁ≥ªÊï∞int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268E] Expected Value]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(f_i\) ÊòØÁ¨¨ \(i\) Ê≠•Êó∂ÊÅ∞Â•ΩÂà∞ËææÁÇπ \(n\) ÁöÑÊ¶ÇÁéáÔºåÊòæÁÑ∂Êï∞Âàó \(\{f_i\}\) Êª°Ë∂≥‰∏Ä‰∏™‰∏çË∂ÖËøá \(n\) Èò∂ÁöÑÁ∫øÊÄßÈÄíÊé®„ÄÇ Âõ†‰∏∫ÁªôÂÆöÁöÑÂõæÊòØÂπ≥Èù¢ÂõæÔºåÊâÄ‰ª• \(m = \mathcal O(n)\)ÔºåÊàë‰ª¨ÂèØ‰ª•Êö¥ÂäõÊ±ÇÂá∫ \(f\) ÁöÑÂâç \(2n\) È°πÔºåÁÑ∂Âêé BM Âá∫ÈÄíÊé®Âºè„ÄÇÂæóÂà∞ÈÄíÊé®Âºè‰πãÂêé‰πüÂ∞±ÂæóÂà∞‰∫ÜÁîüÊàêÂáΩÊï∞ÔºåÊ±Ç‰∏™ÂØºÊää \(x=1\) ‰ª£ÂÖ•Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[ÂêêÊßΩÔºöËøôÈ¢òÁõÆÂêçÂèñÁöÑ„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÂÅöÊ≥ï Ë¶ÅÊòØ‰∏çÊòØÈ¢ÑÂÖàÁü•ÈÅìÊòØ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖç‰º∞ËÆ°‰∏ÄÊòüÊúüÈÉΩÊÉ≥‰∏çÂà∞„ÄÇ„ÄÇ ËÄÉËôëÊûÑÈÄ†‰∏Ä‰∏™Êó†ÂêëÂõæÔºåÁÑ∂ÂêéÁî®‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖçÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ ÂØπÊØè‰∏™ . Âª∫‰∏Ä‰∏™ÁÇπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ +ÔºåÈÇ£‰πàÂª∫‰∏§‰∏™Êñ∞ÁöÑÁÇπÔºå‰∏§‰∏™Êñ∞ÁöÑÁÇπÈÉΩÂêëÂÆÉÂõõÂë®ÁöÑ . ÂØπÂ∫îÁöÑÁÇπËøûËæπÔºåÁÑ∂Âêé‰∏§‰∏™Êñ∞ÁÇπ‰πãÈó¥Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ *ÔºåÂª∫‰∏§‰∏™Êñ∞ÁÇπÔºå‰∏Ä‰∏™Âêë‰∏ä‰∏ãÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°ËæπÔºå‰∏Ä‰∏™ÂêëÂ∑¶Âè≥ÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°Ëæπ„ÄÇËøôÊ†∑Ëøô‰∏™ÂõæÁöÑÊúÄÂ§ßÂåπÈÖçÂáèÂéª * Âíå + ÁöÑ‰∏™Êï∞Â∞±ÊòØÁ≠îÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÁêÜËÆ∫ÂèØ‰ª•ÂÅöÂà∞ \(\mathcal O(n^2m^2)\)ÔºåÂèØËøá„ÄÇ ÁÑ∂ËÄåÊàëÂÜôÁöÑËøô‰∏™Â∏¶Ëä±Ê†ë‰ºº‰πéÊòØ‰∏âÊñπÁöÑÔºå‰ΩÜÂÆÉ‰πüËøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]„ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçtree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫é‰∏ÄÊù°ÈìæÔºåÂÅáËÆæÂÆÉ‰ªéÊüê‰∏ÄÁ´ØÂºÄÂßãÁ¨¨‰∏Ä‰∏™Â§ß‰∫é \(1\) ÁöÑÁÇπÁöÑÁÇπÊùÉ‰∏∫ \(x\)ÔºåËøô‰∏™ÁÇπ(ÂºÄÂßãÁöÑÈÇ£‰∏ÄÁ´ØÂà∞ÂÆÉ)‰πãÂâçÊúâ \(k\) ‰∏™ÁÇπÔºå‰πãÂêéÊúâ \(l\) ‰∏™ÁÇπÔºå‰πãÂêé \(l\) ‰∏™ÁÇπÁÇπÊùÉ‰πòÁßØ‰∏∫ \(s\)„ÄÇ ÂÅáËÆæËøôÊù°ÈìæÁöÑÁ≠îÊ°àÊØîËøô‰∏™ÁÇπÂ∑¶ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÂíåÂè≥ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÁöÑÁ≠îÊ°àÈÉΩË¶Å‰∏•Ê†º‰ºò„ÄÇ ÈÇ£‰πà \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] ÊâÄ‰ª• \(k = l\)„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰∏ÄÊù°ÈìæÊØîÂÆÉÁöÑÊâÄÊúâÂ≠êÈìæÈÉΩ‰∏•Ê†º‰ºòÔºå‰∏îËøôÊù°Èìæ‰∏äÂ≠òÂú®ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÔºåÈÇ£‰πà‰ªéÂÆÉ‰∏§Á´ØÂºÄÂßãÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÈÉΩÊòØ‰∏≠ÁÇπ„ÄÇ ÊâÄ‰ª•Âè™ÈúÄËÄÉËôëÂÖ® \(1\) ÈìæÂíå‰ª•Êüê‰∏™ÁÇπ‰∏∫‰∏≠ÁÇπÔºåÂÖ∂‰ªñÁÇπÈÉΩÊòØ \(1\) ÁöÑÈìæ„ÄÇ Êç¢Ê†π dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea Êï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[Â§™Á•û‰ªô‰∫ÜÔºåÁúã sol ‰∫Ü„ÄÇ ÂÅöÊ≥ï ÂÖàËßÑÂÆöÂΩì‰∏§‰∏™Áü≥Â≠êË∑ùÁ¶ª‰∏∫ \(1\) Êó∂Ôºå‰∏çËÉΩÁßªÂä®ÂùêÊ†áÂ∞èÁöÑÁü≥Â≠ê„ÄÇËøôÊ†∑Â∞±Âè™ÈúÄË¶ÅÂØπÊìç‰ΩúÂ∫èÂàóËÆ°Êï∞‰∫Ü„ÄÇ ËÄÉËôëÂØπÊúâ \(K\) ‰∏™ÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÊñπÊ°àËÆ°Êï∞„ÄÇ\(K = N\) ÁöÑÊÉÖÂÜµÂæàÂÆπÊòìÂçïÁã¨ËÄÉËôë„ÄÇ ÂØπ‰∫é \(K &lt; N\) ÁöÑÊÉÖÂÜµÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÁ°ÆÂÆö‰∫ÜÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÔºåËÄÉËôë‰∏Ä‰∏™Â∫èÂàó \(s\)ÔºåËã•Á¨¨ \(i\) ‰∏™ÊääÊüêÁü≥Â≠êÂùêÊ†á \(+1\) Êìç‰ΩúÁßªÂä®ÁöÑÊòØÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÔºå\(s_i = -1\)ÔºåÂê¶Âàô \(s_i = 1\)„ÄÇËøôÊ†∑ÁöÑ‰∏Ä‰∏™Â∫èÂàó \(s\) ÊòæÁÑ∂Êª°Ë∂≥ \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)„ÄÇÂØπ‰∫é‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂ∫èÂàó \(s\)ÔºåÊàë‰ª¨Êù•ËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊää‚ÄúÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂùêÊ†áÂ§ßÁöÑÁü≥Â≠êÁöÑ‰ΩçÁΩÆ‚ÄùÁöÑÊìç‰ΩúÊèíÂÖ•Âà∞Ëøô‰∏™ÔºàÂè™ÂåÖÂê´ÊääÊüêÁü≥Â≠êÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÔºâÊìç‰ΩúÂ∫èÂàó‰πã‰∏≠ÁöÑÊñπÊ°à„ÄÇÊòæÁÑ∂ \(s\) ‰∏≠Êúâ \(B\) ‰∏™ \(1\)Ôºå\(K-B\) ‰∏™ \(-1\)„ÄÇÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÊèíÂú® \(s_i\) ÂØπÂ∫îÁöÑÊìç‰ΩúÂíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥ÔºåÈÇ£‰πà \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)„ÄÇËÆæ \(t_i = \sum_{k \le i} s_k\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êìç‰ΩúË¢´ÊèíÂÖ•Âú® \(s_i\) Âíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥Ôºå‰∏îÂ≠òÂú® \(j &gt; i\)Ôºå\(t_j \le t_i\)ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∫èÂàó‰∏ÄÂÆö‰∏çÂêàÊ≥ï„ÄÇÊâÄ‰ª•ÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰Ωú‰∏ÄÂÆöÂú® \(t_i = B-(K-B)-(B-A)=B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥ÔºåÂÖ∂‰ªñÊìç‰ΩúÂøÖÈ°ªÊèíÂÖ•ÊúÄÂêé‰∏Ä‰∏™ \(t_i = x, x \le B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥Ôºå‰∏îÂè™Ë¶ÅÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÂæóÂà∞ÁöÑÂ∞±ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ‰∫éÊòØÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÊ±ÇÊää \(N-K-1\) ÊãÜÊàê \(B+A-K+1\) ‰∏™ÈùûË¥üÊï¥Êï∞‰πãÂíåÁöÑÊñπÊ°àÊï∞ÔºåËøôÂæàÂÆπÊòìÁî®‰∏Ä‰∏™ÁªÑÂêàÊï∞ËÆ°ÁÆó„ÄÇÊ≥®ÊÑèÂà∞ÂØπ‰∫é‰∏çÂêåÁöÑ \(s\)ÔºåÊèíÂÖ•Êìç‰ΩúÁöÑÊñπÊ°à‰πãÂíå \(K\) ÊúâÂÖ≥ÔºåÊâÄ‰ª•Êàë‰ª¨Êûö‰∏æ \(K\) ÁªüËÆ°Á≠îÊ°àÂç≥ÂèØ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂØπÂ∫îÁöÑ \(K\)ÔºåËÆ°ÁÆóÂØπÂ∫îÁöÑ \(s\) ÁöÑ‰∏™Êï∞ÊòØ‰∏Ä‰∏™Á±ª‰ººÂç°ÁâπÂÖ∞Êï∞ÁöÑÈóÆÈ¢òÔºå‰∏ç‰ºöÁöÑËØùÂèØ‰ª•ÂéªÁúãÁúã AGC021E„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ balancer \((x_i,y_i)\)ÔºåÂ∞±Âú®ÁÇπ \(x_i\) ÂíåÁÇπ \(y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Ê†áÂè∑‰∏∫ \(i\) ÁöÑÊó†ÂêëËæπ„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö\(T=1\) ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëÊâÄÊúâË¢´Áî®Ëøá balancerÔºåÂèØ‰ª•ÂèëÁé∞ÂÆÉ‰ª¨ÂØπÂ∫îÁöÑËæπÊûÑÊàêÁöÑÂ≠êÂõæ‰∏ÄÂÆöÊòØ \(G\) ÁöÑ‰∏ÄÊ£µÁîüÊàêÊ†ëÔºå‰∏îÂ¶ÇÊûúÊääÊúÄÂêéÁªàÊ≠¢ÁöÑ wire ‰Ωú‰∏∫Ê†πÔºåÊØè‰∏™ÁÇπÂà∞ÂÆÉÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÈÉΩÂ∞è‰∫éÂÆÉÁà∂‰∫≤Âà∞ÂÆÉÁà∂‰∫≤ÁöÑÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ„ÄÇÂèçËøáÊù•ÔºåÂÆπÊòìÈ™åËØÅÂ¶ÇÊûúÂ≠òÂú®‰∏ÄÊ£µËøôÊ†∑ÁöÑÁîüÊàêÊ†ëÔºåÈÇ£‰πà‰πüÂ≠òÂú®‰∏ÄÁßçÂêàÊ≥ïÊñπÊ°à„ÄÇ Êää balancer ‰Ωú‰∏∫ÁÇπÂª∫‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂ¶ÇÊûú balancer \(i,j\) ÈÉΩËøûÊé•‰∫ÜÊüê‰∏™ wireÔºå‰∏î \(i &lt; j\)ÔºåÂ∞±‰ªé \(j\) Âà∞ \(i\) Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÂêàÊ≥ïÊñπÊ°àÔºå‰∏ÄÂÆöÂèØ‰ª•‰ªéËøô‰∏™Âõæ‰∏äÊüê‰∏™ÁÇπÂá∫ÂèëÔºåÂà∞Ëææ‰∏éÊØè‰∏™ wire Áõ∏ËøûÁöÑËá≥Â∞ë‰∏Ä‰∏™ balancer„ÄÇÂèçËøáÊù•ÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÊ†∑‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨‰ªéËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancer ÂºÄÂßãÔºåÊåâÁºñÂè∑‰ªéÂ§ßÂà∞Â∞èËÄÉËôëÊØè‰∏™ balancer„ÄÇÁª¥Êä§‰∏Ä‰∏™ balancer ÁöÑÈõÜÂêàÔºåÂàùÂßãÊó∂Âè™ÊúâËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancerÔºåËÄÉËôëÂà∞‰∏Ä‰∏™ balancer Êó∂ÔºåÂ¶ÇÊûúÂÆÉËøûÊé•ÁöÑ‰∏Ä‰∏™ wire ÊòØÂΩìÂâçÁª¥Êä§ÁöÑÈõÜÂêà‰∏≠Êüê‰∏™ balancer ÁöÑÁ´ØÁÇπÔºåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÂ∞±ÊääËøô‰∏™ balancer Âä†ÂÖ•ÈõÜÂêà„ÄÇÊúÄÂêéÂæóÂà∞ÁöÑÈõÜÂêàÊòæÁÑ∂ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÁîüÊàêÊ†ë„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑ balancerÔºåÁÑ∂ÂêéÁî®‰ª•‰∏äÁÆóÊ≥ïÊûÑÈÄ†Âç≥ÂèØ„ÄÇ‰ºòÂåñ‰∏Ä‰∏ãÂª∫ËæπÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ wireÔºåÊää‰∏éÂÆÉÁõ∏ÈÇªÁöÑ balancer ÊéíÂ∫èÔºåÂè™ËÄÉËôëÁõ∏ÈÇªÁöÑ balancer ‰πãÈó¥ÁöÑÊúâÂêëËæπ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ DAG ‰∏ä DP ÈóÆÈ¢òÔºåÁõ¥Êé•ÂÅöÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(nm)\)ÔºåÁî® bitset ‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ËÉΩËøá‰∫Ü„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÔºö\(T=2\) ÂΩì \(n \ge 3\) Êó∂Ôºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØèÊù°ËæπÔºåÂèØ‰ª•ÂèëÁé∞ÊÄªÂ≠òÂú®‰∏ÄÁßçÊñπÊ°à‰ΩøÊâÄÊúâ wire ÊúÄÁªà‰∏çÊ±áËÅöÂú®Âêå‰∏Ä‰∏™ÁÇπ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁâπÂà§Êéâ‰∏§Ê£µÊ†ë‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊÉÖÂÜµ„ÄÇ Êûö‰∏æÁ¨¨‰∏Ä‰∏™Êìç‰ΩúÁöÑÁÇπÂèäÂÖ∂Êìç‰ΩúÊñπÂºèÔºåËÆæËøô‰∏™ÁÇπ‰∏∫ \(r\)„ÄÇÊàë‰ª¨ËÄÉËôëËøõË°åÂÆåÁ¨¨‰∏ÄÊ¨°Êìç‰ΩúÂêéÁöÑ‰∏§Ê£µÊ†ë„ÄÇ ËÆæÁ¨¨‰∏ÄÊ£µÊ†ë‰∏∫ \(T_A\)ÔºåÁ¨¨‰∫åÊ£µÊ†ë‰∏∫ \(T_B\)ÔºåÊää \(r\) ‰Ωú‰∏∫‰∏§Ê£µÊ†ëÁöÑÊ†π„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âú®ÊúâÊ†πÊ†ë‰∏äËÄÉËôëÈóÆÈ¢ò„ÄÇ ÂÅáËÆæÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°à‰∏≠Ôºå‰Ω†Âú®Êüê‰∏™Êó∂ÂàªÊääÁÇπ \(u\) ÊüìÈªëÂπ∂Êé•Âà∞ÁÇπ \(v\)ÔºåÈÇ£‰πàÂú®Ëøô‰πãÂêé \(v\) ‰ª•ÂèäÂÖ∂Á•ñÂÖà‰∏ÄÂÆöÈÉΩ‰∏çÂèØËÉΩÊòØÂè∂Â≠êÔºåÊâÄ‰ª•Ê≠§Êó∂ \(T_A\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑÁ≠â‰∫é \(T_B\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑ„ÄÇÂõ†Ê≠§ \(v\) ÂøÖÈ°ªÊòØ \(u\) Âú® \(T_B\) ‰∏äÁöÑÁà∂‰∫≤„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™ÁÇπÂàùÂßãÊó∂Âà∞Ê†πÁöÑË∑ØÂæÑÔºàÁªèËøáÁöÑÁÇπÁöÑÂ∫èÂàóÔºâÂú®‰∏§Ê£µÊ†ë‰∏ä‰∏çÂêåÔºåÊàë‰ª¨Áß∞ÂÆÉ‰∏∫‰∏çÂ•ΩÁöÑÔºåÂê¶ÂàôÊàë‰ª¨Áß∞ÂÆÉ‰∏∫Â•ΩÁöÑ„ÄÇÊòæÁÑ∂Êàë‰ª¨‰∏ç‰ºöÊüìÈªëÂ•ΩÁöÑÁÇπÔºåËÄå‰∏çÂ•ΩÁöÑÁÇπÂøÖÈ°ªË¶ÅË¢´ÊüìÈªë„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËß£ÂÜ≥ÂèØË°åÊÄßÈóÆÈ¢ò„ÄÇ ‰∫ãÂÆû‰∏äÔºåÂ≠òÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°àÁ≠â‰ª∑‰∫éÂ≠òÂú®‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÁöÑÊéíÂàóÔºå‰ΩøÂæóÔºö - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_A\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂâç„ÄÇ - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_B\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂêé„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÊòØÂê¶Â≠òÂú®ÊãìÊâëÂ∫èÁöÑÈóÆÈ¢òÔºåÂà§‰∏Ä‰∏ã DAG Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(Tn^3)\)„ÄÇÁî±‰∫éÊàëÊáíÂÜô‰∫Ü \(\mathcal O(Tn^4)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫éÁªôÂÆöÁöÑÂ∫èÂàó \(a\)ÔºåÊàë‰ª¨ÊääÂÆÉÊãÜÊàê‰∏§‰∏™ÈùûË¥üÂ∫èÂàó \(x\) Âíå \(y\) ÁöÑÂíå„ÄÇÁÑ∂Âêé‰ªÖÁî®‰∏çÂáèÂ∫èÂàóÂéªÂæóÂà∞ \(x\)Ôºå‰ªÖÁî®‰∏çÂ¢ûÂ∫èÂàóÂæóÂà∞ \(y\)„ÄÇ ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫éÈïø‰∏∫ \(k\) Â∫èÂàó \(a\) (ÂÆö‰πâ \(a_0 = a_{k+1} = 0\))ÔºåÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂâçÁºÄ‰∏çÂáèÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)ÔºõÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂêéÁºÄ‰∏çÂ¢ûÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÔºåËÄÉËôë \(i\) ‰ªéÂ∞èÂà∞Â§ßÂú∞ÂÜ≥ÂÆö \(x\) Âíå \(y\) ÁöÑÁ¨¨ \(i\) È°πÔºåÁÑ∂Âêé‰ΩøÂæóÂâç \(i\) È°π \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Â∞ΩÂèØËÉΩÂ∞è„ÄÇÁÑ∂ËÄåÁõ¥Êé•Ë¥™ÂøÉÊòØ‰∏çÂØπÁöÑ„ÄÇÊ≥®ÊÑèÂà∞ÔºåÂØπ‰∫é‰∏§Áßç \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Áõ∏Á≠âÁöÑÊñπÊ°àÔºå\(x_i\) ËæÉÂ∞èÁöÑ‰∏ÄÂÆöÊØîËæÉ‰ºòÔºåËÄå‰∏îÂ¶ÇÊûúÂâç \(i\) È°π‰∏Ä‰∏™ÊñπÊ°àÁöÑ‰ª£‰ª∑ÊØîÂâç \(i\) È°πÊúÄÂ∞è‰ª£‰ª∑ÊñπÊ°àÁöÑ‰ª£‰ª∑ËøòË¶ÅÂ§ßË∂ÖËøá \(2\)ÔºåÂÆÉ‰∏ÄÂÆö‰∏ç‰ºò„ÄÇÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊàë‰ª¨ÂèØ‰ª•Âè™‰øùÁïô‰∏â‰∏™ÊñπÊ°àÔºå‰ΩøÂæóÂÖ∂‰∏≠‰∏ÄÂÆöÊúâ‰∏Ä‰∏™Âú®‰πãÂêéÂèØ‰ª•ÂèòÊàêÊúÄ‰ºòÊñπÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // ÂÖàÂà§Êñ≠ÊòØÂê¶ÂèØËÉΩ‰∏çÂ¢ûÂä† // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // ÂÜçÂà§Êñ≠Âè™Â¢ûÂä†‰∏ÄÈ°πÔºåx ÁöÑÊúÄÂ∞èÂÄºÔºàÊòæÁÑ∂ÂèØ‰ª•Âè™Â¢ûÂä†‰∏ÄÈ°πÔºâ ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏çÂ¶®ÂÅáËÆæ \(n \ge m\)„ÄÇ Âè™‰ºö \(\mathcal O(n \log^2 n)\) Ëá™Èó≠‰∫ÜÔºåÂéªÁúãÈ¢òËß£‰∫Ü„ÄÇ Áî±‰∫é‰Ω†ÁöÑÂÜ≥Á≠ñ‰∏ç‰ºöÂΩ±Âìç‰πãÂêéÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°àÔºåÊâÄ‰ª•ÊòæÁÑ∂ÊØèÊ¨°ÈÄâÊ¶ÇÁéáÂ§ßÁöÑÂ∞±ÊØîËæÉÂ•Ω„ÄÇ ËÆæÁ¨¨ \(k+1\) ‰∏™ÈóÆÈ¢òËÉΩÂ§üÁ≠îÂØπÁöÑÊ¶ÇÁéá‰∏∫ \(p_k\)ÔºåÂÅáËÆæÂâç \(k\) ‰∏™ÈóÆÈ¢ò‰∏≠Á≠îÂØπ‰∫Ü \(a\) ‰∏™ÔºåÈÇ£‰πà \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] ÂàÜ‰∏∫ \(n - a &lt; m - (k - a)\) Âíå \(n-a \ge m - (k - a)\) ËÆ°ÁÆóË¥°ÁåÆ„ÄÇ ËÆæ \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] Á¨¨‰∫åÈÉ®ÂàÜ \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] Âø´ÈÄüËÆ°ÁÆó \(H,G\) ÁöÑÊÑè‰πâÊòØÊúâÂ§öÂ∞ëÊù°‰ªé \((0,0)\) Âà∞ \((n,m)\) ÁöÑÈùûÈôçË∑ØÂæÑ‰∏éÁõ¥Á∫ø \(x+y = s\) ÁöÑ‰∫§ÁÇπÁöÑÊ®™ÂùêÊ†áÂú®Êüê‰∏™ËåÉÂõ¥ÂÜÖ„ÄÇ Áî±Ëøô‰∏™ÁªÑÂêàÊÑè‰πâÂæàÂÆπÊòìÂæóÂá∫ \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] ÊâÄ‰ª•Êàë‰ª¨‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æ \(k\) Á∫øÊÄßÁª¥Êä§ \(H\) Âíå \(G\) ÈúÄË¶ÅÁî®Âà∞ÁöÑÂÄºÔºåÂ∞±Âú® \(\mathcal O(n)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∫§Êç¢ÔºåÂ¶ÇÊûú‰∫§Êç¢ÁöÑÊòØ \(a_i\) Âíå \(a_j\)ÔºåÂú®ÁÇπ \(i\) ÂíåÁÇπ \(j\) ‰πãÈó¥Ëøû‰∏ÄÊù°ËæπÔºåÊ†áÂè∑‰∏∫ \(i\)„ÄÇ ËÆæ \(S_1\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_2\) ÊòØÊâÄÊúâ‰∏§‰∏™Â∫èÂàó‰∏≠ÈÉΩÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_3\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêà„ÄÇ \(S_1\) Âíå \(S_3\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(1\)Ôºå\(S_2\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(2\)„ÄÇ‰∏çÈöæËØÅÊòéÔºåÂ¶ÇÊûúÊúÄÁªà‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ \(G\) ÁöÑ‰∏Ä‰∏™ËøûÈÄöÂùóË¶Å‰πàÊòØ‰∏ÄÊù° \(S_1\) ‰∏≠ÁÇπÂà∞ \(S_3\) ‰∏≠ÁÇπÁöÑË∑ØÂæÑÔºåË¶Å‰πàÊòØ‰∏Ä‰∏™ \(S_2\) ÂÜÖÈÉ®ÁöÑÁéØ„ÄÇ ËÄÉËôëÂØπËÉΩ‰Ωø‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ÁöÑÂõæÁöÑÂΩ¢ÊÄÅÂíåËæπÁöÑÊ†áÂè∑ËÆ°Êï∞ÔºåÈÇ£‰πàÔºåÂØπ‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂõæ \(G\)Ôºå‰∏Ä‰∏™ÁéØ‰∏äÁöÑÊ†áÂè∑È°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºå‰∏ÄÊù°ÈìæÊ†áÂè∑‰∏ÄÂÆöÊòØ‰ªé \(S_1\) ‰∏Ä‰æßÂà∞ \(S_3\) ‰∏Ä‰æßÈÄíÂ¢û„ÄÇÊâÄ‰ª•Â¶ÇÊûúÂÜ≥ÂÆö‰∫Ü \(G\)ÔºåÂèØ‰ª•ÂÖàÂÜ≥ÂÆöÊØè‰∏™ËøûÈÄöÂùóÁöÑËæπÁî®Âì™‰∫õÊ†áÂè∑ÔºåÁÑ∂ÂêéÂØπ‰∫éÁéØÂèØ‰ª•‰ªªÊÑèÊéíÂàóÔºåÈìæÂè™Êúâ‰∏ÄÁßçÊ†áÂè∑ÊñπÂºè„ÄÇ ËÄÉËôëÂÜ≥ÂÆö \(S_2\) ‰∏≠ÁöÑÂõæÁöÑÁªìÊûÑÔºåÊàë‰ª¨ÂèØ‰ª•ÂÜôÂá∫ÁéØÂíåÈìæÁöÑ EGFÔºå\(C(x)\) Âíå \(P(x)\)„ÄÇ \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) È¢òÁõÆ‰∏≠Ë¶ÅÊ±ÇÁöÑÂç≥ÊòØ \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)„ÄÇ NTT ‰∏Ä‰∏ãÂç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇÔºàÂÖ∂ÂÆûÁõ¥Êé•ÂÜô‰∏äÁ≥ªÊï∞Â∞±ÊòØ‰∫ÜÔºåÂâçÈù¢Êé®ÁöÑÂÆåÂÖ®Áî®‰∏çÂà∞...Ôºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂêêÊßΩÔºö‰∏∫Âï•ËøôÁßçÊ≤°Âï•ÊÑèÊÄùÁöÑÈ¢ò‰ºöÊòØ agc ÁöÑ F È¢ò„ÄÇ Ëøô‰∏™Ê∏∏ÊàèÊòØ‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÁöÑÂíåÔºåÊâÄ‰ª•Âè™Ë¶Å‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏Êàè SG ÂÄº‰∏ç‰∏ÄÊ†∑Â∞±Ë°å„ÄÇ ËÄÉËôëÊåâ \(SG\) ÂÄº \(dp\)Ôºå\(dp_{S}\) Ë°®Á§∫ÈõÜÂêà \(S\) ‰∏≠‰ªª‰ΩïÁöÑÁÇπ SG ÂÄºÈÉΩÊØî \(S\) Â§ñ‰ªª‰ΩïÁÇπÊ∂àÔºåËá≥Â∞ë‰∏ÄÁ´ØÂú® \(S\) ‰∏≠ÁöÑËæπÁöÑÊñπÊ°àÊï∞„ÄÇ ËΩ¨ÁßªÂ∞±ÊòØÊûö‰∏æ SG ‰∏∫ \(S\) ‰∏≠ÊúÄÂ§ß SG ÂÄºÂä†‰∏ÄÁöÑÁÇπÁöÑÈõÜÂêàÔºåÁÑ∂ÂêéËøô‰∏™ÈõÜÂêàÂÜÖÈÉ®ÊâÄÊúâËæπÈÉΩ‰∏çÈÄâÔºåÊâÄÊúâ‰∏çÂú®Ëøô‰∏™ÈõÜÂêàÂÜÖ‰πü‰∏çÂú® \(S\) ÂÜÖÁöÑÁÇπÂà∞Ëøô‰∏™ÈõÜÂêàËá≥Â∞ëÊúâ‰∏ÄÊù°ËæπÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞ÔºõËøô‰∏™ÈõÜÂêàÂà∞‰∏çÂú®Ëøô‰∏™ÈõÜÂêà‰∏≠‰πü‰∏çÂú® \(S\) ‰∏≠ÁöÑÁÇπÁöÑËæπÂèØÈÄâÂèØ‰∏çÈÄâÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞„ÄÇÊ≥®ÊÑè \(1,2\) ‰∏çËÉΩÂêåÊó∂Âú®Ëøô‰∏™ÈõÜÂêà„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n3^n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÈóÆÈ¢òÊîæÂà∞‰∏Ä‰∏™Êó†ÂêëÂõæ‰∏äËÄÉËôëÔºåÂ¶ÇÊûúÁ¨¨ \(i\) ‰∏™‰∫∫ÈÄâ‰∫ÜÁÅ´È∏° \(x_i,y_i\)ÔºåÂ∞±Âú® \(x_i,y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Êó†ÂêëËæπÔºåÊàë‰ª¨Áß∞ËøôÊù°ËæπÁöÑÊó∂Èó¥‰∏∫ \(i\)„ÄÇ ËÄÉËôë‰∏Ä‰∏™ÁÅ´È∏° \(s\) Âπ∏Â≠òÁöÑÊù°‰ª∂ÔºöÂ¶ÇÊûú \(s\) Âú®Êó∂Âàª \(t\) Ê≤°Ë¢´ÂêÉÊéâÔºåÂØπ‰∫éÊØè‰∏ÄÊù°Ëæπ \(\{s,v\}\)ÔºåÂ¶ÇÊûúËøôÊù°ËæπÁöÑÊó∂Èó¥Â∞è‰∫éÁ≠â‰∫é \(t\)ÔºåË¢´ÂêÉÊéâÁöÑÈÉΩÊòØÁÅ´È∏° \(v\)Ôºå‰∫éÊòØÁÅ´È∏° \(v\) Ë¶ÅÂú®ËøôÊù°ËæπÁöÑÊó∂Èó¥Âπ∏Â≠òÔºåÂ¶ÇÊ≠§‰º†ÈÄí‰∏ãÂéªÔºåÊúÄÁªà‰ºöÂæóÂà∞Ëã•Âπ≤Êù°Ë¢´ÂêÉÊéâÁöÑÁÅ´È∏°Á°ÆÂÆöËæπÔºåËøô‰∫õËæπ‰ºöÊûÑÊàê‰∏ÄÊ£µÊ†ëÔºàÂ¶ÇÊûú‰∏çÊûÑÊàê‰∏ÄÊ£µÊ†ëÁöÑËØùÁÅ´È∏° \(s\) ‰∏çÂèØËÉΩÂπ∏Â≠òÔºâ„ÄÇÊòæÁÑ∂Âè™Ë¶ÅËøô‰∏™Ê†ë‰∏äÁöÑËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Êª°Ë∂≥‰∫ÜÊù°‰ª∂Ôºå\(s\) ‰πü‰∏ÄÂÆö‰ºöÂπ∏Â≠ò„ÄÇÂõ†Ê≠§ÁÅ´È∏° \(s\) Âíå \(t\) ÂêåÊó∂Âπ∏Â≠òÁöÑÊù°‰ª∂Â∞±ÊòØÂÆÉ‰ª¨ÂØπÂ∫îÁöÑÁ°ÆÂÆöÁöÑËæπÊ≤°ÊúâÂÜ≤Á™Å„ÄÇ Áî±‰∫é‰∏Ä‰∏™ÁÅ´È∏°Âπ∏Â≠òÁöÑÊù°‰ª∂‰∏≠ÊúÄÂ§ö \(n-1\) Êù°ËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Ë¢´Á°ÆÂÆöÔºåÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊ£ÄÊü•‰∏§‰∏™ÁÅ´È∏°ÊòØÂê¶ÂèØ‰ª•ÂêåÊó∂Âπ∏Â≠òÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â¶ÇÊûúÁ∫¢Ê†ë‰∏äÊúâ‰∏ÄÊù°Ëæπ \((u,v)\)Ôºå\(u\) Âíå \(v\) Âú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\)ÔºåÈÇ£‰πà Sigma Ëµ∞Âà∞ \(u\) Êàñ \(v\) Â∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª‰∫Ü„ÄÇ Êàë‰ª¨ÊääÂ≠òÂú®‰∏ÄÊù°Áõ∏ÈÇªÁ∫¢ËæπÂú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\) ÁöÑÁÇπÊ†áËÆ∞‰∏Ä‰∏ãÔºåÂè™Ë¶ÅÂà∞ËææËøôÁßçÁÇπÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥ÂæÄ‰∏ãË∑ë„ÄÇ ÂÅáËÆæ Sigma Âú®ÁÇπ \(X\)ÔºåSugim Âú®ÁÇπ \(Y\)ÔºåËÄÉËôëËìùÊ†ëÂéªÊéâÁÇπ \(Y\) ÂêéÂΩ¢ÊàêÁöÑËã•Âπ≤‰∏™ËøûÈÄöÂùóÔºåSigma Êó†Ê≥ï‰ªé‰∏Ä‰∏™ËøûÈÄöÂùóÁöÑÊú™Ê†áËÆ∞ÁÇπÂà∞Âè¶‰∏Ä‰∏™ËøûÈÄöÂùó„ÄÇÊâÄ‰ª•ÊòæÁÑ∂ Sugim ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØÔºåÊØèÊ¨°Âú®ËìùÊ†ë‰∏äÂêë \(X\) ÊâÄÂú®ÁöÑÊñπÂêëËµ∞‰∏ÄÊ≠•„ÄÇSigma ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØ‰∏ç‰ºöÈáçÂ§çÁªèËøáËµ∞ËøáÁöÑÁÇπÁöÑ„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞Ê±ÇÂá∫ Sigma ÂèØËÉΩËµ∞Âà∞Âì™‰∫õÁÇπÔºåÂ¶ÇÊûú‰ªñËÉΩËµ∞Âà∞‰∏Ä‰∏™Ê†áËÆ∞ÁÇπÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª„ÄÇÂê¶ÂàôÁ≠îÊ°àÂ∞±ÊòØËÉΩËµ∞Âà∞ÁöÑÁÇπÂú®ËìùÊ†ë‰∏ä‰∏é \(Y\) ÁöÑÊúÄËøúË∑ùÁ¶ª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // Ê≠§Êó∂ Y ÁöÑÊ∑±Â∫¶‰∏∫ T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÖ≥‰∫éÊúÄÈïøÂèçÈìæÊñπÊ°àÁöÑÊûÑÈÄ†]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏Ä‰∫õÊ±ÇÊúÄÈïøÂèçÈìæÁöÑÈ¢òÁõÆ‰ºöËÆ©‰Ω†ÊûÑÈÄ†ÊñπÊ°àÔºåÊØîÂ¶Ç [CTSC2008] Á•≠Á•Ä Âíå CF590E Birthday„ÄÇ ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÂÜôÁöÑÊØîËæÉÊ∏ÖÊô∞ÁöÑÂÅöÊ≥ïÔºår-64 ÁöÑ uoj blog„ÄÇ Â§ßÊ¶ÇÊòØËØ¥Âª∫Âá∫‰∫åÂàÜÂõæÊ±ÇÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÊâÄÊúâ‰∏§ÈÉ®‰∏≠ÂØπÂ∫îÁöÑÁÇπÈÉΩÂú®Áã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÊûÑÊàêÊúÄÈïøÂèçÈìæ„ÄÇ ÊûÑÊàêÂèçÈìæÊòØÊòæÁÑ∂ÁöÑÔºåÊûÑÊàêÊúÄÈïøÂèçÈìæÁöÑÁêÜÁî±‰ºº‰πé‰∏çÂ§™ÂÆåÊï¥Ôºà‰πüÊúâÂèØËÉΩÊòØ‰ΩúËÄÖËßâÂæóËøôËøá‰∫éÊòæÁÑ∂‰∫ÜÔºâÔºåÂùë‰∫ÜÊàëÂæà‰πÖÔºåËøôÈáåËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ËÆæÂéüÂõæÁÇπÊï∞‰∏∫ \(n\)Ôºå‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç‰∏∫ \(m\)ÔºåÈÇ£‰πàÊúÄÂ∞èÈìæË¶ÜÁõñÂ§ßÂ∞è‰∏∫ \(n-m\)ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞è‰∏∫ \(2n - m\)„ÄÇÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÂ∑¶Âè≥ÈÉ®‰∏≠ÂØπÂ∫îÁÇπÈÉΩÂú®ÂÖ∂‰∏≠ÁöÑÁÇπÊúâ \(n-m\) ‰∏™„ÄÇÈ¶ñÂÖàÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÂÆÉÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπËá≥Â∞ëÊúâ‰∏Ä‰∏™Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÔºàÈÇ£ÁØá blog ‰∏≠‰ºº‰πéÁº∫Â∞ë‰∫ÜËøô‰∏ÄÊ≠•ÔºâÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÁÇπÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÈÉΩ‰∏çÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠Ôºå‰∏ÄÂÆöÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Â∑¶ÈÉ®ÂØπÂ∫îÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπÊúâËæπÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπ \(a\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºå‰πüÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÊúâËæπÁöÑÁÇπ \(b\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠„ÄÇÁî±ÂÅèÂ∫èÂÖ≥Á≥ªÁöÑ‰º†ÈÄíÊÄßÂèØÁü• \(a\) Âíå \(b\) Âú®‰∫åÂàÜÂõæ‰∏äÊúâ‰∏ÄÊù°ËæπÔºå‰∏éÊúÄÂ§ßÁã¨Á´ãÈõÜÁöÑÂÆö‰πâÁüõÁõæ„ÄÇÂõ†Ê≠§ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞èÁ≠â‰∫é \(n + Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁÇπÈÉΩÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÁöÑÊï∞Èáè\)Ôºå‰πüÂ∞±ËØÅÊòé‰∫ÜÊàë‰ª¨ÊûÑÈÄ†Âá∫ÁöÑÂèçÈìæÊòØÊúÄÈïøÂèçÈìæ„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] „ÄåJOISC 2017 Day 1„ÄçÂºÄËçíËÄÖ]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ‰∏úË•øÂçóÂåóÊñπÂêëÂêπÁöÑÊ¨°Êï∞ÂàÜÂà´‰∏∫ \(c_E, c_W, c_S, c_N\)„ÄÇ È¢òÊÑèÁõ∏ÂΩì‰∫éÊòØË¶ÅÊ±Ç \(c_E+c_W+c_S+c_N\) ÊúÄÂ∞èÁöÑ \(c_E,c_W,c_S,c_N\)Ôºå‰ΩøÂæóÂú®Âπ≥Èù¢‰∏äÊîæ \(n\) ‰∏™Áü©ÂΩ¢ÔºåÁ¨¨ \(i\) ‰∏™Áü©ÂΩ¢ÁöÑÊ®™ÂùêÊ†áËåÉÂõ¥‰∏∫ \([S_i - c_N, S_i + c_S]\)ÔºåÁ∫µÂùêÊ†áËåÉÂõ¥‰∏∫ \([E_i - c_W, E_i + c_E]\)ÔºåËÉΩÂ§üË¶ÜÁõñ‰ª• \((1,1)\) ‰∏∫Â∑¶‰∏äËßíÁöÑ \(R \times C\) Áü©ÂΩ¢„ÄÇ ÂÅáËÆæÊúâ‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëË∞ÉÊï¥„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[‰æãÈ¢ò LOJ6440 ÂÅöÊ≥ï ËÄÉËôëËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰Ωú‰∏ÄÊù°Â∞ÑÁ∫ø \(y = \frac{Px+R}Q\)ÔºåÂè™ËÄÉËôë \(x &gt; 0\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(y = i\) Â∞±ÊâßË°åÊìç‰Ωú \(A\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(x = i\) Â∞±ÊâßË°åÊìç‰Ωú \(B\)Ôºå\(i\) ÊòØÊ≠£Êï¥Êï∞„ÄÇ ‚ÄúÊìç‰ΩúÂ∫èÂàó‚ÄùÂØπÂ∫îÁöÑ‰ø°ÊÅØË¶ÅÂèØÂêàÂπ∂„ÄÇ ËÄÉËôëÈÄíÂΩíÂú∞Â§ÑÁêÜÈóÆÈ¢òÔºåËÆæ \(A\) Âíå \(B\) ÊòØ‰∏§‰∏™Êìç‰ΩúÂ∫èÂàóÂØπÂ∫îÁöÑ‰ø°ÊÅØ„ÄÇÂÆö‰πâ \(solve(P, Q, R, L, A, B)\) Ë°®Á§∫‰∏Ä‰∏™Âê´Êúâ \(L\) ‰∏™ \(B\)ÔºåÁ¨¨ \(k\) ‰∏™ \(B\) ÂíåÁ¨¨ \(k-1\) ‰∏™ \(B\) ‰πãÈó¥Êúâ \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) ‰∏™ \(A\) ÁöÑÊìç‰ΩúÂ∫èÂàóÁöÑ‰ø°ÊÅØÔºà\(k = 1\) Êó∂ÊòØÂºÄÂ§¥ \(A\) ÁöÑÊï∞ÈáèÔºâ„ÄÇÊää \(R\) ÂØπ \(Q\) ÂèñÊ®°‰∏ç‰ºöÊîπÂèòÁ≠îÊ°àÔºåÊää \(P\) ÂØπ \(Q\) ÂèñÊ®°Âè™Ë¶ÅÊää \(B\) ÂèòÊàê \(A^{\lfloor \frac P Q \rfloor}B\) Â∞±ÂèØ‰ª•ÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú„ÄÇ ÂÖàÂèñÊ®°Ôºå‰øùËØÅ \(P, R &lt; Q\)„ÄÇ ËÄÉËôë‰∫§Êç¢ \(A\) Âíå \(B\) ÁöÑÂú∞‰ΩçÔºåÂéüÊù•Êàë‰ª¨ÊòØËÄÉËôëÊØè‰∏™ \(B\) ÂâçÈù¢ÊúâÂá†‰∏™ \(A\)ÔºåÁé∞Âú®Êàë‰ª¨ËÄÉËôëÊØè‰∏™ \(A\) ÂâçÈù¢ÊúâÂá†‰∏™ \(B\)ÔºåÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂâçÈù¢ÁöÑÊù°‰ª∂ÊòØ \(i \le \frac{Pj+R}{Q}\)ÔºåÂç≥ \(j \ge \frac{Qi-R}P\)„ÄÇÈÇ£‰πàÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂêéÈù¢ÁöÑÊù°‰ª∂ÊòØ \(j &lt; \frac{Qi-R}P\)Ôºå‰ªéÁ¨¨ \(i\) ‰∏™ \(A\) ÂâçÈù¢Êúâ \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) ‰∏™ \(B\)„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÁâπÂà´ÂéªÂ§ÑÁêÜ‰∏Ä‰∏ãÊúÄÂêé‰∏Ä‰∏™ \(B\) Âíå \(Qi-R-1\) Â∞è‰∫é \(0\) ÁöÑÊÉÖÂÜµÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™ÂΩ¢Âºè‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇÁî±‰∫é \(R &lt; Q\)Ôºå\(i &gt; 0\) Êó∂ \(Qi-R-1 \ge 0\)„ÄÇ‰ΩÜÊòØ \(i = 0\) Êó∂Âá∫Áé∞Ë¥üÊï∞Êåâ‰πãÂâçÁöÑÂÆö‰πâ‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•Á¨¨‰∏Ä‰∏™ \(A\) ‰ª•ÂèäÂâçÈù¢ÁöÑÈÉ®ÂàÜÂçïÁã¨Â§ÑÁêÜÔºåË∞ÉÁî® \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)ÔºåÂ§ÑÁêÜ‰∏ãÂºÄÂ§¥ÁªìÂ∞æÂç≥ÂèØ„ÄÇË¶ÅÂà§‰∏Ä‰∏ãÊ≤°Êúâ \(A\) ÁöÑÊÉÖÂÜµ„ÄÇ Ê∂âÂèäÂà∞Ê±ÇÁü©ÈòµÂπÇÂèØ‰ª•Áõ¥Êé•Âø´ÈÄüÂπÇÔºåÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶‰ªçÊòØ‰∏Ä‰∏™ \(\log\)„ÄÇ ÂÖ≥‰∫éÂÄºÂüü Êú¨È¢òÁöÑÂÄºÂüüÁâπÂà´Â§ßÔºåË¶ÅÂ∞èÂøÉÁàÜ long long„ÄÇ ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûêÂêÑ‰∏™ÂèòÈáèÂÜçÈÄíÂΩíËøáÁ®ã‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Ëøô‰∏™È¢òÊØîËæÉÊ∞¥„ÄÇ ÂÅáËÆæÊ≤°ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôêÔºåÈÇ£‰πàÂÖ∂ÂÆûË¶ÅÁÆó‰∏ÄÂè™ pony ËÉΩÊî∂ÂèñÁöÑ manaÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìËøôÊ¨°Êî∂ÂèñÂíå‰∏äÊ¨°Êî∂ÂèñÁöÑÊó∂Èó¥Èó¥ÈöîÔºå‰πò‰∏ä \(r_i\) Âç≥ÂèØ„ÄÇ Êàë‰ª¨Ë¶ÅÂú®Êìç‰ΩúÊó∂Áª¥Êä§ÊâÄÊúâ pony ÁöÑÊúÄÂêéÊìç‰ΩúÊó∂Èó¥ÔºåËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂå∫Èó¥Ë¶ÜÁõñÈóÆÈ¢òÔºåÂæàÂÆπÊòìÂÜô‰∏Ä‰∏™ÂùáÊëä \(\mathcal O(n \log n)\) ÁöÑÂÆûÁé∞ÔºöÂª∫‰∏Ä‰∏™Á∫øÊÆµÊ†ëÔºå‰øÆÊîπÊó∂ÂÖàÊääËØ¢ÈóÆÂå∫Èó¥Âú®Á∫øÊÆµÊ†ë‰∏äÊãÜÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÔºåÂØπÊØè‰∏™Âå∫Èó¥ÔºåÂÅö‰∏Ä‰∏™ËøôÊ†∑ÁöÑËøáÁ®ãÔºöÂÖàËÄÉËôëÂΩìÂâçÂå∫Èó¥ÊâÄÊúâÁÇπÊòØ‰∏çÊòØÊúÄÁªà‰øÆÊîπÊó∂Èó¥Áõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÔºåÂ∞±Â§ÑÁêÜËøô‰∏™Âå∫Èó¥ÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Âå∫Èó¥‰∏äÊâìÊ†áËÆ∞ÔºåÂê¶ÂàôÂ∞±‰∏§ËæπÈÄíÂΩí‰∏ãÂéª„ÄÇÊØèÊ¨°ÂæÄ‰∏ãÈÄíÂΩíÈÉΩ‰ºö‰ΩøÂæó‰∏Ä‰∏™Á∫øÊÆµÊ†ë‰∏äÂå∫Èó¥‰∏≠‰∏çÂêåÁöÑÊúÄÁªà‰øÆÊîπÊó∂Èó¥Êï∞ÂáèÂ∞ë‰∏ÄÔºå‰ªéËÄåËøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶ÊòØÂùáÊëä \(\mathcal O(n \log n)\)„ÄÇ ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôê‰πüÂèØ‰ª•Á±ª‰ººÁöÑÂ§ÑÁêÜÔºå‰∏çÂêåÁöÑÊòØÔºåÂõ†‰∏∫Êúâ‰∫Ü‰∏äÈôêÔºåÈúÄË¶ÅÂØπÊØè‰∏™Âå∫Èó¥Áª¥Êä§‰∏Ä‰∏™‰ª• \(\lceil \frac {m_i}{r_i}\rceil\) ‰∏∫ÂÖ≥ÈîÆÂ≠óÊéíÂ•ΩÂ∫èÁöÑ‰∏úË•ø„ÄÇËøôÊ†∑‰Ω†ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ãÂâçÂ§öÂ∞ë‰∏™ÈÉΩÊòØÂú®ËøôÊÆµÊó∂Èó¥ÈáåÈù¢ mana Êª°‰∫ÜÁöÑÔºåÁõ¥Êé•Âä†ËøõÁ≠îÊ°àÔºåÁÑ∂ÂêéÂêéÈù¢ÁöÑÂè™ÈúÄË¶ÅÁªüËÆ°‰∏Ä‰∏ã \(r_i\) ÁöÑÂíå‰πò‰∏äÊó∂Èó¥Â∑ÆÂä†ËøõÁ≠îÊ°àÂç≥ÂèØ„ÄÇËøô‰∏™‰∏úË•øÂæàÂÆπÊòìÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ„ÄÇ ÂàùÂßãÂÄºË¶ÅÁâπÂà´Â§ÑÁêÜÔºåÂú®ÊØè‰∏™ÁÇπÁ¨¨‰∏ÄÊ¨°‰øÆÊîπÊó∂Êö¥ÂäõÁÆó‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÊÑüËßâÂÆûÈôÖ‰∏äÂèØ‰ª•Áî®Á∫øÊÆµÊ†ëÂàÜË£ÇÂíåÂêàÂπ∂ÂÅöÂà∞‰∏Ä‰∏™ \(\log\)„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊØíÁò§ÂàÜÁ±ªËÆ®ËÆ∫.... Â∞±Êîæ‰∏™‰ª£Á†Å..ÁªìËÆ∫Â§™È∫ªÁÉ¶Â∞±‰∏çÂÜô‰∫Ü TAT„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Á•û‰ªôÈ¢òÔºåÁúãÈ¢òËß£‰∫Ü„ÄÇ Âèñ‰ªªÊÑè‰∏Ä‰∏™ÁîüÊàêÊ†ëÔºåÂèñËøô‰∏™Ê†ëÁöÑÈáçÂøÉÂíåÊâÄÊúâË∑®ËøáËøô‰∏™ÈáçÂøÉÁöÑÈùûÊ†ëËæπÁöÑÁ´ØÁÇπÔºàÂÆûÈôÖ‰∏ä‰∏§‰∏™Á´ØÁÇπ‰∏≠Âè™Ë¶Å‰ªªÂèñ‰∏Ä‰∏™Â∞±Ë°åÔºåÂè™Ë¶Å‰øùËØÅÂ≠êÊ†ë‰∏çËøûÈÄöÔºâÔºåËÄÉËôëË∑®ËøáËøô‰∫õÁÇπÁöÑË∑ØÂæÑÔºåÁÑ∂ÂêéÂÜçÂØπÊØè‰∏™Â≠êÊ†ëÁÇπÂàÜ„ÄÇ Ê≥®ÊÑè‰∏çË¶ÅÊääËøô‰∫õÁÇπÂà†ÊéâÂÜçÂØπÊØè‰∏™ËøûÈÄöÂùóÂÅöÁÇπÂàÜÊ≤ªÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØËÉΩ‰∏Ä‰∏™ËøûÈÄöÂùó‰∏çÊòØ‰∏Ä‰∏™Ê†ë‰∏äËøûÈÄöÂùóÔºåÂ∞±‰∏çÊòØÂæàÂ•ΩÂ§ÑÁêÜÔºàÂ∫îËØ•‰πüËÉΩÂ§ÑÁêÜÔºâ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÉèÂä®ÊÄÅÁÇπÂàÜÊ≤ª‰∏ÄÊ†∑Áª¥Êä§Â∞±Ë°åÔºåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÂà†ÂéªÁöÑÁÇπ‰∏éÂΩìÂâçËøûÈÄöÂùó‰∏≠ÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ª„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(nk\log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // ÁÇπÂàÜÊ†ë‰∏äÁà∂‰∫≤Ôºå‰∏Ä‰∏™ÁÇπË¢´Âà†ÊéâÊó∂ÂØπÂ∫îÁÇπÂàÜÊ†ë‰∏äÂì™‰∏™ÁÇπvector&lt;int&gt; vimp[maxn], mn[maxn]; // ÁÇπÂàÜÊ†ë‰∏ä‰∏ÄÊ¨°Âà†ÂéªÁöÑÁÇπÔºå‰ª•ÂèäÂà∞ËøûÈÄöÂùóÂÜÖÊúÄËøëË¢´ mark ÁÇπÁöÑË∑ùÁ¶ªunordered_map&lt;ll, int&gt; mdis; // Ë¢´Âà†ÂéªÁöÑÁÇπÂà∞ÂÜÖÈÉ®‰∏Ä‰∏™ÁÇπÁöÑË∑ùÁ¶ªint vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // ÁÇπÂàÜÊ≤ªÁî®ÂèòÈáèvoid dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // ÂéüÊú¨ËøôÈáåÊòØÊääÊâÄÊúâÂ§ÑÁêÜÁöÑÁÇπÂà†ÊéâÁöÑÔºåÂÜôÂæóÂèØËÉΩÊúâÁÇπÂ•áÊÄ™ÔºåÊáíÂæóÊîπ‰∫Ü vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ∫¶Êï∞Â∫èÂàó \(d\)ÔºåÂ≠òÂú®‰∏ÄÊ£µÂØπÂ∫îÁöÑ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(1 \le d_i &lt; n\) ‰∏î \(\sum {d_i} = 2(n-1)\)Ôºà‰ªéÂè∂Â≠êÂΩíÁ∫≥Ôºâ„ÄÇ ËÄÉËôëÂéªÈí¶ÂÆöËøô‰∏™Ê†ëÁöÑ \(k\) ‰∏™ÂåπÈÖçÔºåÂ¶ÇÊûúËÉΩÈí¶ÂÆöÂá∫Êù•Â∞±ËØ¥ÊòéÁ≠îÊ°à \(\ge k\)„ÄÇÈí¶ÂÆö‰∏§‰∏™ÁÇπÂåπÈÖçÂèØ‰ª•Áúã‰ΩúËøô‰∏§‰∏™ÁÇπË¢´Áº©Âà∞‰∫Ü‰∏ÄËµ∑ÔºåÂèòÊàê‰∫Ü‰∏Ä‰∏™Â∫¶Êï∞Âíå‰∏∫‰∏§‰∏™ÁÇπÁöÑÂ∫¶Êï∞‰πãÂíåÂáèÂéª \(2\) ÁöÑÁÇπ„ÄÇÂè™Ë¶Å‰øùËØÅÊâÄÊúâÂåπÈÖçÁº©Ëµ∑Êù•‰πãÂêéÂæóÂà∞ÁöÑÂ∫¶Êï∞Â∫èÂàó‰æùÁÑ∂Êª°Ë∂≥‰πãÂâçÊâÄËØ¥ÁöÑÊù°‰ª∂Âç≥ÂèØ„ÄÇËøôÊòØ‰∏Ä‰∏™‰ºóÊâÄÂë®Áü•ÁöÑË¥™ÂøÉÈóÆÈ¢òÔºåÊéíÂ∫èÂêéË¥™ÂøÉÁî®Â∞èÁöÑÂåπÈÖçÂ§ßÁöÑÂç≥ÂèØ„ÄÇÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè \(1\) Âíå \(1\) Âú®ÁÇπÊï∞Â§ß‰∫é \(2\) Êó∂‰∏çËÉΩÂåπÈÖçÔºàÂõ†‰∏∫ \(1+1-2=0\)ÔºâÔºå‰ΩÜÊòØÁÇπÊï∞Á≠â‰∫é \(2\) Êó∂ÂèØ‰ª•ÂåπÈÖç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â•áÊÄ™ÁöÑÈ¢òÁõÆ... ÂÖàÊääÁÇπÊåâ \(a_i\) ‰ªéÂ∞èÂà∞Â§ßÈáçÊñ∞Ê†á‰∏™Âè∑„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨ÂÅáËÆæ \(a_i &lt; a_{i+1}\)„ÄÇ Êää \(1\) Áúã‰ΩúÊ†πÔºåÊòæÁÑ∂ÂèØ‰ª•ÈÄöËøáË∞ÉÊï¥‰ΩøÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ÁºñÂè∑ÈÉΩÊØî‰ªñÂ∞è„ÄÇ Êää‰∏§ÁßçË¥°ÁåÆ‰∏ÄËµ∑ËÄÉËôëÔºåÂÆö‰πâËæπ \(\{u, fa(u)\}\) ÁöÑË¥°ÁåÆ‰∏∫ \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)ÔºåÂØπÊØè‰∏™ \(u\) ÂéªÊâæËÉΩ‰Ωø‰ª£‰ª∑ÊúÄÂ∞èÁöÑ \(fa(u)\)„ÄÇÁî±‰∫éËøô‰∏™Ê†ëÁöÑÁâπÊÆäÊÄßË¥®ÔºåÁÇπ \(u\) ÊúÄ‰ºòÁöÑÁà∂‰∫≤‰∏ÄÂÆöÊòØÂéüÊ†ë‰∏ä \(u\) ÁöÑÁ•ñÂÖàÔºåÊâÄ‰ª•ÂÄçÂ¢û‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // Ë∑ùÁ¶ª‰∏çË∂ÖËøá 2^k ÁöÑÁÇπint cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™ \(n\) ‰∏™ÁÇπ \(m\) Êù°ËæπÁöÑÂ∏¶ÊùÉÁÆÄÂçïÊúâÂêëÂõæÔºåÊ±Ç‰∏Ä‰∏™ÊúÄÂ∞èËæπÊùÉÂíåÁöÑÊòØ‰ª• \(r\) ‰∏∫Ê†πÁöÑÂÜÖÂêëÁîüÊàêÊ†ë„ÄÇ Â§ñÂêëÊ†ëÁöÑÊÉÖÂÜµÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´ÔºåËæπÂèç‰∏ÄÂèçÂ∞±Â•Ω„ÄÇ Êó†Ê†πÁöÑÊÉÖÂÜµÂèØ‰ª•Âä†‰∏Ä‰∏™ÁÇπËΩ¨Âåñ‰∏∫ÊúâÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ÁÆóÊ≥ï Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæÊòØ DAGÔºå‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑË¥™ÂøÉÊòØÔºåÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ„ÄÇÊòæÁÑ∂ËøôÊ†∑‰ºöÊûÑÊàê‰∏ÄÊ£µÂÜÖÂêëÊ†ëÔºå‰∏î‰∏çÂèØËÉΩÊúâÊùÉÂÄºÂíåÊõ¥Â∞èÁöÑÂÜÖÂêëÊ†ë„ÄÇ Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæ‰∏çÊòØ DAGÔºåÁõ¥Êé•ÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ‰∏ç‰∏ÄÂÆö‰ºöÂæóÂà∞‰∏ÄÊ£µÊ†ëÔºåÊ≠§Êó∂ÂèØËÉΩ‰ºöÊúâÂ§ö‰∏™Âº±ËøûÈÄöÂùóÔºåÊØè‰∏™ËøûÈÄöÂùóÊòØ‰∏ÄÊù°ÈìæÔºàÂåÖÂê´ \(r\) ÁöÑÔºâÊàñËÄÖ‰∏ÄÊ£µÂü∫ÁéØÂÜÖÂêëÊ†ë„ÄÇÂ¶ÇÊûú‰Ω†ÂæóÂà∞‰∫Ü‰∏Ä‰∏™ÂÜÖÂêëÁîüÊàêÊ†ëÂ∞±Ê±ÇÂá∫‰∫ÜÁ≠îÊ°àÔºå‰∏ãÈù¢Êàë‰ª¨ËÄÉËôëËá≥Â∞ëÊúâ‰∏Ä‰∏™ÁéØÁöÑÊÉÖÂÜµ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫é‰∏Ä‰∏™ÔºàÊüê‰∏™Âü∫ÁéØÊ†ëËøûÈÄöÂùó‰∏≠ÁöÑÔºâÁéØÔºå‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÊÅ∞Â•ΩÂè™Êúâ‰∏ÄÊù°ÁéØ‰∏äËæπ‰∏çÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºåÊàë‰ª¨ÂÖàÂÅáËÆæËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºà‰Ω†ÂèØ‰ª•Âä†ÂÖ•‰∏Ä‰∏™ÂÖÖÂàÜÂ∞èÁöÑÂÅèÁßªÈáèÔºåÂú®‰∏çÂΩ±ÂìçÁ≠îÊ°àÁöÑÂâçÊèê‰∏ã‰ΩøËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºâÔºåËÆæÁÇπ \(u\) ÁöÑÊúÄÂ§ßÂá∫ËæπËøûÂêëÁÇπ \(f(u)\)ÔºåËÄÉËôë‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÁÇπ \(u \neq r\)Ôºå\(f(u)\) ‰∏çÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠Ôºå‰∏î \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÊàë‰ª¨ÂèØ‰ª•Êää \(u\) ÁöÑÁà∂‰∫≤Êîπ‰∏∫ \(f(u)\)ÔºåÂæóÂà∞‰∏Ä‰∏™Êõ¥Â∞èÁöÑÂÜÖÂêëÁîüÊàêÊ†ëÔºåËøô‰∏éËøô‰∏™Ê†ëÊòØÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÁüõÁõæ„ÄÇËøôËØ¥ÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁéØ‰∏äÁöÑÁÇπ \(u\)Ôºå‰ΩøÂæó \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ (ÁéØ‰∏äÁÇπËÇØÂÆö‰∏çÊòØ \(r\))Ôºå\(f(u)\) Ë¶Å‰πàÊòØ \(u\) ÁöÑÁà∂‰∫≤Ë¶Å‰πàÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠„ÄÇËÄÉËôë‰ªé \(u\) Âá∫ÂèëÔºåÊØèÊ¨°‰ªé \(u\) Ëµ∞Âêë \(f(u)\)ÔºåÂú®Ëµ∞Âõû \(u\) ‰πãÂâçÔºå‰∏ÄÂÆö‰∏ç‰ºöÁªèËøá‰∏Ä‰∏™ÁÇπ‰∏§Ê¨°Ôºå‰ªéËÄåË∑ØÂæÑ‰∏äÂè™ÊúâÁ¨¨‰∏ÄÊ¨°Ëµ∞ÁöÑÊó∂ÂÄô \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÂõ†Ê≠§ÁéØ‰∏äÂè™Êúâ‰∏ÄÊù°ËæπÊ≤°ÊúâÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠Âá∫Áé∞„ÄÇ Âõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁéØ‰∏äÂì™‰∏ÄÊù°ËæπÊ≤°ÊúâÂá∫Áé∞„ÄÇËÄÉËôëÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÂæóÂà∞‰∏Ä‰∏™‰∏éÂéüÂõæÁ≠â‰ª∑ÁöÑÂõæ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠ \(e\) ÊòØ‰∏çÂú®ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ‰∏≠ÁöÑËæπÔºå‰ªéÂõæ‰∏≠ÂèØ‰ª•ÂæàÊòéÊòæÂú∞ÁúãÂà∞ÔºåÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÊääÁº©ÂÆåÂêéÁöÑÁöÑÁÇπÁöÑÂá∫ËæπËæπÊùÉÂáèÂéªÂéüÊù•ËøôÊù°Âá∫ËæπÂØπÂ∫îÁöÑ \(e\) ÁöÑÊùÉÂÄºÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™Á≠â‰ª∑ÁöÑÂõæ„ÄÇ Êö¥ÂäõÁº©ÁÇπÂèØ‰ª•Áî® \(\mathcal O(nm)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ê±ÇÂá∫ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ„ÄÇ Â§çÊùÇÂ∫¶‰ºòÂåñ Áî®Âπ∂Êü•ÈõÜÁª¥Êä§Âº±ËøûÈÄöÂùóÔºåÂÜçÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ÂΩìÂâçÂì™‰∫õÁÇπË¢´Áº©Êàê‰∫Ü‰∏Ä‰∏™ÁÇπ„ÄÇÁî®ÂèØÂπ∂Â†ÜÁª¥Êä§ÂΩìÂâçÊØè‰∏™ÁÇπÁöÑÂá∫ËæπÔºåÁº©ÁÇπÊó∂Â∏¶ tag ÂêàÂπ∂‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÂá∫ËæπÔºåÂ¶ÇÊûúÂú®Âêå‰∏ÄÂº±ËøûÈÄöÂùóÂèàÂèØ‰ª•Áº©ÁÇπ‰∫ÜÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÂíåÂÖ∂‰ªñÂº±ËøûÈÄöÂùóÂêàÂπ∂Âú®‰∫Ü‰∏ÄËµ∑„ÄÇ Áº©‰∏ÄÊ¨°Ëá≥Â∞ëÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºåÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O((n+m) \log n)\)„ÄÇ ÂÆûÁé∞ ÂíïÂíïÂíï„ÄÇ Áî±‰∫éÂÆûÁé∞Âíï‰∫ÜÊâÄ‰ª•‰πü‰∏çËÉΩ‰øùËØÅ‰∏äÈù¢ËØ¥ÁöÑÊòØÂØπÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Áåú‰∫Ü‰∏™ÁªìËÆ∫Ôºå‰∏ç‰ºöËØÅ‰ΩÜÊòØÂèàÊÉ≥‰∏çÂà∞ÂÖ∂‰ªñÂÅöÊ≥ï..Áúã‰∫ÜÁúºÈ¢òËß£ÂèëÁé∞ÊòØÂØπÁöÑ„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñÔºåÂÅáËÆæ‰Ω†‰π∞‰∫Ü \(x\) Ê¨°Ôºå‰Ω†‰ªéËøô‰∏™ÊäΩÂ•ñ‰∏≠Ëé∑ÂæóÁöÑÈí±Êï∞ÁöÑÊúüÊúõÊòØ \(p_i\frac {x} {x + l_i}\)„ÄÇÂÅáËÆæ‰Ω†Â∑≤Áªè‰π∞‰∫ÜÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñ \(x\) Ê¨°ÔºåÂÜç‰π∞‰∏ÄÊ¨°ÔºåÊúüÊúõÁöÑÂ¢ûÂä†ÈáèÊòØ \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)„ÄÇÂÆπÊòìÂèëÁé∞Ëøô‰∏™Â¢ûÂä†ÈáèÂÖ≥‰∫é \(x\) ÂçïË∞ÉÈÄíÂáèÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÂØπ‰∫éÊâÄÊúâÁöÑ \(i\) Âíå \(x \le i\)ÔºåÊää \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) ‰∏¢Ëøõ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ªéÂ§ßÂà∞Â∞èÊéí‰∏™Â∫èÔºåÂâç \(t\) ‰∏™Êï∞‰πãÂíåÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ§çÊùÇÂ∫¶‰∏çËÉΩÊé•Âèó„ÄÇ Êàë‰ª¨ÂÖàÁÆóÂá∫ÂàùÂßãÊ∏ÖÁ©∫ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÁªôÁ¨¨ \(k\) ‰∏™ÊäΩÂ•ñÂéüÊúâÁöÑÁ•®Êï∞Âä†‰∏ÄÂáè‰∏Ä‰πãÂêéÔºåËÄÉËôë‰∏§ÁßçÊìç‰ΩúÔºö‰∏ÄÔºåÂ∞ë‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ§ö‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñÔºõ‰∫åÔºåÂ§ö‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ∞ë‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñ„ÄÇÊàë‰ª¨ÊâæÂà∞ËÉΩ‰ΩøÊúüÊúõÂ¢ûÂä†ÈáèÊúÄÂ§ßÁöÑÊìç‰ΩúÔºåËøôÂæàÂÆπÊòìÁî®Â†ÜÊù•Áª¥Êä§„ÄÇÂè™ÈúÄË¶ÅÁªèËøá‰∏ÄÊ¨°ËøôÊ†∑ÁöÑÊìç‰ΩúÂç≥ÂèØÂæóÂà∞ÊúÄ‰ºòÊñπÊ°àÔºåËØÅÊòéÂ∞±‰∏çÂÖ∑‰ΩìÂÜôÂá∫‰∫Ü„ÄÇÔºàÊØîÂ¶ÇËØ¥Â¶ÇÊûúÊòØËøõË°åÊìç‰Ωú‰∫åÔºå‰ªéËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÂêéÔºåÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÊØîÂú®‰øÆÊîπÁ•®Êï∞‰πãÂâçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÂ§ßÊù•ËÄÉËôëÂç≥ÂèØÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÔºåÂÖàÊääÈ¢òÁõÆ‰∏≠ÁªôÂÆö‰∏≤ÁøªËΩ¨‰∏Ä‰∏ãÔºåÂèòÊàêË¶ÅÊâæ‰∏Ä‰∏™ÊØè‰∏™‰∏≤ÊòØÂêé‰∏Ä‰∏™‰∏≤Â≠ê‰∏≤ÁöÑÂ∫èÂàó„ÄÇ ‰∏ãÈù¢Êàë‰ª¨ËÆ§‰∏∫ÔºåËøô‰∏™Â∫èÂàó‰∏≠ÁöÑÂÖÉÁ¥†ÊòØ‰∏Ä‰∏™(ÂåÖÂê´‰ΩçÁΩÆÁöÑ)Â≠ê‰∏≤„ÄÇÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤Âá∫Áé∞Âú®‰∏çÂêå‰ΩçÁΩÆË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÁöÑ„ÄÇ ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Â∫èÂàóÔºå‰Ω†‰∏ÄÂÆöÂèØ‰ª•Âú®‰∏çÊîπÂèòÈïøÂ∫¶ÁöÑÊÉÖÂÜµ‰∏ãÊääÂÆÉË∞ÉÊï¥ÊàêÁ¨¨ \(i\) ‰∏™Â≠ê‰∏≤Èïø‰∏∫ \(i\)„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ËÄÉËôëËøôÁ±ªÂ∫èÂàó„ÄÇ Áß∞‰∏Ä‰∏™Â≠ê‰∏≤ \(s[l..r]\) ÊòØÂèØËææÁöÑÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏Ä‰∏™ËøôÁ±ªÂ∫èÂàó‰ª• \(s[l..r]\) ÁªìÂ∞æ„ÄÇÈ¢òÁõÆÂ∞±ÊòØË¶ÅÊ±ÇÊúÄÈïøÂèØËææÁöÑÂ≠ê‰∏≤„ÄÇ Ê≥®ÊÑèÂà∞Â¶ÇÊûú \(l &lt; r\)Ôºå\(s[l..r]\) ÂèØËææÔºåÈÇ£‰πà \(s[l..r-1]\) Âíå \(s[l+1..r]\) ‰∏ÄÂÆöÂèØËææ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(l\) Ê±ÇÂá∫ÊúÄÂ§ßÁöÑ \(r\) ‰ΩøÂæó \(s[l..r]\) ÂèØËææÔºåËÆæÂØπ‰∫é \(l=i\) ÊúÄÂ§ßÁöÑ \(r\) ÊòØ \(f_i\)„ÄÇÂØπ \(f\) ‰Ωú dpÔºåÊòæÁÑ∂ \(f_i \ge f_{i-1}\)ÔºåÊâÄ‰ª•ÊØèÊ¨°ÂÖà‰ª§ \(f_i = f_{i-1}\)ÔºåÁÑ∂ÂêéÊ£ÄÊü•‰∏Ä‰∏ã \(f_i\) ËÉΩ‰∏çËÉΩÂ¢ûÂ§ßÔºåÂ¶ÇÊûúËÉΩÂ¢ûÂ§ßÂ∞±‰∏ÄÁõ¥Â¢ûÂ§ßÂà∞‰∏çËÉΩÂ¢ûÂ§ßÂ∞±Ë°å‰∫Ü„ÄÇÊ£ÄÈ™åÂè™ÈúÄË¶ÅÂú® SAM ‰∏äÊâæÂà∞Ë¶ÅÊ£ÄÈ™åÁöÑ‰∏≤Âú®Êüê‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÊúÄÂêéÂá∫Áé∞‰ΩçÁΩÆÂ∞±Â•ΩÔºåËøôÂæàÂÆπÊòìÁî® SAM + Á∫øÊÆµÊ†ëÂÆûÁé∞Ôºà‰πüÂèØ‰ª•Áî®ÂÖ∂‰ªñÊñπÂºèÔºâ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™‰ºöÂ¢ûÂ§ß \(\mathcal O(n)\) Ê¨°ÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// ÊúâÊ≤°ÊúâÂè≥Á´ØÁÇπÂú® x Êàñ‰πãÂâçÁöÑint check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Êàë‰ª¨ÂÖà‰∏çË¶ÅËÄÉËôëËæπÊùÉ„ÄÇ ËÄÉËôëÁõ¥Êé• dpÔºå\(dp[u][i][j]\) Ë°®Á§∫ \(u\) ÁöÑÂ≠êÊ†ë‰∏≠‰øÆÊîπÂêéÊúâ \(i\) ‰∏™ÈªëÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøúÁöÑ‰∏éÂ≠êÊ†ë‰∏≠ÊâÄÊúâÈªëÁÇπË∑ùÁ¶ªÈÉΩÂ§ß‰∫é \(x\) ÁöÑÁ∫¢ÁÇπ‰∏éÊ†πÁöÑË∑ùÁ¶ª‰∏∫ \(j\)ÔºåÊúÄÂ∞èË¶Å‰øÆÊîπÂá†Ê¨°„ÄÇËΩ¨ÁßªÁöÑÊó∂ÂÄôÈúÄË¶ÅÂÜ≥ÂÆöË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÁ∫¢ÁÇπÔºåÊâÄ‰ª•ÈúÄË¶ÅÁü•ÈÅìË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÁöÑË∑ùÁ¶ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊàë‰ª¨ÂÜçËÆ∞‰∏Ä‰∏™ÊúÄËøëÈªëÁÇπÁöÑËØùÂ§çÊùÇÂ∫¶Â∞±ÁÇ∏‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞‰∏Ä‰∏™ÊÄßË¥®ÔºöÂ¶ÇÊûúÊ†πÊòØÁ∫¢ÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÊâÄÂú®ÁöÑ(Ê†πÁöÑÂÑøÂ≠êÁöÑ)Â≠êÊ†ë‰∏≠‰∏ÄÂÆöÊâÄÊúâÁ∫¢ÁÇπÈÉΩÂèØ‰ª•Âú®Ëøô‰∏™Â≠êÊ†ë‰∏≠ÊâæÂà∞Ë∑ùÁ¶ª‰∏çË∂ÖËøá \(x\) ÁöÑÈªëÁÇπ„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπ \(j = 0\) ÁöÑÊÉÖÂÜµÈ¢ùÂ§ñËÆ∞ÂΩï‰∏ãÊúÄËøëÁöÑÈªëÁÇπ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª• dp ‰∫Ü„ÄÇ Áé∞Âú®Êù•ËÄÉËôë‰∏Ä‰∏ãËæπÊùÉÔºåÊ≥®ÊÑèÂà∞Êàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåËøôÊ†∑Â∞±ËÉΩÂÅöÂ∏¶ÊùÉÁöÑÊÉÖÂÜµ‰∫Ü„ÄÇ ÂÜÖÂ≠òÈúÄË¶ÅÂç°‰∏Ä‰∏ã„ÄÇ È¢òËß£Á´üÁÑ∂ÊòØÂØπ \(500\) Á∫ßÂà´ÁöÑ‰∏úË•øË∑ëÂçïÁ∫ØÂΩ¢Ôºå‰∏çÂ§™ËÉΩÁêÜËß£Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇÁªèËøáËâ∞ÈöæÁöÑË∞ÉËØïÂíåÂç°Â∏∏Áªà‰∫é A ‰∫Ü„ÄÇÔºàÊó∂Èôê 1000 msÔºåÂºÄ Ofast 982 msÔºå‰∏çÂºÄ Ofast 998 msÔºåTATÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : Êúâ i ‰∏™ÈªëÁÇπÔºåÊâÄÊúâÁ∫¢ÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j // g : Êúâ i ‰∏™ÈªëÁÇπÔºåÊ≤°ÊúâÊú™ÂåπÈÖçÁ∫¢ÁÇπÔºåËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÈªëÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Âä®ÊÄÅËßÑÂàí</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÖàÊ±ÇÈáçÂøÉÔºöÈöè‰æøÊâæ‰∏™ÁÇπÔºåÊääÂ§öËæπÂΩ¢ÂàíÂàÜÊàêËã•Âπ≤‰∏™‰∏âËßíÂΩ¢ÔºåÊ±ÇÂá∫ÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºåÊåâÊúâÂêëÈù¢ÁßØÂä†ÊùÉÂπ≥Âùá„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁÇπ \((x_p,y_p)\)ÔºåËÆæ \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)„ÄÇÊääÂÆÉÁªï \((x_0,y_0)\) ÈÄÜÊó∂ÈíàÊóãËΩ¨ \(c\) ÂºßÂ∫¶ÔºåÁõ∏ÂΩì‰∫éÊää \(p\) Â∑¶‰πò‰∏Ä‰∏™Áü©Èòµ \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)„ÄÇÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ \(3 \times 3\) Áü©ÈòµÂ∞±ËÉΩÂø´ÈÄüËé∑ÂæóÊØè‰∏™ÁÇπÁöÑ‰ΩçÁΩÆ„ÄÇÊóãËΩ¨Êó∂ËÄÉËôë‰∏Ä‰∏ãÂõ∫ÂÆöÁöÑÁÇπÂíåÈáçÂøÉÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ Âê¨ÔºàÈ¢òËß£‰∏äÔºâËØ¥ÈúÄË¶ÅÊää‰∏Ä‰∏™ÁÇπÁßªÂà∞ \((0,0)\) ÈÅøÂÖçÁ≤æÂ∫¶ËØØÂ∑Æ„ÄÇ‰∏çÁü•ÈÅì‰∏çËøôÊ†∑ËÉΩ‰∏çËÉΩËøá„ÄÇ ÔºàÊ†∑‰æã 2 ÁúüÁöÑ‰ºöËΩ¨ÂêóÔºüÔºâ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n+m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // Áé∞Âú®Áî® p2 ÊóãËΩ¨ Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁúãÊàêÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™ÁÇπÊó∂‰ºöÁªôÂÆÉÊâÄÂú®ÁöÑËøûÈÄöÂùóÊØè‰∏™ÁÇπ‰∏Ä‰∏™Ë¥°ÁåÆ„ÄÇ ÂØπÊØè‰∏™ÁÇπÂØπ \((u,v)\) ËÆ°ÁÆó \(v\) ‰ºöÁªô \(u\) ‰∏Ä‰∏™Ë¥°ÁåÆÁöÑÊ¶ÇÁéáÔºå Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°à„ÄÇ È¢òÁõÆ‰∏≠ÁªôÂÆöÁöÑÂõæÊòØ‰∏ÄÊ£µÂü∫ÁéØÊ†ë„ÄÇ ÂØπ‰∫é \(u = v\)ÔºåËøô‰∏™Ê¶ÇÁéáÊòØ \(1\)„ÄÇÂØπ \(u \neq v\)ÔºåÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö ‰∏ÄÔºå \(u,v\) Âú®Âêå‰∏Ä‰∏™Â≠êÊ†ë‰∏≠„ÄÇÊää \(u\) Áúã‰ΩúÊ†πÔºåÈÇ£‰πàËøô‰∏™Ê¶ÇÁéáÂ∞±ÊòØÔºåÊØèÊ¨°‰ªéËøòÊú™Ë¢´Âà†Èô§ÁöÑÁÇπ‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÁÇπÔºåÂ∞ÜÂÖ∂Â≠êÊ†ëÂà†Èô§ÔºåÂΩì \(v\) Ë¢´Âà†Èô§Êó∂Ôºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÈô§‰∫Ü \(v\) ‰ª•Â§ñÁöÑÁÇπÈÉΩËøòÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéá„ÄÇËÆæÊÄªÂÖ±Êúâ \(n\) ‰∏™ÁÇπÔºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÊúâ \(k\) ‰∏™ÁÇπÔºåÁ±ª‰ººÁåé‰∫∫ÊùÄ‰∏ÄÈ¢ò‰∏≠ÁöÑÊäÄÂ∑ßÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìËøô‰∏™Ê¶ÇÁéáÁ≠â‰∫é‰∏çÊñ≠‰ªé \([1,n]\) ‰∏≠Á≠âÊ¶ÇÁéáÈöèÊú∫Âèñ‰∏Ä‰∏™Êï¥Êï∞Ôºå‰∏ÄÊó¶Âá∫Áé∞ \(v\) Êàñ \(v\) ÁöÑÁ•ñÂÖàÂ∞±ÂÅúÊ≠¢ÔºåÂÅúÊ≠¢Êó∂Èô§ \(v\) ‰ª•Â§ñ \(v\) ÁöÑÊâÄÊúâÁ•ñÂÖàÈÉΩÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéáÔºåÂç≥ \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)„ÄÇ ‰∫åÔºå\(u,v\) ‰∏çÂú®Âêå‰∏ÄÂ≠êÊ†ë‰∏≠Ôºå‰∏éÊÉÖÂÜµ‰∏ÄÁ±ª‰ººÔºå‰ΩÜÊòØ‰∏çÂêåÁöÑÊòØÊ≠§Êó∂ \(u\) Âà∞ \(v\) Êúâ‰∏§Êù°Ë∑ØÂæÑÔºåÂè™Ë¶ÅÂÖ∂‰∏≠‰∏ÄÊù°Â≠òÂú®Â∞±ÊúâË¥°ÁåÆ„ÄÇÂèØ‰ª•ÂÆπÊñ•ÊàêÁ¨¨‰∏ÄÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂä†‰∏äÁ¨¨‰∫åÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂáèÂéª‰∏§Êù°ÈÉΩÂ≠òÂú®ÁöÑÊ¶ÇÁéá„ÄÇËøô‰∏â‰∏™ÈóÆÈ¢òÈÉΩÂèØ‰ª•Á±ª‰ººÊÉÖÂÜµ‰∏ÄÂú∞Ëß£ÂÜ≥„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n^2)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÊú¨È¢ò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊÉ≥‰∫ÜÊå∫‰πÖÂè™‰ºöËÉ°‰∏™ \(\mathcal O(n \sqrt n \log n)\) ÁöÑËé´Èòü + Áª¥Êä§ huffman Ê†ëÔºåÂéªÁúã‰∫ÜÁúºÂà´‰∫∫ÁöÑÈ¢òËß£ÂèëÁé∞‰πüÊúâÊòØËøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ.....‰∏çËøáÊØîÊàëËÉ°ÁöÑÂ¶ôÂ§ö‰∫ÜÔºå‰∏ãÈù¢ÂÜôÁöÑÊòØÁúãÂà∞ÁöÑÂà´‰∫∫ÁöÑÂÅöÊ≥ï„ÄÇ Áî®Ëé´ÈòüÂ§ÑÁêÜËØ¢ÈóÆÔºåÁª¥Êä§‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÔºåÂπ∂ËÆ∞ÂΩï‰∏ãÂΩìÂâçÂá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞„ÄÇÂØπÊ¨°Êï∞‰∏çË∂ÖËøá \(x\) ÁöÑÊï∞ÔºåËÆ∞‰∏Ä‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÁÑ∂Âêé \(\mathcal O(x)\) ÁÆóÂá∫ÂêàÂπ∂‰ª£‰ª∑„ÄÇËΩ¨Âåñ‰∏∫Âè™ÊúâÂá∫Áé∞Ê¨°Êï∞Ë∂ÖËøá \(x\) ÁöÑÊï∞ÁöÑÊÉÖÂÜµÔºåËøôÊó∂ÊúÄÂ§öÂè™Êúâ \(\frac n x\) ‰∏™Êï∞ÔºåË¥™ÂøÉÂêàÂπ∂Âç≥ÂèØ„ÄÇËØ¢ÈóÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(x + \frac n x \log n)\)ÔºåÂèñ \(x = \sqrt {n \log n}\)ÔºåÂàô‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\sqrt {n \log n}\)„ÄÇ Ëé´ÈòüÁª¥Êä§Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞Êó∂ÂèØ‰ª•‰ΩøÁî®ÈìæË°®ÔºåËøôÊ†∑ÁöÑËØùËé´ÈòüÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï È¢òÁõÆ‰∏≠ÁöÑËøûËæπÊñπÂºèÂèØ‰ª•Ê¶ÇÊã¨‰∏∫ÔºåÂ¶ÇÊûú(ÂºÄ)Âå∫Èó¥ \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∫§‰∏ç‰∏∫Á©∫Ôºå‰∏î \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∏çÊòØ‰∏ÄÂØπÂ≠òÂú®ÂåÖÂê´ÂÖ≥Á≥ªÁöÑÂå∫Èó¥ÔºåÈÇ£‰πàËøô‰∏§‰∏™Âå∫Èó¥‰πãÈó¥Êúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇÂê¶ÂàôÔºåÂ¶ÇÊûú \((l_1,r_1)\) Ë¢´ \((l_2,r_2)\) ÂåÖÂê´Ôºå\((l_1,r_1)\) Âà∞ \((l_2,r_2)\) Êúâ‰∏ÄÊù°ÊúâÂêëËæπ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™‰ªÖÁî±ÂèåÂêëËæπÊûÑÊàêÁöÑËøûÈÄöÂùóÔºåËÆæËøô‰∏™ËøûÈÄöÂùó‰∏≠ÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂‰∏∫ \((L,R)\)ÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ§‰∏∫Áé∞Âú®Â∞±Â≠òÂú®ËøôÊ†∑‰∏Ä‰∏™Âå∫Èó¥ \((L,R)\)„ÄÇÂõ†‰∏∫ÈïøÂ∫¶ÊòØÈÄíÂ¢ûÁöÑÔºåÂ¶ÇÊûú‰πãÂêéÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ \((a,b)\)Ôºå\(a\) Ë¢´ \((L,R)\) ÂåÖÂê´ÊàñËÄÖ \(b\) Ë¢´ \((L,R)\) ÂåÖÂê´ÔºåÈÇ£‰πà \((a,b)\) ‰∏éËøô‰∏™ËøûÈÄöÂùó‰∏≠ÁöÑÊüê‰∏™ÁÇπÊúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇ‰∏çÈöæÂèëÁé∞Ôºå‰∏Ä‰∏™Âå∫Èó¥ \(a\) ËÉΩÂà∞ËææÂå∫Èó¥ \(b\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(a\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Ë¢´ \(b\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂ÂåÖÂê´„ÄÇËøôÊ†∑Êàë‰ª¨Âè™Ë¶ÅÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ËøûÈÄöÂùóÔºåÂπ∂ËÆ∞ÂΩï‰∏Ä‰∏ãËøûÈÄöÂùóÁöÑÂπ∂ÁöÑÂ∑¶Âè≥Á´ØÁÇπÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ËÉΩÂê¶Âà∞Ëææ‰∫Ü„ÄÇ update : ‰ªîÁªÜËØÅ‰∫Ü‰∏Ä‰∏ã‰πãÂêé‰ºº‰πéËøô‰∏ÄÁªìËÆ∫ÂÜç‰∏§‰∏™ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Áõ∏ÂêåÊó∂‰∏çÊàêÁ´ãÔºåÈúÄË¶ÅÁâπÂà´Âà§‰∏Ä‰∏ã‰ºö‰∏ç‰ºöÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂè™Êúâ‰∏Ä‰∏™ÁÇπ„ÄÇ Êàë‰ª¨Áî®Á∫øÊÆµÊ†ëÁª¥Êä§ÔºåÂØπ‰∫éÊØè‰∏™ÁÇπÊúâÂì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´Ëøô‰∏™ÁÇπ„ÄÇËøôÂèØ‰ª•ÈÄöËøáÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™ÁÇπÂºÄ‰∏Ä‰∏™ vector Êù•ÂÆûÁé∞ÔºåÊü•ËØ¢Âì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´‰∏Ä‰∏™ÁÇπÊó∂ÔºåÂè™ÈúÄÂèñËøô‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâ vector ÁöÑÂπ∂Âç≥ÂèØ„ÄÇÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÔºåÂ∞±ÂØπÂ∑¶Âè≥Á´ØÁÇπÊü•‰∏Ä‰∏ãÔºåÊääÂæóÂà∞ÁöÑËøûÈÄöÂùóÂêàÂπ∂ÔºåÁÑ∂ÂêéÂÜçÊääÊñ∞ÁöÑËøûÈÄöÂùóÂä†ÂÖ•Á∫øÊÆµÊ†ë„ÄÇÁî±‰∫éÊâÄÊúâË¢´‰Ω†Êü•ËøáÁöÑÁÇπ vector ‰∏≠ÊâÄÊúâÁÇπÈÉΩ‰ºöË¢´‰Ω†ÂêàÂπ∂ÔºåÊâÄ‰ª•‰Ω†ÊØèÊü•ËØ¢‰∏Ä‰∏™ÁÇπÁöÑ vector Â∞±ÂèØ‰ª•ÊääÂÆÉÁöÑ vector Ê∏ÖÁ©∫ÔºåËÄåÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÊúÄÂ§öÂ¢ûÂä†‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†Âè™‰ºöÁªô \(\mathcal O(\log n)\) ‰∏™ÁÇπÁöÑ vector Ê∑ªÂä†ÂÖÉÁ¥†„ÄÇÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n \alpha (n))\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x ÊòØÊ†πÔºåÊää y Âä†ÂÖ• xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰ΩúÈáçÈìæÂâñÂàÜÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÈáçÈìæÂâñÂàÜÂêéÁöÑ dfs Â∫è„ÄÇ ‰∏ÄÊù°ÈìæÂèØ‰ª•ÊãÜÊàê dfs Â∫è‰∏ä \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥„ÄÇ Êåâ dfs Â∫èÊääÊØè‰∏™ÁÇπÁöÑÂ≠óÁ¨¶ÊéíÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\)ÔºåÈ¢ÑÂÖàÂª∫‰∏Ä‰∏™ËÉΩ \(\mathcal O(1)\) ËØ¢ÈóÆ \(s\) ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcpÔºåËØ¢ÈóÆ \(s^R\) ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcp ÂíåËØ¢ÈóÆ‰∏Ä‰∏™ \(s\) ÁöÑÂêéÁºÄÂíå \(s^R\) ÁöÑ‰∏Ä‰∏™ÂêéÁºÄÁöÑ lcp ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂèØ‰ª•ÂØπ \(ss^R\) Âª∫Ê†ëÁä∂Êï∞ÁªÑÔºåÂõ†‰∏∫Êàë‰∏çÊìÖÈïøÂÜôÊ†ëÁä∂Êï∞ÁªÑÔºåÊâÄ‰ª•ÊàëÂØπÂÆÉ‰ª¨Áî® SAM Ê±ÇÂá∫‰∫ÜÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂÜô‰∫Ü‰∏Ä‰∏™ \(\mathcal O(n\log n) - \mathcal O(1)\) lca„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆÔºå‰∏ÄÊù°ÈìæÔºåÂèØ‰ª•ÁúãÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÔºåÊâÄ‰ª•Â∞±ÂèòÊàê‰∫Ü‰∏§ÁªÑËã•Âπ≤‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÁöÑ‰∏≤Ë¶ÅÊ±Ç lcpÔºåÂà©Áî®È¢ÑÂ§ÑÁêÜÁöÑ‰ø°ÊÅØ‰ªéÂâçÂæÄÂêé‰æùÊ¨°Ê±ÇÂ∞±Ë°å‰∫Ü„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // ÂÜô‰∏Ä‰∏™Áªô‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊîØÊåÅËØ¢ÈóÆ LCP ÁöÑ‰∏úË•ø int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind ÊòØÊ≠£‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ // rind ÊòØÂèç‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôëÊåâ‰∏≤ÈïøÊ†πÂè∑ÂàÜÁ±ª„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ§ß‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåËøôÊ†∑ÁöÑ‰∏≤‰∏ç‰ºöÂæàÂ§öÔºåÊûö‰∏æÊØè‰∏™ËøôÊ†∑ÁöÑ‰∏≤ÔºåÁî® AC Ëá™Âä®Êú∫ÁªüËÆ°ÂÖ∂‰ªñÊØè‰∏™‰∏≤‰Ωú‰∏∫Ëøô‰∏™‰∏≤Â≠ê‰∏≤Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÆó‰∏Ä‰∏ãÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÂõûÁ≠î‰∏Ä‰∏ãÂÖ≥‰∫éËøô‰∏™‰∏≤ÁöÑÊâÄÊúâËØ¢ÈóÆ„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ∞è‰∫éÁ≠â‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåÊääËØ¢ÈóÆ \([l,r]\) ÊãÜÊàê \([1,r]\) Âíå \([1,l-1]\) Áõ∏ÂáèÔºåÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÊØè‰∏™ÂâçÁºÄÔºåÂõûÁ≠î‰∏éÊØè‰∏™ÂâçÁºÄÁõ∏ÂÖ≥ÁöÑÊâÄÊúâÂõûÁ≠î„ÄÇÂú®Êâ´ÂâçÁºÄÁöÑËøáÁ®ã‰∏≠ÔºåÁî®‰∏Ä‰∏™ AC Ëá™Âä®Êú∫ \(\mathcal O(‰∏≤Èïø)\) ËØ¢ÈóÆËøô‰∏™ÂâçÁºÄ‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êüê‰∏™‰∏≤ÁöÑÂ≠ê‰∏≤Âç≥ÂèØ„ÄÇÈÇ£‰πàÂè™ÈúÄË¶ÅÂú® AC Ëá™Âä®Êú∫‰∏äÂÆûÁé∞‰∏Ä‰∏™ fail Ê†ë‰∏äÁöÑÂ≠êÊ†ëÂä†ÔºàÂä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑ‰∏≤ÔºâÔºåÂú® dfs Â∫è‰∏äËΩ¨‰∏∫Âå∫Èó¥Âä†ÔºåÁî®ÂàÜÂùóÂÅöÂà∞ \(\mathcal O(\sqrt n)\) Âå∫Èó¥Âä†Ôºå \(\mathcal O(1)\) ÂçïÁÇπËØ¢ÈóÆÂ∞±Ë°å‰∫Ü„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÂèØ‰ª•‰∫åÂàÜÁ≠îÊ°àÔºåËΩ¨Âåñ‰∏∫ËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºöÊØè‰∏™ËæπÁöÑËæπÊùÉÊòØÊ≠£Ë¥ü‰∏ÄÔºåÂà§Êñ≠ÊòØÂê¶ÊúâÈïøÂ∫¶Âú® \(l\) Âà∞ \(r\) ‰πãÈó¥ÁöÑË∑ØÂæÑÔºåÊùÉÂÄº‰πãÂíåÈùûË¥ü„ÄÇ ‰ªé‰∏ãÂæÄ‰∏äÂêàÂπ∂ÔºåÊØèÊ¨°ËÄÉËôëÂΩìÂâçÁÇπ‰Ωú‰∏∫ lca ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊääÂ≠êÊ†ëÂêàÂπ∂ÔºåÁî±‰∫é‰Ω†ÂêàÂπ∂Êó∂Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁÇπÂ≠êÊ†ë‰∏≠ÊØè‰∏™Ê∑±Â∫¶Âà∞Ê†πÊùÉÂÄºÂíåÊúÄÂ§ßÁöÑÁÇπÔºåÂèØ‰ª•Áî®ÈïøÈìæÂâñÂàÜÊù•Áª¥Êä§Ê∑±Â∫¶‰ø°ÊÅØ„ÄÇÂêàÂπ∂ÁöÑÊó∂ÂÄôÈ°∫‰æøËØ¢ÈóÆ‰∏Ä‰∏ãÁ≠îÊ°àÔºåÈïøÈìæÂâñÂàÜ + Á∫øÊÆµÊ†ëÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÈïøÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁÇπÂàÜÊ≤ª‰∏Ä‰∏ãÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãÈóÆÈ¢òÔºö Êúâ‰∏§‰∏™Èïø‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a_1\) Âíå \(d_1\)Ôºå‰∏§‰∏™Èïø‰∏∫ \(m\) ÁöÑÊï∞ÁªÑ \(a_2\) Âíå \(d_2\)ÔºåÊ±ÇÔºö \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] Êûö‰∏æ‰∏Ä‰∏ã \(i\)ÔºåÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂΩ¢Â¶Ç \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) ÁöÑ‰∏úË•ø„ÄÇ Ê≥®ÊÑèÂà∞ \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) ËÆæ \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) ÊòØÂæàÂÆπÊòìÂ§ÑÁêÜÁöÑÔºåÂè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(1\ldots m\) ‰∏≠ÁöÑÊï∞ \(i\) ËÄÉËôë \(d_2[i]\phi(a_2[i])\) ÂØπÊØè‰∏™ \(s\) ‰∏≠ \(i\) ÁöÑÁ∫¶Êï∞‰∏ãÊ†á‰ΩçÁΩÆÁöÑË¥°ÁåÆÂç≥ÂèØ„ÄÇ Â¶ÇÊûúÊö¥ÂäõËÆ°ÁÆó‰∏äÂºèÔºåÂ§çÊùÇÂ∫¶‰∏∫ \(1 \ldots n\) ‰∏≠ÊØè‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞‰πãÂíå‰πò‰ª•ÁÇπÂàÜÊ≤ªÁöÑ‰∏Ä‰∏™ \(\log\)„ÄÇÂâçÈù¢ÁöÑÈÉ®ÂàÜÂ§çÊùÇÂ∫¶ÊòØ \(\log^2\) ÁöÑÔºàËÄÉËôë \((\sum \frac 1 i )^2\)ÔºâÔºå‰ªéËÄåÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\log^3 n)\)„ÄÇ ÁªßÁª≠ÂØπ‰∏äÂºèÂèòÂΩ¢Ôºö ËÆæ \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)Ôºå\(t_k\) ÊòØ‰∏Ä‰∏™Â∏∏Êï∞„ÄÇ \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] ËÄÉËôëÂØπ \(t\) ËøõË°åÈ¢ÑÂ§ÑÁêÜ„ÄÇ\(t\) ÊòØ‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞ÔºàÂõ†‰∏∫ÂÆÉÊòØ‰∏§‰∏™ÁßØÊÄßÂáΩÊï∞ÁöÑÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºâÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•ÊääÂÆÉÁ≠õÂá∫Êù•„ÄÇ ‰ΩÜÊòØÂõ†‰∏∫ÊàëÊáíÔºåÊàëÈÄâÊã©Áõ¥Êé•Êö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(t\)ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;„ÄÇÔºå &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Êï∞ËÆ∫</tag>
        <tag>ÁÇπÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Èöè‰æøÂèñ‰∏Ä‰∏™ÁÇπ‰ΩúÊ†πÔºåÁî®Á∫øÊÆµÊ†ëÊåâ dfs Â∫èÁª¥Êä§Â≠òÂú®ÁöÑÁÇπÔºåÁª¥Êä§‰∏Ä‰∏ãÊâÄÊúâÂ≠òÂú®ÁöÑÁÇπÁöÑ lca ÂíåÂà∞Ê†πÁöÑË∑ØÂæÑÁöÑÂπ∂ÁöÑÈïøÂ∫¶Âç≥ÂèØ„ÄÇ ËØØ‰ª•‰∏∫Ë¶ÅÂáèÂéªÁÇπÊï∞ * lca ÁöÑÊ∑±Â∫¶ÔºåË∞É‰∫ÜÂ•Ω‰πÖ... ‰∏ÄÁõ¥Ë∞É‰∏çÂá∫Êù•ÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•‰∏Ä‰∏ãÊòØ‰∏çÊòØÂì™ÈáåÊÉ≥Èîô‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈúÄË¶ÅÁªèÂ∏∏Â§ç‰π†ÁöÑ‰∏úË•ø]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÊÑüËßâËá™Â∑±ËÄÉËØïÁöÑÊó∂ÂÄôÂæàÈöæÁã¨Á´ãÊÉ≥Âá∫Êù•‰ΩÜÊòØÂèàÁªèÂ∏∏‰ºöÂøòÁöÑ‰∏úË•ø„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπËßÅ ËøôÁØá blogÔºåËÄÉÂâçÂ§ç‰π†Áî®„ÄÇ Ê•ºÊàøÈáçÂª∫ÁöÑÂÅöÊ≥ï (2020.03.09) ÊîØÈÖçÊ†ë ‰ºØÂä™Âà©Êï∞‰∏éËá™ÁÑ∂Êï∞ÂπÇÂíå Ëá™ÁÑ∂Êï∞ÁöÑÔºàÂèØÈáç / ‰∏çÂèØÈáçÔºâÊó†Â∫èÊãÜÂàÜÔºöÊ†πÂè∑ÂÅöÊ≥ï‰∏é \(\log\) ÂÅöÊ≥ï jlsÁ∫øÊÆµÊ†ë ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó‰∏éÁ±ªÊ¨ßÂá†ÈáåÂæó Â§ÑÁêÜÂàÜÊØçÁ≠âÂ∑ÆÁîüÊàêÂáΩÊï∞ÁöÑÊñπÊ≥ï ‰Ω†ÁöÑÂêçÂ≠ó ÈÇ£‰∏™È¢òÁöÑÂÅöÊ≥ï ÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÊãìÊâëÂ∫è(ÊåáÊåâÁºñÂè∑‰ªéÂ∞èÂà∞Â§ßÊääÊØè‰∏™ÁÇπÂú®ÊãìÊâëÂ∫è‰∏äÁöÑ‰ΩçÁΩÆÂÜô‰∏ãÊù•ÁöÑÂ∫èÂàó)ÔºåËßÅ agc001_f Âà©Áî®Êó∂Èó¥Êà≥Á∫øÊÄßÂü∫ (ÊåâÊØè‰∏™ÂÖÉÁ¥†Ë¢´Âà†Èô§ÁöÑÊó∂Èó¥) ÂÆûÁé∞Á¶ªÁ∫øËøõË°å‰∏çÂ∏¶ log ÁöÑÁ∫øÊÄßÂü∫ÊèíÂÖ•Âà†Èô§ Âà§Á∫øÊÄßÊó†ÂÖ≥Êó∂ÊääÂÆûÊï∞ÊîπÊàêÂèñÊ®°Âπ∂‰∏ç‰ºöÊúâÂ§™Â§ßÊçüÂ§±ÔºåÁ±ª‰ººÂìàÂ∏åÔºàÈÄêÊ≠•ËÄÉËôëÁü©ÈòµÁöÑÂèòÂåñ~ÔºåÂÖ∂ÂÆûÂè™Ë¶Å‰∏çÂá∫Áé∞Ê®°Êï∞ÂÄçÊï∞Â∞±Ë°å Èìæ‰∏äËØ¢ÈóÆ / Âå∫Èó¥ËØ¢ÈóÆÂ∞è‰∫éÁ≠â‰∫é \(k\) (k ÊØèÊ¨°ÁªôÂÆö) ÁöÑÂÖÉÁ¥†ÁöÑ‰ø°ÊÅØ (‰∏çÂèØÂáè)ÔºåÊúâÂäûÊ≥ï‰∏Ä‰∏™ \(\log\) ÁÇπÂèåËÅîÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï (ÂÜô‰∫ÜÁØáÂÖ¨ÂºÄ blog) ‰∏ÄÁ±ª‰∫åÂàÜÂá∏‰ºòÂåñËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ï ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÂÖ∂Êâ©Â±ï ËÆ∞ÂæóÂç∑ÁßØÂΩ¢ÂºèÁöÑ dp ÂèØ‰ª•ÂàÜÊ≤ª fft ‰ºòÂåñ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éÂõûÊªöÊìç‰ΩúÁöÑÊäÄÂ∑ßÂú®ÈúÄË¶ÅÂõûÊªöÁöÑÊï∞ÁªÑÊØîËæÉÂ§öÁöÑÊó∂ÂÄô‰∏Ä‰∏™‰∏Ä‰∏™ÂºÄÊ†àÂõûÊªö‰ºöÊØîËæÉÈ∫ªÁÉ¶ÔºåÂèØ‰ª•ËØïÁùÄ‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; ËøôÊ†∑ËøòÂéüÁöÑÊó∂ÂÄô‰πüÂè™ÈúÄË¶ÅÊ†πÊçÆÊåáÈíàÊêû‰∏ÄÊêûÂ∞±Â•ΩÔºåÂè™ÈúÄË¶ÅÂºÄ‰∏Ä‰∏™Ê†àÂ∞±Ë°å‰∫ÜÔºåÊ≥®ÊÑè \(k\) ‰∏çË¶ÅÂºÄÂ∞è„ÄÇ ÊúâÊó∂ÂÄô‰Ω†ÈúÄË¶ÅËÆ∞ÂΩï‰∏Ä‰∏™ÊîØÊåÅÈöèÊó∂Ê∏ÖÁ©∫ÁöÑ \(01\) Êï∞ÁªÑÔºåËøôÊó∂ÂèØ‰ª•‰∏çÈ¢ùÂ§ñÂºÄÊ†áËÆ∞Êï∞ÁªÑ„ÄÇËÆ∞‰∏Ä‰∏™ÂèòÈáè \(tim\)ÔºåËµã \(1\) ÁöÑÊó∂ÂÄôÂ∞±ËÆæ‰∏∫ \(tim\)ÔºåÂà§Êñ≠ÊòØ \(0\) ËøòÊòØ \(1\) Â∞±ÁúãÊòØÂê¶Á≠â‰∫é \(tim\)ÔºåÊ∏ÖÁ©∫Â∞± \(tim \leftarrow tim + 1\)„ÄÇ ‰∏ä‰∏ãÁïåË¥πÁî®ÊµÅÔºåÂØπÊØèÊù°ÂøÖÈ°ªËæπ‰∏çË¶ÅÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂØπÊØè‰∏Ä‰∏™ÁÇπËÆ∞‰∏Ä‰∏™Â∫¶Êï∞ÔºåÂÖ®ÈÉ®Ê∑ªÂä†‰πãÂêéÂÜçÊ†πÊçÆÂ∫¶Êï∞ÂÜ≥ÂÆöÊØè‰∏™ÁÇπÂà∞Ë∂ÖÁ∫ßÊ∫êËøòÊòØË∂ÖÁ∫ßÊ±áÔºåËøûÂ§öÂ§ßÊµÅÈáèÁöÑËæπÔºåËøôÊ†∑ÂèØ‰ª•Â§ßÂ§ßÂáèÂ∞ëËæπÊï∞„ÄÇ Âú®ÂÅö dinic Êó∂‰ª•‰∏ã‰∏§‰ªΩ‰ª£Á†ÅÊúâÂ∑®Â§ßÂ∏∏Êï∞Â∑ÆË∑ùÔºå‰∏ãÈù¢ÁöÑÊúâÊó∂ÁîöËá≥ÂèØ‰ª•ÊØî‰∏äÈù¢ÁöÑÂø´ÂçÅÂÄçÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà„ÄÇ 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊääÊìç‰ΩúÁ¶ªÁ∫øÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºåÊääÈóÆÈ¢òÂèòÊàêÂè™ÈúÄË¶ÅÊîØÊåÅÂä†ËæπÔºåÂõûÊªöÔºåÁª¥Êä§‰∏§ÁÇπÈó¥ÊúÄÂ∞è \(xor\) Ë∑ØÂæÑ„ÄÇ Âú®ËØ¢ÈóÆ \(u,v\) ‰∏≠Ôºå‰Ω†ÂèØ‰ª•‰ªé \(u\) Ëµ∞Âà∞ \(t\) ÁÑ∂ÂêéËµ∞Âõû \(u\)ÔºåË∑ØÂæÑ‰∏äÊØèÊù°ËæπÈÉΩË¢´ÁªèËøá‰∏§Ê¨°ÔºåÊâÄ‰ª•Ë∑ØÂæÑ‰∏äÁöÑËæπË¥°ÁåÆ‰∏∫ \(0\)„ÄÇÂõ†Ê≠§Â¶ÇÊûúÊúâ‰∏ÄÊù° \(xor\) ‰∏∫ \(x\) ÁöÑ \(u,v\) Ë∑ØÂæÑÔºåÊúâ‰∏Ä‰∏™ \(xor\) ‰∏∫ \(c\) ÁöÑÁéØÔºåÂ∞±Â≠òÂú®‰∏ÄÊù° \(xor\) ‰∏∫ \(x\oplus c\) ÁöÑË∑ØÂæÑ„ÄÇ ‰ªªÊÑèËÄÉËôë‰∏ÄÊ£µÁîüÊàêÊ†ëÔºåÂØπ‰∫é‰∏Ä‰∏™ÈùûÊ†ëËæπ \(u,v,w\)ÔºåËÆæ \(u\) Âà∞ \(v\) ÁöÑÊ†ë‰∏äË∑ØÂæÑ \(xor\) ‰∏∫ \(x\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ \(xor\) ‰∏∫ \(x \oplus w\) ÁöÑÁéØÔºåÂõ†Ê≠§Â¶ÇÊûúÁªèËøá‰∫ÜËøôÊù°ÈùûÊ†ëËæπÔºåÊàë‰ª¨‰∏çÂ¶®ÊääÂÆÉÁúãÊàêÊòØÊ≤øÁùÄÊ†ë‰∏äË∑ØÂæÑ‰ªé \(u\) Ëµ∞Âà∞ \(v\)„ÄÇ‰πãÂêéÂÜçÂºÇÊàñ‰∏äËøô‰∏™Êç¢ÁöÑÊùÉÂÄº„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÊää \(u\) Âà∞ \(v\) ‰πãÈó¥ÁöÑÊ†ë‰∏äË∑ØÂæÑÂºÇÊàñ‰∏ä‰∏Ä‰∫õÁî±‰∏ÄÊù°ÈùûÊ†ëËæπ‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\)ÔºåÁ≠îÊ°àÊúÄÂ∞èÊòØ‰ªÄ‰πà„ÄÇ Áª¥Êä§ÊâÄÊúâÈùûÊ†ëËæπÂä†‰∏ä‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\) ÁöÑÁ∫øÊÄßÂü∫Âç≥ÂèØ„ÄÇ ÁÑ∂ÂêéËÄÉËôëÊÄé‰πàÂä†ËæπÁª¥Êä§Ëøô‰∏™‰∏úË•ø„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂõûÊªöÔºåÂùáÊëäÁÆóÊ≥ïÔºàÂ¶Ç LCTÔºåË∑ØÂæÑÂéãÁº©ÁöÑÂπ∂Êü•ÈõÜÔºâÊó†Ê≥ï‰ΩøÁî®„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊîØÊåÅËØ¢ÈóÆ‰∏§ÁÇπÊòØÂê¶ËøûÈÄöÔºåËØ¢ÈóÆ‰∏§ÁÇπ‰πãÈó¥ÁöÑ \(xor\)ÔºåÂä†ËæπÂíåÂõûÊªöÂç≥ÂèØ„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁªôÁÇπ \(i\) Áª¥Êä§‰∏Ä‰∏™ÂÄº \(v_i\)ÔºåÂàùÂßãÊó∂ÊâÄÊúâÁÇπÁöÑÂÄº \(=0\)ÔºåÁî®ÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÊù•Áª¥Êä§ËøûÈÄöÊÄß„ÄÇÊàë‰ª¨ÂßãÁªàË¶Å‰øùËØÅÂØπ‰∫é‰ªªÊÑèÁöÑ \(u,v\)ÔºåÂ¶ÇÊûú \(u,v\) ËøûÈÄöÔºåÈÇ£‰πà \(u,v\) ‰πãÈó¥Ê†ë‰∏äË∑ØÂæÑÁöÑ \(xor\) Á≠â‰∫é \(v_u \oplus v_v\)„ÄÇÊØèÊ¨°Âä†ËæπÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰∏§‰∏™ËøûÈÄöÂùóÂπ∂Êàê‰∫Ü‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†ÂèØ‰ª•ÈÄöËøáÊääÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑ \(v_i\) ÂºÇÊàñ‰∏ä‰∏Ä‰∏™Êï∞Êù•‰øùÊåÅËøô‰∏ÄÊÄßË¥®„ÄÇÊåâÁß©ÂêàÂπ∂Êó∂Êâì‰∏™ tag Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å ËøôÊ¨°Â∞ùËØï‰∫Ü‰∏ÄÁßçÊñ∞ÁöÑÁ†ÅÈ£é„ÄÇÁúã‰∏äÂéªÂ≠óÁ¨¶ÈáèÂ∞ë‰∫Ü‰∏çÂ∞ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // ÂáÜÂ§áÂ∑¶Âå∫Èó¥ for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // ÂáÜÂ§áÂè≥Âå∫Èó¥ for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊÑüËßâÊØî E È¢òÈöæ‰ΩÜÊòØËøáÁöÑ‰∫∫ËøúÊØî E È¢òÂ§ö... ‰∏çÁü•ÈÅì piece ÊÄé‰πàÁøªËØëÔºåÂêéÈù¢Áî®Áü≥Â≠ê‰ª£Êåá piece„ÄÇ ÂÖàÊûö‰∏æ‰∏Ä‰∏™ÁÇπ \(r\)ÔºåÁÑ∂ÂêéËÄÉËôëÊääÊâÄÊúâÁü≥Â≠êÈÉΩÁßªÂä®Âà∞ÁÇπ \(r\) ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÊää \(r\) ‰Ωú‰∏∫Ê†πÔºåËÄÉËôëÊØè‰∏™Áü≥Â≠êÂà∞ \(r\) ÁöÑË∑ùÁ¶ª‰πãÂíå \(s\)ÔºåÊòæÁÑ∂Êìç‰Ωú‰∏ç‰ºöÊîπÂèò \(s\) ÁöÑÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Â¶ÇÊûú \(s\) ÊòØÂÅ∂Êï∞Ôºå‰∏çÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°à„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°àÔºåÈÇ£‰πàÊúÄÂ∞ëÊ≠•Êï∞ÂøÖÁÑ∂ÊòØ \(\frac s 2\)ÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰∏™ÊñπÊ°à‰∏≠Êúâ‰∏ÄÊ¨°‰Ωø‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ∞èÔºåÂè¶‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ§ßÔºå‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏Ä‰∏™Ê≠•Êï∞Êõ¥Â∞ëÁöÑÁöÑÊñπÊ°à„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âè™ÈúÄËÄÉËôëÂ¶Ç‰ΩïÊ£ÄÈ™åÊñπÊ°àÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™ËÄÉËôë‰∏Ä‰∏™Â≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºå‰∏çÈöæÂèëÁé∞ÊúÄ‰ºòÊñπÊ°à‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏ÄÁßçÂÖàËøõË°åÂÆåÂÖ®Âú®Êüê‰∏™ÂÑøÂ≠êÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÔºåÂÜçËøõË°å‰∏§‰∏™Áü≥Â≠êÂú®‰∏çÂêåÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÁöÑÊñπÊ°à„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂÅöÊ†ëÂΩ¢ dpÔºåËÆæ \(f_{ij}\) Ë°®Á§∫ÊòØÂê¶ÂèØ‰ª•ÂØπ \(i\) ÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÁü≥Â≠êËøõË°åÊìç‰ΩúÔºå‰ΩøÂæó \(i\) Â≠êÊ†ëÂÜÖÈÉ®Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ª‰πãÂíå‰∏∫ \(j\)„ÄÇËÄÉËôëÊÄé‰πàËΩ¨ÁßªÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∫ÜÁÇπ \(u\) ÊØè‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºåÁªèËøáËøô‰∫õÊìç‰ΩúÊó∂ÂÄôÁ¨¨ \(i\) ‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÁü≥Â≠êÂà∞ \(u\) Ë∑ùÁ¶ª‰πãÂíå‰∏∫ \(s_i\)ÔºåÂÖ±Êúâ \(c\) ‰∏™ÂÑøÂ≠êÔºåËÆæ \(\max s_i = t\)ÔºåÂèØ‰ª•ËØÅÊòéÔºå\(f_{uj} = 1\)ÔºåÂΩì‰∏î‰ªÖÂΩì \(j\) ‰∏é \(\sum s_i\) Â•áÂÅ∂ÊÄßÁõ∏ÂêåÔºå‰∏î \(j \ge 2t - \sum s_i\)„ÄÇËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â§™Â§ß‰∫ÜÔºå‰∏çÈöæÂΩíÁ∫≥ËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(f_{ij} = 1\) ÁöÑ \(j\) ÂøÖÁÑ∂ÊòØÊüê‰∏™Âå∫Èó¥ÂÜÖÁöÑÊâÄÊúâÂ•áÊï∞ / ÂÅ∂Êï∞„ÄÇÂà©Áî®Ëøô‰∏™ÊÄßË¥®ÔºåÊàë‰ª¨ dp ‰ΩøÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™Âå∫Èó¥Âç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóËøô‰∏™Âå∫Èó¥ÁöÑÂè≥ËæπÁïåÊó∂ÔºåÂè™ÈúÄÊääÊâÄÊúâÂÑøÂ≠êÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁü≥Â≠êÂà∞Ëøô‰∏™ÂÑøÂ≠êÁöÑË∑ùÁ¶ª‰πãÂíåÈÉΩÂèñÂà∞ÊúÄÂ§ßÂç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóÂ∑¶ËæπÁïåÊó∂ÔºåÊûö‰∏æÂèñÂà∞Â∑¶ËæπÁïåÁöÑÊñπÊ°à‰∏≠Âì™‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) ÊúÄÂ§ßÔºåËÆ©ÂÖ∂‰ªñÂÑøÂ≠êÁöÑ \(s_i\) ÈÉΩÂ∞ΩÈáèÂ∞èÔºåËøô‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) Âú®Â§ß‰∫éÁ≠â‰∫éÂÖ∂‰ªñÂÑøÂ≠êÁöÑÂâçÊèê‰∏ãÂ∞ΩÈáèÂ∞èÔºåÊõ¥Êñ∞‰∏Ä‰∏ãÂ∑¶ËæπÁïåÂç≥ÂèØ„ÄÇÂÖ∑‰ΩìÂÆûÁé∞ÂèØ‰ª•Áúã‰ª£Á†Å„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂæàÊúâÂêØÂèëÊÄßÁöÑÈóÆÈ¢ò...ÂÅö‰∫Ü‰∏ÄÈÅçÊääÂØπ FWT ÁêÜËß£ÁöÑ‰∏çÂΩªÂ∫ïÁöÑÂú∞ÊñπÈÉΩÊêûÊ∏ÖÊ•ö‰∫Ü„ÄÇ ÂÄíËøáÊù•ÁúãÔºåËÆ°ÁÆóÊØè‰∏™Êï∞ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåÊòæÁÑ∂Á≠îÊ°àÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ È¶ñÂÖàËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Âàó \(2^n\) ÂÖÉÁ∫øÊÄßÊñπÁ®ãÁªÑÂéªËß£Ôºå‰ΩÜÊòØÊö¥ÂäõÈ´òÊñØÊ∂àÂÖÉÁöÑÂ§çÊùÇÂ∫¶Â§™È´ò‰∫Ü„ÄÇ Êàë‰ª¨ËÆæ \(f_i\) Ë°®Á§∫ \(i\) ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞Ôºå\(p_i\) Ë°®Á§∫ÈöèÊú∫Êï∞ÁîüÊàêÂô®ÁîüÊàê \(i\) ÁöÑÊ¶ÇÁéá„ÄÇÈÇ£‰πàÂèØ‰ª•ÂèëÁé∞ \(f\) Êï∞ÁªÑÊª°Ë∂≥ÊñπÁ®ã \(f = f\cdot p + w x^0 + \sum x^S\)„ÄÇÂÖ∂‰∏≠‰πòÊ≥ïË°®Á§∫ÈõÜÂêàÂºÇÊàñÂç∑ÁßØ„ÄÇ ÁßªÈ°πÂæóÂà∞ \((x^0-p)f = w x^0 + \sum x^S\)ÔºåÂØπ‰∏§ËæπÂêåÊó∂ FWTÔºåÂæó \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)„ÄÇÊòæÁÑ∂ \(\hat{p}_{0} = \sum p_S= 1\)Ôºå‰ªéËÄå \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)ÔºåËøôÂ∞±Êé®Âá∫‰∫Ü \(w = -2^n\)„ÄÇÊòæÁÑ∂ \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)Ôºå‰ªéËÄåÂèØ‰ª•Êé®Âá∫ \(\hat{f}_S\) ÁöÑÂÄº„ÄÇÊé•‰∏ãÊù•ÔºåÂè™Ë¶ÅÁü•ÈÅì \(\hat f_0\) Â∞±ÂèØ‰ª• IFWT Âá∫ \(f\) ‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞Ôºå\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)ÔºåÂè™ÈúÄÈöè‰æøÁªô \(\hat f_0\) ËÆæ‰∏Ä‰∏™ÂÄºÔºåÁÑ∂Âêé IFWT Âá∫‰∏Ä‰∏™Êï∞ÁªÑ \(f\)ÔºåÂØπÊØè‰∏™ \(i\) Êää \(f_i\) ÂáèÂéª \(f_0\) Âç≥ÂèØ„ÄÇÔºàËøôÈáåÁî®Âà∞‰∫Ü \(f_0 = 0\) ÁöÑÊù°‰ª∂Ôºâ Ê®°Êï∞ÂÜôÊàê \(10^9+7\) ËøòË∞É‰∫ÜÂ•Ω‰πÖ...ÊàëÁúüÁöÑÊòØ zz„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc È¢òÂè∑ÂæàÁ•ûÂ•á...‰ª•ÈìæÊé•‰∏≠ÁöÑ‰∏∫ÂáÜ„ÄÇ È¢òËß£ ÁªôÁÇπ \(i\) ‰∏Ä‰∏™ÊùÉÈáç \(w_i\)ÔºåÈáçÊñ∞ÂÆö‰πâ \(D_i = \sum_k w_k dis(i,k)\)„ÄÇÂàùÂßãÊó∂ÂØπ‰∫éÊâÄÊúâÁöÑ \(i\)Ôºå\(w_i = 1\)„ÄÇ‰ªªÊÑèÊó∂ÂàªÔºå\(\sum_i w_i = n\)„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁÇπ \(v\) ‰∏éÁÇπ \(u\) Áõ∏ÈÇªÔºå‰ª•ÁÇπ \(u\) ‰∏∫Ê†πÊó∂ÁÇπ \(v\) ÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáç‰πãÂíå‰∏∫ \(s\)ÔºåÂàô \(D_v - D_u = n - 2s\)„ÄÇ ÊâæÂà∞ \(D_u\) ÊúÄÂ§ßÁöÑÁÇπ \(u\)ÔºåÁî±‰∫é‰ªª‰Ωï‰∏é \(v\) Áõ∏ÈÇªÁöÑÁÇπÈÉΩÊª°Ë∂≥ \(D_v - D_u \le 0\)ÔºåÊâÄ‰ª•‰ª• \(u\) ‰∏∫Ê†π \(v\) Â≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáçÂíåËá≥Â∞ë‰∏∫ \(\frac n 2\)ÔºåÊâÄ‰ª• \(u\) Ëá≥Â§öÊúâ‰∏Ä‰∏™Áõ∏ÈÇªÁÇπ„ÄÇÊàë‰ª¨‰∏çËÄÉËôë \(n = 1\) ÁöÑÊÉÖÂÜµ„ÄÇ\(u\) ÊòØ‰∏Ä‰∏™Âè∂Â≠ê„ÄÇ ÂÅáËÆæ‰∏é \(u\) Áõ∏ÈÇªÁöÑÁÇπÊòØ \(f\)ÔºåÈÇ£‰πà \(D_f-D_u = 2w_u - n\)ÔºåÁî±‰∫é \(D_i\) ‰∫í‰∏çÁõ∏ÂêåÔºåËøôÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü \(u\) ÁöÑÁà∂‰∫≤ \(f\)„ÄÇÊàë‰ª¨ËÆ∞ÂΩï‰∏Ä‰∏ãÁÇπ \(u\) ÂíåÁÇπ \(f\) Ëøû‰∏ÄÊù°ËæπÔºåÊääÁÇπ \(f\) ÁöÑÊùÉÈáçÂä†‰∏äÁÇπ \(u\) ÁöÑÊùÉÈáçÔºåÁÑ∂ÂêéÊääÁÇπ \(u\) Âà†Âéª„ÄÇËøôÊ†∑ÂØπËøòÂú®Ê†ë‰∏äÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÁÇπ \(i\)ÔºåÁªèËøáËøôÊ¨°Êìç‰Ωú \(D_i\) ÊÅ∞Â•ΩÂáèÂ∞ë‰∫Ü \(w_u\)„ÄÇÊõ¥Êñ∞‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰∏ÄÁõ¥ËøôÊ†∑Êìç‰Ωú‰∏ãÂéªÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü‰∏ÄÊ£µÊ†ëÔºåÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÔºàÊáíÂæóÂà§ÁâπÊÆäÊÉÖÂÜµÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõÈ™åËØÅ‰∫ÜÔºâ ÂÆûÈôÖ‰∏ä‰∏çÈúÄË¶ÅÊõ¥Êñ∞ \(D_i\)ÔºåÂõ†‰∏∫ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØÊï¥‰ΩìÂä†ÔºåËÄåÊàë‰ª¨ÂßãÁªàÂè™‰ºöÁî®Âà∞ \(D_i\) ÁöÑÁõ∏ÂØπÂ§ßÂ∞èÂÖ≥Á≥ªÂíå \(D_f-D_u\) ÁöÑÂÄº„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ËÆæ \(f_{ij}\) Ë°®Á§∫ \(A_i &lt; A_j\) ÁöÑÊ¶ÇÁéá„ÄÇ ÊØèÊ¨°‰øÆÊîπ \(\mathcal O(n)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ ÊúÄÂêéÊ±ÇÂá∫ÈÄÜÂ∫èÂØπ‰∏™Êï∞ÁöÑÊúüÊúõÔºå‰πò‰ª• \(2^q\) Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÁªìËÆ∫ÔºåÊääËæìÂÖ•ÁöÑÊï∞ÁªÑÁúã‰Ωú \(n\) ‰∏™Ê†ºÂ≠êÔºåÊØè‰∏™Ê†ºÂ≠êÈáåÂ°´‰∫Ü‰∏Ä‰∏™Êï∞Â≠ó„ÄÇÂØπÊ†ºÂ≠êÈªëÁôΩÊüìËâ≤ÔºåÁ¨¨‰∏Ä‰∏™Ê†ºÂ≠êÊòØÈªëËâ≤ÔºåÁõ∏ÈÇª‰∏§‰∏™Ê†ºÂ≠êÈ¢úËâ≤‰∏çÂêå„ÄÇ ‰∏çÈöæÂèëÁé∞ÁªìËÆ∫ÔºöÂ¶ÇÊûú \(n\) ‰∏∫ÂÅ∂Êï∞ÔºåÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÂæóÂà∞ÁöÑÊî∂ÁõäÊòØÈªëÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏éÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíåÁöÑÊúÄÂ§ßÂÄº„ÄÇÂ¶ÇÊûú \(n\) ‰∏∫Â•áÊï∞ÔºåËÆæÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏∫ \(s\)ÔºåÂÖàÊâãËÉΩÂ§üËé∑ÂæóËá≥Â∞ë \(x\) ÁöÑÊî∂ÁõäÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏ÄÁßçÈÄâÂá∫Ëã•Âπ≤‰∏™ÁôΩÊ†ºÂ≠êÁöÑÊñπÊ°àÔºåÁî®Ëøô‰∫õÁôΩÊ†ºÂ≠êÊää \(n\) ‰∏™Ê†ºÂ≠êÂàÜÊàêËã•Âπ≤‰∏™ËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÂÜÖÈªëÊ†ºÂ≠êÁöÑÂíåÂáèÂéªÁôΩÊ†ºÂ≠êÁöÑÂíåÈÉΩÂ§ß‰∫éÁ≠â‰∫é \(x-s\)„ÄÇ ËØÅÊòéÊØîËæÉÊòæÁÑ∂ÔºåÂÖ∑‰ΩìËøáÁ®ã‰∏çÂÜôÂá∫‰∫Ü„ÄÇÂ§ßÊ¶ÇÊÄùË∑ØÂ∞±ÊòØË¶ÅËØÅÊòéÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÁöÑÊî∂ÁõäÊòØ \(x\)ÔºåÂè™ÈúÄÂÖàÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•ÔºåÊó†ËÆ∫ÂêéÊâãÊÄé‰πàÊìç‰ΩúËá≥Â∞ëËÉΩÂ§ü \(x\) ÁöÑÊî∂ÁõäÔºåÂêéÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•Êó†ËÆ∫ÂÖàÊâãÊÄé‰πàÊìç‰Ωú‰∏ÄÂÆöËÉΩ‰ΩøÂÖàÊâãËé∑ÂæóËá≥Â§ö \(x\) ÁöÑÊî∂Áõä„ÄÇ\(n\) ‰∏∫Â•áÊï∞Áõ¥Êé•ÂÅöÔºå\(n\) ‰∏∫ÂÅ∂Êï∞‰∫åÂàÜ dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂèØ‰ª•ÂèëÁé∞ÔºåÂÅáËÆæÊúÄÁªàËÉΩÂèòÊàê 0ÔºåÂ¶ÇÊûúÊúâ 000ÔºåÁ¨¨‰∏ÄÊ≠•Êìç‰ΩúÊääÂÆÉÂèòÊàê 0 ‰∏ÄÂÆöÊúÄÁªà‰ªçÁÑ∂ËÉΩÂèòÊàê 0„ÄÇËøôÊòØÂõ†‰∏∫ÔºåÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™Á¨¨‰∏ÄÊ≠•‰∏çÊòØÂØπËøô‰∏â‰∏™Êï∞Êìç‰ΩúÔºåËÄÉËôëÁ¨¨‰∏ÄÊ¨°ÂΩ±ÂìçÂà∞Ëøô‰∏â‰∏™Êï∞‰∏≠Êüê‰∏™Êï∞ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøô‰∏™Êìç‰ΩúÂ∞±ÊòØÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0ÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ÊääËøôÊ¨°Êìç‰ΩúÁßªÂä®Âà∞Á¨¨‰∏ÄÊ¨°Êìç‰Ωú„ÄÇÂê¶ÂàôÁöÑËØùÔºåÈÇ£‰πàÊääËøôÊ¨°Êìç‰ΩúÊîπ‰∏∫ÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0 ËÇØÂÆö‰∏ç‰ºöÊõ¥Âä£„ÄÇÔºàÂõ†‰∏∫ÊääÂ∫èÂàó‰∏äÁöÑ‰∏Ä‰∏™ 0 Êîπ‰∏∫ 1 ÂæóÂà∞ÁöÑÂ∫èÂàó‰∏ÄÂÆö‰∏ç‰ºöÊõ¥Âä£ÔºâÁî®Á±ª‰ººÁöÑÊÄùË∑ØÂèØ‰ª•ËØÅÊòéÔºåÂ¶ÇÊûúÊúâ 010ÔºåÁ¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 0 ‰πü‰∏ç‰ºöÊõ¥Âä£ÔºåÂ¶ÇÊûúÊúâ 101 Á¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 1 ‰πü‰∏ç‰ºöÊõ¥Âä£„ÄÇ ËÄÉËôë‰∏Ä‰∏™Â∫èÂàóÔºåÂèçÂ§çËøõË°å‰ª•‰∏ä‰∏âÁßçÊìç‰ΩúÁõ¥Âà∞‰∏çËÉΩÊìç‰ΩúÔºåÊääÂæóÂà∞ÁöÑÂ∫èÂàóÂàíÂàÜ‰∏∫Ëã•Âπ≤‰∏™ 0 / 1 ÁöÑËøûÁª≠ÊÆµÔºåÈô§‰∫ÜÂºÄÂ§¥ÂíåÁªìÂ∞æÁöÑËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ \(2\)Ôºå‰∏î 0 ÁöÑËøûÁª≠ÊÆµÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá \(2\)„ÄÇÊòæÁÑ∂Êää 111 ÂèòÊàê 1 ÊòØ‰∏ç‰ºòÁöÑ„ÄÇ‰∏çÈöæÁî®ÂΩíÁ∫≥Ê≥ïËØÅÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÔºåÈÉΩ‰∏ç‰ºöÂá∫Áé∞ 000„ÄÇÔºàËÄÉËôëÂú®ËøõË°å‰∏ÄÊ≠•Êìç‰Ωú‰πãÂêéÔºåÂà©Áî® 010 Âèò‰∏∫ 0 ÁöÑÁªìËÆ∫ÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰ΩúÔºåËøôÊ†∑Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™Êõ¥Áü≠ÁöÑÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºâËÄåÂÖ∂‰ªñÊìç‰ΩúÈÉΩ‰ºö‰Ωø 0 ÁöÑ‰∏™Êï∞Âíå 1 ÁöÑ‰∏™Êï∞ÂêåÊó∂ÂáèÂ∞ë 1„ÄÇËøôÂ∞±ËØ¥ÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÊúÄÁªàËÉΩÂèòÊàê 1ÔºåÂΩì‰∏î‰ªÖÂΩì 1 ÁöÑ‰∏™Êï∞Â§ß‰∫é 0 ÁöÑ‰∏™Êï∞„ÄÇÔºàÈïøÂ∫¶ÂøÖ‰∏∫Â•áÊï∞Ôºâ ÂØπËøô‰∏™‰∏úË•ø dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂâçÁºÄ 1 ÁöÑ‰∏™Êï∞ÂáèÂéª 0 ÁöÑ‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫é \(2\)ÔºåËøô‰∏™Â∫èÂàóÂøÖÁÑ∂ÂèØ‰ª•ÂèòÊàê 0„ÄÇÊâÄ‰ª•ÂÆûÈôÖÈúÄË¶ÅËÆ∞ÁöÑÁä∂ÊÄÅÊï∞ÂæàÂ∞ë„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂØπ‰∫é \(i, j\)ÔºåËÄÉËôë \(P_i &gt; P_j\) ÁöÑÊñπÊ°àÊï∞„ÄÇÂè™ÈúÄËÄÉËôë \(A_i \le A_j\) ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇËøôÁõ∏ÂΩì‰∫éÊòØÊää \(A_j\) Êîπ‰∏∫ \(A_i\) ‰πãÂêéÊª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÈôêÂà∂ÁöÑÊéíÂàóÊï∞Èô§‰ª• \(2\)„ÄÇ Êää \(1 \ldots n\) Êåâ \(A_i\) ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåËÆæÊéíÂ∫èÂêéÁ¨¨ \(i\) ‰∏™Êï∞ÊòØ \(p_i\)„ÄÇÊòæÁÑ∂Êª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÊéíÂàóÊÄªÊï∞‰∏∫ \(\prod_i A_{p_i}-i+1\)„ÄÇËÆæÊÄªÊï∞‰∏∫ \(C\)„ÄÇ ËÆæ \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) ÂØπÊâÄÊúâÊª°Ë∂≥ \(p_i &lt; p_j\) ÁöÑ \((i,j)\) ËÆ°ÁÆó \(P_{p_i} &gt; P_{p_j}\) ÁöÑÊéíÂàóÊï∞„ÄÇÂØπ‰∫éÊØè‰∏ÄÂØπ \(i &lt; j\)ÔºåÂ¶ÇÊûú \(p_i &lt; p_j\)ÔºåÈÇ£‰πàÂÆÉÁöÑË¥°ÁåÆÊòØ \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)„ÄÇ\(p_i &gt; p_j\) ÁöÑÊÉÖÂÜµÊ≤°ÊúâÂæàÂ§ßÂå∫Âà´ÔºåÂÖ∑‰ΩìÂºèÂ≠êÂ∞±‰∏çÂÜôÂá∫Êù•‰∫Ü„ÄÇÊûö‰∏æ \(j\)ÔºåÁî®Á∫øÊÆµÊ†ëÂØπÊØè‰∏™ \(p_i\) Áª¥Êä§‰∏ãËøô‰∏™ÂºèÂ≠êÔºåÊØèÊ¨°ÁßªÂä® \(j\) ÁöÑÊó∂ÂÄôÂå∫Èó¥‰πòÊõ¥Êñ∞ÔºåÁªüËÆ°Á≠îÊ°àÊó∂Âå∫Èó¥Ê±ÇÂíåÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ËÆ°Êï∞</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ update: ÊÑüËßâÊàëÂÅöÈ∫ªÁÉ¶‰∫ÜÔºåÈ¢òËß£ÂÅöÊ≥ïÂ•ΩÁÆÄÂçï„ÄÇËøôÁØá blog Â∞±‰∏¢ËøôÂêß‚Ä¶..ÊÑüËßâÊ≤°‰ªÄ‰πàÈîôËØØ„ÄÇ Â¶ÇÊûúÂè™Êää \(0\) ÂèòÊàê \(1\) ËÄå‰∏çÊää \(1\) ÂèòÊàê \(0\)Ôºå‰ºöÂØºËá¥ \(0\) ÁöÑ‰∏™Êï∞ÂáèÂ∞ëÔºåËøò‰∏çÂ¶Ç‰∏çÊîπÂèòÂéüÂ∫èÂàó„ÄÇ Â¶ÇÊûúÊó¢Âá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ‰πüÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\)ÔºåËÆæÊüê‰∏Ä‰∏™Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_1\)ÔºåÊüê‰∏Ä‰∏™Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_2\)„ÄÇ ‰∏çÂ¶®ËÆæ \(p_1 &lt; p_2\)„ÄÇÔºàÂ¶ÇÊûú \(p_1 &gt; p_2\)Ôºå‰∫§Êç¢ÂéüÂ∫èÂàóÂíåÊñ∞Â∫èÂàóÂ∞±Âíå‰∏ÄÁßç \(p_1 &lt; p_2\) ÁöÑÊÉÖÂÜµÁ≠â‰ª∑‰∫ÜÔºâ ËÆæ \(f[l,r]\) Ë°®Á§∫ÂéüÂ∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶Ôºå\(g[l,r]\) Ë°®Á§∫Êñ∞Â∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ ÂÆö‰πâ \(f[l,r] = g[l,r] = 0(l &gt; r)\)„ÄÇ ÈÇ£‰πà \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)„ÄÇ Âõ†Ê≠§Êñ∞Â∫èÂàó‰∏ä \([p_1,p_2]\) ‰∏≠ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂøÖÁÑ∂Ë¶ÅÂåÖÂê´ \(p_1\) Âíå \(p_2\)Ôºå‰ΩÜÊòØÊñ∞Â∫èÂàó‰∏ä \(p_1\) ‰ΩçÁΩÆ‰∏∫ \(1\)Ôºå\(p_2\) ‰ΩçÁΩÆ‰∏∫ \(0\)ÔºåËøôÊòØ‰∏çÂèØËÉΩÁöÑ„ÄÇ Âõ†Ê≠§ÔºåÂè™‰ºöÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆÔºå‰∏ç‰ºöÂá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ„ÄÇ ËÄÉËôëÊää‰∏Ä‰∏™‰ΩçÁΩÆÂú®ÂéüÂ∫èÂàóÂ∑¶Á´ØÊàñÂ∑¶Ëæπ‰∏ç‰∏∫ \(1\) ÁöÑ \(1\) ÂèòÊàê \(0\)Ôºå‰∏çÂØπ‰ªªÊÑèÂå∫Èó¥ÂÜÖÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàó‰∫ßÁîüÂΩ±ÂìçÁöÑÊù°‰ª∂„ÄÇ ÂÅáËÆæËøô‰∏™‰ΩçÁΩÆÊòØ \(p\)„ÄÇÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö \(p &lt; n\) ‰∏î‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(1\). \(p = n\) Êàñ‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\). ÂÖàÁúãÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ„ÄÇÊää‰ΩçÁΩÆ \(p\) ‰∏äÁöÑ \(1\) ÂèòÊàê \(0\) Áúã‰ΩúÊñ∞Â∫èÂàóÔºàÁî® \(g[l,r]\) ÊèèËø∞Êñ∞Â∫èÂàó‰∏äÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºâ„ÄÇÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)ÔºåËÄåÊñ∞Â∫èÂàó‰∏ä‰ΩçÁΩÆ \(p\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøôËØ¥Êòé \([i,p-1]\) Â≠òÂú®ÁªìÂ∞æ‰∏∫ \(0\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂç≥ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÁ≠â‰∫é \([i, p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞„ÄÇÂèØ‰ª•ËØÅÊòéËøô‰∏™Êù°‰ª∂ÂØπ‰ªªÊÑèÁöÑ \(i &lt; p\) ÈÉΩÊàêÁ´ãÁöÑÂÖÖË¶ÅÊù°‰ª∂‰∏∫ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\([i,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºöÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑÔºåÂè™ÈúÄËØÅÂÖÖÂàÜÊÄßÔºåÂÅáËÆæ \([i, p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂ§ß‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºå‰ªªÂèñ‰∏Ä‰∏™ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂÆÉÂøÖÁÑ∂ÂåÖÂê´‰∏Ä‰∏™ \(1\)ÔºåËÆæÁ¨¨‰∏Ä‰∏™ \(1\) ‰ΩçÁΩÆ‰∏∫ \(k\)ÔºåÈÇ£‰πàËøô‰∏™Â≠êÂ∫èÂàó \(k\) ‰πãÂâçÁöÑÂÖÉÁ¥†ÂÜçÊãº‰∏ä \([k,p-1]\) ‰∏≠ÊâÄÊúâÁöÑ \(0\) ÂøÖÁÑ∂ÊòØ‰∏Ä‰∏™ÂÖ® \(0\) ÁöÑ‰∏ç‰ºöÊõ¥Áü≠ÁöÑÂ≠êÂ∫èÂàóÔºàÂõ†‰∏∫ \([k,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºâÔºåËøô‰∏é‰∏çÂ≠òÂú®ÂÖ®‰∏∫ \(0\) ÁöÑ‰∏çÈôçÂ≠êÂ∫èÂàóÁüõÁõæ„ÄÇ‰∏çÈöæÈ™åËØÅËøô‰πüÊòØÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏≠ËÉΩÊää \(p\) ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂„ÄÇ Á¨¨‰∫åÁßçÊÉÖÂÜµÊòæÁÑ∂‰πüÂøÖÈ°ªË¶ÅÊª°Ë∂≥Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑÊù°‰ª∂„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÁî±‰∫é‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøòÈúÄÊª°Ë∂≥ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &gt; p\)Ôºå\([p+1,i]\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºà‰∏éÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑËØÅÊòéÁ±ª‰ººÔºåËØ¶ÁªÜËøáÁ®ãÂ∞±‰∏çÂÜô‰∫ÜÔºâ„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ë¥™ÂøÉÔºåÂØπ‰∫é‰∏Ä‰∏™‰ΩçÁΩÆÔºåÂ¶ÇÊûúÂÆÉÊòØ \(1\)Ôºå‰∏îËÉΩÂ§ü‰øùÊåÅ‰ªªÊÑèÂå∫Èó¥ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏çÂèòÂú∞Âèò‰∏∫ \(0\)ÔºåÂ∞±ÊääÂÆÉÂèòÊàê \(0\)„ÄÇ‰∏çÈöæËØÅÊòéËøôÁßçË¥™ÂøÉÊòØÊ≠£Á°ÆÁöÑÔºåËØ¶ÁªÜËØÅÊòéËøôÈáå‰∏çÂÜô‰∫Ü„ÄÇÔºàÊèêÁ§∫ÔºöËÄÉËôëÊúÄ‰ºòËß£‰∏≠ \(1\rightarrow0\) ÁöÑÊúÄÂ∞è‰ΩçÁΩÆÔºâ Âà§Êñ≠ÊòØÂê¶Â≠òÂú®ÂâçÁºÄ / ÂêéÁºÄ \(0\) ÁöÑ‰∏™Êï∞Â§ö‰∫é / Â∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºåÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÊØè‰∏™ÂâçÁºÄ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞Âáè \(1\) ÁöÑ‰∏™Êï∞ÂæàÂÆπÊòìÂú∞Â§ÑÁêÜ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[ËøòÊ≤°ÂÜôËøá„ÄÇÂ¶ÇÊûúÊúâÈîôËØØÂèØ‰ª• QQ / ËØÑËÆ∫ÂëäËØâÊàë„ÄÇ È¢òËß£ ËøôÊ†∑ÁêÜËß£Ëøô‰∏™ÈóÆÈ¢òÔºöÂàùÂßãÊó∂Êó∂Èó¥‰∏∫Á¨¨ \(0\) Áßí„ÄÇÊØèÁßí‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™ \(i\)ÔºåÁÑ∂ÂêéÊää \(a_i\) Âä†‰∏ä \(k\)ÔºåÊé•‰∏ãÊù•ÂÜçÊääÊâÄÊúâ \(a_i\) ÂáèÂéª \(1\)„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÂÅúÊ≠¢Ëøô‰∏™ËøáÁ®ãÔºåÂπ∂ÊääÂΩìÂâçÁöÑ \(a\) Êï∞ÁªÑ‰Ωú‰∏∫ÁªìÊûú„ÄÇÈóÆÂú®‰∏çÁªèËøá‰ªª‰ΩïÂ≠òÂú® \(a_i &lt; 0\) ÁöÑÁä∂ÊÄÅÁöÑÂâçÊèê‰∏ãÔºåËÉΩÂ§üÂæóÂà∞Â§öÂ∞ëÁßç‰∏çÂêåÁöÑÁªìÊûú„ÄÇ ‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÔºåÂ¶ÇÊûú‰∏çËÄÉËôë \(+k\) Êìç‰ΩúÔºåÊØèÁßíÊØè‰∏™ \(a_i\)ÈÉΩ‰ºöÂáèÂ∞ë \(1\)„ÄÇ ËÆæ \(c_{t,i}\) Ë°®Á§∫Ââç \(t\) Áßí \(a_i\) Ë¢´ÊâßË°å \(+k\) Êìç‰ΩúÁöÑÊ¨°Êï∞„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúËøô‰∏™ËøáÁ®ãÂú®ËøõË°å‰∫Ü \(T\) Áßí‰πãÂêéÁªìÊùüÔºå\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)Ôºå‰πüÂ∞±ÊòØËØ¥ \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)„ÄÇ ‰∏çÈöæËØÅÊòéÂ≠òÂú®ÁªèËøá \(T\) ÁßíÊ≤°ÊúâÂá∫Áé∞ËøáË¥üÊï∞ÁöÑÊñπÊ°àÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºö \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] ÂØπ‰∫é \(t \in \mathbb{N}\)Ôºå\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) ÊòØÂê¶ÊàêÁ´ãÊòØ‰∏é \(T\) Êó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåË¶Å‰πàÂØπÊâÄÊúâÁöÑ \(T\) ÈÉΩÂ≠òÂú®‰∏çÁªèËøáË¥üÊï∞ÁöÑÊñπÊ°àÔºåË¶Å‰πàÂ≠òÂú®‰∏Ä‰∏™ÈùûË¥üÊï¥Êï∞ \(T_0\)ÔºåÂΩì \(T \le T_0\) Êó∂Â≠òÂú®ÊñπÊ°àÔºå\(T &gt; T_0\) Êó∂‰∏çÂ≠òÂú®ÊñπÊ°à„ÄÇ Â§™Êôö‰∫ÜÂÖàÁù°‰∫Ü„ÄÇÂùëÂæÖÂ°´„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[Âè£ËÉ°ÁöÑÊ≤°ÂÆûÁé∞ËøáÔºåÂ¶ÇÊúâÈîôËØØËØ∑ QQ ÊàñËØÑËÆ∫ÂëäËØâÊàëÔºÅ È¢òËß£ ËÄÉËôëÂè™Êúâ‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÁöÑÊÉÖÂÜµ„ÄÇ Á¨¨‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_1, a_1b_1, a_1b_1^2, \ldots\) Á¨¨‰∫å‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_2,a_2b_2,a_2b_2^2,\ldots\) ÂÅáËÆæ \(v\) ÂêåÊó∂Âá∫Áé∞Âú®‰∏§‰∏™Á≠âÊØîÊï∞Âàó‰∏≠ÔºåÈÇ£‰πà \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)„ÄÇ ËÆæ \(p_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™Á¥†Êï∞„ÄÇ \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) ËÄÉËôë‰ªªÊÑè‰∏§‰∏™‰∏çÂêåÁ¥†Êï∞ \(p_i\) Âíå \(p_j\)ÔºåÂÅáËÆæ \(p_i\) Âú® \(a_1,a_2\) ‰∏≠Âá∫Áé∞Ê¨°Êï∞ÂàÜÂà´ÊòØ \(w_{1i},w_{2i}\)„ÄÇ ÈÇ£‰πàÊúâ \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] ËøôÊòØ‰∏Ä‰∏™‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑ„ÄÇÂÅáËÆæ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåËøô‰∏™ÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ ÂÅáËÆæÂ≠òÂú® \(i &lt; j\)Ôºå \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåÈÇ£‰πàËß£Âá∫Ëøô‰∏™ÊñπÁ®ã„ÄÇËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÂîØ‰∏Ä‰∏Ä‰∏™ÂèØËÉΩÊòØÊâÄÊúâÁ≠âÊØîÊï∞ÂàóÂÖ±ÊúâÂÖÉÁ¥†ÁöÑÊï∞ÔºàÁöÑÁ¥†Âõ†Êï∞ÂàÜËß£ÔºâÔºåÁÑ∂ÂêéÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; j\) ÈÉΩÊúâ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÁõ∏ÂÖ≥„ÄÇ ÈÇ£‰πàÂ≠òÂú®Ê≠£Êï¥Êï∞ \(w\)Ôºå\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)„ÄÇ \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] ‰∏çÂ¶®ËÆæ \(a_1 \le a_2\)„ÄÇÈÇ£‰πà‰∏ÄÂÆöÊúâ \(a_1 \mid a_2\)„ÄÇ ËÆæ \(\frac {a_2} {a_1} = x\)ÔºåÂ¶ÇÊûúÊúâËß£ÔºåÂøÖÊúâ \(x = w^n, n \in \mathbb{N}\)„ÄÇ ÊñπÁ®ãÂèò‰∏∫ \(k_1i_1-k_2i_2 = n\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰∏çÂÆöÊñπÁ®ã„ÄÇ‰∏çÈöæÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑ‰∏ÄÁªÑËß£ \(k_1= x, k_2 = y\)„ÄÇÔºàÂÖ∑‰ΩìÊù•ËØ¥ÂÖàÊâæÂà∞ \(k_1i_1-k_2i_2=1\) ÁöÑËß£ÔºåÁÑ∂ÂêéÂú®‰∏§Ëæπ‰πò‰ª• \(n\)Ôºâ ÈÇ£‰πàËøô‰∏™ÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)„ÄÇ ‰∏çÈöæÊâæÂà∞ \(k_1\) ÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞Ëß£ÔºåÂÅáËÆæËøôÊó∂ \(a_1w^{k_1c_1}=t\)„ÄÇËøôÊ†∑‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÂ∞±Ë¢´ÂêàÂπ∂‰∏∫‰∫Ü‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)„ÄÇ ÁªßÁª≠ÊääÂêàÂπ∂ÂæóÂà∞ÁöÑÁ≠âÊØîÊï∞ÂàóÂíåÂÖ∂‰ªñÁ≠âÊØîÊï∞ÂàóËøõË°åÁõ∏ÂêåÁöÑÊìç‰ΩúÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÊîØÈÖçÊ†ë]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÊîØÈÖçÊ†ëÁöÑÁÆóÊ≥ïÂæàÂ¶ô„ÄÇÂÆÉÁöÑËØÅÊòéÂÆûÂú®Â§™Èïø‰∫Ü‚Ä¶.ÂÆåÊï¥ÂÜô‰∏ÄÈÅçÊØîËæÉË¥πÊó∂Èó¥ÔºåËøôÈáåÂ∞±Âè™ÂÜôÁªìËÆ∫‰∫Ü„ÄÇ ÊòæÁÑ∂ÊîØÈÖçÂÖ≥Á≥ªÊûÑÊàê‰∏ÄÊ£µÊ†ë„ÄÇ ÂÆö‰πâ \(sdom(u)\) ÊòØËÉΩÂ§ü‰ªé \(v\) Âá∫ÂèëÂè™ÁªèËøá \(dfn\) ÊØî \(u\) Â§ßÁöÑÂà∞Ëææ \(u\)Ôºà\(u\) Âíå \(v\) ‰∏çÁÆóÂú®ÈáåÈù¢ÔºâÁöÑ \(dfn\) ÊúÄÂ∞èÁöÑ \(v\)„ÄÇ \(sdom(u)\) Ë¶Å‰πàÊòØËÉΩÂ§üÈÄöËøá‰∏ÄÊù°ÂâçÂêëËæπ / Ê†ëËæπÁõ¥Êé•Âà∞Ëææ \(u\) ÁöÑÁÇπÔºåË¶Å‰πàÊòØÊª°Ë∂≥Â≠êÊ†ë‰∏≠Â≠òÂú®Ëá≥Â∞ë‰∏Ä‰∏™ÁÇπËÉΩÂ§üÁõ¥Êé•Ëµ∞Âà∞ \(u\) ‰∏î \(dfn\) ÊØî \(u\) Â§ßÁöÑÁÇπÁöÑ \(sdom\)„ÄÇÊ†πÊçÆËøô‰∏ÄÁÇπÂèØ‰ª•Âπ∂Êü•ÈõÜËÆ°ÁÆó \(sdom\)„ÄÇÂπ∂Êü•ÈõÜÁª¥Êä§ÁöÑÊòØÈìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇ ËÆæ \(v\) ÊòØ \(u\) Âà∞ \(sdom(u)\) ÁöÑÈìæ‰∏äÔºà‰∏çÂê´ \(sdom(u)\)Ôºâ\(sdom\) ÊúÄÂ∞èÁöÑÁÇπ ÔºåÈÇ£‰πàÂ¶ÇÊûú \(sdom(v) = sdom(u)\)Ôºå\(idom(u) = sdom(u)\)ÔºåÂê¶Âàô \(idom(u) = idom(v)\)„ÄÇËøô‰∏™‰∏úË•ø‰πüÊòØË¶ÅÊ±Ç‰∏Ä‰∏™Èìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇÂèØ‰ª•Ê±Ç \(sdom\) ÁöÑÊó∂ÂÄôÈ°∫‰æøÁª¥Êä§‰∏Ä‰∏ã„ÄÇ Âú®Ëøô‰ªΩ‰ª£Á†Å‰∏≠ \(sdom\) Â≠òÁöÑÊòØ \(dfn\) ÊúÄÂ∞èÁöÑÁÇπÁöÑ \(dfn\) ËÄå‰∏çÊòØÁºñÂè∑ÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè„ÄÇ ÔºàÂê¨ËØ¥ËøôÈ¢òÊï∞ÊçÆÂæàÊ∞¥‚Ä¶ËØ¥‰∏çÂÆöÊúâÈîôÊ≤°Ë¢´Êü•Âá∫Êù•Ôºâ Ëøô‰ªΩ‰ª£Á†ÅË¢´Êèê‰∫§Âà∞ „ÄêÊ®°Êùø„ÄëÊîØÈÖçÊ†ë„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT ÈóÆÈ¢òÊÄªÁªì]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥‰ª•Êù•ÂØπ 2-SAT ÁöÑÁêÜËß£ÊØîËæÉÊ®°Á≥äÔºåÊâÄ‰ª•ÂÜôËøôÊ†∑‰∏Ä‰∏™Â∞ΩÂèØËÉΩÊ∏ÖÊô∞ÁöÑÊÄªÁªìÊù•ÁêÜÊ∏ÖÊÄùË∑Ø„ÄÇ 2-SAT ÈóÆÈ¢òÁöÑÂÆö‰πâÔºöÊúâ \(n\) ‰∏™ÈÄªËæëÂèòÈáèÔºåÁî® \(b_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™ÈÄªËæëÂèòÈáè„ÄÇ\(m\) ‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏Ä‰∏™ÈôêÂà∂Êù°‰ª∂ÂΩ¢Â¶ÇÔºö\((\neg)b_i \to (\neg) b_j\)„ÄÇÈóÆÊòØÂê¶Â≠òÂú®Êª°Ë∂≥ÈôêÂà∂ÁöÑ \(b\)„ÄÇ Áî®ÂõæÊù•ÊèèËø∞ÈôêÂà∂Êù°‰ª∂„ÄÇÂØπÊØè‰∏™ÈÄªËæëÂèòÈáèÂª∫‰∏§‰∏™ÁÇπÔºåÂàÜÂà´‰ª£Ë°®ÂèñÂÄº‰∏∫ \(0\) ÂíåÂèñÂÄº‰∏∫ \(1\)„ÄÇ‰ª£Ë°® \(b_i=0\) ÁöÑÁÇπ‰∏∫ \(p_i\)Ôºå‰ª£Ë°® \(b_i = 1\) ÁöÑÁÇπ‰∏∫ \(q_i\)„ÄÇÂØπÊØè‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÂú®Âõæ‰∏äËøû‰∏ÄÊù°ÊúâÂêëËæπÔºåË°®Á§∫‰∏Ä‰∏™ÂëΩÈ¢òÊé®Âá∫Âè¶‰∏Ä‰∏™ÂëΩÈ¢òÔºåÁÑ∂ÂêéÂÜçÂä†‰∏ÄÊù°ËæπË°®Á§∫ËØ•ÈôêÂà∂Êù°‰ª∂ÁöÑÈÄÜÂê¶ÂëΩÈ¢ò„ÄÇ‰∏æ‰æãÊù•ËØ¥ÔºåÂ¶ÇÊûúÊúâÈôêÂà∂Êù°‰ª∂ \(\neg b_i \rightarrow b_j\)ÔºåÂ∞±Âä†ÂÖ• \((p_i, q_j)\) Âíå \((p_j, q_i)\) Ëøô‰∏§Êù°ÊúâÂêëËæπ„ÄÇÈóÆÈ¢òÂ∞±Âèò‰∏∫Âà§ÂÆöÊòØÂê¶Â≠òÂú®ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)ÔºåÊÅ∞Â•ΩÂåÖÂê´ \(p_i\) Âíå \(q_i\) ‰∏≠ÁöÑ‰∏Ä‰∏™ÁÇπÁöÑÈó≠ÂêàÂ≠êÂõæ„ÄÇ ÂÆöÁêÜÔºö2-SAT ÊúâËß£ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂú®Âêå‰∏ÄÂº∫ËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ ÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑ„ÄÇ ‰∏ãÈù¢Áî®ÊûÑÈÄ†ËØÅÊòéÂÖÖÂàÜÊÄßÔºö ÂÖà tarjan Ê±ÇÂá∫Âº∫ËøûÈÄöÂàÜÈáèÔºåÊääÊØè‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÁº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÁî±‰∫é‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÁöÑÁÇπÂØπÂ∫îÁõ∏ÂèçÂèñÂÄºÁöÑÁÇπ‰πüÊûÑÊàê‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÔºåÊâÄ‰ª•Áº©ÁÇπÂêéÔºåËøô‰∏™ÈóÆÈ¢òÂèò‰∏∫‰∫Ü‰∏Ä‰∏™Êõ¥Â∞èÁöÑ 2-SAT ÈóÆÈ¢ò„ÄÇÂè™ÈúÄË¶ÅËß£ÂÜ≥ÂõæÊòØ DAG Êó∂ÁöÑÈóÆÈ¢òÂç≥ÂèØ„ÄÇ ÊääÊâÄÊúâÁöÑËæπÊñπÂêëÂèçËøáÊù•„ÄÇ‰∏ãÈù¢ÊâÄÊúâÁöÑËÆ®ËÆ∫ÈÉΩÊòØÂú®ÂèçÂõæ‰∏äÁöÑ„ÄÇ Áî®Á¨¶Âè∑ \(v^r\) Ë°®Á§∫‰∏éÁÇπ \(v\) ÂØπÂ∫îÁöÑÁÇπÔºö\(p_i^r = q_i, q_i^r = p_i\)„ÄÇ Ê±ÇÂá∫ÊãìÊâëÂ∫èÔºåÊåâÊãìÊâëÂ∫è‰æùÊ¨°Â§ÑÁêÜÊØè‰∏™ÁÇπÔºöÂ¶ÇÊûúÂΩìÂâçÁÇπ \(u\) Ë¢´Êâì‰∫ÜÊ†áËÆ∞ÔºåÈÇ£‰πà‰∏çÈÄâÔºõÂê¶ÂàôÈÄâÊã© \(u\)ÔºåÂπ∂Êää \(u^r\) ‰ª•Âèä \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÊâÄÊúâÁÇπÊâì‰∏äÊ†áËÆ∞ÔºàÈÄíÂΩíËøõË°åÔºåÂ¶ÇÊûúÂ∑≤ÁªèË¢´ÊâìËøáÊ†áËÆ∞Â∞±Ë∑≥ËøáÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºöË¢´Ê†áËÆ∞‰∏ÄÊ¨°Ôºâ„ÄÇ ËøôÊ†∑ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂèØËÉΩÂêåÊó∂Ë¢´ÈÄâÔºåÂ∑≤ÈÄâÁöÑÁÇπ‰πü‰∏ç‰∏éÈôêÂà∂ÁüõÁõæÔºåÂè™ÈúÄË¶ÅËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(u\)Ôºå\(u\) Âíå \(u^r\) ‰∏≠Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÈÄâÂç≥ÂèØ„ÄÇ Â¶ÇÊûú \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´Ê†áËÆ∞ÁöÑÂéüÂõ†ÊòØ \(v\) Ë¢´ÈÄâÊã©Ôºå ÈÇ£‰πà \(u\) ÊòØ \(v^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºåÁî± 2-SAT ÁöÑÊÄßË¥®ÂèØÂæó \(v\) ÊòØ \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºå‰ªéËÄå \(v\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†Âêé„ÄÇ ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ \(u\)Ôºå\(u\) Âíå \(u^r\) ÈÉΩË¢´Ê†áËÆ∞‰∫ÜÔºåÊ†áËÆ∞ \(u\) ÁöÑÂéüÂõ†ÊòØ \(v_1\) ÊòØË¢´ÈÄâÊã©ÔºåÊ†áËÆ∞ \(u^r\) ÁöÑÂéüÂõ†ÊòØ \(v_2\) Ë¢´ÈÄâÊã©„ÄÇÈÇ£‰πà \(v_1\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºå\(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u\) Èù†Âêé„ÄÇ‰∏çÂ¶®ËÆæ \(u\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÈÇ£‰πà \(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÂú®Â§ÑÁêÜ \(v_2\) ‰πãÂâçÂ∞±‰ºöÂÖàÂ§ÑÁêÜ \(u^r\)ÔºåÁüõÁõæ„ÄÇ ÊâÄ‰ª•ËØ•ÁÆóÊ≥ï‰ºöÂæóÂà∞‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊñπÊ°à„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢ò]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Áî®Êù•ËÆ∞ÂΩïÂè£ËÉ°ÁöÑÈ¢òÁõÆ„ÄÇ Â¶ÇÊúâÈîôËØØËØ∑Âä°ÂøÖ qq ÊàñËÄÖËØÑËÆ∫ÂëäËØâÊàëÔºåË∞¢Ë∞¢ÔºÅ JOISC 2018 Day4 T1 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Â¶ÇÊûúËÆ§‰∏∫Áõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥Êúâ‰∏ÄÊù°ËæπÔºåÊú¨È¢òÂ∞±ÂèØ‰ª•ÁúãÊàêÊ±ÇÊúÄÂ§ßÊùÉÁÇπÁã¨Á´ãÈõÜ„ÄÇ ÊòæÁÑ∂‰∏ÄÊù°ÈìæÊòØ‰∫åÂàÜÂõæÔºåÈÇ£‰πàÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫Áî®Ë¥πÁî®ÊµÅÊ±ÇÊúÄÂ∞èÊùÉÁÇπË¶ÜÁõñÈõÜ„ÄÇ ËÆ∞ÂΩïÁõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥ËæπÁöÑÊñπÂêëÔºåÊääËøûÁª≠‰∏ÄÊÆµÊñπÂêëÁõ∏ÂêåÁöÑËßÜ‰Ωú‰∏Ä‰∏™ÊÆµ„ÄÇÁî®Á∫øÊÆµÊ†ëÁª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÊØèÊ¨°ÊúâÊÆµÂèëÁîüÂèòÊõ¥Êó∂Â∞±ËØ¢ÈóÆËøô‰∏™ÊÆµÔºåÁÑ∂Âêé‰øÆÊîπÁ∫øÊÆµÊ†ë‰∏äÁöÑ‰ø°ÊÅØ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Áª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÂ∞±Âú® \(\mathcal O(n \log n)\) ÁöÑÊó∂Èó¥Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ JOISC 2018 Day4 T2 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Áúã‰ΩúÊòØËØ¢ÈóÆ‰∏ÄÊù°Èìæ‰∏ä‰∏ÄÈÉ®ÂàÜÁÇπÁöÑÂØºÂá∫Â≠êÂõæÁöÑËøûÈÄöÂùóÊï∞„ÄÇ‰æùÊ¨°Âä†ÁÇπÔºåÈÄöËøá‰∫åÂàÜÊ±ÇÂá∫Êñ∞Âä†ÁöÑÁÇπÂíåÂ∑≤ÊúâÁÇπÊûÑÊàêÁöÑËøûÈÄöÂùó‰πãÈó¥ÁöÑËøûËæπ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™Êúâ \(n-1\) Êù°ËæπÔºåËØ¢ÈóÆÊ¨°Êï∞‰∏ç‰ºöË∂ÖËøá \(\lceil \log n\rceil (n-1)\)„ÄÇ LOJ 6191 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÈÖçÂØπÊ∏∏Êàè ÁÇπÂáªÊü•ÁúãÈ¢òËß£ ÊúÄÂêé‰∏ÄÂÆö‰ºöÂèòÊàê &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;„ÄÇ \(f_{i,j}\) Ë°®Á§∫Ââç \(i\) ‰∏™Ê∂àÂÆåÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶ÊúÄÂêéÊúâËøûÁª≠ \(j\) ‰∏™ &gt;ÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶‰∏≠ &lt; ÁöÑÊï∞ÈáèÁöÑÊúüÊúõ„ÄÇ ÊúÄÂêéÂæàÂÆπÊòìÁªüËÆ°Á≠îÊ°à„ÄÇ LOJ 6192 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÂüéÂ∏ÇÁΩëÁªú Ê≤°Âï•Â•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÂÄçÂ¢û‰∏Ä‰∏ã„ÄÇ LOJ 6194 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÊéíÂàó ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Êåâ \(a_i\) ‰∏∫Á¨¨‰∏ÄÂÖ≥ÈîÆÂ≠óÔºå\(b_i\) ‰∏∫Á¨¨‰∫åÂÖ≥ÈîÆÂ≠óÊéíÂ∫è„ÄÇÈáçÊñ∞ÁªôÁÇπÁºñÂè∑„ÄÇ ÂÅáËÆæ‰Ωø saved ÂèòÂä®ÁöÑÁÇπÁöÑÁºñÂè∑ÂàÜÂà´ÊòØ \(c_1, \ldots, c_k\)ÔºåÊúâ \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)„ÄÇ ËÄÉËôëÂØπ‰∫éÁªôÂÆöÁöÑ \(c_i\) Âíå \(k\)ÔºåÂ¶Ç‰ΩïËÆ°ÁÆó \(p\) ÁöÑÊï∞Èáè„ÄÇ ËÆæ \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)ÔºåÂÆö‰πâ \(d_0 = n\)„ÄÇ Â¶ÇÊûú \(d_k &gt; 1\)Ôºå\(p\) ÁöÑÊï∞Èáè‰∏∫ \(0\)„ÄÇ Âê¶Âàô \(p\) ÁöÑÊï∞Èáè‰∏∫ \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÆπÊòì \(dp\) Â§ÑÁêÜÁöÑÂºèÂ≠ê„ÄÇÂàÜÊ≤ª‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ÂÅöÂÆå‰∫Ü„ÄÇ LOJ 6212 „ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçmelon ÁÇπÂáªÊü•ÁúãÈ¢òËß£ \(n \le L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(n\)Ôºå\(L &lt; n \le 2L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(L\)Ôºå‰∏ãÈù¢ËÆ®ËÆ∫ \(n &gt; 2L\) ÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûú Alice ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæÁìúÁöÑÊï∞ÈáèÂ§ß‰∫é \(2L\)ÔºåÂèñËµ∞‰∏Ä‰∏™ÁìúÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÁìúÔºåÂ∞±ËÉΩ‰øùËØÅËá≥Â∞ëÊãøÂà∞ \(\lceil \frac {n} 2\rceil\) ‰∏™Áìú„ÄÇÔºàÂõ†‰∏∫ËøôÊ†∑ Alice ÊãøÂà∞ÁöÑÁìú‰∏ÄÂÆö‰∏ç‰ºöÊØî Bob Â∞ëÔºâ Â¶ÇÊûú Bob ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæ Alice ÂàöÂàöÊãøËµ∞‰∫Ü \(x\) ‰∏™ÁìúÔºåÁé∞Âú®ËøòÂâ©‰∏ã \(c\) ‰∏™ÁìúÔºåÂ¶ÇÊûú \(c-x \ge 2L\)ÔºåÈÇ£‰πàÂèñËµ∞ \(x\) ‰∏™ÁìúÔºõÂê¶ÂàôÂÖàÂèñËµ∞ \(x-1\) ‰∏™ÁìúÔºåÂêÉÂÆåÂêéÔºåÂâ©‰ΩôÁìúÊï∞‰∏∫ \(c-(x-1)\)ÔºåÂõ†‰∏∫ \(c-x &lt; 2L\)ÔºåÊâÄ‰ª• \(c-x+1 \le 2L\)ÔºåÂ¶ÇÊûú \(c-x+1 \le L\)ÔºåÁõ¥Êé•ÂèñËµ∞Ââ©‰ΩôÂÖ®ÈÉ®ÁìúÔºåËøôÁßçÊÉÖÂÜµ‰∏ã Bob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÔºåÂõ†‰∏∫ \(c-x+1 \le 2L\)ÔºåÂú®Ââ©‰ΩôÁöÑ \(c-x+1\) ‰∏™Áìú‰∏≠ÔºåBob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÊúÄÂùè‰πüÂè™ÊòØÁî±‰∫é‰∏ä‰∏ÄÊ¨° Alice Êìç‰ΩúÁöÑÊó∂ÂàªÔºåAlice ÂèñËµ∞‰∫Ü \(x\) ‰∏™ËÄå Bob ÂèñËµ∞‰∫Ü \(x-1\) ‰∏™ÔºåBob ÊØî Alice ÊãøÁöÑÁìúÂ∞ë‰∫Ü‰∏Ä‰∏™„ÄÇÊâÄ‰ª• Bob ÊãøÁöÑÁìúÁöÑÊï∞ÈáèÊúÄÂùèÊØî Alice Â∞ë \(1\)„ÄÇ Âõ†Ê≠§ÔºåÂú®ÂèåÊñπÈÉΩÈááÂèñÊúÄ‰ºòÁ≠ñÁï•Êó∂ÔºåAlice ËÉΩËé∑ÂæóÊÅ∞Â•Ω \(\lceil \frac{n} 2\rceil\) ‰∏™Áìú„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂΩì \(n \le L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(n\)ÔºõÂΩì \(L &lt; n \le 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(L\)ÔºõÂΩì \(n &gt; 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(\lceil \frac {n} 2\rceil\)„ÄÇ CF 1215F Radio Stations ÈùûÂ∏∏Â¶ôÁöÑ 2SAT È¢òÔºåÊ≤°ÊÉ≥Âá∫Êù•„ÄÇÁúã‰∫ÜÈ¢òËß£ËßâÂæóÂæà nb„ÄÇÂÖ∑‰ΩìÂÅöÊ≥ïÂ∞±‰∏çÂÜô‰∫Ü„ÄÇÂèØ‰ª•ÁúãÂÆòÊñπÈ¢òËß£„ÄÇ CF 1188E Problem from Red Panda ÂæÖÂ°´Âùë„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á±ªÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥Áî®‰∏ÄÁõ¥Êã∑Êùø...ÈúÄË¶ÅË°•‰∏ÄË°•‰∫Ü„ÄÇ ÈóÆÈ¢ò Ê±Ç \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] Âç≥Âú®‰∏ÄÊù°Áõ¥Á∫ø‰∏ãÁöÑÊï¥ÁÇπÊï∞. ÂÅöÊ≥ï Â¶ÇÊûú \(a \ge c\) Êàñ \(b \ge c\)ÔºåÂàô \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) Âê¶Âàô \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] ÔºàÂõ†‰∏∫ \(i\) ‰ªé \(0\) ÂºÄÂßãÔºåÊâÄ‰ª•Ë¶ÅÁî®Â∞è‰∫éÂè∑Ôºâ ËøôÊ†∑ÊØèÈÄíÂΩí‰∏§Ê¨°Ôºå\((a,c)\) Â∞±ÂèòÊàê \((c, a\bmod c)\)ÔºåÂõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(O(\log (a+c))\). Áî±‰∫é \(a &lt; c, b &lt; c\)ÔºåÊâÄ‰ª• \(n\) ÁöÑÂÄº‰∏ç‰ºöÂ¢ûÂ§ßÔºåÊó†ÈúÄÊãÖÂøÉÁàÜ long long.]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] ÂÆåÁæéÁöÑÈòüÂàó]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òËß£ Â§çÊùÇÂ∫¶ËÆ®ËÆ∫‰∏≠ÈªòËÆ§ \(n,m\) ÂêåÈò∂„ÄÇ ÂÆö‰πâÁ¨¨ \(i\) ‰∏™Êìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥‰∏∫ \(i\)„ÄÇ Ê±ÇÂá∫ÊØèÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÊñ∞ÁöÑ \(x\) ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥ÔºåÂ∞±ÂæàÂ•ΩÊ±ÇÁ≠îÊ°à‰∫Ü„ÄÇ ‰ªéÂêéÂæÄÂâçËÄÉËôëÊØè‰∏™Êìç‰ΩúÔºåËÆ°ÁÆóËøôÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥„ÄÇ ÂÆö‰πâ‰∏Ä‰∏™ÈòüÂàó \(i\) ÁöÑÂºπÂá∫Êó∂Èó¥‰∏∫‰ªéÂΩìÂâçÊìç‰ΩúÂºÄÂßãÔºåÂæÄÂêéÁ¨¨ \(a_i\) ‰∏™ÂΩ±ÂìçÈòüÂàó \(i\) ÁöÑÊìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥„ÄÇ ÂàÜÂùóÔºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØè‰∏™Êìç‰ΩúÔºåÂàÜÂà´Áª¥Êä§ÊØè‰∏ÄÂùó‰∏≠ÁöÑÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄº„ÄÇÊàë‰ª¨Êää‰∏ÄÂùó‰∏≠ÊâÄÊúâÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄºÁß∞‰∏∫Ëøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Âú®Âä†ÂÖ•Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂêéÔºåÁ¨¨ \(i\) ‰∏™Âùó \([a_i,b_i]\) Áª¥Êä§ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t_i\)ÔºåËÆæ \(c_p\) ‰∏∫Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂà∞Á¨¨ \(t_i-1\) ‰∏™Êìç‰Ωú‰∏≠Á¨¨ \(p\) ‰∏™ÈòüÂàóË¢´ push ÁöÑÊ¨°Êï∞ÔºåÁª¥Êä§ \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)„ÄÇÂêåÊó∂Áª¥Êä§ \(c_p\) ÁöÑÂÄº„ÄÇÔºàÈÄöËøáÊâìÊ†áËÆ∞Ôºâ ËÄÉËôëÂú®Âä†ÂÖ•Êìç‰Ωú \(i\) ÂêéÔºåÂ¶Ç‰ΩïÊõ¥Êñ∞ÊØèÂùóÁª¥Êä§ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÅáËÆæËøô‰∏™ÂùóÊòØÁ¨¨ \(k\) ‰∏™Âùó„ÄÇ ÂØπ‰∫éËøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â§ß‰∫éÁ≠â‰∫é \(m\) ÁöÑÊÉÖÂÜµÈ¢ÑÂÖàÂ§ÑÁêÜÂ•Ω„ÄÇ‰∏ãÈù¢Âè™ËÆ®ËÆ∫ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â∞è‰∫é \(m\) ÁöÑÊÉÖÂÜµ„ÄÇ Êõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ Â¶ÇÊûúËøô‰∏™ÂùóË¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êõ¥Êñ∞ \(mn_k \leftarrow mn_k+1\)„ÄÇÊõ¥Êñ∞ \(c_p\) ÁöÑÂÄºÔºåÂç≥Êâì‰∏Ä‰∏™Êï¥ÂùóÂä† \(1\) Ê†áËÆ∞„ÄÇ Â¶ÇÊûúËøô‰∏™ÂùóÊú™Ë¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êö¥ÂäõÈáçÊûÑÔºåÊõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ„ÄÇ Êõ¥Êñ∞ \(t_k\) Êåâ‰ª•‰∏ãÊ≠•È™§ËøõË°åÔºö Â¶ÇÊûú \(mn_k \ge 0\)ÔºåËØ¥Êòé \(t_k\) ÂèØ‰ª•ÂáèÂ∞èÔºåÈÇ£‰πà \(t_k \leftarrow t_k-1\)„ÄÇÂê¶Âàô‰∏çÁî®Êõ¥Êñ∞ÔºåÁªìÊùüÊìç‰Ωú„ÄÇ Â¶ÇÊûúÁ¨¨ \(t_k\) Ê¨°Êìç‰ΩúÂåÖÂê´Êï¥‰∏™ÂùóÔºåÈÇ£‰πà \(mn_k \leftarrow mn_k-1\)ÔºåÊâì \(-1\) Ê†áËÆ∞Êõ¥Êñ∞ \(c_p\) ÁöÑÂÄº„ÄÇÂê¶ÂàôÊö¥ÂäõÈáçÊûÑÊõ¥Êñ∞ \(mn_k\) Âíå \(c_p\) ÁöÑÂÄº„ÄÇ ËΩ¨Âà∞Êìç‰Ωú 1„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂú® \(O(n \sqrt n)\) Êó∂Èó¥ÂÜÖÁª¥Êä§ÊØè‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Ââ©‰ΩôÁöÑÈóÆÈ¢òÊòØ: Â¶Ç‰ΩïÂú®‰ªéÂè≥ÂæÄÂ∑¶Âä†ÂÖ•Êìç‰ΩúÁöÑËøáÁ®ã‰∏≠ÔºåÊîØÊåÅÊü•ËØ¢‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇÊääÂå∫Èó¥ÊãÜÊàêËã•Âπ≤‰∏™ÂùóÂíå‰∏çË∂ÖËøá \(2 \sqrt n\) ‰∏™Â§öÂá∫Êù•ÁöÑÁÇπ„ÄÇÂØπ‰∫éËøô‰∫õÂùóÔºåÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ÔºåÂèñ \(\max\) Âç≥ÂèØ„ÄÇÂØπ‰∫éËøô‰∫õÂ§öÂá∫Êù•ÁöÑÁÇπÔºåÈúÄË¶ÅÂä®ÊÄÅËØ¢ÈóÆ‰ªñ‰ª¨ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Â§ÑÁêÜÂçïÁÇπ‰ø°ÊÅØ Ë¶ÅÊîØÊåÅ‰ªéÂêéÂæÄÂâçÊ∑ªÂä†Êìç‰ΩúÔºåËØ¢ÈóÆÂçï‰∏™ÈòüÂàóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ ÂêåÊ†∑ÂàÜÂùóÁª¥Êä§„ÄÇÂØπÊØè‰∏™ÂùóÂºÄ‰∏Ä‰∏™ vectorÔºåÂØπÊØè‰∏™ÈòüÂàóÂºÄ‰∏Ä‰∏™ vector„ÄÇÂú®ËøõË°å‰øÆÊîπÊó∂ÔºåÂØπÂÆåÊï¥ÂåÖÂê´ÁöÑÊØè‰∏™ÂùóÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑ÔºåÂÜçÂØπ‰∏§ËæπÂ§öÂá∫ÁöÑ \(O (\sqrt n)\) ‰∏™ÈòüÂàóÂØπÂ∫îÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑„ÄÇ ÈÇ£‰πà‰∏Ä‰∏™ÈòüÂàóÁöÑÊìç‰ΩúÂ∫èÂàóÂ∞±ÊòØÂÆÉÁöÑ vector ÂíåÂÆÉÊâÄÂú®ÁöÑÂùóÁöÑ vector ÂΩíÂπ∂ÂêéÁöÑÁªìÊûú„ÄÇÂØπÊØè‰∏™ÁÇπËÆ∞ÂΩïÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t\) (ÊØèÊ¨°ËØ¢ÈóÆÊó∂Êõ¥Êñ∞Ôºå‰øÆÊîπÊó∂‰∏ç‰∏ÄÂÆöÊòØÊúÄÊñ∞ÁöÑ)ÔºåÂÆÉÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâçÁöÑ‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_1\)ÔºåÂÆÉÊâÄÂú®ÂùóÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâç‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_2\)„ÄÇÂØπÊØè‰∏™ÂùóËÆ∞ÂΩïËøô‰∏™Âùó‰∏≠ÁöÑÈòüÂàóÂú®‰∏ä‰∏ÄÊ¨°Êõ¥Êñ∞‰ø°ÊÅØ‰πãÂêé‰øÆÊîπÁöÑÊ¨°Êï∞ \(c\)„ÄÇÈÇ£‰πà‰øÆÊîπÁöÑÊó∂ÂÄôÂØπÊï¥ÂùóÂè™ÈúÄË¶Å \(c \leftarrow c+1\)ÔºåÂØπ‰∏§Á´ØÁöÑÂùóÊõ¥Êñ∞ÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™ÈòüÂàóÁöÑ \(t, p_1, p_2\)ÔºåÂπ∂Êää \(c\) ËÆæ‰∏∫ \(0\)„ÄÇÊõ¥Êñ∞ÊñπÊ≥ïÂ§ßËá¥‰∏∫ÔºöÂØπ‰∫é‰∏Ä‰∏™ÈòüÂàóÔºåÂÖàÂà§Êñ≠ \(t\) ÊòØÂú®ÂÆÉ vector ‰∏≠ËøòÊòØÂú®ÂùóÁöÑ vector ‰∏≠ÔºàÈÄöËøá \(p_1, p_2\) ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ÔºâÔºåËøô‰∏§ÁßçÊÉÖÂÜµÂå∫Âà´‰∏çÂ§ßÔºåÊâÄ‰ª•ËøôÈáåÂè™ÂÜôÂú®Âùó vector ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÂÆö‰πâ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáè \(t = c\)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂùóÁöÑ vector ‰∏≠ÁöÑÁ¨¨ \(p_2+t\) È°πÁöÑÂ∞è‰∫éËøô‰∏™ÈòüÂàóÁöÑ vector ‰∏≠ÁöÑ \(p_1\) È°πÔºåÈÇ£‰πà \(p_1 \leftarrow p_1+1\)ÔºåÁÑ∂Âêé \(t \leftarrow t-1\)ÔºåÁÑ∂ÂêéÂÜçÊ¨°Ê£ÄÊü•ÔºåËøôÊ†∑Âæ™ÁéØÁõ¥Âà∞ÂèØ‰ª•Áõ¥Êé•Êää \(p_2\) Êîπ‰∏∫ \(p_2+t\) ÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ \(p_2\) Â∞±ÂÆåÊàê‰∫ÜÊõ¥Êñ∞„ÄÇ ‰∏Ä‰∏™ÈòüÂàóË¢´Êõ¥Êñ∞Êó∂ËøõË°åÁöÑÂà§Êñ≠ÁöÑÊÄªÊ¨°Êï∞‰∏éÂÆÉÁöÑ vector ‰∏≠ÂÖÉÁ¥†‰∏™Êï∞ÂêåÁ∫ßÔºåÊâÄ‰ª•Êõ¥Êñ∞ÁöÑÊÄªÂ§çÊùÇÂ∫¶ÊòØ \(O(n)\) ÁöÑ„ÄÇÔºà‰ΩÜÊòØÁª¥Êä§ vector ÂíåËøõË°åÊìç‰ΩúÊòØ \(O(\sqrt n)\) ÁöÑÔºâ„ÄÇ ËøôÊ†∑Â∞±‰ª• \(O(n \sqrt n)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ÂÆûÁé∞ 1ÂæÖÂ°´]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊìç‰ΩúÊ®°Êùø]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI ÂâçÂ§ç‰π†„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //ÊúÄÂ§ßÂ§öÈ°πÂºèÈïøÂ∫¶ÔºåÂÄçÊï∞ÈóÆÈ¢òÂ∑≤ÁªèËÄÉËôëconst int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé®]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[Â§öÈ°πÂºèÂèñÊ®°‰ºòÂåñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // ÁâπÂæÅÂ§öÈ°πÂºèint wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //‰πò‰ª• A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÈîôËØØËÆ∞ÂΩï]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ÊØîËæÉÂáΩÊï∞ÂÆö‰πâ‰∏ç‰∏•Ê†ºÔºåÂ≠òÂú®ËøîÂõûÁõ∏Á≠â‰ΩÜÊòØÂÆûÈôÖ‰∏äÊúâÂå∫Âà´ÁöÑÊÉÖÂÜµ„ÄÇËøôÂèØËÉΩÂØºËá¥ÂèåÂ†ÜÁª¥Êä§Âà†Èô§Êìç‰ΩúÊó∂Âá∫Áé∞ÈóÆÈ¢ò„ÄÇÔºàÂ∫îÂΩìÂêåÊó∂ÂºπÊ†à‰ΩÜÊòØÊ†àÈ°∂ÂÖÉÁ¥†‰∏çÁõ∏Á≠âÔºâ for (int i = 1; i &lt;= n; i++) a[n] = inf„ÄÇ Âú®‰∏Ä‰∫õÂõûÊ∫ØÊó∂ÈúÄË¶ÅÊí§ÈîÄÊìç‰ΩúÁöÑ dfs ‰∏≠ÔºåÂõ†‰∏∫ÂÖ∂‰ªñÂéüÂõ† return ÁöÑÊó∂ÂÄôÊ≤°ÊúâÊí§ÈîÄÊìç‰Ωú„ÄÇ Âæ™ÁéØ/if ÈáåÂ±ÇÂ§ñÂ±ÇÂèòÈáèÂêçÊ∑∑Ê∑Ü„ÄÇ ËøõË°å dfs / ÈÄíÂΩíÊó∂ÔºåÂõ†‰∏∫‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè‰∏ãÂ±Ç dfs Êó∂Á†¥Âùè‰∫Ü‰∏äÂ±Ç‰πãÂêéË¶ÅÁî®Âà∞ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÆπÊñ•Êó∂ÔºåÂè™Êûö‰∏æ‰∫ÜÈõÜÂêàÂ§ßÂ∞èÂøòËÆ∞‰∫Ü‰πòÁªÑÂêàÊï∞„ÄÇ ÊèíÂ§¥ dp ‰∏çË¶ÅÂøòËÆ∞ËøûÊé•‰∏§‰∏™Â∑¶Êã¨Âè∑ÊàñËÄÖËøûÊé•‰∏§‰∏™Âè≥Êã¨Âè∑ÁöÑÊÉÖÂÜµ„ÄÇ Ê†ëÈìæÂâñÂàÜÊó∂ÔºåËØ¢ÈóÆÈìæÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèÊòØÊØîËæÉÈáçÈìæÈ°∂Á´ØÊ∑±Â∫¶Â§ßÂ∞èÔºå‰∏çËÉΩÁõ¥Êé•ÊØîËæÉ‰∏§‰∏™ÁÇπÊ∑±Â∫¶Â§ßÂ∞è„ÄÇ sort Êó∂ÂøòËÆ∞Âä†ÊØîËæÉÂáΩÊï∞„ÄÇ Áª¥Êä§Áü©Èòµ‰πòÊ≥ïÊó∂Â∑¶‰πòÂè≥‰πòÊêûÈîô„ÄÇ Á∫øÊÆµÊ†ëÂêàÂπ∂Êó∂ÔºåÂ¶ÇÊûúË¶ÅÂèØÊåÅ‰πÖÂåñÔºåÁ©∫Èó¥Ë¶ÅÂºÄ‰∏§ÂÄç„ÄÇ Âú®Â§ÑÁêÜÊ∂âÂèä‰∏çÂêåÈïøÂ∫¶Â≠óÁ¨¶‰∏≤ÁöÑÂ≠óÁ¨¶‰∏≤ÂìàÂ∏åÊó∂Ôºå‰∏ÄÂÆöË¶ÅÁî® str[i] - 'a' + 1 ËÄå‰∏çÊòØ str[i] - 'a' Âú®Â§ÑÁêÜÂ≠êÊ†ëÊúÄÈïø‰ªéÊ†πÂºÄÂßãË∑ØÂæÑ‰πãÁ±ªÁöÑÈóÆÈ¢òÊó∂ÔºåÂ¶ÇÊûúËøô‰∏™Â≠êÊ†ë‰∏çËÉΩÈÄâÔºådp ÂÄºËÆæ‰∏∫ \(0\) ‰ªç‰ºö +1 Âêë‰∏äË¥°ÁåÆ Âú®Áî® new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Âá∫Áé∞Ë∂äÁïå„ÄÇËøôÊó∂‰∏ç‰ºöÊä•ÈîôÔºåÂá∫Áé∞ new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Ôºå‰∏ÄÂÆöË¶ÅË∞®ÊÖéËÆ°ÁÆóÊØèÊ¨°Ë∞ÉÁî®ÁöÑÂ§ßÂ∞è„ÄÇÔºàÂ∞§ÂÖ∂ÊòØÂÜôÂ§öÈ°πÂºèÊó∂Ôºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[ÂèëËøôÁØáÂçöÂÆ¢‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆ∞ÂΩï‰∏Ä‰∏™ÊûÅ‰∏∫ÈöêËîΩÁöÑÈîôËØØ„ÄÇ ÂÜôÊØîËæÉÂáΩÊï∞‰∏ÄÂÆöË¶Å‰øùËØÅÊòØ‰∏•Ê†ºÁöÑÂ∞è‰∫éÂè∑„ÄÇË¶ÅÁâπÂà´Â§ÑÁêÜÁ≠â‰∫é„ÄÇÂê¶ÂàôÂú®ÈÅáÂà∞Â†ÜÊâìÊ†áËÆ∞Âà†Èô§ËøôÁßçÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÂÖÉÁ¥†Âú®Â†Ü‰∏≠ÁöÑÈ°∫Â∫è‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] „ÄåZJOI2017„ÄçÂ≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÂÅöÊ≥ï ‰∏çÈöæËØÅÊòéÂ¶ÇÊûú‰∏Ä‰∏™Â≠ê‰∏≤ \(s\) Êúâ‰∏§‰∏™ÂêéÁºÄ \(s_1, s_2\)Ôºå\(s_2\) ÊòØ \(s_1\) ÁöÑ border ‰∏î \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)ÔºåÈÇ£‰πàÂØπ‰∫é‰ªªÊÑèÁöÑÂ≠óÁ¨¶‰∏≤ \(t\)Ôºå\(s_2\) ‰∏çÂèØËÉΩÊòØ \(st\) ÁöÑÊúÄÂ∞èÂêéÁºÄ„ÄÇ Áî®‰∏Ä‰∏™Á∫øÊÆµÊ†ëÁª¥Êä§ÊØè‰∏™Âå∫Èó¥ÂÜÖÂèØËÉΩÊàê‰∏∫ÊúÄÂ∞èÂêéÁºÄÁöÑÁÇπÔºåËøôÊ†∑ÁöÑÁÇπÂè™Êúâ \(\mathcal O (\log n)\) ‰∏™„ÄÇpush up ÁöÑÊó∂ÂÄôÊö¥ÂäõÂêàÂπ∂Âç≥ÂèØ„ÄÇ ÊØîËæÉÂ§ßÂ∞èÁöÑÊó∂ÂÄôÈúÄË¶ÅÊü• lcpÔºåÂàÜÂùóÁª¥Êä§ÂâçÁºÄÂìàÂ∏åÂç≥ÂèØÂÅöÂà∞ \(\mathcal O(\sqrt n)\) ‰øÆÊîπÔºå\(\mathcal O(\log n)\) ËØ¢ÈóÆÔºàË∞ÉÊï¥ÂùóÂ§ßÂ∞èÂ∫îËØ•ÂèØ‰ª•ÂÅöÂà∞Êõ¥‰ºòÁöÑÂ§çÊùÇÂ∫¶Ôºâ„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)„ÄÇ ÔºàÁúüÁöÑÊØíÁò§Ôºâ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø]-Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ ÁÆÄÂçïÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] Âå∫Èó¥Á¥†Êï∞‰∏™Êï∞]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ËØïÁùÄÂÆûÁé∞‰∏ã min_25 Á≠õÁöÑÁ¨¨‰∏ÄÊ≠•„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/problemset/problem/715/E È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏§‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàó \(p_1\) Âíå \(p_2\)ÔºåÂÖ∂‰∏≠Êúâ‰∏Ä‰∫õ‰ΩçÁΩÆË¢´ÊåñÁ©∫ÔºåËÆ©‰Ω†Ëá™Â∑±Â°´Êï∞Â≠ó„ÄÇ ËØ∑‰Ω†ÂØπÊØè‰∏™ \(k\) ËæìÂá∫ÔºåÊúâÂ§öÂ∞ëÁßçÂ°´Êï∞Â≠óÊñπÊ°àÔºå‰ΩøÂæó \(p_1\) ÊúÄÂ∞ë‰∫§Êç¢ \(k\) Ê¨°ÂèØ‰ª•ÂèòÊàê \(p_2\)„ÄÇ \(n \le 250\)„ÄÇ Ëß£Ê≥ï È¶ñÂÖàÈ¢òÁõÆ‰øùËØÅËá≥Â∞ëÂ≠òÂú®‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°à‰ΩøÂæó \(p_1\) Âíå \(p_2\) ÊòØÊéíÂàóÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊï∞‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµ„ÄÇ ÂÆπÊòìÁúãÂá∫‰∫§Êç¢Ê¨°Êï∞ \(n-(p_1p_2^{-1}\) ÁöÑËΩÆÊç¢Êï∞\()\)„ÄÇ ÈóÆÈ¢òÂèòÊàê‰∫ÜÊ±ÇÊª°Ë∂≥ \(p_1p_2^{-1}\) ÊÅ∞Â•ΩÂèØ‰ª•ÂàÜËß£‰∏∫ \(k\) ‰∏™‰∏çÁõ∏‰∫§ËΩÆÊç¢ÁöÑÊñπÊ°àÊï∞„ÄÇ ËÆæ \(p_1p_2^{-1}=w\)ÔºåÂàô \(p_1=wp_2\)ÔºåÂç≥ \(p_1[i]=w[p_2[i]]\)„ÄÇ ËÆæÊâÄÊúâ \(p_1\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_1\)ÔºåÊâÄÊúâ \(p_2\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_2\)„ÄÇ ÂÅáËÆæ \(w\) ÊòØÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊéíÂàó„ÄÇÈÇ£‰πàÂØπ‰∫é \(i \in S_1\)ÔºåÊúâ \(p_2[i]=w^{-1}[p_1[i]]\)ÔºõÂØπ‰∫é \(i \in S_2\)ÔºåÊúâ \(p_1[i]=w[p_2[i]]\)„ÄÇÊâÄ‰ª• \(\forall i \in S_1 \cap S_2\)Ôºå\(p_1[i]\) Âíå \(p_2[i]\) ÈÉΩÊòØÁ°ÆÂÆöÁöÑ„ÄÇÂØπ‰∫é \(p_1\) Êù•ËØ¥ÔºåËøòÊúâ \(n-\lvert S_1\cup S_2 \rvert\) ‰∏™‰ΩçÁΩÆË¶ÅÂ°´ÁöÑÊï∞Ê≤°ÊúâÁ°ÆÂÆö„ÄÇÈÇ£‰πàÂ¶ÇÊûúÂ≠òÂú®Ëá≥Â∞ë‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°àÔºåÂ∞±ÊÅ∞Â•ΩÊúâ \((n-\lvert S_1\cup S_2 \rvert)!\) Áßç‰ΩøÂæó \(p_1p_2^{-1}=w\) ÁöÑÂ°´Êï∞ÊñπÊ°à„ÄÇ ÂÜçËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÂêàÊ≥ïÁöÑ \(w\)„ÄÇÂØπ‰∫é \(i \in S_1\cap S_2\)Ôºå\(w[p_2[i]]=p_1[i]\)„ÄÇÊâÄ‰ª• \(w\) ÁöÑ‰∏Ä‰∫õ‰ΩçÁΩÆÂ∑≤ÁªèÁ°ÆÂÆö‰∫Ü„ÄÇÂêåÊó∂ \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)„ÄÇ\(w\) ‰∏≠Á°ÆÂÆöÁöÑ‰ΩçÁΩÆÂ∑≤ÁªèÊûÑÊàê‰∫Ü‰∏Ä‰∫õÈìæÂíå‰∏Ä‰∫õÁéØ„ÄÇÊûÑÊàêÁéØÂêé‰∏çÂèØËÉΩ‰∏éÂÖ∂‰ªñÁÇπËøûËæπÔºåÂèØ‰ª•Áõ¥Êé•ÂøΩÁï•„ÄÇÈìæÂèØ‰ª•Áº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÈÇ£‰πàÈóÆÈ¢òËΩ¨Âåñ‰∏∫ÔºåÁªôÂÆö‰∏§‰∏™ÈõÜÂêà \(A\) Âíå \(B\)ÔºåÊ±ÇÊúâÂ§öÂ∞ë‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàóÔºåÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÊéíÂàóÔºåÊª°Ë∂≥ \(\forall i \in A, w[i] \notin B\)„ÄÇÊòæÁÑ∂Ëøô‰∏™ÈóÆÈ¢òÂè™‰∏é \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) ÊúâÂÖ≥„ÄÇ ÂÖàËÄÉËôë \(A\cap B =\emptyset\)„ÄÇÂÆπÊñ•‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] ÂÜçËÄÉËôë \(A\cap B \neq \emptyset\)„ÄÇÊääÈôêÂà∂Êù°‰ª∂Áúã‰Ωú \(\forall i \in A\setminus B,w[i]\notin B\) Âíå \(\forall i \in A \cap B, w[i] \notin B\)„ÄÇÂØπÁ¨¨‰∫å‰∏™Êù°‰ª∂ÂÆπÊñ•„ÄÇËÆæ \(G(n, c, i)\) ‰∏∫ \(n\) ‰∏™Êï∞ÁöÑÊéíÂàóÔºåÂÜ≥ÂÆö \(c\) ‰∏™‰ΩçÁΩÆÂ°´‰ªÄ‰πàÔºå‰ΩøÂ∑≤ÁªèÂÜ≥ÂÆöÁöÑËæπÊûÑÊàê \(i\) ‰∏™ÁéØÊñπÊ°àÊï∞ÔºàÊòæÁÑ∂Ê≠§Êó∂Êúâ \(n-c\) Êù°ÈìæÔºâ„ÄÇ \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) ÂÆûÈôÖÂè™Êúâ \(n^2\) ÁßçÔºåÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(F\) Âç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n^3)\)„ÄÇ ÂÜçËÄÉËôë \(G\) ÊÄé‰πàËÆ°ÁÆó„ÄÇ\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) ËÆ°ÁÆóÈùûÂ∏∏Êñπ‰æø„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï È¶ñÂÖàÔºå‰∏Ä‰∏™‰ª• \(A\) ‰∏∫ÂºÄÂ§¥‰ª• \(B\) ‰∏∫ÁªìÂ∞æÁöÑÂ∫èÂàóÊòØÂê¶Â≠òÂú®Ôºå‰ªÖ‰∏é \(A\oplus B\) ÊúâÂÖ≥„ÄÇ Â¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÈÇ£‰πà \(A\oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏ÄÂÆöÊòØÂ•áÊï∞„ÄÇ ‰∏Ä‰∏™ÁªìËÆ∫ÊòØÔºåÂ¶ÇÊûú \(A \oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÈÇ£‰πàÊª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàó‰∏ÄÂÆöÂ≠òÂú®„ÄÇ ‰∏ãÈù¢ÈÄíÂΩíÂú∞ÁªôÂá∫ÊûÑÈÄ†„ÄÇ ÂÆö‰πâ \(build(n,A,B)\) ËøîÂõû‰∏Ä‰∏™ \(0 \ldots 2^n-1\) ÁöÑ‰ª• \(A\) ‰∏∫ÂºÄÂ§¥Ôºå\(B\) ‰∏∫ÁªìÂ∞æÁöÑÊéíÂàó„ÄÇÔºà\(A\oplus B\) ‰∏≠ÊúâÂ•áÊï∞‰∏™ \(1\)Ôºâ Ëã• \(n=1\)ÔºåÂ¶ÇÊûú \(A = 0\)ÔºåËøîÂõû \(A, B\)„ÄÇ Ëã• \(A \oplus B\) ‰∏≠ÊÅ∞Êúâ‰∏Ä‰∏™ \(1\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^{n-1}\)ÔºàÂÖ∂‰ªñÊÉÖÂÜµÂè™ÈúÄË¶ÅÊääÊâÄÊúâÊï∞ÂºÇÊàñ‰∏ä \(A\) Âπ∂Êää \(1\) ÊâÄÂú®Âú®‰ΩçÂíåÊúÄÈ´ò‰Ωç‰∫§Êç¢Âç≥ÂèØÔºâ„ÄÇ ËÆæ \(a=build(n-1, 0, 1)\)ÔºåÈÇ£‰πà \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠Â≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæÂÖ∂‰∏≠ \(0\) Âú®ÊúÄ‰Ωé‰Ωç‰∏ä‰∏î \(A\) ÁöÑÊúÄ‰Ωé‰Ωç‰∏∫ \(0\)„ÄÇ ËÆæ \(a = build(n-1, \frac A 2, \frac B 2)\)Ôºå\(b = build(n-1, a_1, a_2)\)„ÄÇ ÈÇ£‰πà \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠‰∏çÂ≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^n-1\)„ÄÇ ËÆæ \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)„ÄÇ Âàô \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊéíÂàó„ÄÇ Áî®‰∏ªÂÆöÁêÜÂèØ‰ª•ÂàÜÊûêÂá∫Áõ¥Êé•ÈÄíÂΩíÁöÑÂ§çÊùÇÂ∫¶Âπ∂‰∏çÈ´ò„ÄÇÊâÄ‰ª•Áõ¥Êé•ÈÄíÂΩí‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï ËÆæ \(f_{i,j}\) Ë°®Á§∫Êää \(p_i \ldots p_n\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÊéíÂ∫èÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇ ËÆæ \(k\) ÊòØ \(p_i \ldots p_n\) ‰∏≠Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÁöÑ‰ΩçÁΩÆÔºå\(p_i\ldots p_k\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÂÖ±Êúâ \(c\) ‰∏™„ÄÇ \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] È¢ÑÂ§ÑÁêÜÂá∫ \(p\) Âíå \(c\)Ôºå\(n^2\) dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ È¢òÁõÆÂ§ßÊÑè Áªô‰Ω†‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÔºåËæπ‰∏äÊúâÂ≠óÁ¨¶„ÄÇÂÆö‰πâË∑ØÂæÑ \(u\) Âà∞ \(v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Â∞±ÊòØÊääË∑ØÂæÑ‰∏äÁöÑÂ≠óÁ¨¶‰æùÊ¨°Êé•Ëµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁªôÂÆö \(m\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s_1,s_2\ldots s_m\)„ÄÇ\(q\) Ê¨°ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏â‰∏™Êï∞ \(i, j, k\)ÔºåËØ¢ÈóÆÂú®Ë∑ØÂæÑ \(i\) Âà∞ \(j\) ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠Ôºå\(s_k\) Âá∫Áé∞‰∫ÜÂá†Ê¨°„ÄÇ Ëß£Ê≥ï Á¨¶Âè∑ËØ¥ÊòéÔºö\(s^R\) Ë°®Á§∫ \(s\) ÁöÑÂèç‰∏≤„ÄÇ\(pre(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂâçÁºÄÔºå\(suf(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂêéÁºÄ„ÄÇ\(s+t\) Ë°®Á§∫ÊääÂ≠óÁ¨¶‰∏≤ \(s\) ÂíåÂ≠óÁ¨¶‰∏≤ \(t\) ÊãºËµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇ ÂÖàÂÅö‰∏ÄÊ¨°ÁÇπÂàÜÊ≤ªÂ∞±ÂèØ‰ª•ÊääÈóÆÈ¢òËΩ¨Âåñ‰∏∫ \(u \rightarrow v\) ÁªèËøáÊ†πÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•Âè™ËÆ®ËÆ∫ÁªèËøáÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ËÆæÊ†π‰∏∫ \(r\)ÔºåËØ¢ÈóÆÁöÑË∑ØÂæÑ‰∏∫ \(u \rightarrow v\)ÔºåËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(s_k\)„ÄÇ ÂèØ‰ª•Êää \(s_k\) Âú®Ë∑ØÂæÑ \(u \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÂàÜÊàê‰∏âÈÉ®ÂàÜËÆ°ÁÆóÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØÂú® \(u\rightarrow r\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∫åÈÉ®ÂàÜÊòØÂú® \(r \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∏âÈÉ®ÂàÜÊòØÂú®Ë∑®Ëøá \(r\) ÁöÑÂåπÈÖç„ÄÇ Ââç‰∏§ÈÉ®ÂàÜÊòØÊØîËæÉÂ•ΩËÆ°ÁÆóÁöÑ„ÄÇÁ¶ªÁ∫ø‰∏Ä‰∏ãÔºåÂØπÊâÄÊúâÁöÑ \(s_i\) Âª∫ACËá™Âä®Êú∫ÔºåÂú®Ê†ë‰∏ädfsÔºåÊØèÊ¨°Âú®ACËá™Âä®Êú∫‰∏äËµ∞‰∏ÄÊù°ËΩ¨ÁßªËæπÔºåÁî® BIT Áª¥Êä§‰∏Ä‰∏ãÊØè‰∏™ÁÇπË¢´Ëµ∞‰∫ÜÂá†Ê¨°ÔºåÂú® dfs Âà∞ÁÇπ \(x\) Êó∂ÔºåÂè™ÈúÄ‰Ωú‰∏ÄÊ¨°Â≠êÊ†ëËØ¢ÈóÆÂç≥ÂèØÂø´ÈÄüÂæóÂà∞ \(s_k\) Âú® \(r\rightarrow x\) ‰∏äÂá∫Áé∞‰∫ÜÂá†Ê¨°ÔºàÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØ¢ÈóÆ \(s_k\) ÁöÑÂèç‰∏≤Âá∫Áé∞‰∫ÜÂá†Ê¨°Ôºâ„ÄÇ ÊØîËæÉÁÆÄÂçïÂ∞±‰∏çËØ¶ÁªÜÊèèËø∞‰∫Ü„ÄÇ Á¨¨‰∏âÈÉ®ÂàÜÊØîËæÉÂ§çÊùÇ„ÄÇËÆæË∑ØÂæÑ \(u\rightarrow r\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(x\)ÔºåË∑ØÂæÑ \(r \rightarrow v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(y\)„ÄÇËÆæ \(p\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(pre(s_k,p)=suf(x,p)\) ÁöÑÊï¥Êï∞Ôºå\(q\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(suf(s_k,q)=pre(y,q)\) ÁöÑÊï¥Êï∞„ÄÇÈÇ£‰πàËÆ°ÁÆóÁ¨¨‰∏âÈÉ®ÂàÜÂèØ‰ª•ËΩ¨Âåñ‰∏∫ËÆ°ÁÆó \(s_k\) Âú® \(suf(x,p)+pre(y,q)\) ‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞„ÄÇ ËÆæ \(t_i\) Ë∑ØÂæÑË°®Á§∫ \(r\rightarrow i\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂàô \(suf(x,p)+pre(y,q)\) ÂèØ‰ª•Ë°®Á§∫‰∏∫ \(pre(s_k,p)+suf(s_k,q)\)ÔºåËøôÊ†∑Â∞±ËΩ¨Âåñ‰∏∫‰∫ÜÂè™‰∏é \(s_k\) Áõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ\(p\)„ÄÅ\(q\) ÁöÑÂÖ∑‰ΩìÊ±ÇÊ≥ïÂêéÈù¢‰ºöËØ¶ÁªÜÊèèËø∞„ÄÇÂÅáËÆæÂ∑≤ÁªèÊ±ÇÂæó‰∫Ü \(p\)„ÄÅ\(q\)ÔºåËÄÉËôëÊÄé‰πàÂø´ÈÄüÂæóÂà∞Á¨¨‰∏âÈÉ®ÂàÜÁöÑÂåπÈÖçÊ¨°Êï∞„ÄÇ ÊääËØ¢ÈóÆÁ¶ªÁ∫ø„ÄÇÂØπÊØè‰∏™ \(i\)ÔºåÂª∫‰∏ÄÊ£µ \(s_i\) ÁöÑÂêéÁºÄÊ†ëÂíå \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë„ÄÇÂú® \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë‰∏ä \(dfs\)Ôºå\(dfs\) ÁöÑËøáÁ®ã‰∏≠ÔºåÁª¥Êä§‰∏ÄÊ£µÁ∫øÊÆµÊ†ë„ÄÇÂ¶ÇÊûú \(dfs\) Âà∞‰∏Ä‰∏™‰ª£Ë°® \(s_i^R\) ÂêéÁºÄÁöÑÁÇπÔºåËÆæËøô‰∏™ÁÇπÂØπÂ∫îÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ \(l\)ÔºåÈÇ£‰πàÂ∞±Âú®Á∫øÊÆµÊ†ë‰∏äÊää \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÂØπÂ∫î \(s_i[l+1\ldots \lvert s_i \rvert]\) ÁöÑÁÇπÁöÑÂ≠êÊ†ë \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂä†‰∏Ä„ÄÇÔºàÂèØËÉΩÊèèËø∞ÁöÑ‰∏çÊòØÂæàÊ∏ÖÊ•ö...Êàë‰πü‰∏çÁü•ÈÅìÊÄé‰πàÊèèËø∞‰∫ÜÔºâÂõûÊ∫ØÊó∂Êí§ÈîÄÊìç‰Ωú„ÄÇÁÑ∂ÂêéÂØπÊØè‰∏™ËØ¢ÈóÆ \(p, q\)ÔºåÂè™Ë¶ÅÂú® \(dfs\) Âà∞ \(s_i^R\) ÈïøÂ∫¶‰∏∫ \(p\) ÁöÑÂêéÁºÄÊó∂ÔºåËØ¢ÈóÆ‰∏Ä‰∏ã \(s_i\) ÈïøÂ∫¶‰∏∫ \(q\) ÁöÑÂêéÁºÄÂú® \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÁöÑ \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÁöÑÂÄºÂç≥ÂèØ„ÄÇ ËÄÉËôëÂ¶Ç‰ΩïÊ±Ç \(p\)„ÄÅ\(q\)„ÄÇÁî±‰∫éÊ±Ç \(q\) ÁöÑËøáÁ®ãÂíåÊ±Ç \(p\) Á±ª‰ººÔºåËøôÈáåÂè™ËØ¶ÁªÜÊèèËø∞Ê±Ç \(p\) ÁöÑËøáÁ®ã„ÄÇÂØπÊâÄÊúâ \(s_i\) ‰ª•Âèä \(s_i^R\) Âª∫Âá∫‰∏Ä‰∏™Âπø‰πâSAM„ÄÇÁÑ∂ÂêéÁ±ª‰ººACËá™Âä®Êú∫+BITÁöÑËøáÁ®ãÂú∞ÔºåÁª¥Êä§‰∏Ä‰∏™‰ª•parentÊ†ë \(dfs\) Â∫è‰∏∫‰∏ãÊ†áÁöÑÁ∫øÊÆµÊ†ë„ÄÇÁÑ∂ÂêéÂú®ÁÇπÂàÜÊ≤ªÂêéÂæóÂà∞ÁöÑËøûÈÄöÂùó‰∏ä \(dfs\)Ôºå\(dfs\) Âà∞ \(u\) Êó∂Áª¥Êä§ \(r\rightarrow u\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Âú®SAM‰∏äÁöÑ‰ΩçÁΩÆÔºåÂπ∂ÊääÂÆÉÁöÑÂ≠êÊ†ëÂú® \(dfs\) Â∫è‰∏äÁöÑ‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÂ≠êÊ†ëÂØπÈïøÂ∫¶Âèñ \(max\)„ÄÇÁÑ∂ÂêéÊ±Ç \(p\) Êó∂Âè™ÈúÄË¶ÅËØ¢ÈóÆ‰∏Ä‰∏ã \(s_k^R\) Âú® \(SAM\) ‰∏äÁöÑ‰ΩçÁΩÆÂú®parent tree‰∏≠ÁöÑ \(dfs\) Âú®Á∫øÊÆµÊ†ë‰∏äÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• „ÄåPKUWC2018„ÄçMinimax„ÄÇ Â§ßËá¥ÊÄùË∑Ø&amp;&amp;ÂêêÊßΩ Á∫øÊÆµÊ†ëÂêàÂπ∂ÔºåÁª¥Êä§Êüê‰∏™ÁÇπÊúÄÂêéÁöÑÂÄºÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™Âå∫Èó¥ÁöÑÊ¶ÇÁéá„ÄÇ merge ÁöÑÊó∂ÂÄôËÆ∞‰∏Ä‰∏ãÂâçÂêéÁºÄÊ¶ÇÁéáÂ∞±ËÉΩËΩ¨Áßª‰∫Ü„ÄÇ ‰ª£Á†ÅËÉΩÂäõÁúüÊòØË∂äÊù•Ë∂äÂ∑Æ‰∫Ü..Á∫øÊÆµÊ†ëÂêàÂπ∂ÈÉΩÂÜô‰∏çÁÜü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 Êï¥Êï∞]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) ‰∏™ \(bit\) Âéã‰∏ÄËµ∑ÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥Â∑¶ËæπËøûÁª≠ \(0\) Âíå \(2^{30}-1\) ÁöÑ‰∏™Êï∞„ÄÇ ‰ª£Á†ÅËÉΩÂäõÂ§™Ëèú‰∫ÜË°•Ë°•Ê∞¥È¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ Ë¥®Êï∞Âà§ÂÆö„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] ÂèçÂõûÊñá‰∏≤]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄåSDOI2018„ÄçÂèçÂõûÊñá‰∏≤„ÄÇ È¢òËß£ ËÄÉËôë‰ªÄ‰πàÊ†∑ÁöÑÂõûÊñá‰∏≤Âú®Âæ™ÁéØÁßª‰Ωç \(k\) ‰ΩçÂêéËøòÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤„ÄÇ ËÆæ \(s\) ÊòØ‰∏Ä‰∏™Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶‰∏∫ \(n\) ÂõûÊñá‰∏≤„ÄÇ ËÆ∞Â≠óÁ¨¶‰∏≤ \(a\) ÁöÑÂèç‰∏≤‰∏∫ \(a^R\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØÂõûÊñá‰∏≤ÔºåÂØπ‰∫é \(1\le i \le n\)Ôºå\(s[i]=s[n-i+1]\)„ÄÇ ÂèàÂõ†‰∏∫ \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤Ôºö ÂØπ‰∫é \(1 \le i \le n-2k\)Ôºö \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) ÂØπ‰∫é \(n-2k &lt; i \le n-k\)Ôºö \(s[i] = s[2n-2k-i+1] = s[i+2k]\) ÂØπ‰∫é \(n-k&lt;i \le n\)Ôºö \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) ÂèØ‰ª•ÁúãÂá∫ \(2k\) ÊòØ \(s\) ÁöÑÂë®ÊúüÔºå‰∏î \(s\) Âæ™ÁéØÂè≥Áßª \(2k\) ‰ΩçÂêéÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤‰∏é \(s\) Áõ∏Á≠â„ÄÇÂõ†Ê≠§ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÊòØ \(n\) ÁöÑÁ∫¶Êï∞„ÄÇËÆæ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÈïøÂ∫¶‰∏∫ \(t\)Ôºå\(t \mid n\)„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûú \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰Ωç‰ªçÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÈÇ£‰πà \(t \mid 2k\)„ÄÇÊúâ \(t\) Áßç‰∏çÂêåÁöÑ‰∏é \(s\) Âæ™ÁéØÂêåÊûÑÁöÑ‰∏≤„ÄÇËã• \(t\) ‰∏∫ÂÅ∂Êï∞ÔºåÈÇ£‰πà \(s\) Âæ™ÁéØÂè≥Áßª \(\frac t 2\) ‰ΩçÊàñÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇÂê¶ÂàôÂè™ÊúâÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇ ‰∏∫‰∫ÜËÆ°ÁÆó‰∏éÊüê‰∏™ÂõûÊñá‰∏≤Âæ™ÁéØÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÔºåËÄÉËôëÊûö‰∏æÂõûÊñá‰∏≤Âπ∂ËÆ°ÁÆó‰∏éËøô‰∏™ÂõûÊñá‰∏≤ÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤ÊúâÂ§öÂ∞ëÁßçÔºåËøôÊ†∑ÊúÄÂ∞èÂë®ÊúüÊòØÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤‰ºöË¢´ÁÆóÊÅ∞Â•Ω‰∏§Ê¨°ÔºåÂÖ∂‰ªñÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤Âè™‰ºöË¢´ÁÆó‰∏ÄÊ¨°„ÄÇÁâπÂà§ÊúÄÂ∞èÂë®Êúü‰∏∫ÂÅ∂Êï∞ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå‰∏çÂèØËÉΩÊûö‰∏æÊâÄÊúâÁöÑÂõûÊñá‰∏≤„ÄÇËÄÉËôëÊääÊúÄÂ∞èÂë®ÊúüÁõ∏ÂêåÁöÑÂõûÊñá‰∏≤ÊîæÂú®‰∏ÄËµ∑Êûö‰∏æ„ÄÇËÆæÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è‰∏∫ \(K\)ÔºåÊúÄÂ∞èÂë®Êúü‰∏∫ \(i\) ÁöÑÁ∫¶Êï∞ÁöÑÂõûÊñá‰∏≤Êúâ \(K^{\lceil \frac i 2 \rceil}\) ‰∏™„ÄÇËé´ÊØî‰πåÊñØÂèçÊºî‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå \(n\) ÈùûÂ∏∏ÁöÑÂ§ßÔºåÊ≤°ÊúâÂäûÊ≥ïÁõ¥Êé•ÂèçÊºîÂá∫‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ ÊääÁ≠îÊ°àÂÜôÂá∫Êù•ÂåñÁÆÄÔºö \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] Êûö‰∏æ \(d\)„ÄÇ \(d\) ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)„ÄÇ \(d\) ‰∏∫Â•áÊï∞Êó∂ÔºåËã• \(n\) ‰∏∫Â•áÊï∞Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)ÔºåÂê¶Âàô \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)„ÄÇ \(Pollard-Rho\) ÂàÜËß£Á¥†Âõ†Êï∞ÂêéÁÆÄÂçïÁªüËÆ°‰∏Ä‰∏ãÁ≠îÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [Ynoi2016]Èïú‰∏≠ÁöÑÊòÜËô´„ÄÇ ËÆ∞ÂΩïÊØè‰∏™ÁÇπ \(i\) ÂâçÈù¢Á¨¨‰∏Ä‰∏™‰∏é‰ªñÂêåËâ≤ÁöÑ‰ΩçÁΩÆ \(pre_i\)„ÄÇËØ¢ÈóÆÂå∫Èó¥È¢úËâ≤Êï∞ÂèòÊàêËØ¢ÈóÆÂå∫Èó¥ÂÜÖÊúâÂ§öÂ∞ë‰∏™ \(pre_i &lt;l\)ÔºåËøôÊòØ‰∏Ä‰∏™‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò„ÄÇÊ≥®ÊÑèÂà∞‰øÆÊîπ \(pre\) Êï∞ÁªÑÊ¨°Êï∞ÂùáÊëä \(\mathcal O (n)\)ÔºåÁî® \(set\) Áª¥Êä§ÊØè‰∏ÄÊÆµÔºåcdqÂàÜÊ≤ªÊàñËÄÖÊ†ëÂ•óÊ†ëÂÅö‰∏Ä‰∏ã‰∫åÁª¥ÂÅèÂ∫èÂç≥ÂèØ„ÄÇ ËøôÈ¢òÊúâ‰∏ÄÁÇπÂç°Â∏∏..cdqÂàÜÊ≤ªÂÜôÂΩíÂπ∂ÈÄüÂ∫¶‰ºöÂø´ÂæàÂ§ö„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //Á¶ªÊï£Âåñint pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //ÂØπ l+1-r ÁöÑpreÊõ¥Êñ∞ set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[È¢òËß£] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[ËôΩÁÑ∂ÂâçÈù¢ËøòÊúâÂæàÂ§öÂùëÊ≤°Ë°•ÂÆå...‰ΩÜÊòØÊàëÂèëÁé∞Ëá™Â∑±‰ª£Á†ÅËÉΩÂäõÈóÆÈ¢òÊØîËæÉ‰∏•Èáç„ÄÇÊâÄ‰ª•Êù•ÂÅöÂÅöynoi„ÄÇ ÂùëÂÖàÊîæÂú®Ëøô...Ê∏ÖÈÜíÁöÑÊó∂ÂÄôÊÖ¢ÊÖ¢Â°´„ÄÇ [YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢„ÄÇ ÂÖàÂíïÁùÄ„ÄÇ„ÄÇ„ÄÇ‰∏á‰∏ÄÈÅá‰∏äÁé∞Êé®Âêß„ÄÇ]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÊâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ„ÄÇ ËøôÈ¢òÁõÆÊúâÈóÆÈ¢òÂêß....Ê®°Êï∞ÂèØ‰ª•ÁàÜ long long ÁöÑ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÂêéÁºÄËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂêéÁºÄËá™Âä®Êú∫„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Splay(Áª¥Êä§Â∫èÂàó)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [NOI2005]Áª¥Êä§Êï∞Âàó„ÄÇ Â∏∏Êï∞ÈùûÂ∏∏ÈùûÂ∏∏Â§ß.....ÂÖàÂΩìÊùøÂ≠êËÉå‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèexp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÂØπÊï∞ÂáΩÊï∞„ÄÇ ‰ª£Á†ÅÁâπÂà´‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊ±ÇÈÄÜ]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÊ±ÇÈÄÜ„ÄÇ \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) ‰ª£Á†Å‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ‰ªªÊÑèÈïøÂ∫¶DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm Ê±Ç \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) ËÆæ \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)„ÄÇ Âàô \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)„ÄÇ \(i-k\) ÂèØËÉΩ‰ºöÂá∫Áé∞Ë¥üÊï∞„ÄÇÂπ≥Áßª‰∏ãÂÅö‰∏™Âç∑ÁßØÂç≥ÂèØ„ÄÇ ÊáíÂæóÂÜôQAQ„ÄÇÔºàÂ•ΩÂÉè‰πüÊ≤°Âï•Â•ΩÂÜôÁöÑÔºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] NTTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∏™ÊôÆÈÄöÁöÑ NTT Ê®°Êùø„ÄÇ‰ª£Á†ÅÈùûÂ∏∏‰∏ë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FFTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÁúÅÈÄâÂâçÂ§ç‰π†„ÄÇËøôÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ fft Ê®°Êùø„ÄÇ ÔºàÂèëÁé∞Ëá™Â∑±Â∑ÆÁÇπfftÊ®°Êùø‰∏ç‰ºöÊâì‰∫ÜÔºâ Âõ†‰∏∫Ê≤°ÊúâÈ¢ÑÂ§ÑÁêÜ&amp;&amp;Áî®‰∫ÜcomplexÁ±ªÂèØËÉΩÂ∏∏Êï∞ÊØîËæÉÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÊàëÂèëÁé∞Ëá™Â∑±ÁöÑ‰ª£Á†ÅËÉΩÂäõÂ§™Âº±‰∫Ü...... Êúâ‰∫õÊ®°ÊùøÈúÄË¶ÅÂπ≥Êó∂ÂÜô‰∏Ä‰∏ãÔºå‰∏çËÉΩÁé∞Âú∫ÂÜôÔºåÂê¶Âàô‰∏ç‰∏ÄÂÆöË∞ÉÁöÑÂá∫Êù•„ÄÇËøôÈáåÂàóÂá∫‰∏Ä‰∫õÂ∏∏Áî®Ê®°Êùø„ÄÇÔºà‰ºòÂåñÂ∏∏Êï∞&amp;&amp;‰ºòÂåñ‰ª£Á†ÅÂ§çÊùÇÂ∫¶&amp;&amp;ËÉå‰∏ãÊù•Ôºâ„ÄÇ Â§öÈ°πÂºèÔºö FFT NTT Â§öÈ°πÂºèÊ±ÇÈÄÜ Â§öÈ°πÂºèln Â§öÈ°πÂºèexp Â§öÈ°πÂºèÂèñÊ®° Â§öÈ°πÂºèÂ§öÁÇπÊ±ÇÂÄº Â§öÈ°πÂºèÂø´ÈÄüÊèíÂÄº Â§öÈ°πÂºèÂ§çÂêàÈÄÜ Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé® Êï∞ËÆ∫Ôºö LucasÂÆöÁêÜ exCRT ÊùúÊïôÁ≠õ Pollard-Rho Miller-Rabin min_25Á≠õ Á±ªÊ¨ßÂá†ÈáåÂæó ‰∫åÊ¨°Ââ©‰Ωô Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºö Á∫øÊÆµÊ†ëÂêàÂπ∂ Ê†ëÁä∂Êï∞ÁªÑ Splay LCT ETT ÁÇπÂàÜÊ†ë Ê†ëÈìæÂâñÂàÜ Âä®ÊÄÅdp Â≠óÁ¨¶‰∏≤Ôºö ÂêéÁºÄËá™Âä®Êú∫ Âª∫ÂêéÁºÄÊ†ë ÂêéÁºÄÊï∞ÁªÑ trieÊ†ëSAM ACËá™Âä®Êú∫ ÂõûÊñáÊ†ë ÂÖ∂‰ªñÔºö FWT ÂçäÂπ≥Èù¢‰∫§ Áü©Èòµ-Ê†ëÂÆöÁêÜ ÂõæËÆ∫Ôºö ÊîØÈÖçÊ†ë ÂúÜÊñπÊ†ë ËæπÂèå]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢òÁõÆ]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑËøô‰πàËèú‰∫ÜËøòÂè£ËÉ°È¢òÁõÆ...Â§ßÊ¶Ç‰ºöË∂äÊù•Ë∂äËèúÂêß.. 2019.3.29 CF 1097G \(k\) Ê¨°ÊñπÁúã‰ΩúÊòØÈÄâ \(k\) Êù°Ëæπ„ÄÇËÄÉËôëÊâÄÊúâ \(k\) Êù°ËæπÁöÑÊúâÂ∫èÂØπÔºåËÆ°ÁÆóÂåÖÂê´ÂÆÉ‰ª¨ÁöÑÈõÜÂêàÊï∞„ÄÇËÉåÂåÖ \(dp\) ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇÊ†πÊçÆÊüêËÄÉËøáÂæàÂ§öÊ¨°ÁöÑÂ§çÊùÇÂ∫¶ÂàÜÊûêÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ \(\mathcal O (nk)\)„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Ôºö https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf È¢òÁõÆÂ§ßÊÑè ËæìÂÖ•‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ≠óÁ¨¶‰∏≤ \(s\)„ÄÇ‰Ω†Êúâ‰∏Ä‰∏™Á©∫‰∏≤ \(t\)Ôºå‰Ω†Ë¶ÅÊääÂÆÉÂèòÊàêËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂèØ‰ª•ËøõË°å‰ª•‰∏ãÂá†ÁßçÊìç‰ΩúÔºö Âú® \(t\) ÁöÑÂºÄÂ§¥ÊàñËÄÖÊú´Â∞æÊ∑ªÂä†‰∏Ä‰∏™Â≠óÁ¨¶„ÄÇ Êää \(t\) ÁøªËΩ¨ËøáÊù•ÔºåÁÑ∂ÂêéÊé•Âú®ÂéüÊù•ÁöÑ \(t\) ÁöÑÂºÄÂ§¥ÊàñÊú´Â∞æ„ÄÇ Ê±ÇÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ \(n \le 10^5\) Ëß£Ê≥ï Âú®ÊúÄÂêéËøûÁª≠ÁöÑËã•Âπ≤Ê¨°Âä†Â≠óÁ¨¶Êìç‰Ωú‰πãÂâçÔºå\(t\) ‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÂÄíËøáÊù•ËÄÉËôëÔºåÁî®ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞Êää \(s\) ÂèòÊàêÁ©∫‰∏≤„ÄÇÂè™ÈúÄË¶ÅÂàÜÂà´ËÄÉËôëÊØè‰∏™ÂõûÊñá‰∏≤ÁöÑÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Âª∫Á´ãÂõûÊñáÊ†ë„ÄÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏âÁßçËΩ¨ÁßªÔºö ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤Âèò‰∏∫‰ªñÁöÑ‰∏ÄÂçä„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂéªÊéâ‰ªñ‰∏§Á´ØÁöÑÂ≠óÁ¨¶„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåËΩ¨ÁßªÂà∞‰ªñÁöÑÊúÄÈïøÂõûÊñáÂâçÁºÄ„ÄÇ ÊåâÈïøÂ∫¶‰ªéÂ∞èÂà∞Â§ßÈ°∫Â∫è \(dp\)„ÄÇÂêé‰∏§ÁßçËΩ¨ÁßªÂèØ‰ª•Áõ¥Êé•ËÆ°ÁÆó„ÄÇÂØπÁ¨¨‰∏ÄÁßçËΩ¨ÁßªÔºåÂÄçÂ¢û‰∏Ä‰∏ãÂà§Êñ≠ \(fail\) Ê†ë‰∏äÊúâÊ≤°ÊúâÈïøÂ∫¶ÊÅ∞Â•Ω‰∏∫‰∏ÄÂçäÁöÑÁ•ñÂÖàÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØÂÅáÁöÑ„ÄÇË¶ÅÁúÅÈÄâ‰∫Ü..ÂÖàË°•ÁÇπÂà´ÁöÑÂÜçÊù•ÊâìËøôÈ¢òQAQ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â≠óÁ¨¶‰∏≤ÊäÄÂ∑ß„ÄÅÊÄùÊÉ≥„ÄÅÁü•ËØÜÁÇπÊï¥ÁêÜ]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon wordÁöÑ‰∏Ä‰∫õÊÄßË¥®]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Lyndon_word ÂÆö‰πâ Â¶ÇÊûú‰∏Ä‰∏™‰∏≤ÊúÄÂ∞èÂêéÁºÄÊòØÂÆÉÊú¨Ë∫´ÔºåÈÇ£‰πàÁß∞‰ªñ‰∏∫ Lyndon word„ÄÇÔºà‰∏é‰∏•Ê†ºÊúÄÂ∞èÂæ™ÁéØÁßª‰ΩçÁöÑÂÆö‰πâÊòØÁ≠â‰ª∑ÁöÑÔºâ Áõ∏ÂÖ≥ÊÄßË¥®ÂíåÁÆóÊ≥ï ÊÄßË¥®1 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºåÈÇ£‰πà \(s\) ‰∏çÂ≠òÂú® border„ÄÇ ÊÄßË¥®2 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºå\(s=uv\) ‰∏î \(u\) Âíå \(v\) ÈùûÁ©∫ÔºåÈÇ£‰πà \(u&lt;v\)„ÄÇ ÊÄßË¥®3 Â¶ÇÊûú \(s,t\) ÊòØ Lyndon word ‰∏î \(s &lt; t\)ÔºåÈÇ£‰πà \(st\) ‰πüÊòØ Lyndon word„ÄÇ ÊÄßË¥®4 ‰∏Ä‰∏™ÈïøÂ∫¶Â§ß‰∫éÁ≠â‰∫é \(2\) Â≠óÁ¨¶‰∏≤ÁöÑ \(s\) ÊòØ Lyndon word ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå\(s\) ÂèØ‰ª•ÊãÜÊàê‰∏§‰∏™ÈùûÁ©∫‰∏≤ \(u,v\)ÔºåÊª°Ë∂≥ \(u &lt; v\) ‰∏î \(u\) Âíå \(v\) ÈÉΩÊòØ Lyndon word„ÄÇ ËØÅÊòé ÂÖÖÂàÜÊÄßÂç≥‰∏ä‰∏ÄÊù°ÊÄßË¥®ÔºåÂè™ËØÅÂøÖË¶ÅÊÄß„ÄÇ ËÆæ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(n\)ÔºåÂêéÁºÄ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄ„ÄÇ ÂÅáËÆæ \(s[1..i-1]\) ÊúâÈïøÂ∫¶‰∏∫ \(k\) ÁöÑ borderÔºåÂç≥ \(s[1..k]=s[i-k..i-1]\)„ÄÇ Âõ†‰∏∫ \(k &lt; i-1\)ÔºåÊâÄ‰ª• \(k+1 \neq i\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØ Lyndon wordÔºå\(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊâÄ‰ª• \(s[i..n]&lt;s[k+1..n]\)„ÄÇÂèàÂõ†‰∏∫ \(s[i-k..i-1]=s[1..k]\)ÔºåÊâÄ‰ª• \(s[i-k..n]&lt;s[1..n]\)ÔºåËøô‰∏é \(s\) ÊòØ Lyndon word ÁüõÁõæ„ÄÇÊâÄ‰ª• \(s[1..i-1]\) Ê≤°Êúâ border„ÄÇ Ê†πÊçÆ Lyndon word ÁöÑÂÆö‰πâÂèä \(s[1..i-1]\) Ê≤°Êúâ borderÔºåÊúâ \(\forall 1 &lt; j \le i-1\)Ôºå\(\exists j \le k \le i-1\)ÔºåÊª°Ë∂≥ \(s[k] &gt; s[k-j+1]\)ÔºåÂç≥ \(s[j..i-1] &gt; s[1..i-1]\)„ÄÇÊâÄ‰ª• \(s[1..i-1]\) ÊòØ Lyndon word„ÄÇ Âõ†‰∏∫ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊòæÁÑ∂‰∏çÂ≠òÂú® \(j&gt;i\) Êª°Ë∂≥ \(s[j..n]&lt;s[i..n]\)ÔºåÊâÄ‰ª• \(s[i..n]\) ÊòØ Lyndon word„ÄÇ ÊâÄ‰ª• \(u=s[1..i-1],v=s[i..n]\) ÊòØ‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊãÜÂàÜÔºåÂøÖË¶ÅÊÄßÂæóËØÅ„ÄÇ ÊÄßË¥®5 ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\) ÈÉΩÂèØ‰ª•ÂîØ‰∏ÄÂú∞ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÂÖ∏Â∫è‰∏çÂ¢ûÁöÑ Lyndon Word„ÄÇ ÊàëÊäΩ‰ª£Â§™Ëèú‰∫Ü...ÂÖ∂‰ªñÁöÑÊÄßË¥®‰ª•ÂêéÂÜçË°•Âêß„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon ÂàÜËß£]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ëß£Ê≥ï ÂÖ≥‰∫é Lyndon word ÁöÑ‰∏Ä‰∫õÁªìËÆ∫ÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/D È¢òÁõÆÂ§ßÊÑè ÁªôÂÆö‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÔºå‰ª• \(1\) ‰∏∫Ê†πÁöÑÊ†ëÔºåÁ¨¨ \(i\) ‰∏™ÁÇπÊúâ‰∏Ä‰∏™‰ª∑Ê†º \(c_i\)„ÄÇ ‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™‰∫∫‰ºöÁªôÊØè‰∏™Âè∂ËäÇÁÇπËÆæÁΩÆ‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ‰Ω†Âè™ËÉΩÂØπÂ∑≤ÁªèÈÄâÊã©ÁöÑÁÇπÂÅöÂ≠êÊ†ëÂä†‰ªªÊÑèÊï∞Â≠óÁöÑÊìç‰Ωú„ÄÇ ‰Ω†Ë¶ÅÈÄöËøáËã•Âπ≤Ê¨°Êìç‰ΩúÊääÊâÄÊúâÂè∂Â≠êËäÇÁÇπ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\)„ÄÇ ÈóÆÔºöË¶ÅÁ°Æ‰øùÂè¶‰∏Ä‰∏™‰∫∫Êó†ËÆ∫ÊÄé‰πàÊìç‰Ωú‰Ω†ÈÉΩËÉΩÊääÂè∂Â≠ê‰∏äÁöÑÊï∞ÂèòÊàê \(0\)Ôºå‰Ω†ÈÄâÊã©ÁöÑÁÇπ‰ª∑Ê†ºÊÄªÂíåÊúÄÂ∞èÊòØ‰ªÄ‰πàÔºüÊúâÂì™‰∫õÁÇπË¢´Ëá≥Â∞ë‰∏ÄÁßçÊúÄÂ∞è‰ª∑Ê†ºÁöÑÊñπÊ°àÂåÖÂê´Ôºü \(n \le 200000\)Ôºå\(0\le c_i \le 10^9\)„ÄÇ Ëß£Ê≥ï Ëøô‰∏™ÈóÆÈ¢òÂèØ‰ª•ÁúãÊàêÔºå‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπ‰Ωú‰∏∫Êú™Áü•Êï∞ÔºåÊØè‰∏™Âè∂Â≠êÁöÑÈôêÂà∂ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÊñπÁ®ãÔºå‰Ω†Ë¶ÅËÆ©Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÊª°Ë∂≥ÔºåÊó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåËøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Âõ†‰∏∫‰ª∑Ê†ºÊòØÈùûË¥üÊï¥Êï∞ÔºåÂ¶ÇÊûúÁ≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÁõ∏ÂÖ≥ÔºåÂøÖÂèØ‰ª•Âà†Èô§Êüê‰∏ÄÂàóÔºåÂç≥ÂèØ‰ª•Â∞ëÈÄâ‰∏Ä‰∏™ÁÇπÔºåËøôÊ†∑‰∏ÄÂÆö‰∏ç‰ºöÂèòÁöÑÊõ¥Â∑ÆÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥„ÄÇÂõ†‰∏∫Êó†ËÆ∫Â∏∏Êï∞È°πÁöÑÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩË¶ÅÊúâËß£ÔºåÊâÄ‰ª•Ë°åÊï∞Á≠â‰∫éÂàóÊï∞„ÄÇ ÁªìËÆ∫ ËÆæÂè∂ËäÇÁÇπ‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∏Ä‰∏™ÂåÖÂê´ÊÅ∞Â•Ω \(x\) ‰∏™ÁÇπÁöÑÈÄâÂèñÊñπÊ°àËÉΩ‰øùËØÅÂèØ‰ª•Â∞ÜÊâÄÊúâÂè∂Â≠ê‰∏äÁöÑÊï∞Â≠óÂèòÊàê \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÔºåÂ≠òÂú®Ë¢´ÈÄâÂèñÁöÑÁÇπÔºå‰∏îÊ∑±Â∫¶ÊúÄÂ§ßÁöÑË¢´ÈÄâÂèñÁÇπ‰∏çÂêå„ÄÇ ËØÅÊòé ÂøÖË¶ÅÊÄßÊòæÁÑ∂„ÄÇ ÂÖÖÂàÜÊÄßÔºöÊääÊñπÁ®ãÁªÑÁöÑÊú™Áü•Êï∞Êåâ‰ªªÊÑè‰∏ÄÁßç \(dfs\) Â∫èÊéíÂàóÔºåÁ≥ªÊï∞Áü©Èòµ‰∏≠ÔºåÊØè‰∏ÄË°åÁöÑÁ¨¨‰∏Ä‰∏™Èùû \(0\) ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂàóÈÉΩ‰∏çÂêåÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥ÔºåÂèàÂõ†‰∏∫Ë°åÊï∞Á≠â‰∫éÂàóÊï∞ÔºåÊâÄ‰ª•Êó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Áä∂ÊÄÅ \(dp[i][j][k]\) Ôºö \(i\) Ë°®Á§∫Âè™ËÄÉËôë‰ª• \(i\) ‰∏∫Ê†πÁöÑÂ≠êÊ†ë„ÄÇ \(j\) Ë°®Á§∫ \(i\) ÊòØÂê¶Ë¢´ÈÄâÊã©„ÄÇ \(k\) Ë°®Á§∫ÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Âè∂Â≠êÔºå‰ªñÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏≠Ê≤°ÊúâÁÇπË¢´ÈÄâÊã©„ÄÇ \(dp\) Êï∞ÁªÑ‰∏≠Â≠òÁöÑÊòØÔºåÊª°Ë∂≥‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏äÊ∑±Â∫¶ÊúÄÂ§ßÁöÑÁ•ñÂÖà‰∏çÂêåÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÁúã‰Ωú \(0\)ÔºâÁöÑÊúÄÂ∞è‰ª∑Ê†ºÂíå„ÄÇ \(dp\) ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéËÆ∞ÂΩïÂì™‰∫õËΩ¨ÁßªÂèØ‰ª•ÂèñÂà∞ÊúÄ‰ºòÂÄºÔºåÊúÄÂêé‰ªéÊ†πÂºÄÂßã \(dfs\) ‰∏ÄÈÅçÊ±ÇÊñπÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ÔºàÂ∑®‰∏ëÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/C È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s\)„ÄÇ ËØ∑‰Ω†Êää \(s\) ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÁ¨¶‰∏≤ \(s=t_1t_2\cdots t_k\)„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∏≤ÔºåËã• \(t_i\) ÊòØ \(t_1t_2\cdots t_{i-1}\) ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(b\) ÁöÑ‰ª£‰ª∑ÔºåÂê¶Âàô \(t_i\) ÈïøÂ∫¶ÂøÖÈ°ª‰∏∫ \(1\)Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(a\) ÁöÑ‰ª£‰ª∑„ÄÇÊ±ÇÊúÄÂ∞è‰ª£‰ª∑„ÄÇ \(n \le 5000\)ÔºåÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è \(26\)„ÄÇ Ëß£Ê≥ï ËÆæ \(dp_i\) Ë°®Á§∫Ââç \(i\) ‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂ∞èÂàíÂàÜÔºåÂú®Ê±ÇÂá∫ \(dp_i\) ÂêéÁî® \(kmp\) ÊâæÊúÄÈïøÂú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑ‰ªé \(i+1\) ÂºÄÂßãÁöÑ‰∏≤ÔºåÊõ¥Êñ∞ÊâÄÊúâ \(dp_j\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÊï¥ÁêÜÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Impartial_game impartial game ÊòØÊåáÊª°Ë∂≥Â¶Ç‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÔºö - ‰∏§‰∏™Áé©ÂÆ∂ËΩÆÊµÅÊìç‰ΩúÔºåÁõ¥Âà∞ËææÂà∞‰∏çËÉΩÊìç‰ΩúÁöÑÁä∂ÊÄÅÔºàterminal positionÔºâ„ÄÇ - ÂΩì‰∏Ä‰∏™Áé©ÂÆ∂‰∏çËÉΩÊìç‰ΩúÊó∂Ôºåwinner Â∞±Ë¢´Á°ÆÂÆö‰∫Ü„ÄÇ - ÊØè‰∏™Áä∂ÊÄÅÁöÑÊìç‰ΩúÊï∞ÂíåÁä∂ÊÄÅÊÄªÊï∞ÊòØÊúâÈôêÁöÑ„ÄÇ - ÊâÄÊúâÁöÑÊìç‰ΩúÂøÖÈ°ªÂêåÊó∂ËÉΩË¢´‰∏§‰∏™Áé©ÂÆ∂ËøõË°å„ÄÇ - ÊâÄÊúâÊìç‰ΩúÁöÑÁªìÊûúÈÉΩÊòØÁ°ÆÂÆöÊÄßÁöÑ„ÄÇ Normal play convention wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Normal_play_convention Impartial game ÁöÑ Normal play convention ÔºöÊúÄÂêé‰∏Ä‰∏™ÂèØ‰ª•Êìç‰ΩúÁöÑÁé©ÂÆ∂Ëé∑ËÉú„ÄÇ NimÊ∏∏Êàè wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Nim ÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅÂèñÁü≥Â≠ê„ÄÇÊØèÊ¨°ËΩÆÂà∞ÁöÑ‰∫∫ÂèØ‰ª•ÈÄâÊã©‰ªéÊüê‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Ëã•Âπ≤È¢óÁü≥Â≠êÔºà‰∏çËÉΩ‰∏çÊãøÔºâÔºå‰∏çËÉΩÊåâËßÑÂàôÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ Nim Ê∏∏ÊàèÂ±û‰∫é Impartial game„ÄÇ NimÊ∏∏ÊàèÁöÑËÉúÂà©Êù°‰ª∂ ÂÆöÁêÜÔºöÂΩì‰∏î‰ªÖÂΩìÊØèÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) Êó∂ÔºåÂÖàÊâãÂøÖËÉú„ÄÇ ËØÅÊòéÔºö ÂØπ‰∫é terminal positionÔºåÂç≥Ê≤°ÊúâÁü≥ÁöÑÊÉÖÂÜµÔºåÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåËΩÆÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑ‰∫∫Ëæì„ÄÇÂÆöÁêÜÂØπ terminal position ÊàêÁ´ã„ÄÇ ÂºïÁêÜ1 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\)ÔºåÂàôÂÆÉÂøÖÂÆöÂèØ‰ª•ËΩ¨ÁßªÂà∞‰∏Ä‰∏™Áü≥Â≠ê‰∏™Êï∞‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\)„ÄÇ ËÆæ \(s\) ÊúÄÈ´òÁöÑ‰∫åËøõÂà∂‰ΩçÊòØÁ¨¨ \(k\) ‰ΩçÔºà‰ªé‰ΩéÂà∞È´òÔºåÊúÄ‰Ωé‰Ωç‰∏∫Á¨¨ \(0\) ‰ΩçÔºâ„ÄÇ ‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÂ†ÜÁü≥Â≠ê‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∫åËøõÂà∂‰∏ã \(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)„ÄÇ Èô§‰∫ÜËøôÂ†ÜÁü≥Â≠êÂ§ñÔºåÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\oplus x\)„ÄÇ \(s\oplus x\) Âíå \(x\) Âú®ÊâÄÊúâÊØîÁ¨¨ \(k\) ‰ΩçÈ´òÁöÑ‰∫åËøõÂà∂‰Ωç‰∏äÁõ∏Á≠âÔºå\(s\oplus x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(0\)Ôºå\(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)ÔºåÊâÄ‰ª• \(s \oplus x &lt; x\)„ÄÇ ÂèØ‰ª•‰ªéËøôÂ†ÜÁü≥Â≠ê‰∏≠ÂèñËµ∞ \(x-s\oplus x\) ‰∏™Áü≥Â≠êÔºå‰ΩøÂºÇÊàñÂíåÂèò‰∏∫ \(0\)„ÄÇ ÂºïÁêÜ2 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÈÉΩ‰ºöËΩ¨ÁßªÂà∞‰∏Ä‰∏™ÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊìç‰ΩúÁöÑÂ†ÜÂú®Êìç‰ΩúÂâçÊúâ \(x\) È¢óÁü≥Â≠ê„ÄÇ ÈÇ£‰πàÈô§‰∫ÜËøôÂ†Ü‰ª•Â§ñÁöÑÂÖ∂‰ªñÂ†ÜÁü≥Â≠êÊï∞ÂºÇÊàñÂíå‰πü‰∏∫ \(x\)„ÄÇ Âú®ÂèñÁü≥Â≠êÂêéÔºåËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏ÄÂÆö‰∏ç‰∏∫ \(x\)„ÄÇ Âè™ÊúâËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏∫ \(x\) Êó∂Ôºå‰∏éÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíåÊâç‰ºö‰∏∫ \(0\)„ÄÇ ÊâÄ‰ª•Êìç‰ΩúÂêéÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏ÄÂÆöÈùû \(0\)„ÄÇ Ê†πÊçÆÁªìÊûÑÂΩíÁ∫≥Ê≥ïÂèØÁü•ÂÆöÁêÜÊàêÁ´ã„ÄÇ Sprague‚ÄìGrundy ÂÆöÁêÜ wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Sprague‚ÄìGrundy_theorem ÂÆö‰πâ \(mex\) ËøêÁÆóÔºå‰∏Ä‰∏™ÈõÜÂêàÁöÑ \(mex\) ÂÄºÊòØÊúÄÂ∞èÁöÑÊ≤°ÊúâÂá∫Áé∞Âú®Ëøô‰∏™ÈõÜÂêà‰∏≠ÁöÑËá™ÁÑ∂Êï∞„ÄÇ ÂÆö‰πâ Sprague-Grundy ÂáΩÊï∞ÔºöÂØπ‰∫é‰∏Ä‰∏™Áä∂ÊÄÅ \(x\)ÔºåÂΩì \(x\) ÊòØ terminal position Êó∂Ôºå\(SG(x)=mex\{SG(y)|x\) ÂèØ‰ª•ËΩ¨ÁßªÂà∞ \(y\}\)„ÄÇ ÂèØ‰ª•Áî® Sprague-Grundy ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏™Áä∂ÊÄÅÊòØÂøÖËÉúÁä∂ÊÄÅËøòÊòØÂøÖË¥•Áä∂ÊÄÅÔºåÂõ†‰∏∫ÂøÖËÉúÁä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏ç‰∏∫ \(0\)ÔºåÂøÖË¥•Áä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏∫ \(0\)„ÄÇ ÂÆö‰πâ‰∏§‰∏™Ê∏∏ÊàèÁöÑ disjunctive sum ‰∏∫‰∏Ä‰∏™Ê∏∏ÊàèÔºöËΩÆÂà∞ÊØè‰∏™Áé©ÂÆ∂ÁöÑÊó∂ÂÄôÔºå‰ªñÂèØ‰ª•ÈÄâÊã©‰∏§‰∏™Ê∏∏Êàè‰∏≠ÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Ê∏∏Êàè‰∏äÊìç‰Ωú‰∏ÄÊ≠•ÔºåÊó†Ê≥ïÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÊòæÁÑ∂ disjunctive sum Êª°Ë∂≥‰∫§Êç¢ÂæãÂíåÁªìÂêàÂæã„ÄÇ ÂÆöÁêÜ Êúâ \(n\) ‰∏™Ê∏∏Êàè \(G_1,G_2,\cdots,G_n\)ÔºåËÆæ‰ªñ‰ª¨ÁöÑ disjunctive sum ‰∏∫ \(G\)„ÄÇÈÇ£‰πà \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)„ÄÇ ËØÅÊòéÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ Ëøô‰πüËØ¥Êòé‰∫ÜÊØè‰∏Ä‰∏™ normal play convention ‰∏ãÁöÑ impartial game ÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰∏™NimÊ∏∏Êàè„ÄÇ]]></content>
      <tags>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
