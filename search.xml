<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LOJ2461] 完美的队列]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[题目链接 定义第 \(i\) 个操作的发生时间为 \(i\)。 求出每次操作加入的新的 \(x\) 全部被弹出的最早时间，就很好求答案了。 从后往前考虑每个操作，计算这次操作加入的元素全部被弹出的最早时间。 定义一个队列 \(i\) 的弹出时间为从当前操作开始，往后第 \(a_i\) 个影响队列 \(i\) 的操作的发生时间。 分块，从后往前依次加入每个操作，分别维护每一块中的队列弹出时间的 \(\max\)。 考虑在加入操作 \(i\) 后，每一块中的队列弹出时间 \(\max\) 发生什么样的变化。 被 \([l_i,r_i]\) 包含的块 与 \([l_i,r_i]\) 有交但是没有被包含的块]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式操作模板]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI 前复习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //最大多项式长度，倍数问题已经考虑const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) ret = 1LL*ret*x%mod;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;struct poly &#123;4int *a, len;4poly(int l_ = 0) &#123;44len = l_;44a = new int[l_];44for (int i = 0; i &lt; l_; i++) a[i] = 0;4&#125;&#125;;void ntt(int *a, int l, int ty) &#123;4rev[0] = 0;4for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1)));4for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]);4for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123;44int wn = qpow(g, (mod-1)/len);44for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123;444int w = 1;444for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123;4444int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod;4444a[i+j] = (v1 + v2) % mod;4444a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod;4444w = 1LL*w*wn%mod;444&#125;44&#125;4&#125;4if (ty == -1) &#123;44int inv = qpow(1&lt;&lt;l, mod-2);44for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod;44for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]);4&#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123;4poly ret(p1.len + p2.len - 1);4int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l;4for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0;4for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i];4for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i];4ntt(wa, l, 1); ntt(wb, l, 1);4for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod;4ntt(wc, l, -1);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i];4return ret;&#125;poly polyInv(const poly &amp;p) &#123;4if (p.len == 1) &#123;44poly ret(1);44ret.a[0] = qpow(p.a[0], mod-2);44return ret;4&#125;4int nlen = (p.len+1)/2;4poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i];4poly G = polyInv(tmp);4poly ret(p.len);4for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod;4poly t = p*G*G;4for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod;4return ret;&#125;poly polyLn(const poly &amp;p) &#123;4if (p.len == 1) return poly(1);4poly inv = polyInv(p);4poly d(p.len);4for (int i = 0; i+1 &lt; p.len; i++) &#123;44d.a[i] = 1LL*p.a[i+1]*(i+1)%mod;4&#125;4inv = inv * d;4poly ret(p.len);4for (int i = 1; i &lt; ret.len; i++) &#123;44ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod;4&#125;4return ret;&#125;poly polyExp(const poly &amp;p) &#123;4if (p.len == 1) &#123;44poly ret(1);44ret.a[0] = 1;44return ret;4&#125;4int nlen = (p.len+1)/2;4poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i];4poly G = polyExp(tmp);4poly t(p.len), v(p.len);4for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i];4v = polyLn(v);4for (int i = 0; i &lt; p.len; i++) &#123;44t.a[i] = (mod - v.a[i] + p.a[i]) % mod;4&#125;4t.a[0] = (t.a[0] + 1) % mod;4t = t*G;4poly ret(p.len);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i];4return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123;4poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1);4for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i];4for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i];4poly v = rF*polyInv(rQ);4for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i];4poly t = P*Q;4for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123;4if (p.len == 1) &#123;44poly ret(1);44ret.a[0] = 1;44return ret;4&#125;4int nlen = (p.len+1)/2;4poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i];4poly F0 = polySqrt(np);4poly exF0(p.len);4for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i];4poly tmp = F0*F0;4poly extmp(p.len);4for (int i = 0; i &lt; p.len; i++) &#123;44if (i &lt; tmp.len) extmp.a[i] = tmp.a[i];44extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod;4&#125;4poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod;4poly tt = extmp*polyInv(Q);4poly res(p.len);4for (int i = 0; i &lt; res.len; i++) &#123;44res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod;4&#125;4return res;&#125;int main() &#123;4int n;4scanf("%d", &amp;n);4poly P(n);4for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]);4poly res = polySqrt(P);4for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]);4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 常系数齐次线性递推]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[多项式取模优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) ret = 1LL*ret*x%mod;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;struct poly &#123;4int *a, len;4poly(int l_ = 0) &#123;44len = l_;44a = new int[len];44for (int i = 0; i &lt; len; i++)444a[i] = 0;4&#125;&#125; P; // 特征多项式int wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123;4for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1)));4for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]);4for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123;44int wn = qpow(g, (mod-1)/len);44for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123;444int w = 1;444for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123;4444int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod;4444a[i] = (v1 + v2) % mod;4444a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod;4444w = 1LL*w*wn%mod;444&#125;44&#125;4&#125;4if (ty == -1) &#123;44int inv = qpow((1&lt;&lt;l), mod-2);44for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod;44for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]);4&#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123;4poly ret(p1.len + p2.len - 1);4int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l;4for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0;4for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i];4for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i];4ntt(wa, l, 1); ntt(wb, l, 1);4for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod;4ntt(wc, l, -1);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i];4return ret;&#125;poly polyInv(const poly &amp;p) &#123;4if (p.len == 1) &#123;44poly ret(1);44ret.a[0] = qpow(p.a[0], mod-2);44return ret;4&#125;4int nlen = (p.len + 1) / 2;4poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i];4poly f0 = polyInv(np);4poly t1 = p*f0;4poly t2(p.len);4for (int i = 0; i &lt; p.len; i++) &#123;44if (i &lt; t1.len) &#123;444t2.a[i] = (mod - t1.a[i]) % mod;44&#125;4&#125;4t2.a[0] = (t2.a[0] + 2) % mod;4poly res = f0*t2;4poly ret(p.len);4for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i];4return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123;4if (p.len &lt; q.len) return p;4poly rp(p.len-q.len+1), rq(p.len-q.len+1);4for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i];4for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i];4poly t1 = rp*polyInv(rq);4poly t2(p.len-q.len+1);4for (int i = 0; i &lt; t2.len; i++) &#123;44t2.a[i] = t1.a[p.len-q.len-i];4&#125;4poly t3 = t2*q;4poly ret(q.len-1);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod;4return ret;&#125;poly calMod(int y) &#123;4poly ret(1); ret.a[0] = 1;4poly x(2); x.a[1] = 1;4while (y) &#123;44if (y &amp; 1) ret = polyMod(ret * x, P);44x = polyMod(x * x, P);44y &gt;&gt;= 1;4&#125;4return ret;&#125;void polyPrint(const poly &amp;p) &#123;4printf("%d :\n", p.len);4for (int i = 0; i &lt; p.len; i++) &#123;44printf("%d ", p.a[i]);4&#125;4printf("\n");&#125;int main() &#123;4scanf("%d%d", &amp;n, &amp;k);4for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125;4for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125;4//乘以 A^n4int ans = 0;4P = poly(k+1);4for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod;4P.a[k] = 1;4//polyPrint(P);4poly pol = calMod(n);4//polyPrint(pol);4for (int i = 0; i &lt; pol.len; i++) &#123;44ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod;4&#125;4printf("%d\n", ans);4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[较难发现的一些zz错误]]></title>
    <url>%2F2019%2F07%2F02%2F%E8%BE%83%E9%9A%BE%E5%8F%91%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9Bzz%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[比较函数定义不严格。 for (int i = 1; i &lt;= n; i++) a[n] = inf。 在一些回溯时需要撤销操作的 dfs 中，因为其他原因 return 的时候没有撤销操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[发这篇博客主要是为了记录一个极为隐蔽的错误。 写比较函数一定要保证是严格的小于号。要特别处理等于。否则在遇到堆打标记删除这种问题的时候，相同元素在堆中的顺序会影响答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123;4bool operator()(const int &amp;x, const int &amp;y) &#123;44if (L[x] == L[y]) return x &lt; y;44return L[x] &gt; L[y];4&#125;&#125;;struct C2 &#123;4bool operator()(const int &amp;x, const int &amp;y) &#123;44if (D[x] == D[y]) return x &lt; y;44return D[x] &gt; D[y];4&#125;&#125;;struct C3 &#123;4bool operator()(const int &amp;x, const int &amp;y) &#123;44if (L[x]-D[x] == L[y]-D[y]) return x &lt; y;44return L[x]-D[x] &gt; L[y]-D[y];4&#125;&#125;;struct C4 &#123;4bool operator()(const int &amp;x, const int &amp;y) &#123;44return D[x]-L[x] &gt; D[y]-L[y];4&#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123;4priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d;4void _c() &#123;44while (!d.empty() &amp;&amp; q.top() == d.top()) &#123;444q.pop();444d.pop();44&#125;4&#125;4T1 getTop() &#123;44_c();44if (!q.empty()) return q.top();44else return 0;4&#125;4void del(T1 x) &#123;44d.push(x);4&#125;4void add(T1 x) &#123;44q.push(x);4&#125;4int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123;4L[0] = D[0] = 0x7fffffff;4scanf("%d", &amp;n);4for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]);4for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i);4for (int i = 1; i &lt;= n; i++) &#123;44ans[i] = ans[i-1];44&#123;444int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop();444if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123;4444ans[i] += L[v1];4444h2.add(v1);4444h3.del(v1);4444h4.del(v1);444&#125; else &#123;4444ans[i] += L[v3]-D[v3]+D[v2];4444h1.del(v3);4444h2.add(v3);4444h1.add(v2);4444h3.del(v2);4444h4.del(v2);444&#125;44&#125;44&#123;444int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop();444if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123;4444ans[i] += D[v1];4444h1.add(v1);4444h4.del(v1);4444h3.del(v1);444&#125; else &#123;4444ans[i] += D[v3]-L[v3]+L[v2];4444h2.del(v3);4444h1.add(v3);4444h2.add(v2);4444h4.del(v2);4444h3.del(v2);444&#125;44&#125;4&#125;4for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]);4return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] 「ZJOI2017」字符串]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[题目链接 做法 不难证明如果一个子串 \(s\) 有两个后缀 \(s_1, s_2\)，\(s_2\) 是 \(s_1\) 的 border 且 \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)，那么对于任意的字符串 \(t\)，\(s_2\) 不可能是 \(st\) 的最小后缀。 用一个线段树维护每个区间内可能成为最小后缀的点，这样的点只有 \(\mathcal O (\log n)\) 个。push up 的时候暴力合并即可。 比较大小的时候需要查 lcp，分块维护前缀哈希即可做到 \(\mathcal O(\sqrt n)\) 修改，\(\mathcal O(\log n)\) 询问（调整块大小应该可以做到更优的复杂度）。 总复杂度 \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)。 （真的毒瘤）]]></content>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[题目链接。 ### 做法]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板]-貌似是洲阁筛的筛法]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[提交至 简单的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123;4if (x &gt;= mod) return x-mod;4if (x &lt; 0) return x+mod;4return x;&#125;int getin(ll x) &#123;4if (x &gt;= sqr) &#123;44if (!in1[n/x]) in1[n/x] = ++ tot;44return in1[n/x];4&#125; else &#123;44if (!in2[x]) in2[x] = ++ tot;44return in2[x];4&#125;&#125;ll calp(ll n) &#123;4if (n == 1) return 0;4return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123;4if (val[n] == 1) return 0;4if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]);4else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123;4isnp[1] = 1;4for (int i = 2; i &lt;= 1000000; i++) &#123;44if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125;44for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123;444isnp[i*p[j]] = 1;444if (i % p[j] == 0) break;44&#125;4&#125;4for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1];4scanf("%lld", &amp;n);4sqr = int(sqrt(n));4for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123;44val[getin(n/i)] = n/i;4&#125;4for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125;4for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1));4for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]);4for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123;44for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123;444f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod);444g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1)));44&#125;4&#125;4int mx = 0;4for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i;4for (int i = mx; i &gt;= 1; i--) &#123;44for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123;444int e = 1;444ll v = p[i];444if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1);444while (v &lt;= val[j]) &#123;4444int t = 0;4444if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123;44444t = mo(calh(getin(val[j]/v), i+1)+1);4444&#125; else t = mo(h[getin(val[j]/v)]+1);4444h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod);4444++ e; v *= p[i];444&#125;44&#125;4&#125;4printf("%d\n", mo(h[getin(n)]+1));4return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] 区间素数个数]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接。 试着实现下 min_25 筛的第一步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123;4if (x &gt;= sqr) &#123;44if (!in1[n/x]) in1[n/x] = ++ tot;44return in1[n/x];4&#125; else &#123;44if (!in2[x]) in2[x] = ++ tot;44return in2[x];4&#125;&#125;int main() &#123;4scanf("%lld", &amp;n);4sqr = int(sqrt(n));4isnp[1] = 1;4for (int i = 2; i &lt;= 1000000; i++) &#123;44if (!isnp[i]) &#123;444prm[++ cnt] = i;44&#125;44for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123;444isnp[i*prm[j]] = 1;444if (i % prm[j] == 0) break;44&#125;4&#125;4int mx = 0;4for (ll i = 1; i &lt;= n;) &#123;44ll nxt = n/(n/i)+1;44val[getin(n/i)] = n/i;44i = nxt;4&#125;4for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1;4int last = 0;4for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123;44last = i;44for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123;444f[j] -= (f[getin(val[j]/prm[i])]-(i-1));44&#125;4&#125;4printf("%lld\n", f[getin(n)]);4return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/problemset/problem/715/E 题目大意 你有两个长度为 \(n\) 的排列 \(p_1\) 和 \(p_2\)，其中有一些位置被挖空，让你自己填数字。 请你对每个 \(k\) 输出，有多少种填数字方案，使得 \(p_1\) 最少交换 \(k\) 次可以变成 \(p_2\)。 \(n \le 250\)。 解法 首先题目保证至少存在一种填数方案使得 \(p_1\) 和 \(p_2\) 是排列，所以不需要考虑已经确定的数不合法的情况。 容易看出交换次数 \(n-(p_1p_2^{-1}\) 的轮换数\()\)。 问题变成了求满足 \(p_1p_2^{-1}\) 恰好可以分解为 \(k\) 个不相交轮换的方案数。 设 \(p_1p_2^{-1}=w\)，则 \(p_1=wp_2\)，即 \(p_1[i]=w[p_2[i]]\)。 设所有 \(p_1\) 中已经确定的位置的下标构成的集合为 \(S_1\)，所有 \(p_2\) 中已经确定的位置的下标构成的集合为 \(S_2\)。 假设 \(w\) 是已经确定的排列。那么对于 \(i \in S_1\)，有 \(p_2[i]=w^{-1}[p_1[i]]\)；对于 \(i \in S_2\)，有 \(p_1[i]=w[p_2[i]]\)。所以 \(\forall i \in S_1 \cap S_2\)，\(p_1[i]\) 和 \(p_2[i]\) 都是确定的。对于 \(p_1\) 来说，还有 \(n-\lvert S_1\cup S_2 \rvert\) 个位置要填的数没有确定。那么如果存在至少一种填数方案，就恰好有 \((n-\lvert S_1\cup S_2 \rvert)!\) 种使得 \(p_1p_2^{-1}=w\) 的填数方案。 再考虑有多少种恰有 \(k\) 个环的合法的 \(w\)。对于 \(i \in S_1\cap S_2\)，\(w[p_2[i]]=p_1[i]\)。所以 \(w\) 的一些位置已经确定了。同时 \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)。\(w\) 中确定的位置已经构成了一些链和一些环。构成环后不可能与其他点连边，可以直接忽略。链可以缩成一个点。那么问题转化为，给定两个集合 \(A\) 和 \(B\)，求有多少个长度为 \(n\) 的排列，恰有 \(k\) 个环的排列，满足 \(\forall i \in A, w[i] \notin B\)。显然这个问题只与 \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) 有关。 先考虑 \(A\cap B =\emptyset\)。容斥一下即可。 \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] 再考虑 \(A\cap B \neq \emptyset\)。把限制条件看作 \(\forall i \in A\setminus B,w[i]\notin B\) 和 \(\forall i \in A \cap B, w[i] \notin B\)。对第二个条件容斥。设 \(G(n, c, i)\) 为 \(n\) 个数的排列，决定 \(c\) 个位置填什么，使已经决定的边构成 \(i\) 个环方案数（显然此时有 \(n-c\) 条链）。 \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) 实际只有 \(n^2\) 种，暴力预处理 \(F\) 即可，时间复杂度 \(\mathcal O(n^3)\)。 再考虑 \(G\) 怎么计算。\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) 计算非常方便。 这样就做完了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123;4int ret = 0;4for (int x = 0; x &lt;= a; ++ x) &#123;44int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod;44if (x &amp; 1) tmp = (mod-tmp)%mod;44ret = (ret + tmp) % mod;4&#125;4return ret;&#125;int main() &#123;4scanf("%d", &amp;n);4jc[0] = 1; S[0][0] = 1;4inv[1] = 1;4for (int i = 2; i &lt;= n; i++) &#123;44inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod;4&#125;4for (int i = 0; i &lt;= n; i++) C[i][0] = 1;4for (int i = 1; i &lt;= n; i++) &#123;44for (int j = 1; j &lt;= i; j++) &#123;444C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;44&#125;44jc[i] = 1LL*jc[i-1]*i%mod;4&#125;4for (int i = 1; i &lt;= n; i++) &#123;44for (int j = 1; j &lt;= i; j++) &#123;444for (int k = 1; k &lt;= i; k++) &#123;4444S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod;444&#125;44&#125;4&#125;4for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]);4for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]);4for (int i = 1; i &lt;= n; i++) &#123;44if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1;44vis2[p2[i]] = 1;44if (p1[i] &amp;&amp; p2[i]) &#123;444w[p1[i]] = p2[i];444deg[p2[i]] ++;44&#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X;4&#125;4for (int i = 1; i &lt;= n; i++) &#123;44if (!vis[i] &amp;&amp; !deg[i]) &#123;444int t = i, last = 0;444while (t &amp;&amp; !vis[t]) &#123;4444vis[t] = 1;4444last = t;4444t = w[t];444&#125;444if (!t) &#123;4444++ tot_n;4444if (vis1[last]) ++ A;4444if (vis2[i]) ++ B;4444if (vis1[last] &amp;&amp; vis2[i]) ++ T;444&#125; else ++ base;44&#125;4&#125;4for (int i = 1; i &lt;= n; i++) &#123;44if (!vis[i]) &#123;444int t = i, last = 0;444while (t &amp;&amp; !vis[t]) &#123;4444vis[t] = 1;4444last = t;4444t = w[t];444&#125;444if (!t) &#123;4444++ tot_n;4444if (vis1[last]) ++ A;4444if (vis2[i]) ++ B;4444if (vis1[last] &amp;&amp; vis2[i]) ++ T;444&#125; else ++ base;44&#125;4&#125;4A -= T; B -= T;4for (int x = 0; x &lt;= T; x++) &#123;44for (int j = 0; j &lt;= n; j++) &#123;444F[x][j] = calF(tot_n-x, A, B+T-x, j);44&#125;4&#125;4G[0][0][0] = 1;4for (int i = 1; i &lt;= n; i++) &#123;44G[i][0][0] = 1;44for (int j = 1; j &lt;= i; j++) &#123;444G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod;444for (int k = 1; k &lt;= j; k++) &#123;4444G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod;444&#125;44&#125;4&#125;4for (int k = 0; k &lt;= tot_n; k++) &#123;44int tans = 0;44for (int x = 0; x &lt;= T; x++) &#123;444int K = C[T][x];444int sum = 0;444if (x &amp; 1) K = (mod - K) % mod;444for (int i = 0; i &lt;= k; i++) &#123;4444sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod;444&#125;444tans = (tans + 1LL*K*sum%mod)%mod;44&#125;44ans[n-(k+base)] = tans;4&#125;4for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod));4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 首先，一个以 \(A\) 为开头以 \(B\) 为结尾的序列是否存在，仅与 \(A\oplus B\) 有关。 如果存在一个满足条件的序列，那么 \(A\oplus B\) 中 \(1\) 的个数一定是奇数。 一个结论是，如果 \(A \oplus B\) 中 \(1\) 的个数是奇数，那么满足条件的序列一定存在。 下面递归地给出构造。 定义 \(build(n,A,B)\) 返回一个 \(0 \ldots 2^n-1\) 的以 \(A\) 为开头，\(B\) 为结尾的排列。（\(A\oplus B\) 中有奇数个 \(1\)） 若 \(n=1\)，如果 \(A = 0\)，返回 \(A, B\)。 若 \(A \oplus B\) 中恰有一个 \(1\)，不妨设 \(A = 0, B = 2^{n-1}\)（其他情况只需要把所有数异或上 \(A\) 并把 \(1\) 所在在位和最高位交换即可）。 设 \(a=build(n-1, 0, 1)\)，那么 \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) 是一个满足条件的排列。 若 \(A\oplus B\) 中存在 \(0\)，不妨设其中 \(0\) 在最低位上且 \(A\) 的最低位为 \(0\)。 设 \(a = build(n-1, \frac A 2, \frac B 2)\)，\(b = build(n-1, a_1, a_2)\)。 那么 \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) 是一个满足条件的排列。 若 \(A\oplus B\) 中不存在 \(0\)，不妨设 \(A = 0, B = 2^n-1\)。 设 \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)。 则 \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) 是一个合法的排列。 用主定理可以分析出直接递归的复杂度并不高。所以直接递归一下就好。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123;4if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123;44return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2);4&#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123;4if (n == 1) &#123;44vector&lt;int&gt; ret;44ret.push_back(A); ret.push_back(B);44return ret;4&#125; else &#123;44vector&lt;int&gt; ret;44int cnt = 0, t = A^B;44for (int i = 0; i &lt; n; i++) &#123;444if (t &amp; (1&lt;&lt;i)) &#123;4444++ cnt;444&#125;44&#125;44if (cnt == 1) &#123;444int p = 0;444for (int i = 0; i &lt; n; i++) &#123;4444if (t &amp; (1&lt;&lt;i)) &#123;44444p = i;44444break;4444&#125;444&#125;444A = swap(A, p, n-1); B = swap(B, p, n-1);444vector&lt;int&gt; a = build(n-1, 0, 1);444for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]);444for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]);444for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A;444for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1);444return ret;44&#125; else if (cnt &lt; n) &#123;444int p = 0;444for (int i = 0; i &lt; n; i++) &#123;4444if (!(t &amp; (1&lt;&lt;i))) &#123;44444p = i;44444break;4444&#125;444&#125;444A = swap(A, p, 0); B = swap(B, p, 0);444int q = 0;444if (A &amp; 1) &#123;4444q = 1;4444A ^= q;4444B ^= q;444&#125;444vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1);444vector&lt;int&gt; b = build(n-1, a[0], a[1]);444vector&lt;int&gt; ret;444ret.push_back(a[0]&lt;&lt;1);444for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1);444for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1);444for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q;444for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0);444return ret;44&#125; else &#123;444vector&lt;int&gt; ret;444vector&lt;int&gt; a = build(n-1, 0, 1);444vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1);444for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]);444for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]);444for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A;444return ret;44&#125;4&#125;&#125;int n, A, B;int main() &#123;4scanf("%d%d%d", &amp;n, &amp;A, &amp;B);4int t = A^B, cnt = 0;4for (int i = 0; i &lt; n; i++) &#123;44if (t &amp; (1&lt;&lt;i)) &#123;444++ cnt;44&#125;4&#125;4if (cnt &amp; 1) &#123;44puts("YES");44vector&lt;int&gt; ans = build(n, A, B);44for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123;444printf("%d ", ans[i]);44&#125;44printf("\n");4&#125; else puts("NO");4return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 设 \(f_{i,j}\) 表示把 \(p_i \ldots p_n\) 中大于等于 \(j\) 的数排序的最小代价。 设 \(k\) 是 \(p_i \ldots p_n\) 中第一个大于等于 \(j\) 的数的位置，\(p_i\ldots p_k\) 中大于等于 \(j\) 的数共有 \(c\) 个。 \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] 预处理出 \(p\) 和 \(c\)，\(n^2\) dp 一下即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123;4scanf("%d%d%d", &amp;n, &amp;A, &amp;B);4for (int i = 1; i &lt;= n; i++) &#123;44scanf("%d", &amp;p[i]);44rp[p[i]] = i;4&#125;4for (int i = 1; i &lt;= n; i++) &#123;44for (int j = n; j &gt;= 1; j--) &#123;444K[i][j] = K[i][j+1];444if (rp[j] &gt;= i) K[i][j] = rp[j];44&#125;4&#125;4for (int j = 1; j &lt;= n; j++) &#123;44for (int i = 1; i &lt;= n; i++) &#123;444if (p[i] &gt;= j) sum[i] = sum[i-1] + 1;444else sum[i] = sum[i-1];44&#125;44for (int i = 1; i &lt;= n; i++) &#123;444int k = K[i][j];444if (k) &#123;4444C[i][j] = sum[k]-sum[i-1];444&#125;44&#125;4&#125;4for (int i = n; i &gt;= 1; i--) &#123;44for (int j = n; j &gt;= 1; j--) &#123;444if (!K[i][j]) f[i][j] = 0;444else &#123;4444ll c = C[i][j], k = K[i][j];4444f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]);444&#125;44&#125;4&#125;4printf("%lld\n", f[1][1]);4return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF%2F</url>
    <content type="text"><![CDATA[题目链接。 题目大意 给你一棵 \(n\) 个点的树，边上有字符。定义路径 \(u\) 到 \(v\) 上的字符串就是把路径上的字符依次接起来得到的字符串。给定 \(m\) 个字符串 \(s_1,s_2\ldots s_m\)。\(q\) 次询问，每次询问给出三个数 \(i, j, k\)，询问在路径 \(i\) 到 \(j\) 的字符串中，\(s_k\) 出现了几次。 解法 符号说明：\(s^R\) 表示 \(s\) 的反串。\(pre(s,i)\) 表示 \(s\) 的长度为 \(i\) 的前缀，\(suf(s,i)\) 表示 \(s\) 的长度为 \(i\) 的后缀。\(s+t\) 表示把字符串 \(s\) 和字符串 \(t\) 拼起来得到的字符串。 先做一次点分治就可以把问题转化为 \(u \rightarrow v\) 经过根的情况，所以只讨论经过根的情况。 设根为 \(r\)，询问的路径为 \(u \rightarrow v\)，询问的字符串为 \(s_k\)。 可以把 \(s_k\) 在路径 \(u \rightarrow v\) 上的匹配分成三部分计算，第一部分是在 \(u\rightarrow r\) 上的匹配，第二部分是在 \(r \rightarrow v\) 上的匹配，第三部分是在跨过 \(r\) 的匹配。 前两部分是比较好计算的。离线一下，对所有的 \(s_i\) 建AC自动机，在树上dfs，每次在AC自动机上走一条转移边，用 BIT 维护一下每个点被走了几次，在 dfs 到点 \(x\) 时，只需作一次子树询问即可快速得到 \(s_k\) 在 \(r\rightarrow x\) 上出现了几次（对于第一部分是询问 \(s_k\) 的反串出现了几次）。 比较简单就不详细描述了。 第三部分比较复杂。设路径 \(u\rightarrow r\) 上的字符串为 \(x\)，路径 \(r \rightarrow v\) 上的字符串为 \(y\)。设 \(p\) 是最大的满足 \(pre(s_k,p)=suf(x,p)\) 的整数，\(q\) 是最大的满足 \(suf(s_k,q)=pre(y,q)\) 的整数。那么计算第三部分可以转化为计算 \(s_k\) 在 \(suf(x,p)+pre(y,q)\) 中的出现次数。 设 \(t_i\) 路径表示 \(r\rightarrow i\) 上的字符串。则 \(suf(x,p)+pre(y,q)\) 可以表示为 \(pre(s_k,p)+suf(s_k,q)\)，这样就转化为了只与 \(s_k\) 相关的问题。\(p\)、\(q\) 的具体求法后面会详细描述。假设已经求得了 \(p\)、\(q\)，考虑怎么快速得到第三部分的匹配次数。 把询问离线。对每个 \(i\)，建一棵 \(s_i\) 的后缀树和 \(s_i^R\) 的后缀树。在 \(s_i^R\) 的后缀树上 \(dfs\)，\(dfs\) 的过程中，维护一棵线段树。如果 \(dfs\) 到一个代表 \(s_i^R\) 后缀的点，设这个点对应的字符串长度为 \(l\)，那么就在线段树上把 \(s_i\) 的后缀树上对应 \(s_i[l+1\ldots \lvert s_i \rvert]\) 的点的子树 \(dfs\) 序上位置加一。（可能描述的不是很清楚...我也不知道怎么描述了）回溯时撤销操作。然后对每个询问 \(p, q\)，只要在 \(dfs\) 到 \(s_i^R\) 长度为 \(p\) 的后缀时，询问一下 \(s_i\) 长度为 \(q\) 的后缀在 \(s_i\) 的后缀树上的 \(dfs\) 序上位置在线段树上的值即可。 考虑如何求 \(p\)、\(q\)。由于求 \(q\) 的过程和求 \(p\) 类似，这里只详细描述求 \(p\) 的过程。对所有 \(s_i\) 以及 \(s_i^R\) 建出一个广义SAM。然后类似AC自动机+BIT的过程地，维护一个以parent树 \(dfs\) 序为下标的线段树。然后在点分治后得到的连通块上 \(dfs\)，\(dfs\) 到 \(u\) 时维护 \(r\rightarrow u\) 上的字符串在SAM上的位置，并把它的子树在 \(dfs\) 序上的位置在线段树上子树对长度取 \(max\)。然后求 \(p\) 时只需要询问一下 \(s_k^R\) 在 \(SAM\) 上的位置在parent tree中的 \(dfs\) 在线段树上的位置即可。 代码]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[题目链接 「PKUWC2018」Minimax。 大致思路&amp;&amp;吐槽 线段树合并，维护某个点最后的值在线段树上每个区间的概率。 merge 的时候记一下前后缀概率就能转移了。 代码能力真是越来越差了..线段树合并都写不熟。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) 444ret = 1LL*ret*x%mod;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123;4tree[u].push_back(v);&#125;void modify(int rt, int v) &#123;4if (rt) &#123;44tag[rt] = 1LL*tag[rt]*v%mod;44sum[rt] = 1LL*sum[rt]*v%mod;4&#125;&#125;void pushDown(int rt) &#123;4if (tag[rt] != 1) &#123;44modify(ls[rt], tag[rt]);44modify(rs[rt], tag[rt]);44tag[rt] = 1;4&#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123;4int pmax = p, pmin = (mod+1-p)%mod;4int a = sum[rt1], b = sum[rt2];4int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod;4int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod;4if (!rt1 || !rt2) &#123;44if (!rt1 &amp;&amp; !rt2) return 0;44if (rt1 &amp;&amp; !rt2) &#123;444modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod);444return rt1;44&#125;44if (rt2 &amp;&amp; !rt1) &#123;444modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod);444return rt2;44&#125;4&#125;4pushDown(rt1); pushDown(rt2);4sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod;4if (l == r) return rt1;4int m = (l + r) &gt;&gt; 1;4int t1 = (Rp1+sum[rs[rt1]])%mod;4int t2 = (Rp2+sum[rs[rt2]])%mod;4int t3 = (Lp1+sum[ls[rt1]])%mod;4int t4 = (Lp2+sum[ls[rt2]])%mod;4ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2);4rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2);4return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123;4if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125;4sum[rt] ++;4if (l == r) return;4int m = (l + r) &gt;&gt; 1;4pushDown(rt);4if (p &lt;= m) update(p, l, m, ls[rt]);4else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123;4int rt = 0;4if (tree[u].size() == 0) update(p[u], 1, maxw, rt);4if (tree[u].size() == 1) rt = dfs(tree[u][0]);4if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0);4return rt;&#125;void cal_ans(int l, int r, int rt) &#123;4if (l == r) &#123;44if (sum[rt]) &#123;444++ _;444ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod;44&#125;44return;4&#125;4pushDown(rt);4int m = (l + r) &gt;&gt; 1;4if (ls[rt]) cal_ans(l, m, ls[rt]);4if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123;4scanf("%d", &amp;n);4for (int i = 1; i &lt;= n; i++) &#123;44int f = 0;44scanf("%d", &amp;f);44if (i &gt; 1) addEdge(f, i);4&#125;4for (int i = 1; i &lt;= n; i++) 44scanf("%d", &amp;p[i]);4int rt = dfs(1);4cal_ans(1, maxw, rt);4printf("%d\n", ans);4return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 整数]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) 个 \(bit\) 压一起，线段树维护区间左边连续 \(0\) 和 \(2^{30}-1\) 的个数。 代码能力太菜了补补水题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123;4int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123;4DAT ret;4ret.len = x.len + y.len;4ret.lc0 = x.lc0; ret.lc1 = x.lc1;4if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0;4if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1;4return ret;&#125;void modify0(int rt) &#123;4tag0[rt] = 1;4tag1[rt] = 0;4T[rt].lc1 = T[rt].val = 0;4T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123;4tag1[rt] = 1;4tag0[rt] = 0;4T[rt].lc0 = 0;4T[rt].val = MX;4T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123;4if (tag0[rt]) &#123;44modify0(rt&lt;&lt;1);44modify0(rt&lt;&lt;1|1);44tag0[rt] = 0;4&#125;4if (tag1[rt]) &#123;44modify1(rt&lt;&lt;1);44modify1(rt&lt;&lt;1|1);44tag1[rt] = 0;4&#125;&#125;void pushUp(int rt) &#123;4T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123;4if (L &gt; R) return;4if (L &lt;= l &amp;&amp; r &lt;= R) &#123;44modify0(rt);44return;4&#125;4pushDown(rt);4int m = (l + r) &gt;&gt; 1;4if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1);4if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1);4pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123;4if (L &gt; R) return;4if (L &lt;= l &amp;&amp; r &lt;= R) &#123;44modify1(rt);44return;4&#125;4pushDown(rt);4int m = (l + r) &gt;&gt; 1;4if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1);4if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1);4pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123;4if (l == r) &#123;44if (v == MX) &#123;444T[rt].lc1 = 1;44&#125; else T[rt].lc1 = 0;44if (v == 0) &#123;444T[rt].lc0 = 1;44&#125; else T[rt].lc0 = 0;44T[rt].val = v;44return;4&#125;4pushDown(rt);4int m = (l + r) &gt;&gt; 1;4if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1);4else upd(p, v, m+1, r, rt&lt;&lt;1|1);4pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123;4if (L &lt;= l &amp;&amp; r &lt;= R) &#123;44return T[rt];4&#125;4pushDown(rt);4int m = (l + r) &gt;&gt; 1;4DAT ret; ret.len = ret.lc0 = ret.lc1 = 0;4if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1);4if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1);4return ret;&#125;int qry(int p, int l, int r, int rt) &#123;4if (l == r) return T[rt].val;4int m = (l + r) &gt;&gt; 1;4pushDown(rt);4if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1);4else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123;4if (!v) return;4int t = qry(p, 0, MAXN, 1);4if ((t+v) &gt;= BASE) &#123;44upd(p, (t+v)%BASE, 0, MAXN, 1);44DAT dat = qrys(p+1, MAXN, 0, MAXN, 1);44updc0(p+1, p+dat.lc1, 0, MAXN, 1);44upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1);4&#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123;4if (!v) return;4int t = qry(p, 0, MAXN, 1);4if ((t-v) &lt; 0) &#123;44upd(p, t-v+BASE, 0, MAXN, 1);44DAT dat = qrys(p+1, MAXN, 0, MAXN, 1);44updc1(p+1, p+dat.lc0, 0, MAXN, 1);44upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1);4&#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123;4if (l == r) &#123;44T[rt].len = T[rt].lc0 = 1;44return;4&#125;4int m = (l + r) &gt;&gt; 1;4build(l, m, rt&lt;&lt;1);4build(m+1, r, rt&lt;&lt;1|1);4pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123;4scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3);4build(0, MAXN, 1);4for (int i = 1; i &lt;= n; i++) &#123;44int opt;44scanf("%d", &amp;opt);44if (opt == 1) &#123;444int a, b;444scanf("%d%d", &amp;a, &amp;b);444//b/30*30444//2^&#123;b%30&#125;*b444if (a &lt; 0) &#123;4444a = -a;4444ll v = (1ll&lt;&lt;(b%30))*a;4444sub(b/30, v%BASE);4444sub(b/30+1, v/BASE);444&#125; else &#123;4444ll v = (1ll&lt;&lt;(b%30))*a;4444add(b/30, v%BASE);4444add(b/30+1, v/BASE);444&#125;44&#125; else &#123;444int k;444scanf("%d", &amp;k);444int t = qry(k/30, 0, MAXN, 1);444printf("%d\n", (t&gt;&gt;(k%30))&amp;1);44&#125;4&#125;4return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[提交至 质数判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123;4return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123;4ll ret = 1;4while (x) &#123;44if (x &amp; 1) ret = mul(ret, a, mod);44a = mul(a, a, mod);44x &gt;&gt;= 1;4&#125;4return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123;4if (p == 2) return 1;4if (p == 1 || p % 2 == 0) return 0;4ll t = p-1, c = 0;4while (t % 2 == 0) &#123;44t /= 2;44++ c;4&#125;4for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123;44int a = prm[i];44ll v = qpow(a, t, p);44for (int j = 0; j &lt; c; j++) &#123;444ll nv = mul(v, v, p);444if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0;444v = nv;44&#125;44if (v != 1) return 0;4&#125;4return 1;&#125;int T;int main() &#123;4ll n;4while (scanf("%lld", &amp;n) != EOF) &#123;44if (miller_rabin(n)) puts("Y");44else puts("N");4&#125;4return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] 反回文串]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[提交至 「SDOI2018」反回文串。 题解 考虑什么样的回文串在循环移位 \(k\) 位后还是一个回文串。 设 \(s\) 是一个循环右移 \(k\) 位后仍是回文串的长度为 \(n\) 回文串。 记字符串 \(a\) 的反串为 \(a^R\)。 因为 \(s\) 是回文串，对于 \(1\le i \le n\)，\(s[i]=s[n-i+1]\)。 又因为 \(s\) 循环右移 \(k\) 位后仍是回文串： 对于 \(1 \le i \le n-2k\)： \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) 对于 \(n-2k &lt; i \le n-k\)： \(s[i] = s[2n-2k-i+1] = s[i+2k]\) 对于 \(n-k&lt;i \le n\)： \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) 可以看出 \(2k\) 是 \(s\) 的周期，且 \(s\) 循环右移 \(2k\) 位后得到的字符串与 \(s\) 相等。因此 \(s\) 的最小周期是 \(n\) 的约数。设 \(s\) 的最小周期长度为 \(t\)，\(t \mid n\)。 显然，如果 \(s\) 循环右移 \(k\) 位仍是一个回文串，那么 \(t \mid 2k\)。有 \(t\) 种不同的与 \(s\) 循环同构的串。若 \(t\) 为偶数，那么 \(s\) 循环右移 \(\frac t 2\) 位或循环右移 \(0\) 位是回文串。否则只有循环右移 \(0\) 位是回文串。 为了计算与某个回文串循环同构的字符串数，考虑枚举回文串并计算与这个回文串同构的字符串有多少种，这样最小周期是偶数的回文串的循环同构串会被算恰好两次，其他回文串的循环同构串只会被算一次。特判最小周期为偶数的情况即可。 然而不可能枚举所有的回文串。考虑把最小周期相同的回文串放在一起枚举。设字符集大小为 \(K\)，最小周期为 \(i\) 的约数的回文串有 \(K^{\lceil \frac i 2 \rceil}\) 个。莫比乌斯反演一下即可。 然而 \(n\) 非常的大，没有办法直接反演出一个数组。 把答案写出来化简： \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] 枚举 \(d\)。 \(d\) 为偶数时，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)。 \(d\) 为奇数时，若 \(n\) 为奇数，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)，否则 \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)。 \(Pollard-Rho\) 分解素因数后简单统计一下答案即可。 代码]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] 镜中的昆虫]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[提交至 [Ynoi2016]镜中的昆虫。 记录每个点 \(i\) 前面第一个与他同色的位置 \(pre_i\)。询问区间颜色数变成询问区间内有多少个 \(pre_i &lt;l\)，这是一个二维偏序问题。注意到修改 \(pre\) 数组次数均摊 \(\mathcal O (n)\)，用 \(set\) 维护每一段，cdq分治或者树套树做一下二维偏序即可。 这题有一点卡常..cdq分治写归并速度会快很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123;4int l, r, c;4seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123;4int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123;4if (x.x != y.x) return x.x &lt; y.x;4return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //离散化int pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123;4return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123;4for (int i = x; i &lt;= n; i += lowbit(i)) &#123;44sum[i] += v;4&#125;&#125;int ask(int x) &#123;4int ret = 0;4for (int i = x; i; i -= lowbit(i)) &#123;44ret += sum[i];4&#125;4return ret;&#125;int getval(int a) &#123;4if (val.count(a)) return val[a];4else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123;4s.insert(seg(l, r, v));4bc[v].insert(l);4ec[v].insert(r);&#125;void removeseg(iter sg) &#123;4bc[sg-&gt;c].erase(sg-&gt;l);4ec[sg-&gt;c].erase(sg-&gt;r);4s.erase(sg);&#125;void split(int p) &#123; //split p p+14if (!p) return;4iter i = s.lower_bound(seg(0, p));4int l = i-&gt;l, r = i-&gt;r;4int r1 = p-1, l2 = p+1;4int v = i-&gt;c;4removeseg(i);4if (l &lt;= r1) addseg(l, r1, v);4addseg(p, p, v);4if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123;4//OPT4if (v != p-1) st.insert(p);4if (on) &#123;44++ so;44op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0;4&#125;4pre[p] = v;4++ so;4op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123;4set&lt;int&gt;::iterator t = ec[v].lower_bound(p);4if (t == ec[v].begin()) return 0;4else return (*(--t));&#125;int findnxt(int p, int v) &#123;4set&lt;int&gt;::iterator t = bc[v].upper_bound(p);4if (t == bc[v].end()) return -1;4else return (*t);&#125;int getcol(int p) &#123;4iter t = s.lower_bound(seg(0, p));4return t-&gt;c;&#125;void solve(int l, int r) &#123;4if (l == r) return;4int m = (l + r) &gt;&gt; 1;4solve(l, m);4solve(m+1, r);4int p1 = l, p2 = m+1, p = l;4while (p1 &lt;= m || p2 &lt;= r) &#123;44if (p1 &gt; m) ta[p++] = op[p2++];44else if (p2 &gt; r) ta[p++] = op[p1++];44else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++];44else ta[p++] = op[p2++];4&#125;4for (int i = l; i &lt;= r; i++) op[i] = ta[i];4for (int i = l; i &lt;= r; i++) &#123;44if (op[i].ty == 0) &#123;444if (op[i].pos &lt;= m) &#123;4444add(op[i].y+1, op[i].v);444&#125;44&#125; else &#123;444if (op[i].pos &gt; m) &#123;4444ans[op[i].id] += op[i].v*ask(op[i].y+1);444&#125;44&#125;4&#125;4for (int i = l; i &lt;= r; i++) &#123;44if (op[i].ty == 0) &#123;444if (op[i].pos &lt;= m) &#123;4444add(op[i].y+1, - op[i].v);444&#125;44&#125;4&#125;&#125;int main() &#123;4scanf("%d%d", &amp;n, &amp;m);4for (int i = 1; i &lt;= n; i++) &#123;44scanf("%d", &amp;a[i]);44a[i] = getval(a[i]);44addseg(i, i, a[i]);44modifypre(i, _pos[a[i]], 0);44_pos[a[i]] = i;4&#125;4for (int i = 1; i &lt;= m; i++) &#123;44int o, l, r, x;44scanf("%d%d%d", &amp;o, &amp;l, &amp;r);44if (o == 1) &#123;444scanf("%d", &amp;x);444x = getval(x);444split(l-1); split(r);444modifypre(l, findpre(l, x));444iter it = s.lower_bound(seg(0, l));444while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123;4444int nxt = findnxt(it-&gt;r, it-&gt;c);4444iter tmp = it;4444int c = it-&gt;c;4444++ it;4444removeseg(tmp);4444if (nxt != -1) &#123;44444if (c == x) modifypre(nxt, r);44444else modifypre(nxt, findpre(nxt, c));4444&#125;444&#125;444addseg(l, r, x);444//对 l+1-r 的pre更新444set&lt;int&gt;::iterator t = st.lower_bound(l+1);444while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123;4444modifypre(*t, (*t)-1);4444set&lt;int&gt;::iterator tmp = t;4444++ t;4444st.erase(tmp);444&#125;444int nxt = findnxt(r, x);444if (nxt != -1) modifypre(nxt, r);44&#125; else &#123;444isq[i] = 1;444++ so;444op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i;444++ so;444op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i;44&#125;4&#125;4for (int i = 1; i &lt;= so; i++) op[i].pos = i;4solve(1, so);4for (int i = 1; i &lt;= m; i++) &#123;44if (isq[i]) &#123;444printf("%d\n", ans[i]);44&#125;4&#125;4return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[虽然前面还有很多坑没补完...但是我发现自己代码能力问题比较严重。所以来做做ynoi。 坑先放在这...清醒的时候慢慢填。 [YNOI2016] 镜中的昆虫]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[提交至 【模板】快速沃尔什变换。 先咕着。。。万一遇上现推吧。]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 扩展中国剩余定理]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】扩展中国剩余定理。 这题目有问题吧....模数可以爆 long long 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123;4if (!y) return x;4return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123;4ll t = y, ret = 0;4for (int i = 0; i &lt; 63; i++) &#123;44if (x &amp; (1ll&lt;&lt;i))444ret = (ret + t) % mod;44t = t*2%mod;4&#125;4return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;4if (!b) &#123;44x = 1; y = 0;44return;4&#125;4exgcd(b, a%b, y, x);4y -= (a/b)*x;&#125;int main() &#123;4scanf("%d", &amp;n);4a1 = 1; b1 = 0;4for (int i = 1; i &lt;= n; i++) &#123;44ll a2, b2;44scanf("%lld%lld", &amp;a2, &amp;b2);44ll na = a1/gcd(a1,a2)*a2;44ll x, y;44exgcd(a1, -a2, x, y);44ll k = (b2-b1)/gcd(a1,-a2);44int t = 1;44if (k &lt; 0) &#123;444k = -k; 444t = -t;44&#125;44if (x &lt; 0) &#123;444x = -x;444t = -t;44&#125;44ll k1 = t*mul(k, x, na);44k1 %= na;44if (k1 &lt; 0) k1 += na;44b1 = (mul(k1%na, a1, na)+b1)%na;44a1 = na;4&#125;4printf("%lld\n", b1);4return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 后缀自动机]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[提交至 【模板】后缀自动机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123;4int np = ++tot; len[np] = l; val[np] = 1;4while (!tr[last][c]) &#123;44tr[last][c] = np;44last = par[last];4&#125;4if (!last) par[np] = 1;4else &#123;44int q = tr[last][c];44if (len[q] == len[last] + 1) &#123;444par[np] = q;44&#125; else &#123;444int nq = ++tot;444len[nq] = len[last] + 1;444par[nq] = par[q];444memcpy(tr[nq], tr[q], sizeof(tr[nq]));444par[q] = par[np] = nq;444while (tr[last][c] == q) &#123;4444tr[last][c] = nq;4444last = par[last];444&#125;44&#125;4&#125;4last = np;&#125;void dfs(int u) &#123;4sum[u] = val[u];4for (int i = 0; i &lt; tree[u].size(); i++) &#123;44int v = tree[u][i];44dfs(v);44sum[u] += sum[v];4&#125;&#125;int main() &#123;4scanf("%s", s+1);4n = int(strlen(s+1));4last = ++tot;4for (int i = 1; i &lt;= n; i++) &#123;44addchar(s[i]-'a', i);4&#125;4for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i);4dfs(1);4for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]);4printf("%lld\n", ans); 4return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Splay(维护序列)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[提交至 [NOI2005]维护数列。 常数非常非常大.....先当板子背了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123;4sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1;4sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x];4msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]]));4lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]);4rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]);4mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123;4int ret = Q.front(); Q.pop();4rev[ret] = 0;4tag[ret] = has_tag[ret] = 0;4fa[ret] = 0;4ch[ret][0] = ch[ret][1] = 0;4sz[ret] = 1;4sum[ret] = val[ret] = v;4mx[ret] = v;4if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v;4else lsum[ret] = rsum[ret] = msum[ret] = 0;4return ret;&#125;void Rev(int x) &#123;4swap(ch[x][0], ch[x][1]);4rev[x] ^= 1;4swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123;4tag[x] = v; has_tag[x] = 1;4sum[x] = sz[x]*v;4val[x] = v;4mx[x] = v;4if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v;4else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123;4if (rev[x]) &#123;44if (ch[x][0]) Rev(ch[x][0]);44if (ch[x][1]) Rev(ch[x][1]);44rev[x] = 0;4&#125;4if (has_tag[x]) &#123;44if (ch[x][0]) modify(ch[x][0], tag[x]);44if (ch[x][1]) modify(ch[x][1], tag[x]);44has_tag[x] = 0;4&#125;&#125;void delNode(int x) &#123;4Q.push(x);&#125;int getson(int x) &#123;4return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123;4if (!fa[x]) return;4int f = fa[x], ff = fa[fa[x]], s = getson(x);4if (ff) ch[ff][getson(f)] = x;4fa[x] = ff;4ch[f][s] = ch[x][s^1];4fa[ch[x][s^1]] = f;4ch[x][s^1] = f;4fa[f] = x;4pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123;4if (fa[x]) PushDown(fa[x]);4pushDown(x);&#125;void splay(int x) &#123;4PushDown(x);4for (int f; fa[x]; rotate(x)) &#123;44if (fa[f=fa[x]]) &#123;444rotate((getson(f) == getson(x)) ? f : x);44&#125;4&#125;4rt = x;&#125;int getRank(int x) &#123;4splay(x);4return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123;4pushDown(x);4if (k &lt;= sz[ch[x][0]]) &#123;44return kth(ch[x][0], k);4&#125; else if (k == sz[ch[x][0]] + 1) &#123;44splay(x);44return x;4&#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123;4if (!k) &#123;44r1 = 0;44r2 = r;44return;4&#125;4if (k == sz[r]) &#123;44r1 = r;44r2 = 0;44return;4&#125;4int x = kth(r, k);4int rs = ch[x][1];4fa[rs] = ch[x][1] = 0;4pushUp(x);4r1 = x; r2 = rs;&#125;int maxNode(int x) &#123;4while (ch[x][1]) &#123;44pushDown(x);44x = ch[x][1];4&#125;4splay(x);4return x;&#125;int merge(int x, int y) &#123;4if (!x || !y) return x+y;4splay(x);4int mx = maxNode(x);4ch[mx][1] = y; fa[y] = mx;4pushUp(mx);4return mx;&#125;void del(int r) &#123;4if (ch[r][0]) del(ch[r][0]);4delNode(r);4if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123;4pushDown(r);4if (ch[r][0]) print(ch[r][0]);4printf("%d ", val[r]);4if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123;4mx[0] = -0x3f3f3f3f;4scanf("%d%d", &amp;n, &amp;m);4for (int i = 1; i &lt;= 500000; i++) Q.push(i);4for (int i = 1; i &lt;= n; i++) &#123;44scanf("%d", &amp;a[i]);44newNode(a[i]);4&#125;4for (int i = n; i &gt; 1; i--) &#123;44fa[i] = i-1;44ch[i-1][1] = i;44pushUp(i-1);4&#125;4rt = 1;4for (int i = 1; i &lt;= m; i++) &#123;44scanf("%s", buf);44if (buf[0] == 'I') &#123;444int p, cnt;444scanf("%d%d", &amp;p, &amp;cnt);444int t_rt = 0;444while (cnt --) &#123;4444int c; scanf("%d", &amp;c);4444int t = newNode(c);4444ch[t][0] = t_rt;4444if (t_rt) fa[t_rt] = t;4444t_rt = t;4444pushUp(t);444&#125;444int r1, r2;444split(p, rt, r1, r2);444rt = merge(merge(r1, t_rt), r2);44&#125; else if (buf[0] == 'D') &#123;444int p, cnt;444scanf("%d%d", &amp;p, &amp;cnt);444int r1, r2, r3;444split(p-1, rt, r1, r2);444split(cnt, r2, r2, r3);444rt = merge(r1, r3);444del(r2);44&#125; else if (buf[0] == 'M') &#123;444if (buf[2] == 'K') &#123;4444int p, cnt, v;4444scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v);4444int r1, r2, r3;4444split(p-1, rt, r1, r2);4444split(cnt, r2, r2, r3);4444if (r2) modify(r2, v);4444rt = merge(merge(r1, r2), r3);444&#125; else &#123;4444if (mx[rt] &lt; 0) printf("%d\n", mx[rt]);4444else printf("%d\n", msum[rt]);444&#125;44&#125; else if (buf[0] == 'R') &#123;444int p, cnt;444scanf("%d%d", &amp;p, &amp;cnt);444int r1, r2, r3;444split(p-1, rt, r1, r2);444split(cnt, r2, r2, r3);444Rev(r2);444rt = merge(merge(r1, r2), r3);44&#125; else &#123;444int p, cnt;444scanf("%d%d", &amp;p, &amp;cnt);444if (!cnt) &#123;4444puts("0");444&#125; else &#123;4444int r1, r2, r3;4444split(p-1, rt, r1, r2);4444split(cnt, r2, r2, r3);4444printf("%d\n", sum[r2]);4444rt = merge(merge(r1, r2), r3);444&#125;44&#125;4&#125;4return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式exp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式ln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式对数函数。 代码特别丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) ret = 1LL*ret*x%mod;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;int n = 0;struct poly &#123;4int *a, len;4poly(int l) &#123;44len = l;44a = new int[l];44for (int i = 0; i &lt; l; i++)444a[i] = 0;4&#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123;4int len = (1 &lt;&lt; t);4for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1));4for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]);4for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123;44int wn = qpow(g, (mod-1)/l);44for (int s = 0; s &lt; len; s += l) &#123;444int w = 1;444for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123;4444int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod;4444a[i] = (v1+v2) % mod;4444a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod;4444w = 1LL*w*wn%mod;444&#125;44&#125;4&#125;4if (ty == -1) &#123;44for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]);44int r = qpow(len, mod-2);44for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod;4&#125;&#125;poly operator*(poly a, poly b) &#123;4poly ret(a.len + b.len - 1);4int t = 0;4while ((1&lt;&lt;t) &lt; ret.len) ++ t;4for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0;4for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i];4for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i];4ntt(w_a, t, 1);4ntt(w_b, t, 1);4for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod;4ntt(w_c, t, -1);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i];4return ret;&#125;poly poly_inverse(poly a) &#123;4if (a.len == 1) &#123;44poly ret(1);44ret.a[0] = qpow(a.a[0], mod-2);44return ret;4&#125;4int nl = (a.len+1)/2;4poly na(nl);4for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i];4poly r = poly_inverse(na);4poly t = r*a;4t.len = a.len;4for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod;4t.a[0] = (t.a[0] + 2) % mod;4poly ret = t*r;4ret.len = a.len;4return ret;&#125;poly poly_ln(poly a) &#123;4poly t(a.len-1);4for (int i = 1; i &lt; a.len; i++) &#123;44t.a[i-1] = 1LL * a.a[i] * i % mod;4&#125;4poly x = poly_inverse(a);4poly s = x*t;4s.len = a.len;4poly ret(a.len);4for (int i = 1; i &lt; a.len; i++) &#123;44ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod;4&#125;4return ret;&#125;int main() &#123;4scanf("%d", &amp;n);4poly A(n);4for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]);4poly P = poly_ln(A);4for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]);4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式求逆]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式求逆。 \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) 代码丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) &#123;444ret = 1LL*ret*x%mod;44&#125;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123;4int *a, len;4poly (int l = 0) &#123;44a = new int[l];44len = l;44for (int i = 0; i &lt; l; i++) &#123;444a[i] = 0;44&#125;4&#125;&#125;;void ntt(int *a, int t, int ty) &#123;4int len = (1 &lt;&lt; t);4for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1));4for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]);4for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123;44int wn = qpow(g, (mod-1)/l);44for (int s = 0; s &lt; len; s += l) &#123;444int w = 1;444for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123;4444int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod;4444a[i] = (v1+v2) % mod;4444a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod;4444w = 1LL*w*wn%mod;444&#125;44&#125;4&#125; 4if (ty == -1) &#123;44for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]);44int r = qpow(len, mod-2);44for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod;4&#125;&#125;poly operator*(poly A, poly B) &#123;4poly ret(A.len + B.len - 1);4int t = 0;4while ((1&lt;&lt;t) &lt; ret.len) t ++;4for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0;4for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i];4for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i];4ntt(w_a, t, 1); ntt(w_b, t, 1);4for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod;4ntt(w_c, t, -1);4for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i];4return ret;&#125;poly inverse(poly A) &#123;4if (A.len == 1) &#123;44poly ret(1);44ret.a[0] = qpow(A.a[0], mod-2);44return ret;4&#125;4int nlen = (A.len+1)/2;4poly nA(nlen);4for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i];4poly r = inverse(nA);4poly tmp = A*r;4tmp.len = A.len;4for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod;4tmp.a[0] = (tmp.a[0]+2) % mod;4poly ret = r*tmp;4ret.len = A.len;4return ret;&#125;int main() &#123;4scanf("%d", &amp;n);4poly F(n);4for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]);4poly G = inverse(F);4for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]);4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 任意长度DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm 求 \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) 设 \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)。 则 \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)。 \(i-k\) 可能会出现负数。平移下做个卷积即可。 懒得写QAQ。（好像也没啥好写的）]]></content>
  </entry>
  <entry>
    <title><![CDATA[[模板] NTT模板]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一个普通的 NTT 模板。代码非常丑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123;4int ret = 1;4while (y) &#123;44if (y &amp; 1) &#123;444ret = 1LL*ret*x%mod;44&#125;44x = 1LL*x*x%mod;44y &gt;&gt;= 1;4&#125;4return ret;&#125;void calrev(int l) &#123;4rev[0] = 0;4for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123;44rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1);44if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1));4&#125;&#125;void ntt(int *a, int t, int ty) &#123;4int len = 1&lt;&lt;t;4for (int i = 0; i &lt; len; i++) &#123;44if (rev[i] &gt; i)444swap(a[i], a[rev[i]]);4&#125;4for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123;44int wn = qpow(g, (mod-1)/l);44for (int s = 0; s &lt; len; s += l) &#123;444int w = 1;444for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123;4444int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod;4444a[i] = (v1+v2) % mod;4444a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod;4444w = 1LL*w*wn%mod;444&#125;44&#125;4&#125;4if (ty == -1) &#123;44for (int i = 1; i &lt; len/2; i++) &#123;444swap(a[i], a[len-i]);44&#125;44int r = qpow(len, mod-2);44for (int i = 0; i &lt; len; i++) &#123;444a[i] = 1LL*a[i]*r%mod;44&#125;4&#125;&#125;int main() &#123;4scanf("%d%d", &amp;n, &amp;m);4for (int i = 0; i &lt;= n; i++)44scanf("%d", &amp;w_a[i]);4for (int i = 0; i &lt;= m; i++) 44scanf("%d", &amp;w_b[i]);4int l = 0;4while ((1&lt;&lt;l) &lt; n+m+1) l ++;4calrev(l);4ntt(w_a, l, 1); ntt(w_b, l, 1);4for (int i = 0; i &lt; (1&lt;&lt;l); i++)44w_c[i] = 1LL*w_a[i]*w_b[i]%mod;4ntt(w_c, l, -1);4for (int i = 0; i &lt;= n+m; i++) &#123;44printf("%d ", w_c[i]);4&#125; 4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FFT模板]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[省选前复习。这是一个普通的 fft 模板。 （发现自己差点fft模板不会打了） 因为没有预处理&amp;&amp;用了complex类可能常数比较大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123;4rev[0] = 0;4int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x;4for (int i = 1; i &lt; len; i++) &#123;44rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1);44if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1));4&#125;4for (int i = 0; i &lt; len; i++) 44if (rev[i] &gt; i)444swap(a[rev[i]], a[i]);4for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123;44C wn(cos(2*M_PI/l), t*sin(2*M_PI/l));44for (int s = 0; s &lt; len; s += l) &#123;444C w(1, 0);444for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123;4444C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w;4444a[i] = v1+v2;4444a[i+(l&gt;&gt;1)] = v1-v2;4444w = w * wn;444&#125;44&#125;4&#125;4if (t == -1) &#123;44for (int i = 0; i &lt; len; i++) &#123;444a[i] /= len;44&#125;4&#125;&#125;int main() &#123;4scanf("%d%d", &amp;n, &amp;m); 4for (int i = 0; i &lt;= n; i++)44scanf("%d", &amp;a[i]);4for (int i = 0; i &lt;= m; i++)44scanf("%d", &amp;b[i]);4int l = 1;4while (l &lt; n+m+1) l &lt;&lt;= 1;4for (int i = 0; i &lt;= n; i++) c_a[i] = a[i];4for (int i = 0; i &lt;= m; i++) c_b[i] = b[i];4fft(c_a, l, 1); fft(c_b, l, 1);4for (int i = 0; i &lt; l; i++)44c_c[i] = c_a[i]*c_b[i];4fft(c_c, l, -1);4for (int i = 0; i &lt;= n+m; i++) &#123;44printf("%d ", int(c_c[i].real()+0.5));4&#125;4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[我发现自己的代码能力太弱了...... 有些模板需要平时写一下，不能现场写，否则不一定调的出来。这里列出一些常用模板。（优化常数&amp;&amp;优化代码复杂度&amp;&amp;背下来）。 多项式： FFT NTT 多项式求逆 多项式ln 多项式exp 多项式取模 多项式多点求值 多项式快速插值 多项式复合逆 常系数齐次线性递推 数论： Lucas定理 exCRT 杜教筛 Pollard-Rho Miller-Rabin min_25筛 类欧几里得 二次剩余 貌似是洲阁筛的筛法 高级数据结构： 线段树合并 树状数组 Splay LCT ETT 点分树 树链剖分 动态dp 字符串： 后缀自动机 建后缀树 后缀数组 trie树SAM AC自动机 回文树 其他： FWT 半平面交 矩阵-树定理]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[口胡的题目]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[我的这么菜了还口胡题目...大概会越来越菜吧.. 2019.3.29 CF 1097G \(k\) 次方看作是选 \(k\) 条边。考虑所有 \(k\) 条边的有序对，计算包含它们的集合数。背包 \(dp\) 一下就好了。根据某考过很多次的复杂度分析，时间复杂度是 \(\mathcal O (nk)\)。]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[题面： https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf 题目大意 输入一个长度为 \(n\) 的字符串 \(s\)。你有一个空串 \(t\)，你要把它变成输入的字符串。可以进行以下几种操作： 在 \(t\) 的开头或者末尾添加一个字符。 把 \(t\) 翻转过来，然后接在原来的 \(t\) 的开头或末尾。 求最少操作次数。 \(n \le 10^5\) 解法 在最后连续的若干次加字符操作之前，\(t\) 一定是回文串。倒过来考虑，用最少操作次数把 \(s\) 变成空串。只需要分别考虑每个回文串的最少操作次数。 建立回文树。只需要考虑三种转移： 一个长度为偶数的回文串变为他的一半。 一个回文串，去掉他两端的字符。 一个回文串，转移到他的最长回文前缀。 按长度从小到大顺序 \(dp\)。后两种转移可以直接计算。对第一种转移，倍增一下判断 \(fail\) 树上有没有长度恰好为一半的祖先即可。 代码 下面的代码是假的。要省选了..先补点别的再来打这题QAQ。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串技巧、思想、知识点整理]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX18uXWInXEVZguRGWW0PMPLyoxUg7D7e9WaZjt8H08ckvc4aCojaMBXk7kVAqzQpw3/Ydx7SHT21YuQhGPJgoH9Kr36EYx6MwtmtkswbuZWydLMd7Pa+u8l0f8knBohP4LlNhIc7Cg4YifAsX9G9JUYnSEK1naNb+54VJMGxPHHhSSSmggASzF5E8INVimoEc1IZC0JtIHwE1qm9M0mKP5oZ6A8EhOoY0iq5oL8ic8lBHBziwe/KMKQLUgWDhIaAlh4iRZ5VRC/GmF+33AvtNN7Bzt8L4YFtM4HwU9verv+niv6nE539DwNP5PTrcxZzv+qJe6GW0ZKX1IcOBDpiFs21jbVAbNpdo5y57e4zo0m4ZA9KGAnO48W1BWX2CLWJe3L9CLRkhgIUTbpRWCQHsqPf93xz4J3Kbh09ZSpnVbw341EObadnoquU37PVbk8eHu2lElvinT5AcAWbk9IMFDQhj4QbUzz8M30VEyopXKCwA2p4XiKW0rP2vyS38UOcbExuGabMHm/ZCmTygMX7K45I8gO6egqrnjiNolXtKN6jSe2kJHaWKdfFhiO69FLfmDB+ndRTpyh2fsq+lJmv1szIJjZ1d0lhHthqznt3q+CUlRnWpwLzRwg6O7DsLQDEhNHSKC8Mp1EVqYZBQW7+DW+2BKuFSHdireKuQMg4tIm1WWJ5LBVkXzKAD9lvcWu+5AD9mczn6bEUXFLhrlhpZY0+bKDP7sIGHXde3TBtyzazi9x1adSTk954cQ4qElo5oNwavhxoaKfwAoUyob+QABmfKHDJbs+P66nXDX2k9XFRCgocnHblHJZkpirNH3X0LaBxdWtlYAYeS3vmruHokemTBetT5iTW5MwZ4lRreHhGIC5B9EOq7joJnRJTqD1nOPBVE49hv+5JurD8Rc4zkcE7fmTK/8UNUQko7Z3gK8Qk4ACxEfmXD9vKfINPUit0FQtjvnM6k0mKxGxPnmH1wXB6huL61DnCaqaPWFwyyf3ltO6nWMT52OTWwEHYB30VQgGXNOu+/uUfKzO2OrUIbrjm29xb6h1e+NeSqJchWrAGbkwN0fBUsaYoN2Ask0YQJv5SdEKE16DwGOu5syx7G2YS77p7kEUE5ohCta1jdq3HaSJI2lXvvDT+B/r6+aVSj78iupBZrgjq/o3JgOoN3J0g6IOeOZ05oKei4vnT1c0U5vEoCgoubx/9YuPDnPHOjXGnAVZYudoNCGf9J9AuhqK25ngzopmB1xSwFMy+uGIzaS/auRBShi8AqoGFXo7l+ffwNwyrk+kBG1gDCbHA5u4RuR6F4KNOlayKW4SID+foxUYIA9McDTcwk1zKmZ5Zmsx34E0Ce0S6WWfqQT7xGdExgenN0u13FPYzP07cj43B28AGbMiaHUN8M8Mi0kdOvJUs8ILu9jNp0lpFHLRzZF0UFT5nCVuGPTg2/eS7T9yhOKI8Rd8WyxfpFwTTz7AAMpbnYhkx4hJHJAiQ0v0TkZ1LkvcNpOS073jLNbYSO+4nYMY6RxhEJtlgs2AdjRkwV94m2GSIN/9AvR4vVVdHWWi934XVigJzlyi370/QDKabhASO/Hy6JMaydLpaLs8mrBxsGA5i+Png+l3jSVk2BR1lRuEzQYspDMmWC/1J9PuAD8im3fYV4CxWjQKiFORGDCC+is8oJSizBLLPC4gWDqTsIGbgq3K/HBXmJZBka67t6w7yuG2bd3zJz4GwZCVWIPTt3J+anx0iTuSYleluGeda8Yp6WJnXGfoEODbro+6zjxSkjqP26BW+mv7BNb39yeayMLwsclyNFEeYcQf/x6ZWycyWkvNpsj3o3tCsc7MVHKYONdTzKq49j9NkUYKeIo1MuI7kqeEL94F8vgiAJ1NYLJq15yn31hkmJspBwzQqZCbyT1MgyeznMHKILi9LtWjAXhxREz8iFpKM2oZRRR8B0Q7LMAULAW5yFSISrHpW0zSRVUlU2cKyWo9wbjpEsEvMoNzUF4TNMjJAFTYHcOQBMY4BB4yhj9DuuN+NVbUmtIkiGVEzqLttakPBUtcsi4tZdQqDYlHeij6He7Bg1Zii4FtCzp7xeqMSgy3yfvcJq4/YZCisFxxN74hsa/KZpBBTX/byvV/kzRsySiH+N/Xe7GQZryxGEg/FcsXyl+XrHU7gKBDKP5EZugULygDlCtGJigiG8UtAmsCygDvSdVAhvx3vO/Lv1eJLawegFQA49w+tBGURtNClRJCGNrCQQ10EKqRUeVM71XaXLScEyb4GjHuYrJwMnW/CZHI8zvq2ubOnMBjfJ9z62lE4uRITikDpydqErnPZ1zZjCw63WamK22jjBUGK453/U83vAVlMub1ILRLKaCwCrxG10kigFETBAis01eOt9f8y+DeG9C+xQA7n8RQj9lkOsdx6vqQ2B96qMar8l1nyI35zdjlc0Va+/BVoFoJ6PqWhS5Bi8dJvmy4SODbrCQXEEAXCH7ZHhdpt+zYkz+JeQkjEt/8vPIFqzsiNtOQPBA==]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>知识点</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon word的一些性质]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipedia链接：https://en.wikipedia.org/wiki/Lyndon_word 定义 如果一个串最小后缀是它本身，那么称他为 Lyndon word。（与严格最小循环移位的定义是等价的） 相关性质和算法 性质1 如果 \(s\) 是 Lyndon word，那么 \(s\) 不存在 border。 性质2 如果 \(s\) 是 Lyndon word，\(s=uv\) 且 \(u\) 和 \(v\) 非空，那么 \(u&lt;v\)。 性质3 如果 \(s,t\) 是 Lyndon word 且 \(s &lt; t\)，那么 \(st\) 也是 Lyndon word。 性质4 一个长度大于等于 \(2\) 字符串的 \(s\) 是 Lyndon word 的充要条件是，\(s\) 可以拆成两个非空串 \(u,v\)，满足 \(u &lt; v\) 且 \(u\) 和 \(v\) 都是 Lyndon word。 证明 充分性即上一条性质，只证必要性。 设 \(s\) 的长度为 \(n\)，后缀 \(s[i..n]\) 是 \(s\) 的次小后缀。 假设 \(s[1..i-1]\) 有长度为 \(k\) 的 border，即 \(s[1..k]=s[i-k..i-1]\)。 因为 \(k &lt; i-1\)，所以 \(k+1 \neq i\)。 因为 \(s\) 是 Lyndon word，\(s[i..n]\) 是 \(s\) 的次小后缀，所以 \(s[i..n]&lt;s[k+1..n]\)。又因为 \(s[i-k..i-1]=s[1..k]\)，所以 \(s[i-k..n]&lt;s[1..n]\)，这与 \(s\) 是 Lyndon word 矛盾。所以 \(s[1..i-1]\) 没有 border。 根据 Lyndon word 的定义及 \(s[1..i-1]\) 没有 border，有 \(\forall 1 &lt; j \le i-1\)，\(\exists j \le k \le i-1\)，满足 \(s[k] &gt; s[k-j+1]\)，即 \(s[j..i-1] &gt; s[1..i-1]\)。所以 \(s[1..i-1]\) 是 Lyndon word。 因为 \(s[i..n]\) 是 \(s\) 的次小后缀，显然不存在 \(j&gt;i\) 满足 \(s[j..n]&lt;s[i..n]\)，所以 \(s[i..n]\) 是 Lyndon word。 所以 \(u=s[1..i-1],v=s[i..n]\) 是一组合法的拆分，必要性得证。 性质5 任意一个字符串 \(s\) 都可以唯一地拆成若干个字典序不增的 Lyndon Word。 我抽代太菜了...其他的性质以后再补吧。]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon 分解]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[解法 关于 Lyndon word 的一些结论可以看这个。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123;4scanf("%s", str+1);4n = int(strlen(str+1));4int s = 1, l = 0, p = 0;4while (s &lt; n) &#123;44l = 1; p = s+1;44for (p = s+1; ; ++p) &#123;444if (str[p] &lt; str[p-l]) &#123;4444while (s+l-1 &lt; p) &#123;44444printf("%d ", s+l-1);44444s += l;4444&#125;4444break;444&#125; else if (str[p] &gt; str[p-l]) &#123;4444l = p-s+1;444&#125;44&#125; &#125;4if (s &lt;= n) printf("%d ", n);4printf("\n");4return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/D 题目大意 给定一棵 \(n\) 个点，以 \(1\) 为根的树，第 \(i\) 个点有一个价格 \(c_i\)。 你要选一些点，然后另一个人会给每个叶节点设置一个数字。你只能对已经选择的点做子树加任意数字的操作。 你要通过若干次操作把所有叶子节点上的数变为 \(0\)。 问：要确保另一个人无论怎么操作你都能把叶子上的数变成 \(0\)，你选择的点价格总和最小是什么？有哪些点被至少一种最小价格的方案包含？ \(n \le 200000\)，\(0\le c_i \le 10^9\)。 解法 这个问题可以看成，你要选一些点作为未知数，每个叶子的限制构成了一个方程，你要让这个线性方程组满足，无论常数项取值是什么，这个线性方程组都有解。 因为价格是非负整数，如果系数矩阵的列向量组线性相关，必可以删除某一列，即可以少选一个点，这样一定不会变的更差，所以系数矩阵的列向量组线性无关。因为无论常数项的取值是什么，方程组都要有解，所以行数等于列数。 结论 设叶节点个数为 \(x\)，一个包含恰好 \(x\) 个点的选取方案能保证可以将所有叶子上的数字变成 \(0\) 的充要条件是，任意两个叶子到根的路径上，存在被选取的点，且深度最大的被选取点不同。 证明 必要性显然。 充分性：把方程组的未知数按任意一种 \(dfs\) 序排列，系数矩阵中，每一行的第一个非 \(0\) 元素所在的列都不同，所以系数矩阵的列向量组线性无关，又因为行数等于列数，所以无论常数项取值是什么，方程组都有解。 状态 \(dp[i][j][k]\) ： \(i\) 表示只考虑以 \(i\) 为根的子树。 \(j\) 表示 \(i\) 是否被选择。 \(k\) 表示是否存在一个叶子，他到 \(i\) 的路径中没有点被选择。 \(dp\) 数组中存的是，满足任意两个叶子到 \(i\) 的路径上深度最大的祖先不同（如果不存在则看作 \(0\)）的最小价格和。 \(dp\) 一下，然后记录哪些转移可以取到最优值，最后从根开始 \(dfs\) 一遍求方案即可。 代码 （巨丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/C 题目大意 你有一个长度为 \(n\) 个字符串 \(s\)。 请你把 \(s\) 拆成若干个字符串 \(s=t_1t_2\cdots t_k\)。 对于第 \(i\) 个串，若 \(t_i\) 是 \(t_1t_2\cdots t_{i-1}\) 的字符串，你需要付出 \(b\) 的代价，否则 \(t_i\) 长度必须为 \(1\)，你需要付出 \(a\) 的代价。求最小代价。 \(n \le 5000\)，字符集大小 \(26\)。 解法 设 \(dp_i\) 表示前 \(i\) 个字符的最小划分，在求出 \(dp_i\) 后用 \(kmp\) 找最长在前面出现过的从 \(i+1\) 开始的串，更新所有 \(dp_j\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈整理（一）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipedia链接：https://en.wikipedia.org/wiki/Impartial_game impartial game 是指满足如下条件的游戏： - 两个玩家轮流操作，直到达到不能操作的状态（terminal position）。 - 当一个玩家不能操作时，winner 就被确定了。 - 每个状态的操作数和状态总数是有限的。 - 所有的操作必须同时能被两个玩家进行。 - 所有操作的结果都是确定性的。 Normal play convention wikipedia链接：https://en.wikipedia.org/wiki/Normal_play_convention Impartial game 的 Normal play convention ：最后一个可以操作的玩家获胜。 Nim游戏 wikipedia链接：https://en.wikipedia.org/wiki/Nim 有若干堆石子，两个人轮流取石子。每次轮到的人可以选择从某一堆中拿走若干颗石子（不能不拿），不能按规则操作的人输。 Nim 游戏属于 Impartial game。 Nim游戏的胜利条件 定理：当且仅当每堆石子的个数异或和不为 \(0\) 时，先手必胜。 证明： 对于 terminal position，即没有石的情况，异或和为 \(0\)，轮到这个状态的人输。定理对 terminal position 成立。 引理1 若一个状态，每堆石子个数异或和不为 \(0\)，则它必定可以转移到一个石子个数为 \(0\) 的状态。 证明： 设每堆石子个数的异或和为 \(s\)。 设 \(s\) 最高的二进制位是第 \(k\) 位（从低到高，最低位为第 \(0\) 位）。 一定存在一堆石子个数为 \(x\)，二进制下 \(x\) 的第 \(k\) 位为 \(1\)。 除了这堆石子外，其他堆石子个数的异或和为 \(s\oplus x\)。 \(s\oplus x\) 和 \(x\) 在所有比第 \(k\) 位高的二进制位上相等，\(s\oplus x\) 的第 \(k\) 位为 \(0\)，\(x\) 的第 \(k\) 位为 \(1\)，所以 \(s \oplus x &lt; x\)。 可以从这堆石子中取走 \(x-s\oplus x\) 个石子，使异或和变为 \(0\)。 引理2 若一个状态，每堆石子个数异或和为 \(0\)，无论怎么操作都会转移到一个每堆石子个数异或和不为 \(0\) 的状态。 证明： 设操作的堆在操作前有 \(x\) 颗石子。 那么除了这堆以外的其他堆石子数异或和也为 \(x\)。 在取石子后，这堆石子的个数一定不为 \(x\)。 只有这堆石子的个数为 \(x\) 时，与其他堆石子个数的异或和才会为 \(0\)。 所以操作后，每堆石子个数的异或和一定非 \(0\)。 根据结构归纳法可知定理成立。 Sprague–Grundy 定理 wikipedia链接：https://en.wikipedia.org/wiki/Sprague–Grundy_theorem 定义 \(mex\) 运算，一个集合的 \(mex\) 值是最小的没有出现在这个集合中的自然数。 定义 Sprague-Grundy 函数：对于一个状态 \(x\)，当 \(x\) 是 terminal position 时，\(SG(x)=mex\{SG(y)|x\) 可以转移到 \(y\}\)。 可以用 Sprague-Grundy 函数判断一个状态是必胜状态还是必败状态，因为必胜状态函数值必不为 \(0\)，必败状态函数值必为 \(0\)。 定义两个游戏的 disjunctive sum 为一个游戏：轮到每个玩家的时候，他可以选择两个游戏中的一个游戏，然后在这个游戏上操作一步，无法操作的人输。 显然 disjunctive sum 满足交换律和结合律。 定理 有 \(n\) 个游戏 \(G_1,G_2,\cdots,G_n\)，设他们的 disjunctive sum 为 \(G\)。那么 \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)。 证明可以看这个。 这也说明了每一个 normal play convention 下的 impartial game 都等价于一个Nim游戏。]]></content>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
