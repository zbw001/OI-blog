<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LOJ3158]„ÄåNOI2019„ÄçÂ∫èÂàó]]></title>
    <url>%2F2020%2F05%2F14%2Floj3158%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! U2FsdGVkX1+RjZixXPBfrPn4MJM57Z6FCYD7Eft/j8+KvxsEEmlVVCjw3eeKxSeVbCrLfwBTt5Sj30kbfizpNq4tA+SOfDZLRCEbaDMKw72KQh3X3VUcic72GexMh04MYm+ss3VnlrrfDA7LGMdcZBJ+idCzyyg5BXRhPZ4g9Y36sS2g/fX5vM7OpkOFrODzrH0OQGv8EEO0CwMNaa1jYHgNoUfDwKRWV/SS1nDAbfqMdUYP+gftj2nhLIEvmT45oX6dBgrvfLgEhqfQPtx3ve64JFaQXdWKE38wv20M/+Ex7boZnr+cZ8HY4dOnD2IXN+ITpDPJSjzA0rdL75ONCie7WnvF76kkEvVsG330EZgQSbCoEbjVZZ4JcAHr6LQLQUby0grD5Ri9OXUi1y8M+V2vGzB40e2Q723PzCATsm2MRRZzYn6TlL9RtzEz0ZniewmRjP/9xBCIasduo5FDAxaM7g53FeXx7SdU1AyXc7P5hoIqVPkA5+QCdgVvO90yTdVYRdcRAlYahcL3SQLRMxlknUSwQEMkYGSXNm/FbaZf+59p0D/aZMFqFuRuAfvDk+XRdpTOKINEjW5HmC+HVfDzEHQ5Kfq0dIxQd+WVSQ9USof/zkV+yQRHNNoTi5ME7Y5mtUiP4thC0UZWyHB9fiVf4JvQ27YZsmlkCVbaWAVf7dMl0LyalR3/jMxAK5vtEfwN9KWX8dFdknp9yIW/O6qRtyrQa7raZ9S4KcUkXio5W8bk3E/Mrej5T6ROKsMnFaDSl7mNXz+MpPayAQ7vnWnoaJ4x0bVDBFbo37FZxnqJGKAMr5XlRE3y92LAEfG9mbmnBKMeGEBKx8JC0mBPXuaqseMgoRWM1yJvpOjJICBGK3FC+EesGx77OQBkY2q+HmQf7VF2hrDuo1ha0mr1d5i1iw97wqywzeJdJdcBnuNdH1a4llRpqybwxsNkkz/5FcygnK4Pog6DDLnnnpn0UjKRLMaZCFt+3VXThpvJ5IK2W5zrdTZ9hXGgor0+Ke/OY2paXZawRVxzzhZo1nU/LKfSv2nyohOS2T/lGMlqwdd0tNevvR+xuz1KqMP6rf3ekmoiEBx/We0MlrwHXDqJdWdrlsMttpD3y17O3Q5d+mv/Wec62dU5jS3FF2OCMq5tM3WK49DsclbaK8l8Rs0BgQBNj5LmVU8OMn28UUUEWBTJK0XqctkA9FBYCg3jrwiGq7GvCdo7vkz0sw1OBuki2nBEvipBTKbhU5ORxXtCepZZ/eaDbjXm4vqa2QdPyNYH7lv5i52ROYh0B0+8yFOR/3z8DpEvnflPnB9aoFa9H3MvSPomz9PCJcnq3hCyDzCvEWLpb3i4Xw2yeMVZbH/VtLDVc9TsW4FM/LdUHolf1oynFPebpGZTDGwKR22RaQNg/HbLqxP+oT3xK2G+3PzU0tjgKIrbx8IXlDswhMXrKGt5lHab+L2LdySDRHL1UZpr]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Ê®°ÊãüË¥πÁî®ÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4977] Ë∑≥‰ºûÊ±ÇÁîü]]></title>
    <url>%2F2020%2F05%2F14%2Fbzoj4977%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éËøôÁØá blog ÂÜô‰∏ãÊó∂ÔºåÁõÆÂâçÁàÜÁÇ∏ OJ Ê≠£Â§Ñ‰∫éÁàÜÁÇ∏Áä∂ÊÄÅÔºåËøôÈáåÈôÑ‰∏Ä‰∏™È¢òÁõÆÊèèËø∞„ÄÇ È¢òÁõÆÊèèËø∞ Â∞è Q ÊúÄËøëÊ≤âËø∑‰∫é„ÄäË∑≥‰ºûÊ±ÇÁîü„ÄãÊ∏∏Êàè„ÄÇ‰ªñÁªÑÂª∫‰∫Ü‰∏ÄÊîØÁî± \(n\) ÂêçÁé©ÂÆ∂ÔºàÂåÖÊã¨‰ªñËá™Â∑±ÔºâÁªÑÊàêÁöÑÊàòÈòüÔºåÁºñÂè∑‰æùÊ¨°‰∏∫ \(1\) Âà∞ \(n\)„ÄÇËøô‰∏™Ê∏∏Êàè‰∏≠ÔºåÊØèÂ±ÄÊ∏∏ÊàèÂºÄÂßãÊó∂ÔºåÊâÄÊúâÁé©ÂÆ∂ÈÉΩ‰ºö‰ªéÈ£ûÊú∫‰∏äË∑≥‰ºûÔºåÈÄâÊã©‰∏Ä‰∏™ÁõÆÁöÑÂú∞ÈôçËêΩÔºåË∑≥‰ºûÂíåÈôçËêΩÁöÑÊó∂Èó¥ÊúâÊó©ÊúâÊôö„ÄÇÂú®ÊüêÂ±ÄÊ∏∏ÊàèÈôçËêΩÂâçÔºå‰ªñ‰ª¨Âú®Á©∫‰∏≠ËßÇÂØüÂèëÁé∞Âú∞Èù¢‰∏ä‰∏ÄÂÖ±Êúâ \(m\) Èó¥ÊàøÂ≠êÔºåÁºñÂè∑‰æùÊ¨°‰∏∫ \(1\) Âà∞ \(m\)„ÄÇÂÖ∂‰∏≠ÊØèÈó¥ÊàøÂ≠êÊÅ∞Â•ΩÊúâ‰∏ÄÂêçÊïå‰∫∫Êó©‰∫é‰ªñ‰ª¨Âà∞Ëææ„ÄÇÂ∞è Q ÊàòÈòüÁöÑÁ¨¨ \(i\) ÂêçÁé©ÂÆ∂Êã•Êúâ \(a_i\) ÂèëÂ≠êÂºπÔºåÂú∞Èù¢‰∏äÁ¨¨ \(i\) Èó¥ÊàøÂ≠êÈáåÁöÑÊïå‰∫∫Êã•Êúâ \(b_i\) ÂèëÂ≠êÂºπÔºåÊ∂àÁÅ≠‰ªñÂèØ‰ª•Ëé∑Âæó \(c_i\) ÁÇπÁßØÂàÜ„ÄÇÊØèÂêçÁé©ÂÆ∂ÂøÖÈ°ª‰∏îÂè™ËÉΩÈÄâÊã©‰∏ÄÈó¥ÊàøÂ≠êÈôçËêΩÔºåÁÑ∂ÂêéÂéªÊ∂àÁÅ≠ÈáåÈù¢ÁöÑÊïå‰∫∫„ÄÇËã•Á¨¨ \(i\) ÂêçÁé©ÂÆ∂ÈÄâÊã©‰∫ÜÁ¨¨ \(j\) Èó¥ÊàøÂ≠êÔºåÂ¶ÇÊûú \(a_i&gt;b_j\)ÔºåÈÇ£‰πà‰ªñÂ∞±ÂèØ‰ª•Ê∂àÁÅ≠ËØ•Êïå‰∫∫ÔºåËé∑Âæó \(a_i-b_j+c_j\) ÁöÑÂõ¢ÈòüÂ•ñÂä±ÁßØÂàÜÔºåÂê¶Âàô‰ªñ‰ºöË¢´Êïå‰∫∫Ê∂àÁÅ≠„ÄÇ‰∏∫‰∫ÜÈò≤Ê≠¢Âõ¢ÁÅ≠ÔºåÂ∞è Q ‰∏çÂÖÅËÆ∏Â§öÂêçÁé©ÂÆ∂ÈÄâÊã©Âêå‰∏ÄÈó¥ÊàøÂ≠êÔºåÂõ†Ê≠§Â¶ÇÊûúÊüê‰ΩçÁé©ÂÆ∂ÊØ´Êó†Âà©Áî®‰ª∑ÂÄºÔºå‰Ω†ÂèØ‰ª•ÈÄâÊã©ËÆ©‰ªñÈÄÄÂá∫Ê∏∏Êàè„ÄÇÂõ†‰∏∫ÊàøÂ≠ê‰πãÈó¥ÁöÑË∑ùÁ¶ªËøáÈïøÔºå‰Ω†ÂèØ‰ª•ËÆ§‰∏∫ÊØèÂêçÁé©ÂÆ∂Âú®ÈôçËêΩ‰πãÂêé‰∏çËÉΩÂÜçÂéªÊ∂àÁÅ≠ÂÖ∂ÂÆÉÊàøÈó¥ÈáåÁöÑÊïå‰∫∫„ÄÇ‰Ωú‰∏∫Â∞è Q ÊàòÈòüÁöÑÊåáÊå•ÔºåËØ∑Âà∂ÂÆö‰∏ÄÂ•óÊúÄ‰ºòÁöÑÈôçËêΩÊñπÊ°àÔºå‰ΩøÂæóÊúÄÂêéËé∑ÂæóÁöÑÂõ¢ÈòüÂ•ñÂä±ÊÄªÁßØÂàÜÊúÄÂ§ß„ÄÇ \(n, m \le 10^5\) ÂÅöÊ≥ï Âª∫Â¶Ç‰∏ãË¥πÁî®ÊµÅÂõæÔºåÊ±ÇÊúÄÂ§ßË¥πÁî®ÊµÅ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠Êï∞Â≠óÊ†áÊ≥®ÁöÑÊòØË¥πÁî®„ÄÇ ÂÅáËÆæÂàöÂºÄÂßãÊ∫êÁÇπÂá∫ÂèëÁöÑÈÇ£‰∫õËæπ‰∏çÂ≠òÂú®Ôºå‰æùÊ¨°Âä†ÂÖ•ÈÇ£‰∫õËæπÔºåÊØèÊ¨°Âä†ÂÖ•‰∏ÄÊù°ËæπÂêéÊõ¥Êñ∞ÊúÄÂ∞èË¥πÁî®ÊµÅ„ÄÇ ÂèØ‰ª•Ê≥®ÊÑèÂà∞Â¢ûÂπøËøáÁ®ã‰∏≠Âä†ÂÖ•ÁöÑÂèçÂêëËæπÈÉΩÊòØ‰ªéÂ∑¶Âà∞Âè≥ÁöÑÔºåËøôÊ†∑ÁöÑËæπ‰∏ç‰ºöË¢´Áî®Âà∞„ÄÇ ÊâÄ‰ª•Êàë‰ª¨‰∏çÈúÄË¶ÅÂÖ≥ÂøÉÂàùÂßãÊó∂‰∏çÂú®Ë¥πÁî®ÊµÅÂõæ‰∏äÁöÑËæπ„ÄÇÊØèÊ¨°Âä†ÂÖ•‰∏ÄÊù°ËæπÂêéÊúâ‰∏âÁßçÊÉÖÂÜµÔºö Â¢ûÂπø‰∏ÄÊù°Ê∫êÂà∞Ê±áÁöÑÁÆÄÂçïË∑ØÂæÑ Ê∂àÊéâ‰∏Ä‰∏™ÂåÖÂê´Âä†ÂÖ•ÁöÑËæπÁöÑÁÆÄÂçïË¥üÁéØ (Âõ†‰∏∫ÊòØË¥üÁéØ‰∏ÄÂÆöÁªèËøáÊ±áÔºåÊâÄ‰ª•‰πüÂ∞±‰∏ÄÂÆöÊÅ∞Â•ΩÁªèËøá‰∏§Êù°‰∏éÊ±áÁõ∏ÈÇªÁöÑËæπ) ‰∏ç‰ΩúÊõ¥Êñ∞ Á¨¨‰∏ÄÁßçÁõ∏ÂΩì‰∫éÊòØÊääÊñ∞Âä†ÂÖ•ÁöÑËæπÂØπÂ∫îÁöÑÁé©ÂÆ∂Âíå‰∏Ä‰∏™Ê≤°ÊúâË¢´ÂåπÈÖçÁöÑÊàøÂ≠êÂåπÈÖçÔºåÁ¨¨‰∫åÁßçÁõ∏ÂΩì‰∫éÊòØÊää‰∏Ä‰∏™Â∑≤ÂåπÈÖçÁöÑÊàøÂ≠êÂåπÈÖçÁöÑÁé©ÂÆ∂Êîπ‰∏∫Êñ∞Âä†ÂÖ•ÁöÑËæπÂØπÂ∫îÁöÑÁé©ÂÆ∂„ÄÇ ÊääÊâÄÊúâ‰∫∫ÂíåÊàøÂ≠êÊéí‰∏™Â∫èÔºå‰ªéÂ∑¶Âà∞Âè≥Â§ÑÁêÜÔºåÁî®Â†ÜÁª¥Êä§‰∏Ä‰∏ãÂì™‰∏™Êî∂ÁõäÊØîËæÉÂ§ßÔºåÂ¶ÇÊûúÈÉΩÊòØË¥üÁöÑÂ∞±‰∏ç‰ΩúÊõ¥Êñ∞ÔºåÂê¶ÂàôÂ∞±ÈÄâÊî∂ÁõäËæÉÂ§ßÁöÑÊõ¥Êñ∞Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll,int&gt; pi;ll ans = 0;const ll inf = 1e18;const int maxn = 100010;/* struct Heap &#123; priority_queue&lt;pi&gt; pq, d; int mt() &#123; while (!d.empty() &amp;&amp; pq.top() == d.top()) &#123; d.pop(); pq.pop(); &#125; &#125; pi top() &#123; mt(); if (pq.empty()) &#123; return pi(-inf, 0); &#125; return pq.top(); &#125; void push(pi p) &#123; pq.push(p); &#125; void del(pi p) &#123; d.push(p); &#125;&#125; H1, H2;*/priority_queue&lt;pi&gt; H1, H2;// H1 Êú™ÂåπÈÖçÔºåH2 Â∑≤ÂåπÈÖçint n, m, a[maxn], b[maxn], c[maxn];pi p[maxn &lt;&lt; 1];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); p[i] = pi(a[i], i); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;b[i], &amp;c[i]); p[n+i] = pi(b[i], i + n); &#125; sort(p + 1, p + n + m + 1); for (int i = 1; i &lt;= n + m; i++) &#123; int t = p[i].second; if (t &lt;= n) &#123; ll v1 = -inf, v2 = -inf; pi p1 = H1.empty() ? pi(-inf, 0) : H1.top(), p2 = H2.empty() ? pi(-inf, 0) : H2.top(); v1 = p1.first + p[i].first, v2 = p2.first + p[i].first; if (max(v1, v2) &gt; 0) &#123; if (v1 &gt; v2) &#123; H1.pop(); ans += v1; H2.push(pi(-p[i].first, p1.second)); &#125; else &#123; H2.pop(); ans += v2; H2.push(pi(-p[i].first, p1.second)); &#125; &#125; &#125; else &#123; H2.push(pi(c[t - n] - p[i].first, t - n)); &#125; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Ê®°ÊãüË¥πÁî®ÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] Ê®°ÊãüË¥πÁî®ÊµÅÈóÆÈ¢ò]]></title>
    <url>%2F2020%2F05%2F14%2F%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1349D] Slime and Biscuits]]></title>
    <url>%2F2020%2F05%2F13%2FCF1349D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(\sum a_i = s\)„ÄÇ ÊòæÁÑ∂Âú®‰ªª‰Ωï‰∏Ä‰∏™Êó∂ÂàªÂè™ÊúâËá≥Â§ö‰∏Ä‰∏™‰∫∫Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤„ÄÇ ËÆæ‰ªé‰∏Ä‰∏™Â≠òÂú®‰∏Ä‰∏™‰∫∫Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÁä∂ÊÄÅÂºÄÂßãÔºåÂÅáËÆæÊ∏∏Êàè‰∏ç‰ºöÁªìÊùüÔºå\(k\) Ê≠•‰πãÂêéÂ≠òÂú®‰∏Ä‰∏™Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑ‰∫∫Ôºå‰∏îËøôÊòØËøô‰∏™‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéá‰∏∫ \(q_k\) (\(q_0=1\))ÔºåËÆæ \(Q(x) = \sum_{k \ge 0} q_k x^k\)„ÄÇ ËÆæÁ¨¨ \(k\) Ê≠•Êó∂Á¨¨‰∏ÄÊ¨°Âá∫Áé∞‰∏Ä‰∏™Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑ‰∫∫ÁöÑÊ¶ÇÁéá‰∏∫ \(f_k\) (Âç≥Ê∏∏Êàè \(k\) Ê≠•ÁªìÊùüÁöÑÊ¶ÇÁéá)ÔºåËÆæ \(F(x) = \sum_{k\ge 0} f_kx^k\)„ÄÇ ËÆæ \(p_{i,k}\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™‰∫∫ \(k\) Ê≠•ÂêéÁ¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéáÔºåËÆæ \(P_i(x) = \sum_{k \ge 0} p_{i,k}x^k\)„ÄÇ ÈÇ£‰πà \(F(x) Q(x) = \sum P_i(x)\)ÔºåÊâÄ‰ª• \(F(x) = \frac{\sum P_i(x)}{Q(x)}\)„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \(F&#39;(1)\)„ÄÇÁî±ÂàÜÂºèÊ±ÇÂØºÂÖ¨ÂºèÈóÆÈ¢òË¢´ËΩ¨Âåñ‰∏∫Ê±Ç \(P_i(1), P&#39;_i(1), Q(1), Q&#39;(1)\)„ÄÇ ÊòæÁÑ∂ \(P_i(1) = 1, Q(1) = n\)ÔºåËÄÉËôë \(P&#39;_i(x), Q&#39;(x)\) ÁöÑÂÆûÈôÖÊÑè‰πâÔºåÈóÆÈ¢òÂèòÊàêÊ±Ç‰∏Ä‰∏™ÂàùÂßãÊúâ \(x\) ‰∏™È•ºÂπ≤ÁöÑ‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåËøôËøô‰∏™ÂÄº‰∏∫ \(x_i\)ÔºåÈÇ£‰πàÊúâ \[ x_s = 0\\ x_i = 1 + \frac 1 {n(n-1)}[(n-i)(n-2)x_i + i(n-1)x_{i-1}+(n-i)x_{i+1}]\\ P&#39;_i(1) = x_{a_i}, Q&#39;(1) = (n-1) x_0 \] Ëß£ÊñπÁ®ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n + \sum a_i)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;const int maxn = 300010;int n, a[maxn], x[maxn], k[maxn], b[maxn], s;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; y &gt;&gt;= 1; x = 1LL * x * x % mod; &#125; return ret;&#125;int inv(ll x) &#123; return qpow(x % mod, mod - 2);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; &#125; k[0] = 1; for (int i = 0; i &lt; s; i++) &#123; int k1 = 1LL * (mod + 1 - 1LL * (s-i) * inv(s) % mod * (n-2) % mod * inv(n-1) % mod) % mod * inv(1LL * (s-i) * inv(s) % mod * inv(n-1) % mod) % mod; int k2 = 1LL * (mod-i) * (n-1) % mod * inv(s - i) % mod; int _b = 1LL * (n-1) * (mod - s) % mod * inv(s - i) % mod; k[i+1] = (k[i+1] + 1LL * k1 * k[i] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k1 * b[i] % mod) % mod; if (i &gt; 0) &#123; k[i+1] = (k[i+1] + 1LL * k2 * k[i-1] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k2 * b[i-1] % mod) % mod; &#125; b[i+1] = (b[i+1] + _b) % mod; &#125; int t = 0; x[0] = 1LL * (mod - b[s]) * qpow(k[s], mod - 2) % mod; for (int i = 1; i &lt;= s; i++) &#123; x[i] = (1LL * k[i] * x[0] + b[i]) % mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; t = (t + x[a[i]]) % mod; &#125; int ans = 1LL * (t - 1LL * (n-1) * x[0] % mod + mod) % mod * inv(n) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏ÄÁ±ªÂå∫Èó¥Âä†Âå∫Èó¥ËØ¢ÈóÆÈóÆÈ¢òÁöÑÈÄöÁî®Â§ÑÁêÜÊñπÊ≥ï]]></title>
    <url>%2F2020%2F05%2F13%2F%E4%B8%80%E7%B1%BB%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4%E8%AF%A2%E9%97%AE%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êï¥ÁêÜ‰∏Ä‰∏ãËøô‰∏ÄÁ±ªÈóÆÈ¢òÁöÑÁêÜËß£ÊñπÂºè..‰ª•‰æø‰ª•ÂêéÊõ¥ÂÆπÊòìÊÉ≥Ê∏ÖÊ•öËøôÁ±ªÈóÆÈ¢ò„ÄÇ ‰Ω†Ë¶ÅÁª¥Êä§‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a\)ÔºåËøô‰∏™Êï∞ÁªÑÊúâ‰∏Ä‰∏™ÂàùÂßãÂÄº„ÄÇÊúâ‰∏§‰∏™‰∫åÁª¥Êï∞ÁªÑ \(p[c][n]\) Âíå \(q[d][n]\)„ÄÇ ‰Ω†Ë¶ÅÊîØÊåÅ‰∏§ÁßçÊìç‰Ωú 1. ÁªôÂÆö \(l, r, k, x\)Ôºå\(1 \le k \le c\)ÔºåÂØπÊØè‰∏™ \(l \le i \le r\)ÔºåÊää \(a[i]\) ÊîπÊàê \(a[i] + x\cdot p[k][i]\) 2. ÁªôÂÆö \(l, r, k\)Ôºå\(1 \le k \le d\)ÔºåÊ±Ç \(\sum_{i=l}^r q[k][i]\cdot a[i]\) Ëøô‰∏™ÂΩ¢ÂºèÁöÑÈóÆÈ¢òÂú®‰∏Ä‰∏ãÊØîËæÉÂ§çÊùÇÁöÑÊ†ë‰∏äÈóÆÈ¢òÁöÑÁª¥Êä§‰∏≠ÂæàÂ∏∏ËßÅ„ÄÇÂ§ßÈÉ®ÂàÜËøôÊ†∑ÁöÑÈóÆÈ¢ò‰∏≠ÈÉΩÊúâ \(c = 1\) Êàñ \(d = 1\)„ÄÇ Êàë‰ª¨ÂÖàÊù•ÂÆö‰πâ‰∏ÄÊ£µÁª¥Êä§‰∏Ä‰∏™ \(a\) Êï∞ÁªÑÔºåÊîØÊåÅÂΩ¢Â¶Ç \(l,r,x\)ÔºåÊääÊâÄÊúâ \(l \le i\le r\) ÁöÑ \(a[i]\) ÊîπÊàê \(a[i] + x \cdot k[i]\) (\(k\) ÊòØ‰∏Ä‰∏™È¢ÑÂÖàÁ°ÆÂÆöÁöÑÊï∞ÁªÑ) ÁöÑÊìç‰ΩúÁöÑÁ∫øÊÆµÊ†ë„ÄÇÂè™Ë¶ÅËÆ∞ÂΩï‰∏Ä‰∏ãÊØè‰∏™Á∫øÊÆµÊ†ë‰∏äÁÇπÂØπÂ∫îÂå∫Èó¥ÂÜÖ \(k\) ÁöÑÂíåÂ∞±ÂæàÂÆπÊòìÊâìÊâì tag ÂÆûÁé∞ÔºåË∑ëËµ∑Êù•ÊïàÁéáÂíåÊôÆÈÄöÁ∫øÊÆµÊ†ëÊ≤°Êúâ‰ªÄ‰πàÂå∫Âà´„ÄÇÊàë‰∏ÄËà¨ÊòØËøôÊ†∑ÂÆûÁé∞ÁöÑÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct segTree &#123; ll k[maxn], iv[maxn], sk[maxn &lt;&lt; 2], sum[maxn &lt;&lt; 2], add[maxn &lt;&lt; 2]; void build(int l, int r, int rt) &#123; if (l == r) &#123; sk[rt] = k[l]; sum[rt] = iv[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); sk[rt] = sk[rt&lt;&lt;1] + sk[rt&lt;&lt;1|1]; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void modify(int rt, ll v) &#123; add[rt] += v; sum[rt] += sk[rt] * v; &#125; void pushDown(int rt) &#123; if (add[rt]) &#123; modify(rt&lt;&lt;1, add[rt]); modify(rt&lt;&lt;1|1, add[rt]); add[rt] = 0; &#125; &#125; void upd(int p, ll v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] += sk[rt] * v; return; &#125; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) &#123; upd(p, v, l, m, rt&lt;&lt;1); &#125; else &#123; upd(p, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void upd(int L, int R, ll v, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify(rt, v); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) &#123; upd(L, R, v, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; upd(L, R, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; ll qry(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; ll ret = 0; if (L &lt;= m) &#123; ret += qry(L, R, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; ret += qry(L, R, m+1, r, rt&lt;&lt;1|1); &#125; return ret; &#125;&#125;; ÂÖ∂‰∏≠ \(iv\) Êï∞ÁªÑÊòØ \(a\) ÁöÑÂàùÂßãÂÄº„ÄÇ ‰∏ãÈù¢ÁªôÂá∫‰∏Ä‰∏™ÈúÄË¶ÅÂºÄ \(c\cdot d\) Ê£µÁ∫øÊÆµÊ†ëÁöÑÂÆûÁé∞ÔºöÂØπÊØè‰∏™ \(1 \le x \le c, 1\le y \le d\)ÔºåÂºÄ‰∏ÄÊ£µÁ∫øÊÆµÊ†ë \((x,y)\)ÔºåÁª¥Êä§ÁöÑÊï∞ÁªÑÂç≥‰πãÂâçÂÆö‰πâÁöÑ \(a\) Êï∞ÁªÑÔºå\(k[i] = p[x][i]\cdot q[y][i]\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™ËØ¢ÈóÆ \(l,r,y\)ÔºåÊàë‰ª¨Â∞±ÂØπÊØè‰∏™ \(x\)ÔºåÂú®Á∫øÊÆµÊ†ë \((x,y)\) ‰∏äËØ¢ÈóÆÂå∫Èó¥ \(l,r\)ÔºåÊääÂæóÂà∞ÁöÑÁªìÊûúÂä†Ëµ∑Êù•„ÄÇËøôÊ†∑Âú®Â§ÑÁêÜ‰∏Ä‰∏™‰øÆÊîπ \(l,r,x,a\) ÁöÑÊó∂ÂÄôÔºåÂè™Ë¶ÅÂØπÊØè‰∏™ \(1 \le y \le d\) ÈÉΩÂú®Á∫øÊÆµÊ†ë \((x,y)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>ËÉ°Ë®Ä‰π±ËØ≠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2504] „Äå2018 ÈõÜËÆ≠Èòü‰∫íÊµã Day 5„ÄçÂ∞è H Áà±ÊüìËâ≤]]></title>
    <url>%2F2020%2F05%2F12%2Floj2504%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÁºñÂè∑ÁúãÊàê \(1 \ldots n\) Ë∞É‰∫ÜÂ∑®‰πÖÔºåÊàëÂ§ßÊ¶ÇÊ≤°Êïë‰∫Ü„ÄÇ ÊòæÁÑ∂ÁºñÂè∑ÊúÄÂ∞èÈªëÁêÉÁºñÂè∑‰∏∫ \(k\) ÁöÑÊñπÊ°àÊúâ \(\binom{n-k+1}m^2 - \binom {n-k}m^2\) Áßç„ÄÇ Á≠îÊ°à‰∏∫ \[ \sum_{k = 0}^{n-1} (\binom{n-k}m^2 - \binom {n-k-1}m^2) F(k) \] Ê≥®ÊÑèÂà∞ \((\binom{n-k}m^2 - \binom {n-k-1}m^2) F(k)\) ÊòØ‰∏Ä‰∏™ÂÖ≥‰∫é \(k\) ÁöÑ \(3m\) Ê¨°Â§öÈ°πÂºèÔºåÊàë‰ª¨Ë¶ÅÊ±ÇËøô‰∏™Â§öÈ°πÂºèÁöÑ‰∏Ä‰∏™ÂâçÁºÄÂíåÔºåËøô‰∏™Â§öÈ°πÂºèÁöÑÂâçÁºÄÂíåÊòØ‰∏Ä‰∏™ \(3m+1\) Ê¨°Â§öÈ°πÂºèÔºåËÆæÂÆÉ‰∏∫ \(G(k)\)„ÄÇÂ¶ÇÊûúÊàë‰ª¨Áü•ÈÅì \(F(0) \ldots F(3m+1)\) Â∞±ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞ÂæóÂà∞ \(G(0) \ldots G(3m+1)\)ÔºåÁÑ∂ÂêéÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂæóÂà∞ \(G(n-1)\)„ÄÇ ‰ΩÜÊòØÊàë‰ª¨Âè™Áü•ÈÅì \(F(0) \ldots F(m)\)„ÄÇËÄÉËôëÂ¶Ç‰ΩïËÆ°ÁÆó \(F(m+1) \ldots F(3m+1)\)„ÄÇ \[ F(x) = \sum_{i=0}^m F(i) \prod_{j \neq i, 0 \le j\le m} \frac{x-j}{i-j} \\\\ \text{ÂØπ‰∫é $m &lt; x \le 3m+1$} \\\\ F(x) = \sum_{i=0}^m F(i) \frac {(-1)^{m-i}x^{\underline{m+1}}} {(x-i)i!(m-i)!}=x^{\underline{m+1}} \sum_{i=0}^m F(i)\frac{(-1)^{m-i}}{i!(m-i)!} \frac 1 {x-i} \] ËøôÂèØ‰ª•Áî® NTT ‰ºòÂåñÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(m \log m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int mod = 998244353;const int g = 3;const int maxm = 1000010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; y &gt;&gt;= 1; x = 1LL * x * x % mod; &#125; return ret;&#125;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;namespace NTT &#123; int wn[30], w[(1 &lt;&lt; 22) + 10], rev[(1&lt;&lt;22) + 10], wa[(1 &lt;&lt; 22) + 10], wb[(1 &lt;&lt; 22) + 10], wc[(1 &lt;&lt; 22) + 10]; ull _a[(1 &lt;&lt; 22) + 10]; void init() &#123; for (int i = 0; i &lt;= 22; i++) &#123; wn[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; &#125; void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int i = 0; i &lt; l; i++) &#123; _a[i] = a[i]; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; w[0] = 1; ++ _; for (int i = 1; i &lt; len; i++) &#123; w[i] = 1LL * w[i-1] * wn[_] % mod; &#125; for (int s = 0; s &lt; l; s += len) &#123; for (int i = s; i &lt; s + (len &gt;&gt; 1); i++) &#123; ull v1 = _a[i], v2 = w[i - s] * _a[i + (len &gt;&gt; 1)] % mod; _a[i] = v1 + v2; _a[i + (len &gt;&gt; 1)] = v1 + mod - v2; &#125; &#125; if (len == (1 &lt;&lt; 15)) &#123; for (int i = 0; i &lt; l; i++) &#123; _a[i] %= mod; &#125; &#125; &#125; for (int i = 0; i &lt; l; i++) &#123; a[i] = _a[i] % mod; &#125; if (ty == -1) &#123; int inv = qpow(l, mod - 2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;&#125;int cal(int x) &#123; return 1LL * x * x % mod;&#125;int n, m;int F[maxm * 3], _F[maxm * 3], G[maxm * 3], fac[maxm * 3], ifac[maxm * 3], inv[maxm * 3], rinv[maxm * 3];int pw[maxm * 3]; // n - i ÁöÑ m Ê¨°‰∏ãÈôçÂπÇint main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= m; i++) &#123; scanf("%d", &amp;F[i]); &#125; NTT::init(); fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= 3 * m + 1; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 0; i &lt;= 3 * m + 1; i++) &#123; rinv[i] = qpow(n - i, mod - 2); &#125; for (int i = 1; i &lt;= 3 * m + 1; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; &#123; using namespace NTT; int l = (1 &lt;&lt; 22); for (int i = 0; i &lt;= m; i++) &#123; wa[i] = 1LL * F[i] * ifac[i] % mod * ifac[m - i] % mod; if ((m - i) &amp; 1) &#123; wa[i] = mo(mod - wa[i]); &#125; &#125; for (int i = 1; i &lt;= 3 * m + 1; i++) &#123; wb[i] = inv[i]; &#125; ntt(wa, 22, 1), ntt(wb, 22, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, 22, -1); for (int i = m + 1; i &lt;= 3 * m + 1; i++) &#123; F[i] = 1LL * fac[i] * ifac[i - m - 1] % mod * wc[i] % mod; &#125; &#125; &#123; // P1 : n - i &gt;= m pw[0] = 1; for (int i = 0; i &lt; m; i++) &#123; pw[0] = 1LL * pw[0] * (n - i) % mod; &#125; for (int i = 1; i &lt;= n - m &amp;&amp; i &lt;= 3 * m + 2; i++) &#123; pw[i] = 1LL * pw[i-1] * rinv[i - 1] % mod * (n - i - m + 1) % mod; &#125; // P2 : n - i &lt; 0 for (int i = n + 1; i &lt;= 3 * m + 2; i++) &#123; pw[i] = 1LL * fac[i - n + m - 1] * ifac[i - n - 1] % mod; if (m &amp; 1) &#123; pw[i] = mo(mod - pw[i]); &#125; &#125; &#125; for (int i = 0; i &lt;= 3 * m + 1; i++) &#123; _F[i] = 1LL * cal(ifac[m]) * (cal(pw[i]) + mod - cal(pw[i+1])) % mod * F[i] % mod; &#125; G[0] = _F[0]; for (int i = 1; i &lt;= 3 * m + 1; i++) &#123; G[i] = mo(G[i-1] + _F[i]); &#125; if (n - 1 &gt; 3 * m + 1) &#123; int ans = 0; int t = 1; for (int i = 0; i &lt;= 3 * m + 1; i++) &#123; t = 1LL * t * (n - 1 - i) % mod; &#125; for (int i = 0; i &lt;= 3 * m + 1; i++) &#123; int v = 1LL * t * qpow(n - 1 - i, mod - 2) % mod * ifac[i] % mod * ifac[3 * m + 1 - i] % mod; if ((3 * m + 1 - i) &amp; 1) &#123; v = mo(mod - v); &#125; ans = mo(ans + 1LL * G[i] * v % mod) % mod; &#125; printf("%d\n", ans); &#125; else &#123; printf("%d\n", G[n-1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6363] „ÄåÂú∞Â∫ïËî∑Ëñá„Äç]]></title>
    <url>%2F2020%2F05%2F11%2Floj6363%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(A(x) = \sum_k a_k\frac{x^k}{k!}\)ÔºåÁÇπÂèåËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(B(x) = \sum_{k} b_k \frac{x^k}{k!}\) (Âùá‰∏çÂê´Á©∫ÂõæÔºå‰∏Ä‰∏™ÁÇπ‰∏çÁÆóÁÇπÂèåËøûÈÄöÂõæ) Âàô \[ A(x) = x\sum_{k \ge 0} \frac{(\sum_{s \ge 2} A(x)^{s-1}\frac {b_s} {(s-1)!})^k}{k!} = x \exp(B&#39;(A(x))) \\\\ B&#39;(A(x)) = \ln(\frac {A(x)} x) \] Áî®ÊãâÊ†ºÊúóÊó•ÂèçÊºîÊ±Ç \([x^n]B(x)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)Ôºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ \(i \in S\) ‰ª• \(\mathcal O(i \log i)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ËÆ°ÁÆó \([x^i]B(i)\)ÔºåÁÑ∂Âêé‰ªÖ‰øùÁïôËøô‰∫õÈ°πÂæóÂà∞‰∏Ä‰∏™È¢òÁõÆÂÖÅËÆ∏ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁîüÊàêÂáΩÊï∞ \(C(x)\)„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÂ§ßÂ∞èÈÉΩÂú® \(S\) ÂÜÖÁöÑÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ \(D(x)\) (‰∏ãÈù¢Áî® \(D(x)^{-1}\) Ë°®Á§∫ \(D(x)\) ÁöÑÂ§çÂêàÈÄÜ) : \[ C&#39;(D(x)) = \ln(\frac {D(x)} x) \\\\ C&#39;(x) = \ln (\frac {x}{D(x)^{-1}}) \\\\ D(x)^{-1} = \frac x {\exp C&#39;(x)} \] ÊâÄ‰ª• \(D(x)\) ÊòØ \(\frac x {\exp C&#39;(x)}\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O((n + \sum_{x \in S} x) \log n)\) ‰∏•ÈáçÂç°Â∏∏„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wn[100];int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpow(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;int w[maxn * 8];unsigned long long _a[maxn * 8];void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) _a[rev[i]] = a[i]; int _ = 0; for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int _wn = wn[++ _]; w[0] = 1; for (int i = 1; i &lt; len; i++) &#123; w[i] = 1LL * w[i-1] * _wn % mod; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; unsigned long long v1 = _a[i+j], v2 = _a[i+j+(len&gt;&gt;1)]*w[j]%mod; _a[i+j] = v1 + v2; _a[i+j+(len &gt;&gt; 1)] = v1 + mod - v2; &#125; &#125; if (len == (1 &lt;&lt; 15)) &#123; for (int j = 0; j &lt; (1&lt;&lt;l); j++) &#123; _a[j] = _a[j] % mod; &#125; &#125; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i++) &#123; a[i] = _a[i] % mod; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;poly A, lnA, dlnA;int ok[maxn], fac[maxn], ifac[maxn];void init(int n) &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly tmp(n + 2); for (int i = 0; i &lt;= n + 1; i++) &#123; tmp.a[i] = 1LL * ifac[i] * qpow(2, 1LL * i * (i - 1) / 2) % mod; &#125; poly lnt = polyLn(tmp); A = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; A.a[i] = 1LL * (i + 1) * lnt.a[i + 1] % mod; &#125; lnA = polyLn(A); dlnA = poly(n); for (int i = 0; i &lt; n; i++) &#123; dlnA.a[i] = 1LL * (i + 1) * lnA.a[i + 1] % mod; &#125;&#125;int cal(int n) &#123; poly nA(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nA.a[i] = 1LL * lnA.a[i] * (mod - n) % mod; &#125; poly T = polyExp(nA) * dlnA; return 1LL * qpow(n, mod-2) % mod * T.a[n - 1] % mod;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); ok[x] = 1; &#125; for (int i = 0; i &lt;= 20; i++) wn[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); init(n); poly dC(n + 1); for (int i = 0; i &lt;= n; i++) &#123; if (ok[i + 1]) &#123; dC.a[i] = cal(i); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; dC.a[i] = 1LL * dC.a[i] * n % mod; &#125; poly t = polyExp(dC); int ans = 1LL * t.a[n - 1] * fac[n - 1] % mod * qpow(n, mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÁõ∏ÂÖ≥ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F11%2FLagrange%2F</url>
    <content type="text"><![CDATA[ÊäÄÂ∑ß ÊèèËø∞ÊñπÂºè Â∞ΩÈáè‰ΩøÁî®Â§çÂêàÈÄÜÁöÑÊ¶ÇÂøµÊù•ÊèèËø∞ÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºåËøôÊ†∑ÂèØ‰ª•ÁúÅÂéªÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ ÂÆö‰πâËÆ∞Âè∑ \(F(x)^{-1}\) Ë°®Á§∫ \(F(x)\) ÁöÑÂ§çÂêàÈÄÜ (Ê≥®ÊÑè‰∏çË¶Å‰∏éÂÄíÊï∞Ê∑∑Ê∑Ü)Ôºå‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÊãâÊ†ºÊúóÊó•ÂèçÊºîÂÖ¨ÂºèÂèØ‰ª•Ë°®Á§∫‰∏∫ \[ [x^n]F(x)^{-1} = \frac 1 n[x^{-1}] \frac 1 {F^n(x)} \\\\ [x^n]G(F(x)^{-1}) = \frac 1 n [x^{-1}] \frac{G&#39;(x)}{F^n(x)} \] ÈÄöËøá‰∏éÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÂá†‰πéÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑËØÅÊòéÊñπÊ≥ïÂèØ‰ª•ËØÅÊòéÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÁöÑ‰∏Ä‰∏™Êâ©Â±ïÔºöËã• \(F(G(x)) = H(x)\)ÔºåÂàô \([x^n]F(x) = \frac 1 n [x^{-1}] \frac{H&#39;(x)}{G^n(x)}\)„ÄÇÁ¨¨‰∫å‰∏™ÂºèÂ≠ê‰∏éËøô‰∏ÄÁªìËÆ∫ÊòØÁ≠â‰ª∑ÁöÑÔºå‰ΩÜÊòØÂª∫ËÆÆÂ∞ΩÂèØËÉΩ‰ΩøÁî®Á¨¨‰∫å‰∏™ÂºèÂ≠êËÄå‰∏çË¶Å‰ΩøÁî®Ëøô‰∏™ÁªìËÆ∫„ÄÇ Êé®ÂØºÊäÄÂ∑ß Èô§‰∫ÜÁßªÈ°πÁ≠âÂèòÂΩ¢‰πãÂ§ñÔºåËøòÂèØ‰ª•Âà©Áî®Â§çÂêàËøõË°åÂåñÁÆÄ„ÄÇÁî®Â§çÂêàÂåñÁÆÄÊó∂Ê≥®ÊÑèË¶ÅÁÅµÊ¥ª‰ΩøÁî®Â∑¶Âè≥ÈÄÜÔºåÂç≥ÁÅµÊ¥ª‰ΩøÁî® \(A(x) = B(x) \Rightarrow F(A(x))= F(B(x))\) Âíå \(A(x) = B(x) \Rightarrow A(F(x)) = B(F(x))\)ÔºåÈÅøÂÖç‰∏ÄÁõ¥Âè™ÊÉ≥Âà∞ÂÖ∂‰∏≠‰∏ÄÁßçÁöÑÊÉÖÂÜµ„ÄÇ ÂØπ‰∫é \(F(G(x)) = H(x)\)ÔºåÁü• \(H(x), F(x)\) Ê±Ç \([x^n] G(x)\) ÁöÑÊÉÖÂÜµÔºåÁõÆÂâçÊöÇ‰∏çÁü•Êúâ‰ªÄ‰πàÂ•ΩÁöÑÂÅöÊ≥ïÔºå‰ΩÜÊòØÂØπ‰∫é‰∏Ä‰∫õ \(H(x)\) ‰∏é \(G(x)\) ÊúâËæÉ‰∏∫ÁÆÄÂçïÁöÑÂÖ≥Á≥ªÁöÑÈóÆÈ¢òÊòØÂèØÂÅöÁöÑ„ÄÇ ‰æãÂ¶Ç \(F(G(x)) = xG(x) \Rightarrow F(G(G(x)^{-1})) = G^{-1}(x)G(G(x)^{-1}) \Rightarrow F(x) = x G(x)^{-1}\)ÔºåÂç≥ \(G\) ÊòØ \(\frac {F(x)} x\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5827] ÁÇπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F11%2FLuogu5827%2F</url>
    <content type="text"><![CDATA[ÂàöÂºÄÂßã‰ª•‰∏∫ÂíåËæπÂèåÊ≤°Âï•Â∑ÆÂà´..ÁªìÊûúÂêéÊù•Êêû‰∫ÜÂ•Ω‰πÖ„ÄÇ UPDÔºöÂ•ΩÂÉèÂ≠òÂú®Êõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ï„ÄÇ ÂÅöÊ≥ï ËÆæ \(n\) ‰∏™ÁÇπÁöÑÁÇπÂèåËøûÈÄöÂõæÊúâ \(f_n\) ‰∏™ÔºåËøûÈÄöÂõæÊúâ \(g_n\) ‰∏™ÔºåÂÆÉ‰ª¨ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÈí¶ÂÆöÊ†π) Êàë‰ª¨ËÆ§‰∏∫‰∏Ä‰∏™ÁÇπÁöÑÂõæ‰∏çÁÇπÂèåËøûÈÄöÔºå‰∏îËøô‰∏Ä‰∏™ÁÇπ‰∏∫Ââ≤ÁÇπ„ÄÇÁî±‰∫éÈ¢òÁõÆÈáå‰∏Ä‰∏™ÁÇπÊòØÁÆóÁÇπÂèåËøûÈÄöÂõæÁöÑÔºåË¶ÅÁâπÂà§‰∏ã„ÄÇ ËÆæ \(n\) ‰∏™ÁÇπÁöÑÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæ‰∏™Êï∞‰∏∫ \(b_n\)ÔºåÂÖ∂ EGF ‰∏∫ \(B(x)\)„ÄÇÊ†πÊçÆÂâ≤ÁÇπÁöÑÂÆö‰πâÔºåÂéªÊéâÊ†π‰πãÂêéÁöÑÁÇπÊûÑÊàê‰∏Ä‰∏™ËøûÈÄöÂõæÔºåÊâÄ‰ª• \(b_n = \frac n {n!}(2^{n-1}-1)(n-1)!g_{n-1}=(2^{n-1}-1)g_{n-1}\ (n \ge 2)\)„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåÂåÖÂê´‰∏çÊòØÂâ≤ÁÇπÁöÑÁÇπÁöÑÁÇπÂèåÊòØÂîØ‰∏ÄÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Êûö‰∏æÂåÖÂê´Ê†πÁöÑÁÇπÂèåÁöÑÂ§ßÂ∞èÊù•ËÆ°ÁÆó \(B(x)\)„ÄÇËÆæ \(H(x) = G&#39;(x)\) (ÂØπ EGF Ê±ÇÂØºÁõ∏ÂΩì‰∫éÂπ≥Áßª‰∫Ü)ÔºåÂåÖÂê´Ê†πÁöÑÁÇπÂèåÂ§ßÂ∞è‰∏∫ \(n\) ‰∏îÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(n\frac{f_n}{n!}x^n H^{n-1}(x)\) (ËÄÉËôëÂÜ≥ÂÆöÊ†πÔºåÁÑ∂ÂêéÂÜ≥ÂÆöËøô‰∏™ÁÇπÂèå‰∏≠Èô§‰∫ÜÊ†π‰ª•Â§ñÊØè‰∏™ÁÇπÊåÇÁöÑËøûÈÄöÂõæ)„ÄÇ ËÆæ \(C(x) = \frac{B(x)}x\)ÔºåÂàô \[ B(x) = \sum_{n \ge 1} n\frac{f_n}{n!} x^n H^{n-1}(x) = xF&#39;(xH(x)) \\\\ xC(x) = xF&#39;(xH(x)) \\\\ C(x) = F&#39;(xH(x)) \] ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \[ [x^n] F(x) = \frac 1 n[x^{n-1}] F&#39;(x)=\frac 1 {n(n-1)}[x^{-1}]\frac{C&#39;(x)}{(xH(x))^{n-1}} \] ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; const int N = 100000; poly tmp(N + 1); for (int i = 0; i &lt;= N; i++) &#123; tmp.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnT = polyLn(tmp); poly G(N + 1); for (int i = 1; i &lt;= N; i++) &#123; // G.a[i] = 1LL * lnT.a[i] * i % mod; G.a[i] = lnT.a[i]; &#125; poly H(N); for (int i = 0; i &lt; N; i++) &#123; H.a[i] = 1LL * (i + 1) * G.a[i+1] % mod; &#125; poly B(N+1); int _ = 1; for (int i = 1; i &lt;= N; i++) &#123; B.a[i] = 1LL * (_ - 1) * G.a[i-1] % mod; _ = 1LL * _ * 2 % mod; &#125; poly C(N); for (int i = 0; i &lt; N; i++) &#123; C.a[i] = B.a[i+1]; &#125; poly lnH = polyLn(H); poly dC(N-1); for (int i = 0; i &lt; N-1; i++) &#123; dC.a[i] = 1LL * C.a[i+1] * (i+1) % mod; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); if (n == 1) &#123; puts("1"); continue; &#125; poly nH = poly(n); for (int i = 0; i &lt; n; i++) &#123; nH.a[i] = 1LL * lnH.a[i] * (mod - (n - 1)) % mod; &#125; poly res = polyExp(nH) * dC; int ans = 1LL * res.a[n - 2] * qpow(n - 1, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5828] ËæπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F10%2FLuogu5828%2F</url>
    <content type="text"><![CDATA[‰πãÂâçËØïÂõæÈÄöËøáÁî®Ê†ëÁöÑÁîüÊàêÂáΩÊï∞Â§çÂêàËæπÂèåÁöÑÁîüÊàêÂáΩÊï∞Êù•ÂæóÂà∞Á≠îÊ°à...‰ΩÜÊòØÈóÆÈ¢ò‰ºº‰πéÁ≠â‰ª∑‰∫éÂ∑≤Áü• \(F(x), H(x)\)Ôºå\(F(G(x)) = H(x)\)ÔºåÊ±Ç \([x^n] G(x)\)„ÄÇÊàë‰∏çÊòØÂæà‰ºöÔºåÂ¶ÇÊûúÊúâ‰∫∫‰ºöÁöÑËØùÊ±ÇÊïôÊàë‰∏Ä‰∏ã /kel„ÄÇ ‰∏ãÈù¢ÂÜôÁöÑÊòØÈ¢òËß£ÂÅöÊ≥ï„ÄÇ UPDÔºöÊ†ëÁöÑÁîüÊàêÂáΩÊï∞ÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁúãÂÅö‰∏Ä‰∏™ÊãâÊ†ºÊúóÊó•ÂèçÊºîÁöÑÁªìÊûú..ÊâÄ‰ª•ÊÑüÊÄßÁêÜËß£‰∏Ä‰∏ãÂèØ‰ª•ÁªïËøá‰∏äÈù¢ÈÇ£‰∏™ÂºèÂ≠êÊòØ‰∏Ä‰∏™ÂæàËá™ÁÑ∂ÁöÑ‰∏úË•ø„ÄÇ(Á∫ØÂ±ûËÉ°Ë®Ä‰π±ËØ≠) ÂÅöÊ≥ï ËÆæÊúâÊ†πËæπÂèåÂíåÊúâÊ†πËøûÈÄöÂõæ (ÊúâÊ†πÂ∞±ÊòØÈí¶ÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπ‰ΩúÊ†π) ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÂåÖÂê´Á©∫Âõæ) ‰ºóÊâÄÂë®Áü•ÔºåËÆæÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(H(x)\)ÔºåÂàôËøûÈÄöÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(\ln H(x)\)ÔºåÊâÄ‰ª• \(G(x) = \frac {xH&#39;(x)} {H(x)}\) (‰∏çÁî®ÁúüÁöÑÊåâÁÖßËøô‰∏™ÂºèÂ≠êÂéªÁÆóÔºåÂ∞±ÊòØÁ¨¨ \(i\) È°π‰πò‰ª• \(i\) ÁöÑÊÑèÊÄù)„ÄÇ ËÄÉËôëÊ†πÊâÄÂú®ÁöÑËæπÂèåÊÅ∞Â•Ω‰∏∫ \(n\) ÁöÑËøûÈÄöÂõæÊï∞ÔºåËøôÊ†∑ÁöÑËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ÊòØ \(x^n f_n \sum_k n^k \frac{G^k(x)}{k!}=x^nf_n\exp(nG(x))\)„ÄÇ ÊâÄ‰ª•Êúâ \(G(x) = \sum_{n \ge 1} f_n (x\exp G(x))^n=F(x\exp G(x))\)„ÄÇ ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \([x^n] F(x) = \frac 1 n[x^{-1}]\frac {G&#39;(x)}{(x\exp G(x))^n}\) ÊàëÈÄâÊã©Ë¥¥Êùø üíäüíäüíä ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; poly G, dG; &#123; int n = 100000; poly H(n + 1); for (int i = 0; i &lt;= n; i++) &#123; H.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnH = polyLn(H); G = poly(n + 1); for (int i = 1; i &lt;= n; i++) &#123; G.a[i] = 1LL * lnH.a[i] * i % mod; &#125; dG = poly(n); for (int i = 0; i &lt; n; i++) &#123; dG.a[i] = 1LL * G.a[i+1] * (i+1) % mod; &#125; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); poly nG = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nG.a[i] = 1LL * G.a[i] * (mod - n) % mod; &#125; poly res = polyExp(nG) * dG; int ans = 1LL * res.a[n-1] * qpow(n, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3684] Â§ßÊúãÂèãÂíåÂ§öÂèâÊ†ë]]></title>
    <url>%2F2020%2F05%2F10%2Fbzoj3684%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÁÇπÊùÉ‰∏∫ \(k\) ÁöÑÊ†ëÊúâ \(a_k\) Ê£µÔºåËÆæ \(A(x) = \sum_{i\ge 1} a_i x^i\) ËÆæ \(D(x) = \sum x^{d_i}\) Êúâ \(A(x) = D(A(x)) + x\)„ÄÇËÆæ \(C(x) = x - D(x)\)ÔºåÂàô \(C(A(x)) = x\) ÂÖ∂‰∏≠ \(C\) Âíå \(A\) ÈÉΩÊòØÊ≤°ÊúâÂ∏∏Êï∞È°π‰∏î‰∏ÄÊ¨°È°π‰∏∫ \(1\) ÁöÑÂ§öÈ°πÂºè„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \([x^s] A(x)\)Ôºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºö\([x^s] A(x) = \frac 1 s [x^{-1}] \frac 1 {C^s(x)}\) ËÆæ \(C(x) = xP(x)\)ÔºåÂàô \([x^s]A(x) = \frac 1 s [x^{s-1}] \frac 1 {P^s(x)}\) Ê±Ç‰∏™ÈÄÜÁÑ∂ÂêéÂ§öÈ°πÂºèÂø´ÈÄüÂπÇ‰∏Ä‰∏ãÂç≥ÂèØÔºå‰πüÂèØ‰ª•ÂÖà \(\ln\) ÂÜç \(\exp\)„ÄÇ BZOJ ‰∏äÂø´ÈÄüÂπÇ T ‰∫ÜÔºå‰ΩÜÊòØË¥¥‰∫Ü‰∏™ÊùøÂ≠êÊîπÊàê \(\ln\) + \(\exp\) Â∞±Ëøá‰∫ÜÔºåÁúã‰∫ÜÁ°ÆÂÆûÊòØÊØîÂø´ÈÄüÂπÇÂø´ÁöÑ„ÄÇ (BZOJ Á°ÆÂÆûÂ§™ÊÖ¢‰∫Ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 950009857;const int maxn = 100010;int g = 0;int s, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int wl[21];vector&lt;int&gt; vp;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int checkg(int g) &#123; int ok = 1; for (int i = 0; i &lt; vp.size(); i++) &#123; int p = vp[i]; if (qpow(g, (mod - 1) / p) == 1) &#123; ok = 0; &#125; &#125; return ok;&#125;struct poly &#123; int *a, len; poly (int len_=0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int _wl = wl[++ _]; for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = mo(v1 + v2); a[s + i + (len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL * w * _wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * inv * a[i] % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l - i]); &#125; &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int _l = 0; while ((1 &lt;&lt; _l) &lt; ret.len) &#123; ++ _l; &#125; int l = (1 &lt;&lt; _l); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, _l, 1), ntt(wb, _l, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, _l, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly qpow(poly p, int x) &#123; int l = p.len; poly ret(1); ret.a[0] = 1; while (x) &#123; if (x &amp; 1) &#123; ret = ret * p; ret.len = l; &#125; x &gt;&gt;= 1; p = p * p; p.len = l; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0 (tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; v0.a[0] = (v0.a[0] + mod - 2) % mod; for (int i = 0; i &lt; p.len; i++) &#123; v0.a[i] = (mod - v0.a[i]) % mod; &#125; v0.len = p.len; poly v1 = v0 * r0; v1.len = p.len; return v1;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;int main() &#123; &#123; int _ = mod - 1; for (int i = 2; i * i &lt;= _; i++) &#123; if (_ % i == 0) &#123; vp.push_back(i); while (_ % i == 0) &#123; _ /= i; &#125; &#125; &#125; if (_ &gt; 1) &#123; vp.push_back(_); &#125; for (int i = 2; i &lt;= mod; i++) &#123; if (checkg(i)) &#123; g = i; break; &#125; &#125; &#125; for (int i = 0; i &lt;= 20; i++) &#123; wl[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; scanf("%d%d", &amp;s, &amp;m); poly P(s); for (int i = 1; i &lt;= m; i++) &#123; int x = 0; scanf("%d", &amp;x); P.a[x - 1] = mod - 1; &#125; P.a[0] = 1; poly lnP = polyLn(P); int t = (mod - s) % mod; for (int i = 0; i &lt; lnP.len; i++) &#123; lnP.a[i] = 1LL * lnP.a[i] * t % mod; &#125; poly res = polyExp(lnP); int ans = 1LL * qpow(s, mod-2) * res.a[s-1] % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(C(x) = \sum x^{c_i}\)Ôºå\(a_i\) ÊòØÊùÉÂÄºÂíå‰∏∫ \(i\) ÁöÑ‰∫åÂèâÊ†ëÊï∞Èáè (ÁâπÂà´Âú∞ÔºåÁ©∫‰∫åÂèâÊ†ëÁÆó‰Ωú‰∏ÄÁßçÊùÉÂÄºÂíå‰∏∫ \(0\) ÁöÑ‰∫åÂèâÊ†ë)Ôºå\(A(x) = \sum_{i \ge 0} a_ix^i\)„ÄÇ Âàô \(A(x) = A^2(x)C(x)+ 1\)Ôºå\(C(x)A^2(x)-A(x)+1=0\)„ÄÇÁî±‰∏ÄÂÖÉ‰∫åÊ¨°ÊñπÁ®ãÊ±ÇÊ†πÂÖ¨ÂºèÂæó \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)ÔºåÁî±‰∫éÂàÜÊØçÊ≤°ÊúâÂ∏∏Êï∞È°πÔºåËøôÈáåÂ∫îËØ•ÂèñË¥üÂè∑„ÄÇ ‰∫éÊòØÂ§öÈ°πÂºèÂºÄÊ†π‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇ(Âõ†‰∏∫ \([x^0] (1-4C(x)) = 1\)ÔºåÂè™Â≠òÂú®‰∏§‰∏™ÁöÑÂ§öÈ°πÂºè \(F(x)\) Êª°Ë∂≥ \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)Ôºå‰∏ÄÊ≠£‰∏ÄË¥ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[Á•û‰ªôÈ¢òÔºå‰πãÂâçÂê¨‰∫∫ÊèêËøá„ÄÇ‰ΩÜÊòØÂá∏ÊÄßÂÆåÂÖ®‰∏ç‰ºöËØÅÔºå‰ºö‰∫Ü‰πãÂêéË°•‰∏ä QwQ„ÄÇ ÂÅöÊ≥ï ÊòæÁÑ∂‰Ωø \(\sum s_i^2\) ÂèñÂà∞ÊúÄÂ∞èÂÄºÁöÑÂàíÂàÜ‰∏ÄÂÆöÊª°Ë∂≥Êù°‰ª∂„ÄÇ ÊâÄ‰ª•‰∫åÂàÜÊñúÁéáÊ±ÇÂá∫ \(\sum s_i^2\) ÊúÄÂ∞èÁöÑÂ∫èÂàóÂ∞±Ë°å‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éÊàëÊ∞¥Âπ≥Â§™‰ΩéÊôÆÂèäÁªÑÁü•ËØÜÁÇπÈÉΩÊ≤°ÊéåÊè°Ôºå‰ªäÂ§©Áªà‰∫éÊêûÊáÇ‰∫Ü‰∏ÄÁÇπÊâÄ‰ª•ÊâìÁÆóËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢ËÆ®ËÆ∫ÁöÑÈÉΩÊòØÊó†ÂêëÂõæÔºåÁî±‰∫éËøûÈÄöÂùóÈó¥Áã¨Á´ãÔºåÊàë‰ª¨Âè™ËÄÉËôëËøûÈÄöÂõæÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûúÁÇπÊï∞‰∏∫ \(1\)ÔºåÂú®Êüê‰∫õÈóÆÈ¢ò‰∏ãÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Âè™ËÄÉËôëÁÇπÊï∞‰∏ç‰∏∫ \(1\) ÁöÑÊÉÖÂÜµ„ÄÇ ÂÆö‰πâ 1 ÂØπ‰∫é‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\)ÔºåÂ¶ÇÊûú‰ªé \(G\) Âà†ÂéªÁÇπ \(u\) ÂíåÊâÄÊúâ‰∏éÂÆÉÁõ∏ÈÇªÁöÑËæπÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄöÔºåÂ∞±Áß∞ \(u\) ÊòØ \(G\) ÁöÑ‰∏Ä‰∏™Ââ≤ÁÇπ„ÄÇ ÂÆö‰πâ 2 Ëã•ËøûÈÄöÂõæ \(G\) ‰∏≠‰∏çÂ≠òÂú®Ââ≤ÁÇπÔºåÂàôÁß∞ \(G\) ÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂõæ„ÄÇ ÂÆö‰πâ 3 Áß∞ËøûÈÄöÂõæ \(G\) ÁöÑÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂõæÂ≠êÂõæ‰∏∫ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇ ÊÄßË¥® 1 ‰∏§‰∏™‰∏çÂêåÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑ‰∫§Ëá≥Â§öÂåÖÂê´‰∏Ä‰∏™ÁÇπ„ÄÇ ËØÅÊòé ÂÅáËÆæ‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè \(A\) Âíå \(B\) Êúâ‰∫§ÔºåËÆæËøô‰∏§‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂπ∂‰∏∫ \(H\)ÔºåÊ†πÊçÆÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂÆö‰πâÔºå\(H\) ‰∏ÄÂÆö‰∏çÊòØÁÇπÂèåËøûÈÄöÂõæÔºåÊâÄ‰ª•Â≠òÂú®‰∏Ä‰∏™ÁÇπ \(u\)Ôºå‰ªé \(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂêéÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄö„ÄÇ\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæÂç≥‰∏∫ \(A\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) Âíå \(B\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) ÂæóÂà∞ÁöÑÂõæÁöÑÂπ∂„ÄÇÂ¶ÇÊûú \(A\) Âíå \(B\) ÁöÑ‰∫§Â§ß‰∫é \(1\)ÔºåÁî±‰∫é‰∏§‰∏™Êúâ‰∫§ÁöÑËøûÈÄöÂõæÁöÑÂπ∂‰ªç‰∏∫ËøûÈÄöÂõæÔºå\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæ‰πüÊòØËøûÈÄöÂõæÔºåËøôÂ∞±ÂØºÂá∫‰∫ÜÁüõÁõæ„ÄÇ ÊÄßË¥® 2 Âú®‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\) ‰∏≠ÔºåÂØπ‰∫é‰ªªÊÑè‰∏ÄÊù°Ëæπ \(e\)ÔºåÊÅ∞Êúâ‰∏Ä‰∏™ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÂåÖÂê´Ëæπ \(e\)„ÄÇ ËØÅÊòé Ëæπ \(e\) ÁöÑ‰∏§‰∏™È°∂ÁÇπÁöÑÂØºÂá∫Â≠êÂõæÂ∞±ÊòØ‰∏Ä‰∏™ \(G\) ÁöÑÂ§ßÂ∞è‰∏∫ \(2\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª•‰πü‰∏ÄÂÆöÂ≠òÂú®ÂåÖÂê´Ëæπ \(e\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÁî±ÊÄßË¥® 1 ÂèØÁü•‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏çÂèØËÉΩÂåÖÂê´Âêå‰∏ÄÊù°Ëæπ„ÄÇ Áî±‰∫éÁÇπÂèåËøûÈÄöÂàÜÈáèÊòØËøûÈÄöÁöÑÔºåÂè™Ë¶ÅÁ°ÆÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâËæπÔºåÁÇπ‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÂõæ \(G\) ÁöÑÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÊûÑÊàêËæπÈõÜÁöÑ‰∏Ä‰∏™ÂàíÂàÜ„ÄÇ Âú®Âõæ‰∏ä‰Ωú DFSÔºåÂèñ‰∏ÄÊ£µ‰ª• \(r\) ‰∏∫Ê†πÁöÑ DFS Ê†ëÔºåËÆæÁÇπ \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´ËÆøÈóÆÊó∂Èó¥‰∏∫ \(dfn_u\)Ôºå\(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÈÄöËøá‰∏ÄÊù°ËøîÁ•ñËæπËÉΩÂ§üÂà∞ËææÁöÑ dfn ÊúÄÂ∞èÁöÑÁÇπÁöÑ dfn ‰∏é \(dfn_u\) ÁöÑÊúÄÂ∞èÂÄº‰∏∫ \(low_u\) (Ê≥®ÊÑèËøîÁ•ñËæπÊåáÁöÑÊòØÈùûÊ†ëËæπÔºå‰∏çÂåÖÂê´ \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÔºåÂÆûÁé∞Êó∂Ë¶ÅÁâπÂà§)„ÄÇ ËÆæÁÇπ \(u\) Âú®ËøôÊ£µ DFS Ê†ë‰∏äÁöÑÁà∂‰∫≤‰∏∫ \(fa(u)\)„ÄÇ ÂØπ‰∫éÁÇπ \(u \neq r, fa(u) \neq r\)ÔºåÂ¶ÇÊûú \(low_u &lt; dfn_{fa(u)}\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ÁÇπ \(u, fa(u), fa(fa(u))\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºå‰ªéËÄå \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÂíå \(fa(u)\) Âà∞Áà∂‰∫≤ÁöÑËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ Âú® DFS ÁöÑËøáÁ®ã‰∏≠ÔºåÊØèÁªèËøá‰∏ÄÊù°Ê†ëËæπÂ∞±ÊääËøôÊù°Ê†ëËæπÊîæÂÖ•‰∏Ä‰∏™Ê†à‰∏≠„ÄÇÂú®ÁÇπ \(u\) ÂõûÊ∫ØÊó∂ÔºåÊ£ÄÊü•‰∏Ä‰∏ãÊòØÂê¶Êúâ \(low_u \ge dfn_{fa(u)}\) (Â¶ÇÊûúÊòØÊ†πÁöÑËØù‰∏çÁî®Ê£ÄÊü•‰∫Ü)„ÄÇ ËÄÉËôëÁ¨¨‰∏ÄÊ¨°Êª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂõûÊ∫ØÔºåÊ≠§Êó∂ÁÇπ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπÈÉΩÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÔºåÂõ†Ê≠§Â≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæ„ÄÇÂõ†‰∏∫‰∏çÂ≠òÂú®Ë∑®Ëøá \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÁöÑÈùûÊ†ëËæπÔºåËøô‰∏™ÁÇπÂèåËøûÈÄöÂ≠êÂõæÊòØ‰∏Ä‰∏™ÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª• \(u\) ÁöÑÂ≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊàë‰ª¨ÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÁÇπ‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂Âêé‰ªéÊ†à‰∏≠ÂºπÂá∫ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπ„ÄÇ Âú®‰πãÂêéÁöÑÂõûÊ∫Ø‰∏≠ÔºåÂ¶ÇÊûúÊª°Ë∂≥ \(low_u \ge dfn_{fa(u)}\)ÔºåÈÇ£‰πàÊ≠§Êó∂Ê†à‰∏≠ÊâÄÊúâÊ†ëËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠Ôºå‰∏îËøô‰∫õËæπÁöÑÊâÄÊúâÁ´ØÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰øùÂ≠ò‰∏ãÊù•ÁÑ∂ÂêéÊääÊ†à‰∏≠ÊâÄÊúâ \(u\) Â≠êÊ†ë‰∏≠ÁöÑËæπÂºπÂá∫Âç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n+m)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫‰∫ÜÊØè‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁÇπÈõÜ„ÄÇ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑËæπÂ∞±ÊòØËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÂÜÖÈÉ®ÁöÑÊ†ëËæπÂä†‰∏äËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâÁÇπÁöÑËøîÁ•ñËæπÔºåËøôÂæàÂÆπÊòìÂ§ÑÁêÜ„ÄÇÔºàÊ≥®ÊÑèËøôÈáåËøîÁ•ñËæπÁöÑÂÆö‰πâÊòØ‰ªéÊüê‰∏™ÁÇπÂá∫ÂèëÂà∞ÂÆÉÁ•ñÂÖàÁöÑÈùûÊ†ëËæπÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÊØèÊù°ÈùûÊ†ëËæπÊòØÊÅ∞Â•Ω‰∏Ä‰∏™ÁÇπÁöÑËøîÁ•ñËæπÔºâ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏Ä‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°àÊï∞Á≠â‰∫éÂêÑ‰∏™ÁÇπÂèåÁöÑÊüìËâ≤ÊñπÊ°àÊï∞‰πòÁßØÈô§‰ª•È¢úËâ≤Êï∞ÁöÑ(ÁÇπÂèåÊï∞ - ËøûÈÄöÂùóÊï∞)Ê¨°ÊñπÔºàËÄÉËôëÂØπÊØè‰∏™ËøûÈÄöÂùóÂú®ÂúÜÊñπÊ†ë‰∏ä‰ªé‰∏äÂæÄ‰∏ãÂØπÊØè‰∏™ÁÇπÂèåÊüìËâ≤Ôºâ„ÄÇ Ê†πÊçÆÈ¢òÁõÆ‰∏≠ÁöÑÊù°‰ª∂Ôºå‰∏Ä‰∏™ÁÇπÂèåÁöÑÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøá \(7\)ÔºåÊö¥ÂäõÊûö‰∏æÈõÜÂêàÂàíÂàÜÂèØ‰ª•Ê±ÇÂá∫‰∏Ä‰∏™ÁÇπÂèåÁöÑËâ≤Â§öÈ°πÂºèÔºåÂàÜÊ≤ª fft ‰∏Ä‰∏ãÂç≥ÂèØÂæóÂà∞ÁªôÂÆöÁöÑÂõæÁöÑËâ≤Â§öÈ°πÂºèÔºåÁÑ∂ÂêéÂ§öÁÇπÊ±ÇÂÄº‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ (‰∏∫Âï•‰∏ÄÂÆöË¶ÅÁªôÂêÑÁßçÊüìËâ≤ÊñπÊ°àÊï∞È¢òÂ•ó‰∏™Â§öÁÇπÊ±ÇÂÄº...Â•ΩÊó†ËÅä) ÂÆåÂÖ®‰∏ç‰ºöÂÜôÁÇπÂèå..Ë∞É‰∫Ü‰∏ÄÂ§©„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// Á¨¨‰∏ÄÁ±ªÊñØÁâπÊûóÊï∞int S[10][10];// ‰∏ãÈôçÂπÇÁ≥ªÊï∞int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268E] Expected Value]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(f_i\) ÊòØÁ¨¨ \(i\) Ê≠•Êó∂ÊÅ∞Â•ΩÂà∞ËææÁÇπ \(n\) ÁöÑÊ¶ÇÁéáÔºåÊòæÁÑ∂Êï∞Âàó \(\{f_i\}\) Êª°Ë∂≥‰∏Ä‰∏™‰∏çË∂ÖËøá \(n\) Èò∂ÁöÑÁ∫øÊÄßÈÄíÊé®„ÄÇ Âõ†‰∏∫ÁªôÂÆöÁöÑÂõæÊòØÂπ≥Èù¢ÂõæÔºåÊâÄ‰ª• \(m = \mathcal O(n)\)ÔºåÊàë‰ª¨ÂèØ‰ª•Êö¥ÂäõÊ±ÇÂá∫ \(f\) ÁöÑÂâç \(2n\) È°πÔºåÁÑ∂Âêé BM Âá∫ÈÄíÊé®Âºè„ÄÇÂæóÂà∞ÈÄíÊé®Âºè‰πãÂêé‰πüÂ∞±ÂæóÂà∞‰∫ÜÁîüÊàêÂáΩÊï∞ÔºåÊ±Ç‰∏™ÂØºÊää \(x=1\) ‰ª£ÂÖ•Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[ÂêêÊßΩÔºöËøôÈ¢òÁõÆÂêçÂèñÁöÑ„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÂÅöÊ≥ï Ë¶ÅÊòØ‰∏çÊòØÈ¢ÑÂÖàÁü•ÈÅìÊòØ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖç‰º∞ËÆ°‰∏ÄÊòüÊúüÈÉΩÊÉ≥‰∏çÂà∞„ÄÇ„ÄÇ ËÄÉËôëÊûÑÈÄ†‰∏Ä‰∏™Êó†ÂêëÂõæÔºåÁÑ∂ÂêéÁî®‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖçÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ ÂØπÊØè‰∏™ . Âª∫‰∏Ä‰∏™ÁÇπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ +ÔºåÈÇ£‰πàÂª∫‰∏§‰∏™Êñ∞ÁöÑÁÇπÔºå‰∏§‰∏™Êñ∞ÁöÑÁÇπÈÉΩÂêëÂÆÉÂõõÂë®ÁöÑ . ÂØπÂ∫îÁöÑÁÇπËøûËæπÔºåÁÑ∂Âêé‰∏§‰∏™Êñ∞ÁÇπ‰πãÈó¥Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ *ÔºåÂª∫‰∏§‰∏™Êñ∞ÁÇπÔºå‰∏Ä‰∏™Âêë‰∏ä‰∏ãÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°ËæπÔºå‰∏Ä‰∏™ÂêëÂ∑¶Âè≥ÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°Ëæπ„ÄÇËøôÊ†∑Ëøô‰∏™ÂõæÁöÑÊúÄÂ§ßÂåπÈÖçÂáèÂéª * Âíå + ÁöÑ‰∏™Êï∞Â∞±ÊòØÁ≠îÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÁêÜËÆ∫ÂèØ‰ª•ÂÅöÂà∞ \(\mathcal O(n^2m^2)\)ÔºåÂèØËøá„ÄÇ ÁÑ∂ËÄåÊàëÂÜôÁöÑËøô‰∏™Â∏¶Ëä±Ê†ë‰ºº‰πéÊòØ‰∏âÊñπÁöÑÔºå‰ΩÜÂÆÉ‰πüËøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]„ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçtree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫é‰∏ÄÊù°ÈìæÔºåÂÅáËÆæÂÆÉ‰ªéÊüê‰∏ÄÁ´ØÂºÄÂßãÁ¨¨‰∏Ä‰∏™Â§ß‰∫é \(1\) ÁöÑÁÇπÁöÑÁÇπÊùÉ‰∏∫ \(x\)ÔºåËøô‰∏™ÁÇπ(ÂºÄÂßãÁöÑÈÇ£‰∏ÄÁ´ØÂà∞ÂÆÉ)‰πãÂâçÊúâ \(k\) ‰∏™ÁÇπÔºå‰πãÂêéÊúâ \(l\) ‰∏™ÁÇπÔºå‰πãÂêé \(l\) ‰∏™ÁÇπÁÇπÊùÉ‰πòÁßØ‰∏∫ \(s\)„ÄÇ ÂÅáËÆæËøôÊù°ÈìæÁöÑÁ≠îÊ°àÊØîËøô‰∏™ÁÇπÂ∑¶ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÂíåÂè≥ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÁöÑÁ≠îÊ°àÈÉΩË¶Å‰∏•Ê†º‰ºò„ÄÇ ÈÇ£‰πà \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] ÊâÄ‰ª• \(k = l\)„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰∏ÄÊù°ÈìæÊØîÂÆÉÁöÑÊâÄÊúâÂ≠êÈìæÈÉΩ‰∏•Ê†º‰ºòÔºå‰∏îËøôÊù°Èìæ‰∏äÂ≠òÂú®ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÔºåÈÇ£‰πà‰ªéÂÆÉ‰∏§Á´ØÂºÄÂßãÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÈÉΩÊòØ‰∏≠ÁÇπ„ÄÇ ÊâÄ‰ª•Âè™ÈúÄËÄÉËôëÂÖ® \(1\) ÈìæÂíå‰ª•Êüê‰∏™ÁÇπ‰∏∫‰∏≠ÁÇπÔºåÂÖ∂‰ªñÁÇπÈÉΩÊòØ \(1\) ÁöÑÈìæ„ÄÇ Êç¢Ê†π dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea Êï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[Â§™Á•û‰ªô‰∫ÜÔºåÁúã sol ‰∫Ü„ÄÇ ÂÅöÊ≥ï ÂÖàËßÑÂÆöÂΩì‰∏§‰∏™Áü≥Â≠êË∑ùÁ¶ª‰∏∫ \(1\) Êó∂Ôºå‰∏çËÉΩÁßªÂä®ÂùêÊ†áÂ∞èÁöÑÁü≥Â≠ê„ÄÇËøôÊ†∑Â∞±Âè™ÈúÄË¶ÅÂØπÊìç‰ΩúÂ∫èÂàóËÆ°Êï∞‰∫Ü„ÄÇ ËÄÉËôëÂØπÊúâ \(K\) ‰∏™ÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÊñπÊ°àËÆ°Êï∞„ÄÇ\(K = N\) ÁöÑÊÉÖÂÜµÂæàÂÆπÊòìÂçïÁã¨ËÄÉËôë„ÄÇ ÂØπ‰∫é \(K &lt; N\) ÁöÑÊÉÖÂÜµÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÁ°ÆÂÆö‰∫ÜÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÔºåËÄÉËôë‰∏Ä‰∏™Â∫èÂàó \(s\)ÔºåËã•Á¨¨ \(i\) ‰∏™ÊääÊüêÁü≥Â≠êÂùêÊ†á \(+1\) Êìç‰ΩúÁßªÂä®ÁöÑÊòØÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÔºå\(s_i = -1\)ÔºåÂê¶Âàô \(s_i = 1\)„ÄÇËøôÊ†∑ÁöÑ‰∏Ä‰∏™Â∫èÂàó \(s\) ÊòæÁÑ∂Êª°Ë∂≥ \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)„ÄÇÂØπ‰∫é‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂ∫èÂàó \(s\)ÔºåÊàë‰ª¨Êù•ËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊää‚ÄúÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂùêÊ†áÂ§ßÁöÑÁü≥Â≠êÁöÑ‰ΩçÁΩÆ‚ÄùÁöÑÊìç‰ΩúÊèíÂÖ•Âà∞Ëøô‰∏™ÔºàÂè™ÂåÖÂê´ÊääÊüêÁü≥Â≠êÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÔºâÊìç‰ΩúÂ∫èÂàó‰πã‰∏≠ÁöÑÊñπÊ°à„ÄÇÊòæÁÑ∂ \(s\) ‰∏≠Êúâ \(B\) ‰∏™ \(1\)Ôºå\(K-B\) ‰∏™ \(-1\)„ÄÇÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÊèíÂú® \(s_i\) ÂØπÂ∫îÁöÑÊìç‰ΩúÂíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥ÔºåÈÇ£‰πà \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)„ÄÇËÆæ \(t_i = \sum_{k \le i} s_k\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êìç‰ΩúË¢´ÊèíÂÖ•Âú® \(s_i\) Âíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥Ôºå‰∏îÂ≠òÂú® \(j &gt; i\)Ôºå\(t_j \le t_i\)ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∫èÂàó‰∏ÄÂÆö‰∏çÂêàÊ≥ï„ÄÇÊâÄ‰ª•ÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰Ωú‰∏ÄÂÆöÂú® \(t_i = B-(K-B)-(B-A)=B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥ÔºåÂÖ∂‰ªñÊìç‰ΩúÂøÖÈ°ªÊèíÂÖ•ÊúÄÂêé‰∏Ä‰∏™ \(t_i = x, x \le B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥Ôºå‰∏îÂè™Ë¶ÅÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÂæóÂà∞ÁöÑÂ∞±ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ‰∫éÊòØÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÊ±ÇÊää \(N-K-1\) ÊãÜÊàê \(B+A-K+1\) ‰∏™ÈùûË¥üÊï¥Êï∞‰πãÂíåÁöÑÊñπÊ°àÊï∞ÔºåËøôÂæàÂÆπÊòìÁî®‰∏Ä‰∏™ÁªÑÂêàÊï∞ËÆ°ÁÆó„ÄÇÊ≥®ÊÑèÂà∞ÂØπ‰∫é‰∏çÂêåÁöÑ \(s\)ÔºåÊèíÂÖ•Êìç‰ΩúÁöÑÊñπÊ°à‰πãÂíå \(K\) ÊúâÂÖ≥ÔºåÊâÄ‰ª•Êàë‰ª¨Êûö‰∏æ \(K\) ÁªüËÆ°Á≠îÊ°àÂç≥ÂèØ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂØπÂ∫îÁöÑ \(K\)ÔºåËÆ°ÁÆóÂØπÂ∫îÁöÑ \(s\) ÁöÑ‰∏™Êï∞ÊòØ‰∏Ä‰∏™Á±ª‰ººÂç°ÁâπÂÖ∞Êï∞ÁöÑÈóÆÈ¢òÔºå‰∏ç‰ºöÁöÑËØùÂèØ‰ª•ÂéªÁúãÁúã AGC021E„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ balancer \((x_i,y_i)\)ÔºåÂ∞±Âú®ÁÇπ \(x_i\) ÂíåÁÇπ \(y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Ê†áÂè∑‰∏∫ \(i\) ÁöÑÊó†ÂêëËæπ„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö\(T=1\) ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëÊâÄÊúâË¢´Áî®Ëøá balancerÔºåÂèØ‰ª•ÂèëÁé∞ÂÆÉ‰ª¨ÂØπÂ∫îÁöÑËæπÊûÑÊàêÁöÑÂ≠êÂõæ‰∏ÄÂÆöÊòØ \(G\) ÁöÑ‰∏ÄÊ£µÁîüÊàêÊ†ëÔºå‰∏îÂ¶ÇÊûúÊääÊúÄÂêéÁªàÊ≠¢ÁöÑ wire ‰Ωú‰∏∫Ê†πÔºåÊØè‰∏™ÁÇπÂà∞ÂÆÉÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÈÉΩÂ∞è‰∫éÂÆÉÁà∂‰∫≤Âà∞ÂÆÉÁà∂‰∫≤ÁöÑÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ„ÄÇÂèçËøáÊù•ÔºåÂÆπÊòìÈ™åËØÅÂ¶ÇÊûúÂ≠òÂú®‰∏ÄÊ£µËøôÊ†∑ÁöÑÁîüÊàêÊ†ëÔºåÈÇ£‰πà‰πüÂ≠òÂú®‰∏ÄÁßçÂêàÊ≥ïÊñπÊ°à„ÄÇ Êää balancer ‰Ωú‰∏∫ÁÇπÂª∫‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂ¶ÇÊûú balancer \(i,j\) ÈÉΩËøûÊé•‰∫ÜÊüê‰∏™ wireÔºå‰∏î \(i &lt; j\)ÔºåÂ∞±‰ªé \(j\) Âà∞ \(i\) Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÂêàÊ≥ïÊñπÊ°àÔºå‰∏ÄÂÆöÂèØ‰ª•‰ªéËøô‰∏™Âõæ‰∏äÊüê‰∏™ÁÇπÂá∫ÂèëÔºåÂà∞Ëææ‰∏éÊØè‰∏™ wire Áõ∏ËøûÁöÑËá≥Â∞ë‰∏Ä‰∏™ balancer„ÄÇÂèçËøáÊù•ÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÊ†∑‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨‰ªéËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancer ÂºÄÂßãÔºåÊåâÁºñÂè∑‰ªéÂ§ßÂà∞Â∞èËÄÉËôëÊØè‰∏™ balancer„ÄÇÁª¥Êä§‰∏Ä‰∏™ balancer ÁöÑÈõÜÂêàÔºåÂàùÂßãÊó∂Âè™ÊúâËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancerÔºåËÄÉËôëÂà∞‰∏Ä‰∏™ balancer Êó∂ÔºåÂ¶ÇÊûúÂÆÉËøûÊé•ÁöÑ‰∏Ä‰∏™ wire ÊòØÂΩìÂâçÁª¥Êä§ÁöÑÈõÜÂêà‰∏≠Êüê‰∏™ balancer ÁöÑÁ´ØÁÇπÔºåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÂ∞±ÊääËøô‰∏™ balancer Âä†ÂÖ•ÈõÜÂêà„ÄÇÊúÄÂêéÂæóÂà∞ÁöÑÈõÜÂêàÊòæÁÑ∂ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÁîüÊàêÊ†ë„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑ balancerÔºåÁÑ∂ÂêéÁî®‰ª•‰∏äÁÆóÊ≥ïÊûÑÈÄ†Âç≥ÂèØ„ÄÇ‰ºòÂåñ‰∏Ä‰∏ãÂª∫ËæπÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ wireÔºåÊää‰∏éÂÆÉÁõ∏ÈÇªÁöÑ balancer ÊéíÂ∫èÔºåÂè™ËÄÉËôëÁõ∏ÈÇªÁöÑ balancer ‰πãÈó¥ÁöÑÊúâÂêëËæπ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ DAG ‰∏ä DP ÈóÆÈ¢òÔºåÁõ¥Êé•ÂÅöÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(nm)\)ÔºåÁî® bitset ‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ËÉΩËøá‰∫Ü„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÔºö\(T=2\) ÂΩì \(n \ge 3\) Êó∂Ôºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØèÊù°ËæπÔºåÂèØ‰ª•ÂèëÁé∞ÊÄªÂ≠òÂú®‰∏ÄÁßçÊñπÊ°à‰ΩøÊâÄÊúâ wire ÊúÄÁªà‰∏çÊ±áËÅöÂú®Âêå‰∏Ä‰∏™ÁÇπ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁâπÂà§Êéâ‰∏§Ê£µÊ†ë‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊÉÖÂÜµ„ÄÇ Êûö‰∏æÁ¨¨‰∏Ä‰∏™Êìç‰ΩúÁöÑÁÇπÂèäÂÖ∂Êìç‰ΩúÊñπÂºèÔºåËÆæËøô‰∏™ÁÇπ‰∏∫ \(r\)„ÄÇÊàë‰ª¨ËÄÉËôëËøõË°åÂÆåÁ¨¨‰∏ÄÊ¨°Êìç‰ΩúÂêéÁöÑ‰∏§Ê£µÊ†ë„ÄÇ ËÆæÁ¨¨‰∏ÄÊ£µÊ†ë‰∏∫ \(T_A\)ÔºåÁ¨¨‰∫åÊ£µÊ†ë‰∏∫ \(T_B\)ÔºåÊää \(r\) ‰Ωú‰∏∫‰∏§Ê£µÊ†ëÁöÑÊ†π„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âú®ÊúâÊ†πÊ†ë‰∏äËÄÉËôëÈóÆÈ¢ò„ÄÇ ÂÅáËÆæÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°à‰∏≠Ôºå‰Ω†Âú®Êüê‰∏™Êó∂ÂàªÊääÁÇπ \(u\) ÊüìÈªëÂπ∂Êé•Âà∞ÁÇπ \(v\)ÔºåÈÇ£‰πàÂú®Ëøô‰πãÂêé \(v\) ‰ª•ÂèäÂÖ∂Á•ñÂÖà‰∏ÄÂÆöÈÉΩ‰∏çÂèØËÉΩÊòØÂè∂Â≠êÔºåÊâÄ‰ª•Ê≠§Êó∂ \(T_A\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑÁ≠â‰∫é \(T_B\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑ„ÄÇÂõ†Ê≠§ \(v\) ÂøÖÈ°ªÊòØ \(u\) Âú® \(T_B\) ‰∏äÁöÑÁà∂‰∫≤„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™ÁÇπÂàùÂßãÊó∂Âà∞Ê†πÁöÑË∑ØÂæÑÔºàÁªèËøáÁöÑÁÇπÁöÑÂ∫èÂàóÔºâÂú®‰∏§Ê£µÊ†ë‰∏ä‰∏çÂêåÔºåÊàë‰ª¨Áß∞ÂÆÉ‰∏∫‰∏çÂ•ΩÁöÑÔºåÂê¶ÂàôÊàë‰ª¨Áß∞ÂÆÉ‰∏∫Â•ΩÁöÑ„ÄÇÊòæÁÑ∂Êàë‰ª¨‰∏ç‰ºöÊüìÈªëÂ•ΩÁöÑÁÇπÔºåËÄå‰∏çÂ•ΩÁöÑÁÇπÂøÖÈ°ªË¶ÅË¢´ÊüìÈªë„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËß£ÂÜ≥ÂèØË°åÊÄßÈóÆÈ¢ò„ÄÇ ‰∫ãÂÆû‰∏äÔºåÂ≠òÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°àÁ≠â‰ª∑‰∫éÂ≠òÂú®‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÁöÑÊéíÂàóÔºå‰ΩøÂæóÔºö - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_A\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂâç„ÄÇ - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_B\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂêé„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÊòØÂê¶Â≠òÂú®ÊãìÊâëÂ∫èÁöÑÈóÆÈ¢òÔºåÂà§‰∏Ä‰∏ã DAG Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(Tn^3)\)„ÄÇÁî±‰∫éÊàëÊáíÂÜô‰∫Ü \(\mathcal O(Tn^4)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫éÁªôÂÆöÁöÑÂ∫èÂàó \(a\)ÔºåÊàë‰ª¨ÊääÂÆÉÊãÜÊàê‰∏§‰∏™ÈùûË¥üÂ∫èÂàó \(x\) Âíå \(y\) ÁöÑÂíå„ÄÇÁÑ∂Âêé‰ªÖÁî®‰∏çÂáèÂ∫èÂàóÂéªÂæóÂà∞ \(x\)Ôºå‰ªÖÁî®‰∏çÂ¢ûÂ∫èÂàóÂæóÂà∞ \(y\)„ÄÇ ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫éÈïø‰∏∫ \(k\) Â∫èÂàó \(a\) (ÂÆö‰πâ \(a_0 = a_{k+1} = 0\))ÔºåÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂâçÁºÄ‰∏çÂáèÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)ÔºõÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂêéÁºÄ‰∏çÂ¢ûÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÔºåËÄÉËôë \(i\) ‰ªéÂ∞èÂà∞Â§ßÂú∞ÂÜ≥ÂÆö \(x\) Âíå \(y\) ÁöÑÁ¨¨ \(i\) È°πÔºåÁÑ∂Âêé‰ΩøÂæóÂâç \(i\) È°π \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Â∞ΩÂèØËÉΩÂ∞è„ÄÇÁÑ∂ËÄåÁõ¥Êé•Ë¥™ÂøÉÊòØ‰∏çÂØπÁöÑ„ÄÇÊ≥®ÊÑèÂà∞ÔºåÂØπ‰∫é‰∏§Áßç \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Áõ∏Á≠âÁöÑÊñπÊ°àÔºå\(x_i\) ËæÉÂ∞èÁöÑ‰∏ÄÂÆöÊØîËæÉ‰ºòÔºåËÄå‰∏îÂ¶ÇÊûúÂâç \(i\) È°π‰∏Ä‰∏™ÊñπÊ°àÁöÑ‰ª£‰ª∑ÊØîÂâç \(i\) È°πÊúÄÂ∞è‰ª£‰ª∑ÊñπÊ°àÁöÑ‰ª£‰ª∑ËøòË¶ÅÂ§ßË∂ÖËøá \(2\)ÔºåÂÆÉ‰∏ÄÂÆö‰∏ç‰ºò„ÄÇÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊàë‰ª¨ÂèØ‰ª•Âè™‰øùÁïô‰∏â‰∏™ÊñπÊ°àÔºå‰ΩøÂæóÂÖ∂‰∏≠‰∏ÄÂÆöÊúâ‰∏Ä‰∏™Âú®‰πãÂêéÂèØ‰ª•ÂèòÊàêÊúÄ‰ºòÊñπÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // ÂÖàÂà§Êñ≠ÊòØÂê¶ÂèØËÉΩ‰∏çÂ¢ûÂä† // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // ÂÜçÂà§Êñ≠Âè™Â¢ûÂä†‰∏ÄÈ°πÔºåx ÁöÑÊúÄÂ∞èÂÄºÔºàÊòæÁÑ∂ÂèØ‰ª•Âè™Â¢ûÂä†‰∏ÄÈ°πÔºâ ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏çÂ¶®ÂÅáËÆæ \(n \ge m\)„ÄÇ Âè™‰ºö \(\mathcal O(n \log^2 n)\) Ëá™Èó≠‰∫ÜÔºåÂéªÁúãÈ¢òËß£‰∫Ü„ÄÇ Áî±‰∫é‰Ω†ÁöÑÂÜ≥Á≠ñ‰∏ç‰ºöÂΩ±Âìç‰πãÂêéÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°àÔºåÊâÄ‰ª•ÊòæÁÑ∂ÊØèÊ¨°ÈÄâÊ¶ÇÁéáÂ§ßÁöÑÂ∞±ÊØîËæÉÂ•Ω„ÄÇ ËÆæÁ¨¨ \(k+1\) ‰∏™ÈóÆÈ¢òËÉΩÂ§üÁ≠îÂØπÁöÑÊ¶ÇÁéá‰∏∫ \(p_k\)ÔºåÂÅáËÆæÂâç \(k\) ‰∏™ÈóÆÈ¢ò‰∏≠Á≠îÂØπ‰∫Ü \(a\) ‰∏™ÔºåÈÇ£‰πà \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] ÂàÜ‰∏∫ \(n - a &lt; m - (k - a)\) Âíå \(n-a \ge m - (k - a)\) ËÆ°ÁÆóË¥°ÁåÆ„ÄÇ ËÆæ \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] Á¨¨‰∫åÈÉ®ÂàÜ \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] Âø´ÈÄüËÆ°ÁÆó \(H,G\) ÁöÑÊÑè‰πâÊòØÊúâÂ§öÂ∞ëÊù°‰ªé \((0,0)\) Âà∞ \((n,m)\) ÁöÑÈùûÈôçË∑ØÂæÑ‰∏éÁõ¥Á∫ø \(x+y = s\) ÁöÑ‰∫§ÁÇπÁöÑÊ®™ÂùêÊ†áÂú®Êüê‰∏™ËåÉÂõ¥ÂÜÖ„ÄÇ Áî±Ëøô‰∏™ÁªÑÂêàÊÑè‰πâÂæàÂÆπÊòìÂæóÂá∫ \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] ÊâÄ‰ª•Êàë‰ª¨‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æ \(k\) Á∫øÊÄßÁª¥Êä§ \(H\) Âíå \(G\) ÈúÄË¶ÅÁî®Âà∞ÁöÑÂÄºÔºåÂ∞±Âú® \(\mathcal O(n)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∫§Êç¢ÔºåÂ¶ÇÊûú‰∫§Êç¢ÁöÑÊòØ \(a_i\) Âíå \(a_j\)ÔºåÂú®ÁÇπ \(i\) ÂíåÁÇπ \(j\) ‰πãÈó¥Ëøû‰∏ÄÊù°ËæπÔºåÊ†áÂè∑‰∏∫ \(i\)„ÄÇ ËÆæ \(S_1\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_2\) ÊòØÊâÄÊúâ‰∏§‰∏™Â∫èÂàó‰∏≠ÈÉΩÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_3\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêà„ÄÇ \(S_1\) Âíå \(S_3\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(1\)Ôºå\(S_2\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(2\)„ÄÇ‰∏çÈöæËØÅÊòéÔºåÂ¶ÇÊûúÊúÄÁªà‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ \(G\) ÁöÑ‰∏Ä‰∏™ËøûÈÄöÂùóË¶Å‰πàÊòØ‰∏ÄÊù° \(S_1\) ‰∏≠ÁÇπÂà∞ \(S_3\) ‰∏≠ÁÇπÁöÑË∑ØÂæÑÔºåË¶Å‰πàÊòØ‰∏Ä‰∏™ \(S_2\) ÂÜÖÈÉ®ÁöÑÁéØ„ÄÇ ËÄÉËôëÂØπËÉΩ‰Ωø‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ÁöÑÂõæÁöÑÂΩ¢ÊÄÅÂíåËæπÁöÑÊ†áÂè∑ËÆ°Êï∞ÔºåÈÇ£‰πàÔºåÂØπ‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂõæ \(G\)Ôºå‰∏Ä‰∏™ÁéØ‰∏äÁöÑÊ†áÂè∑È°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºå‰∏ÄÊù°ÈìæÊ†áÂè∑‰∏ÄÂÆöÊòØ‰ªé \(S_1\) ‰∏Ä‰æßÂà∞ \(S_3\) ‰∏Ä‰æßÈÄíÂ¢û„ÄÇÊâÄ‰ª•Â¶ÇÊûúÂÜ≥ÂÆö‰∫Ü \(G\)ÔºåÂèØ‰ª•ÂÖàÂÜ≥ÂÆöÊØè‰∏™ËøûÈÄöÂùóÁöÑËæπÁî®Âì™‰∫õÊ†áÂè∑ÔºåÁÑ∂ÂêéÂØπ‰∫éÁéØÂèØ‰ª•‰ªªÊÑèÊéíÂàóÔºåÈìæÂè™Êúâ‰∏ÄÁßçÊ†áÂè∑ÊñπÂºè„ÄÇ ËÄÉËôëÂÜ≥ÂÆö \(S_2\) ‰∏≠ÁöÑÂõæÁöÑÁªìÊûÑÔºåÊàë‰ª¨ÂèØ‰ª•ÂÜôÂá∫ÁéØÂíåÈìæÁöÑ EGFÔºå\(C(x)\) Âíå \(P(x)\)„ÄÇ \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) È¢òÁõÆ‰∏≠Ë¶ÅÊ±ÇÁöÑÂç≥ÊòØ \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)„ÄÇ NTT ‰∏Ä‰∏ãÂç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇÔºàÂÖ∂ÂÆûÁõ¥Êé•ÂÜô‰∏äÁ≥ªÊï∞Â∞±ÊòØ‰∫ÜÔºåÂâçÈù¢Êé®ÁöÑÂÆåÂÖ®Áî®‰∏çÂà∞...Ôºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂêêÊßΩÔºö‰∏∫Âï•ËøôÁßçÊ≤°Âï•ÊÑèÊÄùÁöÑÈ¢ò‰ºöÊòØ agc ÁöÑ F È¢ò„ÄÇ Ëøô‰∏™Ê∏∏ÊàèÊòØ‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÁöÑÂíåÔºåÊâÄ‰ª•Âè™Ë¶Å‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏Êàè SG ÂÄº‰∏ç‰∏ÄÊ†∑Â∞±Ë°å„ÄÇ ËÄÉËôëÊåâ \(SG\) ÂÄº \(dp\)Ôºå\(dp_{S}\) Ë°®Á§∫ÈõÜÂêà \(S\) ‰∏≠‰ªª‰ΩïÁöÑÁÇπ SG ÂÄºÈÉΩÊØî \(S\) Â§ñ‰ªª‰ΩïÁÇπÊ∂àÔºåËá≥Â∞ë‰∏ÄÁ´ØÂú® \(S\) ‰∏≠ÁöÑËæπÁöÑÊñπÊ°àÊï∞„ÄÇ ËΩ¨ÁßªÂ∞±ÊòØÊûö‰∏æ SG ‰∏∫ \(S\) ‰∏≠ÊúÄÂ§ß SG ÂÄºÂä†‰∏ÄÁöÑÁÇπÁöÑÈõÜÂêàÔºåÁÑ∂ÂêéËøô‰∏™ÈõÜÂêàÂÜÖÈÉ®ÊâÄÊúâËæπÈÉΩ‰∏çÈÄâÔºåÊâÄÊúâ‰∏çÂú®Ëøô‰∏™ÈõÜÂêàÂÜÖ‰πü‰∏çÂú® \(S\) ÂÜÖÁöÑÁÇπÂà∞Ëøô‰∏™ÈõÜÂêàËá≥Â∞ëÊúâ‰∏ÄÊù°ËæπÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞ÔºõËøô‰∏™ÈõÜÂêàÂà∞‰∏çÂú®Ëøô‰∏™ÈõÜÂêà‰∏≠‰πü‰∏çÂú® \(S\) ‰∏≠ÁöÑÁÇπÁöÑËæπÂèØÈÄâÂèØ‰∏çÈÄâÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞„ÄÇÊ≥®ÊÑè \(1,2\) ‰∏çËÉΩÂêåÊó∂Âú®Ëøô‰∏™ÈõÜÂêà„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n3^n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÈóÆÈ¢òÊîæÂà∞‰∏Ä‰∏™Êó†ÂêëÂõæ‰∏äËÄÉËôëÔºåÂ¶ÇÊûúÁ¨¨ \(i\) ‰∏™‰∫∫ÈÄâ‰∫ÜÁÅ´È∏° \(x_i,y_i\)ÔºåÂ∞±Âú® \(x_i,y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Êó†ÂêëËæπÔºåÊàë‰ª¨Áß∞ËøôÊù°ËæπÁöÑÊó∂Èó¥‰∏∫ \(i\)„ÄÇ ËÄÉËôë‰∏Ä‰∏™ÁÅ´È∏° \(s\) Âπ∏Â≠òÁöÑÊù°‰ª∂ÔºöÂ¶ÇÊûú \(s\) Âú®Êó∂Âàª \(t\) Ê≤°Ë¢´ÂêÉÊéâÔºåÂØπ‰∫éÊØè‰∏ÄÊù°Ëæπ \(\{s,v\}\)ÔºåÂ¶ÇÊûúËøôÊù°ËæπÁöÑÊó∂Èó¥Â∞è‰∫éÁ≠â‰∫é \(t\)ÔºåË¢´ÂêÉÊéâÁöÑÈÉΩÊòØÁÅ´È∏° \(v\)Ôºå‰∫éÊòØÁÅ´È∏° \(v\) Ë¶ÅÂú®ËøôÊù°ËæπÁöÑÊó∂Èó¥Âπ∏Â≠òÔºåÂ¶ÇÊ≠§‰º†ÈÄí‰∏ãÂéªÔºåÊúÄÁªà‰ºöÂæóÂà∞Ëã•Âπ≤Êù°Ë¢´ÂêÉÊéâÁöÑÁÅ´È∏°Á°ÆÂÆöËæπÔºåËøô‰∫õËæπ‰ºöÊûÑÊàê‰∏ÄÊ£µÊ†ëÔºàÂ¶ÇÊûú‰∏çÊûÑÊàê‰∏ÄÊ£µÊ†ëÁöÑËØùÁÅ´È∏° \(s\) ‰∏çÂèØËÉΩÂπ∏Â≠òÔºâ„ÄÇÊòæÁÑ∂Âè™Ë¶ÅËøô‰∏™Ê†ë‰∏äÁöÑËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Êª°Ë∂≥‰∫ÜÊù°‰ª∂Ôºå\(s\) ‰πü‰∏ÄÂÆö‰ºöÂπ∏Â≠ò„ÄÇÂõ†Ê≠§ÁÅ´È∏° \(s\) Âíå \(t\) ÂêåÊó∂Âπ∏Â≠òÁöÑÊù°‰ª∂Â∞±ÊòØÂÆÉ‰ª¨ÂØπÂ∫îÁöÑÁ°ÆÂÆöÁöÑËæπÊ≤°ÊúâÂÜ≤Á™Å„ÄÇ Áî±‰∫é‰∏Ä‰∏™ÁÅ´È∏°Âπ∏Â≠òÁöÑÊù°‰ª∂‰∏≠ÊúÄÂ§ö \(n-1\) Êù°ËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Ë¢´Á°ÆÂÆöÔºåÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊ£ÄÊü•‰∏§‰∏™ÁÅ´È∏°ÊòØÂê¶ÂèØ‰ª•ÂêåÊó∂Âπ∏Â≠òÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â¶ÇÊûúÁ∫¢Ê†ë‰∏äÊúâ‰∏ÄÊù°Ëæπ \((u,v)\)Ôºå\(u\) Âíå \(v\) Âú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\)ÔºåÈÇ£‰πà Sigma Ëµ∞Âà∞ \(u\) Êàñ \(v\) Â∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª‰∫Ü„ÄÇ Êàë‰ª¨ÊääÂ≠òÂú®‰∏ÄÊù°Áõ∏ÈÇªÁ∫¢ËæπÂú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\) ÁöÑÁÇπÊ†áËÆ∞‰∏Ä‰∏ãÔºåÂè™Ë¶ÅÂà∞ËææËøôÁßçÁÇπÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥ÂæÄ‰∏ãË∑ë„ÄÇ ÂÅáËÆæ Sigma Âú®ÁÇπ \(X\)ÔºåSugim Âú®ÁÇπ \(Y\)ÔºåËÄÉËôëËìùÊ†ëÂéªÊéâÁÇπ \(Y\) ÂêéÂΩ¢ÊàêÁöÑËã•Âπ≤‰∏™ËøûÈÄöÂùóÔºåSigma Êó†Ê≥ï‰ªé‰∏Ä‰∏™ËøûÈÄöÂùóÁöÑÊú™Ê†áËÆ∞ÁÇπÂà∞Âè¶‰∏Ä‰∏™ËøûÈÄöÂùó„ÄÇÊâÄ‰ª•ÊòæÁÑ∂ Sugim ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØÔºåÊØèÊ¨°Âú®ËìùÊ†ë‰∏äÂêë \(X\) ÊâÄÂú®ÁöÑÊñπÂêëËµ∞‰∏ÄÊ≠•„ÄÇSigma ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØ‰∏ç‰ºöÈáçÂ§çÁªèËøáËµ∞ËøáÁöÑÁÇπÁöÑ„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞Ê±ÇÂá∫ Sigma ÂèØËÉΩËµ∞Âà∞Âì™‰∫õÁÇπÔºåÂ¶ÇÊûú‰ªñËÉΩËµ∞Âà∞‰∏Ä‰∏™Ê†áËÆ∞ÁÇπÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª„ÄÇÂê¶ÂàôÁ≠îÊ°àÂ∞±ÊòØËÉΩËµ∞Âà∞ÁöÑÁÇπÂú®ËìùÊ†ë‰∏ä‰∏é \(Y\) ÁöÑÊúÄËøúË∑ùÁ¶ª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // Ê≠§Êó∂ Y ÁöÑÊ∑±Â∫¶‰∏∫ T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÖ≥‰∫éÊúÄÈïøÂèçÈìæÊñπÊ°àÁöÑÊûÑÈÄ†]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏Ä‰∫õÊ±ÇÊúÄÈïøÂèçÈìæÁöÑÈ¢òÁõÆ‰ºöËÆ©‰Ω†ÊûÑÈÄ†ÊñπÊ°àÔºåÊØîÂ¶Ç [CTSC2008] Á•≠Á•Ä Âíå CF590E Birthday„ÄÇ ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÂÜôÁöÑÊØîËæÉÊ∏ÖÊô∞ÁöÑÂÅöÊ≥ïÔºår-64 ÁöÑ uoj blog„ÄÇ Â§ßÊ¶ÇÊòØËØ¥Âª∫Âá∫‰∫åÂàÜÂõæÊ±ÇÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÊâÄÊúâ‰∏§ÈÉ®‰∏≠ÂØπÂ∫îÁöÑÁÇπÈÉΩÂú®Áã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÊûÑÊàêÊúÄÈïøÂèçÈìæ„ÄÇ ÊûÑÊàêÂèçÈìæÊòØÊòæÁÑ∂ÁöÑÔºåÊûÑÊàêÊúÄÈïøÂèçÈìæÁöÑÁêÜÁî±‰ºº‰πé‰∏çÂ§™ÂÆåÊï¥Ôºà‰πüÊúâÂèØËÉΩÊòØ‰ΩúËÄÖËßâÂæóËøôËøá‰∫éÊòæÁÑ∂‰∫ÜÔºâÔºåÂùë‰∫ÜÊàëÂæà‰πÖÔºåËøôÈáåËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ËÆæÂéüÂõæÁÇπÊï∞‰∏∫ \(n\)Ôºå‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç‰∏∫ \(m\)ÔºåÈÇ£‰πàÊúÄÂ∞èÈìæË¶ÜÁõñÂ§ßÂ∞è‰∏∫ \(n-m\)ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞è‰∏∫ \(2n - m\)„ÄÇÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÂ∑¶Âè≥ÈÉ®‰∏≠ÂØπÂ∫îÁÇπÈÉΩÂú®ÂÖ∂‰∏≠ÁöÑÁÇπÊúâ \(n-m\) ‰∏™„ÄÇÈ¶ñÂÖàÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÂÆÉÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπËá≥Â∞ëÊúâ‰∏Ä‰∏™Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÔºàÈÇ£ÁØá blog ‰∏≠‰ºº‰πéÁº∫Â∞ë‰∫ÜËøô‰∏ÄÊ≠•ÔºâÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÁÇπÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÈÉΩ‰∏çÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠Ôºå‰∏ÄÂÆöÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Â∑¶ÈÉ®ÂØπÂ∫îÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπÊúâËæπÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπ \(a\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºå‰πüÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÊúâËæπÁöÑÁÇπ \(b\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠„ÄÇÁî±ÂÅèÂ∫èÂÖ≥Á≥ªÁöÑ‰º†ÈÄíÊÄßÂèØÁü• \(a\) Âíå \(b\) Âú®‰∫åÂàÜÂõæ‰∏äÊúâ‰∏ÄÊù°ËæπÔºå‰∏éÊúÄÂ§ßÁã¨Á´ãÈõÜÁöÑÂÆö‰πâÁüõÁõæ„ÄÇÂõ†Ê≠§ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞èÁ≠â‰∫é \(n + Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁÇπÈÉΩÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÁöÑÊï∞Èáè\)Ôºå‰πüÂ∞±ËØÅÊòé‰∫ÜÊàë‰ª¨ÊûÑÈÄ†Âá∫ÁöÑÂèçÈìæÊòØÊúÄÈïøÂèçÈìæ„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] „ÄåJOISC 2017 Day 1„ÄçÂºÄËçíËÄÖ]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ‰∏úË•øÂçóÂåóÊñπÂêëÂêπÁöÑÊ¨°Êï∞ÂàÜÂà´‰∏∫ \(c_E, c_W, c_S, c_N\)„ÄÇ È¢òÊÑèÁõ∏ÂΩì‰∫éÊòØË¶ÅÊ±Ç \(c_E+c_W+c_S+c_N\) ÊúÄÂ∞èÁöÑ \(c_E,c_W,c_S,c_N\)Ôºå‰ΩøÂæóÂú®Âπ≥Èù¢‰∏äÊîæ \(n\) ‰∏™Áü©ÂΩ¢ÔºåÁ¨¨ \(i\) ‰∏™Áü©ÂΩ¢ÁöÑÊ®™ÂùêÊ†áËåÉÂõ¥‰∏∫ \([S_i - c_N, S_i + c_S]\)ÔºåÁ∫µÂùêÊ†áËåÉÂõ¥‰∏∫ \([E_i - c_W, E_i + c_E]\)ÔºåËÉΩÂ§üË¶ÜÁõñ‰ª• \((1,1)\) ‰∏∫Â∑¶‰∏äËßíÁöÑ \(R \times C\) Áü©ÂΩ¢„ÄÇ ÂÅáËÆæÊúâ‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëË∞ÉÊï¥„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[‰æãÈ¢ò LOJ6440 ÂÅöÊ≥ï ËÄÉËôëËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰Ωú‰∏ÄÊù°Â∞ÑÁ∫ø \(y = \frac{Px+R}Q\)ÔºåÂè™ËÄÉËôë \(x &gt; 0\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(y = i\) Â∞±ÊâßË°åÊìç‰Ωú \(A\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(x = i\) Â∞±ÊâßË°åÊìç‰Ωú \(B\)Ôºå\(i\) ÊòØÊ≠£Êï¥Êï∞„ÄÇ ‚ÄúÊìç‰ΩúÂ∫èÂàó‚ÄùÂØπÂ∫îÁöÑ‰ø°ÊÅØË¶ÅÂèØÂêàÂπ∂„ÄÇ ËÄÉËôëÈÄíÂΩíÂú∞Â§ÑÁêÜÈóÆÈ¢òÔºåËÆæ \(A\) Âíå \(B\) ÊòØ‰∏§‰∏™Êìç‰ΩúÂ∫èÂàóÂØπÂ∫îÁöÑ‰ø°ÊÅØ„ÄÇÂÆö‰πâ \(solve(P, Q, R, L, A, B)\) Ë°®Á§∫‰∏Ä‰∏™Âê´Êúâ \(L\) ‰∏™ \(B\)ÔºåÁ¨¨ \(k\) ‰∏™ \(B\) ÂíåÁ¨¨ \(k-1\) ‰∏™ \(B\) ‰πãÈó¥Êúâ \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) ‰∏™ \(A\) ÁöÑÊìç‰ΩúÂ∫èÂàóÁöÑ‰ø°ÊÅØÔºà\(k = 1\) Êó∂ÊòØÂºÄÂ§¥ \(A\) ÁöÑÊï∞ÈáèÔºâ„ÄÇÊää \(R\) ÂØπ \(Q\) ÂèñÊ®°‰∏ç‰ºöÊîπÂèòÁ≠îÊ°àÔºåÊää \(P\) ÂØπ \(Q\) ÂèñÊ®°Âè™Ë¶ÅÊää \(B\) ÂèòÊàê \(A^{\lfloor \frac P Q \rfloor}B\) Â∞±ÂèØ‰ª•ÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú„ÄÇ ÂÖàÂèñÊ®°Ôºå‰øùËØÅ \(P, R &lt; Q\)„ÄÇ ËÄÉËôë‰∫§Êç¢ \(A\) Âíå \(B\) ÁöÑÂú∞‰ΩçÔºåÂéüÊù•Êàë‰ª¨ÊòØËÄÉËôëÊØè‰∏™ \(B\) ÂâçÈù¢ÊúâÂá†‰∏™ \(A\)ÔºåÁé∞Âú®Êàë‰ª¨ËÄÉËôëÊØè‰∏™ \(A\) ÂâçÈù¢ÊúâÂá†‰∏™ \(B\)ÔºåÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂâçÈù¢ÁöÑÊù°‰ª∂ÊòØ \(i \le \frac{Pj+R}{Q}\)ÔºåÂç≥ \(j \ge \frac{Qi-R}P\)„ÄÇÈÇ£‰πàÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂêéÈù¢ÁöÑÊù°‰ª∂ÊòØ \(j &lt; \frac{Qi-R}P\)Ôºå‰ªéÁ¨¨ \(i\) ‰∏™ \(A\) ÂâçÈù¢Êúâ \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) ‰∏™ \(B\)„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÁâπÂà´ÂéªÂ§ÑÁêÜ‰∏Ä‰∏ãÊúÄÂêé‰∏Ä‰∏™ \(B\) Âíå \(Qi-R-1\) Â∞è‰∫é \(0\) ÁöÑÊÉÖÂÜµÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™ÂΩ¢Âºè‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇÁî±‰∫é \(R &lt; Q\)Ôºå\(i &gt; 0\) Êó∂ \(Qi-R-1 \ge 0\)„ÄÇ‰ΩÜÊòØ \(i = 0\) Êó∂Âá∫Áé∞Ë¥üÊï∞Êåâ‰πãÂâçÁöÑÂÆö‰πâ‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•Á¨¨‰∏Ä‰∏™ \(A\) ‰ª•ÂèäÂâçÈù¢ÁöÑÈÉ®ÂàÜÂçïÁã¨Â§ÑÁêÜÔºåË∞ÉÁî® \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)ÔºåÂ§ÑÁêÜ‰∏ãÂºÄÂ§¥ÁªìÂ∞æÂç≥ÂèØ„ÄÇË¶ÅÂà§‰∏Ä‰∏ãÊ≤°Êúâ \(A\) ÁöÑÊÉÖÂÜµ„ÄÇ Ê∂âÂèäÂà∞Ê±ÇÁü©ÈòµÂπÇÂèØ‰ª•Áõ¥Êé•Âø´ÈÄüÂπÇÔºåÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶‰ªçÊòØ‰∏Ä‰∏™ \(\log\)„ÄÇ ÂÖ≥‰∫éÂÄºÂüü Êú¨È¢òÁöÑÂÄºÂüüÁâπÂà´Â§ßÔºåË¶ÅÂ∞èÂøÉÁàÜ long long„ÄÇ ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûêÂêÑ‰∏™ÂèòÈáèÂÜçÈÄíÂΩíËøáÁ®ã‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Ëøô‰∏™È¢òÊØîËæÉÊ∞¥„ÄÇ ÂÅáËÆæÊ≤°ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôêÔºåÈÇ£‰πàÂÖ∂ÂÆûË¶ÅÁÆó‰∏ÄÂè™ pony ËÉΩÊî∂ÂèñÁöÑ manaÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìËøôÊ¨°Êî∂ÂèñÂíå‰∏äÊ¨°Êî∂ÂèñÁöÑÊó∂Èó¥Èó¥ÈöîÔºå‰πò‰∏ä \(r_i\) Âç≥ÂèØ„ÄÇ Êàë‰ª¨Ë¶ÅÂú®Êìç‰ΩúÊó∂Áª¥Êä§ÊâÄÊúâ pony ÁöÑÊúÄÂêéÊìç‰ΩúÊó∂Èó¥ÔºåËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂå∫Èó¥Ë¶ÜÁõñÈóÆÈ¢òÔºåÂæàÂÆπÊòìÂÜô‰∏Ä‰∏™ÂùáÊëä \(\mathcal O(n \log n)\) ÁöÑÂÆûÁé∞ÔºöÂª∫‰∏Ä‰∏™Á∫øÊÆµÊ†ëÔºå‰øÆÊîπÊó∂ÂÖàÊääËØ¢ÈóÆÂå∫Èó¥Âú®Á∫øÊÆµÊ†ë‰∏äÊãÜÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÔºåÂØπÊØè‰∏™Âå∫Èó¥ÔºåÂÅö‰∏Ä‰∏™ËøôÊ†∑ÁöÑËøáÁ®ãÔºöÂÖàËÄÉËôëÂΩìÂâçÂå∫Èó¥ÊâÄÊúâÁÇπÊòØ‰∏çÊòØÊúÄÁªà‰øÆÊîπÊó∂Èó¥Áõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÔºåÂ∞±Â§ÑÁêÜËøô‰∏™Âå∫Èó¥ÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Âå∫Èó¥‰∏äÊâìÊ†áËÆ∞ÔºåÂê¶ÂàôÂ∞±‰∏§ËæπÈÄíÂΩí‰∏ãÂéª„ÄÇÊØèÊ¨°ÂæÄ‰∏ãÈÄíÂΩíÈÉΩ‰ºö‰ΩøÂæó‰∏Ä‰∏™Á∫øÊÆµÊ†ë‰∏äÂå∫Èó¥‰∏≠‰∏çÂêåÁöÑÊúÄÁªà‰øÆÊîπÊó∂Èó¥Êï∞ÂáèÂ∞ë‰∏ÄÔºå‰ªéËÄåËøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶ÊòØÂùáÊëä \(\mathcal O(n \log n)\)„ÄÇ ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôê‰πüÂèØ‰ª•Á±ª‰ººÁöÑÂ§ÑÁêÜÔºå‰∏çÂêåÁöÑÊòØÔºåÂõ†‰∏∫Êúâ‰∫Ü‰∏äÈôêÔºåÈúÄË¶ÅÂØπÊØè‰∏™Âå∫Èó¥Áª¥Êä§‰∏Ä‰∏™‰ª• \(\lceil \frac {m_i}{r_i}\rceil\) ‰∏∫ÂÖ≥ÈîÆÂ≠óÊéíÂ•ΩÂ∫èÁöÑ‰∏úË•ø„ÄÇËøôÊ†∑‰Ω†ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ãÂâçÂ§öÂ∞ë‰∏™ÈÉΩÊòØÂú®ËøôÊÆµÊó∂Èó¥ÈáåÈù¢ mana Êª°‰∫ÜÁöÑÔºåÁõ¥Êé•Âä†ËøõÁ≠îÊ°àÔºåÁÑ∂ÂêéÂêéÈù¢ÁöÑÂè™ÈúÄË¶ÅÁªüËÆ°‰∏Ä‰∏ã \(r_i\) ÁöÑÂíå‰πò‰∏äÊó∂Èó¥Â∑ÆÂä†ËøõÁ≠îÊ°àÂç≥ÂèØ„ÄÇËøô‰∏™‰∏úË•øÂæàÂÆπÊòìÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ„ÄÇ ÂàùÂßãÂÄºË¶ÅÁâπÂà´Â§ÑÁêÜÔºåÂú®ÊØè‰∏™ÁÇπÁ¨¨‰∏ÄÊ¨°‰øÆÊîπÊó∂Êö¥ÂäõÁÆó‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÊÑüËßâÂÆûÈôÖ‰∏äÂèØ‰ª•Áî®Á∫øÊÆµÊ†ëÂàÜË£ÇÂíåÂêàÂπ∂ÂÅöÂà∞‰∏Ä‰∏™ \(\log\)„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊØíÁò§ÂàÜÁ±ªËÆ®ËÆ∫.... Â∞±Êîæ‰∏™‰ª£Á†Å..ÁªìËÆ∫Â§™È∫ªÁÉ¶Â∞±‰∏çÂÜô‰∫Ü TAT„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Á•û‰ªôÈ¢òÔºåÁúãÈ¢òËß£‰∫Ü„ÄÇ Âèñ‰ªªÊÑè‰∏Ä‰∏™ÁîüÊàêÊ†ëÔºåÂèñËøô‰∏™Ê†ëÁöÑÈáçÂøÉÂíåÊâÄÊúâË∑®ËøáËøô‰∏™ÈáçÂøÉÁöÑÈùûÊ†ëËæπÁöÑÁ´ØÁÇπÔºàÂÆûÈôÖ‰∏ä‰∏§‰∏™Á´ØÁÇπ‰∏≠Âè™Ë¶Å‰ªªÂèñ‰∏Ä‰∏™Â∞±Ë°åÔºåÂè™Ë¶Å‰øùËØÅÂ≠êÊ†ë‰∏çËøûÈÄöÔºâÔºåËÄÉËôëË∑®ËøáËøô‰∫õÁÇπÁöÑË∑ØÂæÑÔºåÁÑ∂ÂêéÂÜçÂØπÊØè‰∏™Â≠êÊ†ëÁÇπÂàÜ„ÄÇ Ê≥®ÊÑè‰∏çË¶ÅÊääËøô‰∫õÁÇπÂà†ÊéâÂÜçÂØπÊØè‰∏™ËøûÈÄöÂùóÂÅöÁÇπÂàÜÊ≤ªÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØËÉΩ‰∏Ä‰∏™ËøûÈÄöÂùó‰∏çÊòØ‰∏Ä‰∏™Ê†ë‰∏äËøûÈÄöÂùóÔºåÂ∞±‰∏çÊòØÂæàÂ•ΩÂ§ÑÁêÜÔºàÂ∫îËØ•‰πüËÉΩÂ§ÑÁêÜÔºâ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÉèÂä®ÊÄÅÁÇπÂàÜÊ≤ª‰∏ÄÊ†∑Áª¥Êä§Â∞±Ë°åÔºåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÂà†ÂéªÁöÑÁÇπ‰∏éÂΩìÂâçËøûÈÄöÂùó‰∏≠ÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ª„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(nk\log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // ÁÇπÂàÜÊ†ë‰∏äÁà∂‰∫≤Ôºå‰∏Ä‰∏™ÁÇπË¢´Âà†ÊéâÊó∂ÂØπÂ∫îÁÇπÂàÜÊ†ë‰∏äÂì™‰∏™ÁÇπvector&lt;int&gt; vimp[maxn], mn[maxn]; // ÁÇπÂàÜÊ†ë‰∏ä‰∏ÄÊ¨°Âà†ÂéªÁöÑÁÇπÔºå‰ª•ÂèäÂà∞ËøûÈÄöÂùóÂÜÖÊúÄËøëË¢´ mark ÁÇπÁöÑË∑ùÁ¶ªunordered_map&lt;ll, int&gt; mdis; // Ë¢´Âà†ÂéªÁöÑÁÇπÂà∞ÂÜÖÈÉ®‰∏Ä‰∏™ÁÇπÁöÑË∑ùÁ¶ªint vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // ÁÇπÂàÜÊ≤ªÁî®ÂèòÈáèvoid dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // ÂéüÊú¨ËøôÈáåÊòØÊääÊâÄÊúâÂ§ÑÁêÜÁöÑÁÇπÂà†ÊéâÁöÑÔºåÂÜôÂæóÂèØËÉΩÊúâÁÇπÂ•áÊÄ™ÔºåÊáíÂæóÊîπ‰∫Ü vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ∫¶Êï∞Â∫èÂàó \(d\)ÔºåÂ≠òÂú®‰∏ÄÊ£µÂØπÂ∫îÁöÑ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(1 \le d_i &lt; n\) ‰∏î \(\sum {d_i} = 2(n-1)\)Ôºà‰ªéÂè∂Â≠êÂΩíÁ∫≥Ôºâ„ÄÇ ËÄÉËôëÂéªÈí¶ÂÆöËøô‰∏™Ê†ëÁöÑ \(k\) ‰∏™ÂåπÈÖçÔºåÂ¶ÇÊûúËÉΩÈí¶ÂÆöÂá∫Êù•Â∞±ËØ¥ÊòéÁ≠îÊ°à \(\ge k\)„ÄÇÈí¶ÂÆö‰∏§‰∏™ÁÇπÂåπÈÖçÂèØ‰ª•Áúã‰ΩúËøô‰∏§‰∏™ÁÇπË¢´Áº©Âà∞‰∫Ü‰∏ÄËµ∑ÔºåÂèòÊàê‰∫Ü‰∏Ä‰∏™Â∫¶Êï∞Âíå‰∏∫‰∏§‰∏™ÁÇπÁöÑÂ∫¶Êï∞‰πãÂíåÂáèÂéª \(2\) ÁöÑÁÇπ„ÄÇÂè™Ë¶Å‰øùËØÅÊâÄÊúâÂåπÈÖçÁº©Ëµ∑Êù•‰πãÂêéÂæóÂà∞ÁöÑÂ∫¶Êï∞Â∫èÂàó‰æùÁÑ∂Êª°Ë∂≥‰πãÂâçÊâÄËØ¥ÁöÑÊù°‰ª∂Âç≥ÂèØ„ÄÇËøôÊòØ‰∏Ä‰∏™‰ºóÊâÄÂë®Áü•ÁöÑË¥™ÂøÉÈóÆÈ¢òÔºåÊéíÂ∫èÂêéË¥™ÂøÉÁî®Â∞èÁöÑÂåπÈÖçÂ§ßÁöÑÂç≥ÂèØ„ÄÇÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè \(1\) Âíå \(1\) Âú®ÁÇπÊï∞Â§ß‰∫é \(2\) Êó∂‰∏çËÉΩÂåπÈÖçÔºàÂõ†‰∏∫ \(1+1-2=0\)ÔºâÔºå‰ΩÜÊòØÁÇπÊï∞Á≠â‰∫é \(2\) Êó∂ÂèØ‰ª•ÂåπÈÖç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â•áÊÄ™ÁöÑÈ¢òÁõÆ... ÂÖàÊääÁÇπÊåâ \(a_i\) ‰ªéÂ∞èÂà∞Â§ßÈáçÊñ∞Ê†á‰∏™Âè∑„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨ÂÅáËÆæ \(a_i &lt; a_{i+1}\)„ÄÇ Êää \(1\) Áúã‰ΩúÊ†πÔºåÊòæÁÑ∂ÂèØ‰ª•ÈÄöËøáË∞ÉÊï¥‰ΩøÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ÁºñÂè∑ÈÉΩÊØî‰ªñÂ∞è„ÄÇ Êää‰∏§ÁßçË¥°ÁåÆ‰∏ÄËµ∑ËÄÉËôëÔºåÂÆö‰πâËæπ \(\{u, fa(u)\}\) ÁöÑË¥°ÁåÆ‰∏∫ \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)ÔºåÂØπÊØè‰∏™ \(u\) ÂéªÊâæËÉΩ‰Ωø‰ª£‰ª∑ÊúÄÂ∞èÁöÑ \(fa(u)\)„ÄÇÁî±‰∫éËøô‰∏™Ê†ëÁöÑÁâπÊÆäÊÄßË¥®ÔºåÁÇπ \(u\) ÊúÄ‰ºòÁöÑÁà∂‰∫≤‰∏ÄÂÆöÊòØÂéüÊ†ë‰∏ä \(u\) ÁöÑÁ•ñÂÖàÔºåÊâÄ‰ª•ÂÄçÂ¢û‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // Ë∑ùÁ¶ª‰∏çË∂ÖËøá 2^k ÁöÑÁÇπint cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™ \(n\) ‰∏™ÁÇπ \(m\) Êù°ËæπÁöÑÂ∏¶ÊùÉÁÆÄÂçïÊúâÂêëÂõæÔºåÊ±Ç‰∏Ä‰∏™ÊúÄÂ∞èËæπÊùÉÂíåÁöÑÊòØ‰ª• \(r\) ‰∏∫Ê†πÁöÑÂÜÖÂêëÁîüÊàêÊ†ë„ÄÇ Â§ñÂêëÊ†ëÁöÑÊÉÖÂÜµÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´ÔºåËæπÂèç‰∏ÄÂèçÂ∞±Â•Ω„ÄÇ Êó†Ê†πÁöÑÊÉÖÂÜµÂèØ‰ª•Âä†‰∏Ä‰∏™ÁÇπËΩ¨Âåñ‰∏∫ÊúâÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ÁÆóÊ≥ï Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæÊòØ DAGÔºå‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑË¥™ÂøÉÊòØÔºåÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ„ÄÇÊòæÁÑ∂ËøôÊ†∑‰ºöÊûÑÊàê‰∏ÄÊ£µÂÜÖÂêëÊ†ëÔºå‰∏î‰∏çÂèØËÉΩÊúâÊùÉÂÄºÂíåÊõ¥Â∞èÁöÑÂÜÖÂêëÊ†ë„ÄÇ Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæ‰∏çÊòØ DAGÔºåÁõ¥Êé•ÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ‰∏ç‰∏ÄÂÆö‰ºöÂæóÂà∞‰∏ÄÊ£µÊ†ëÔºåÊ≠§Êó∂ÂèØËÉΩ‰ºöÊúâÂ§ö‰∏™Âº±ËøûÈÄöÂùóÔºåÊØè‰∏™ËøûÈÄöÂùóÊòØ‰∏ÄÊù°ÈìæÔºàÂåÖÂê´ \(r\) ÁöÑÔºâÊàñËÄÖ‰∏ÄÊ£µÂü∫ÁéØÂÜÖÂêëÊ†ë„ÄÇÂ¶ÇÊûú‰Ω†ÂæóÂà∞‰∫Ü‰∏Ä‰∏™ÂÜÖÂêëÁîüÊàêÊ†ëÂ∞±Ê±ÇÂá∫‰∫ÜÁ≠îÊ°àÔºå‰∏ãÈù¢Êàë‰ª¨ËÄÉËôëËá≥Â∞ëÊúâ‰∏Ä‰∏™ÁéØÁöÑÊÉÖÂÜµ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫é‰∏Ä‰∏™ÔºàÊüê‰∏™Âü∫ÁéØÊ†ëËøûÈÄöÂùó‰∏≠ÁöÑÔºâÁéØÔºå‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÊÅ∞Â•ΩÂè™Êúâ‰∏ÄÊù°ÁéØ‰∏äËæπ‰∏çÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºåÊàë‰ª¨ÂÖàÂÅáËÆæËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºà‰Ω†ÂèØ‰ª•Âä†ÂÖ•‰∏Ä‰∏™ÂÖÖÂàÜÂ∞èÁöÑÂÅèÁßªÈáèÔºåÂú®‰∏çÂΩ±ÂìçÁ≠îÊ°àÁöÑÂâçÊèê‰∏ã‰ΩøËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºâÔºåËÆæÁÇπ \(u\) ÁöÑÊúÄÂ§ßÂá∫ËæπËøûÂêëÁÇπ \(f(u)\)ÔºåËÄÉËôë‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÁÇπ \(u \neq r\)Ôºå\(f(u)\) ‰∏çÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠Ôºå‰∏î \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÊàë‰ª¨ÂèØ‰ª•Êää \(u\) ÁöÑÁà∂‰∫≤Êîπ‰∏∫ \(f(u)\)ÔºåÂæóÂà∞‰∏Ä‰∏™Êõ¥Â∞èÁöÑÂÜÖÂêëÁîüÊàêÊ†ëÔºåËøô‰∏éËøô‰∏™Ê†ëÊòØÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÁüõÁõæ„ÄÇËøôËØ¥ÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁéØ‰∏äÁöÑÁÇπ \(u\)Ôºå‰ΩøÂæó \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ (ÁéØ‰∏äÁÇπËÇØÂÆö‰∏çÊòØ \(r\))Ôºå\(f(u)\) Ë¶Å‰πàÊòØ \(u\) ÁöÑÁà∂‰∫≤Ë¶Å‰πàÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠„ÄÇËÄÉËôë‰ªé \(u\) Âá∫ÂèëÔºåÊØèÊ¨°‰ªé \(u\) Ëµ∞Âêë \(f(u)\)ÔºåÂú®Ëµ∞Âõû \(u\) ‰πãÂâçÔºå‰∏ÄÂÆö‰∏ç‰ºöÁªèËøá‰∏Ä‰∏™ÁÇπ‰∏§Ê¨°Ôºå‰ªéËÄåË∑ØÂæÑ‰∏äÂè™ÊúâÁ¨¨‰∏ÄÊ¨°Ëµ∞ÁöÑÊó∂ÂÄô \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÂõ†Ê≠§ÁéØ‰∏äÂè™Êúâ‰∏ÄÊù°ËæπÊ≤°ÊúâÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠Âá∫Áé∞„ÄÇ Âõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁéØ‰∏äÂì™‰∏ÄÊù°ËæπÊ≤°ÊúâÂá∫Áé∞„ÄÇËÄÉËôëÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÂæóÂà∞‰∏Ä‰∏™‰∏éÂéüÂõæÁ≠â‰ª∑ÁöÑÂõæ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠ \(e\) ÊòØ‰∏çÂú®ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ‰∏≠ÁöÑËæπÔºå‰ªéÂõæ‰∏≠ÂèØ‰ª•ÂæàÊòéÊòæÂú∞ÁúãÂà∞ÔºåÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÊääÁº©ÂÆåÂêéÁöÑÁöÑÁÇπÁöÑÂá∫ËæπËæπÊùÉÂáèÂéªÂéüÊù•ËøôÊù°Âá∫ËæπÂØπÂ∫îÁöÑ \(e\) ÁöÑÊùÉÂÄºÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™Á≠â‰ª∑ÁöÑÂõæ„ÄÇ Êö¥ÂäõÁº©ÁÇπÂèØ‰ª•Áî® \(\mathcal O(nm)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ê±ÇÂá∫ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ„ÄÇ Â§çÊùÇÂ∫¶‰ºòÂåñ Áî®Âπ∂Êü•ÈõÜÁª¥Êä§Âº±ËøûÈÄöÂùóÔºåÂÜçÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ÂΩìÂâçÂì™‰∫õÁÇπË¢´Áº©Êàê‰∫Ü‰∏Ä‰∏™ÁÇπ„ÄÇÁî®ÂèØÂπ∂Â†ÜÁª¥Êä§ÂΩìÂâçÊØè‰∏™ÁÇπÁöÑÂá∫ËæπÔºåÁº©ÁÇπÊó∂Â∏¶ tag ÂêàÂπ∂‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÂá∫ËæπÔºåÂ¶ÇÊûúÂú®Âêå‰∏ÄÂº±ËøûÈÄöÂùóÂèàÂèØ‰ª•Áº©ÁÇπ‰∫ÜÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÂíåÂÖ∂‰ªñÂº±ËøûÈÄöÂùóÂêàÂπ∂Âú®‰∫Ü‰∏ÄËµ∑„ÄÇ Áº©‰∏ÄÊ¨°Ëá≥Â∞ëÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºåÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O((n+m) \log n)\)„ÄÇ ÂÆûÁé∞ ÂíïÂíïÂíï„ÄÇ Áî±‰∫éÂÆûÁé∞Âíï‰∫ÜÊâÄ‰ª•‰πü‰∏çËÉΩ‰øùËØÅ‰∏äÈù¢ËØ¥ÁöÑÊòØÂØπÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Áåú‰∫Ü‰∏™ÁªìËÆ∫Ôºå‰∏ç‰ºöËØÅ‰ΩÜÊòØÂèàÊÉ≥‰∏çÂà∞ÂÖ∂‰ªñÂÅöÊ≥ï..Áúã‰∫ÜÁúºÈ¢òËß£ÂèëÁé∞ÊòØÂØπÁöÑ„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñÔºåÂÅáËÆæ‰Ω†‰π∞‰∫Ü \(x\) Ê¨°Ôºå‰Ω†‰ªéËøô‰∏™ÊäΩÂ•ñ‰∏≠Ëé∑ÂæóÁöÑÈí±Êï∞ÁöÑÊúüÊúõÊòØ \(p_i\frac {x} {x + l_i}\)„ÄÇÂÅáËÆæ‰Ω†Â∑≤Áªè‰π∞‰∫ÜÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñ \(x\) Ê¨°ÔºåÂÜç‰π∞‰∏ÄÊ¨°ÔºåÊúüÊúõÁöÑÂ¢ûÂä†ÈáèÊòØ \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)„ÄÇÂÆπÊòìÂèëÁé∞Ëøô‰∏™Â¢ûÂä†ÈáèÂÖ≥‰∫é \(x\) ÂçïË∞ÉÈÄíÂáèÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÂØπ‰∫éÊâÄÊúâÁöÑ \(i\) Âíå \(x \le i\)ÔºåÊää \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) ‰∏¢Ëøõ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ªéÂ§ßÂà∞Â∞èÊéí‰∏™Â∫èÔºåÂâç \(t\) ‰∏™Êï∞‰πãÂíåÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ§çÊùÇÂ∫¶‰∏çËÉΩÊé•Âèó„ÄÇ Êàë‰ª¨ÂÖàÁÆóÂá∫ÂàùÂßãÊ∏ÖÁ©∫ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÁªôÁ¨¨ \(k\) ‰∏™ÊäΩÂ•ñÂéüÊúâÁöÑÁ•®Êï∞Âä†‰∏ÄÂáè‰∏Ä‰πãÂêéÔºåËÄÉËôë‰∏§ÁßçÊìç‰ΩúÔºö‰∏ÄÔºåÂ∞ë‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ§ö‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñÔºõ‰∫åÔºåÂ§ö‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ∞ë‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñ„ÄÇÊàë‰ª¨ÊâæÂà∞ËÉΩ‰ΩøÊúüÊúõÂ¢ûÂä†ÈáèÊúÄÂ§ßÁöÑÊìç‰ΩúÔºåËøôÂæàÂÆπÊòìÁî®Â†ÜÊù•Áª¥Êä§„ÄÇÂè™ÈúÄË¶ÅÁªèËøá‰∏ÄÊ¨°ËøôÊ†∑ÁöÑÊìç‰ΩúÂç≥ÂèØÂæóÂà∞ÊúÄ‰ºòÊñπÊ°àÔºåËØÅÊòéÂ∞±‰∏çÂÖ∑‰ΩìÂÜôÂá∫‰∫Ü„ÄÇÔºàÊØîÂ¶ÇËØ¥Â¶ÇÊûúÊòØËøõË°åÊìç‰Ωú‰∫åÔºå‰ªéËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÂêéÔºåÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÊØîÂú®‰øÆÊîπÁ•®Êï∞‰πãÂâçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÂ§ßÊù•ËÄÉËôëÂç≥ÂèØÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÔºåÂÖàÊääÈ¢òÁõÆ‰∏≠ÁªôÂÆö‰∏≤ÁøªËΩ¨‰∏Ä‰∏ãÔºåÂèòÊàêË¶ÅÊâæ‰∏Ä‰∏™ÊØè‰∏™‰∏≤ÊòØÂêé‰∏Ä‰∏™‰∏≤Â≠ê‰∏≤ÁöÑÂ∫èÂàó„ÄÇ ‰∏ãÈù¢Êàë‰ª¨ËÆ§‰∏∫ÔºåËøô‰∏™Â∫èÂàó‰∏≠ÁöÑÂÖÉÁ¥†ÊòØ‰∏Ä‰∏™(ÂåÖÂê´‰ΩçÁΩÆÁöÑ)Â≠ê‰∏≤„ÄÇÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤Âá∫Áé∞Âú®‰∏çÂêå‰ΩçÁΩÆË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÁöÑ„ÄÇ ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Â∫èÂàóÔºå‰Ω†‰∏ÄÂÆöÂèØ‰ª•Âú®‰∏çÊîπÂèòÈïøÂ∫¶ÁöÑÊÉÖÂÜµ‰∏ãÊääÂÆÉË∞ÉÊï¥ÊàêÁ¨¨ \(i\) ‰∏™Â≠ê‰∏≤Èïø‰∏∫ \(i\)„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ËÄÉËôëËøôÁ±ªÂ∫èÂàó„ÄÇ Áß∞‰∏Ä‰∏™Â≠ê‰∏≤ \(s[l..r]\) ÊòØÂèØËææÁöÑÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏Ä‰∏™ËøôÁ±ªÂ∫èÂàó‰ª• \(s[l..r]\) ÁªìÂ∞æ„ÄÇÈ¢òÁõÆÂ∞±ÊòØË¶ÅÊ±ÇÊúÄÈïøÂèØËææÁöÑÂ≠ê‰∏≤„ÄÇ Ê≥®ÊÑèÂà∞Â¶ÇÊûú \(l &lt; r\)Ôºå\(s[l..r]\) ÂèØËææÔºåÈÇ£‰πà \(s[l..r-1]\) Âíå \(s[l+1..r]\) ‰∏ÄÂÆöÂèØËææ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(l\) Ê±ÇÂá∫ÊúÄÂ§ßÁöÑ \(r\) ‰ΩøÂæó \(s[l..r]\) ÂèØËææÔºåËÆæÂØπ‰∫é \(l=i\) ÊúÄÂ§ßÁöÑ \(r\) ÊòØ \(f_i\)„ÄÇÂØπ \(f\) ‰Ωú dpÔºåÊòæÁÑ∂ \(f_i \ge f_{i-1}\)ÔºåÊâÄ‰ª•ÊØèÊ¨°ÂÖà‰ª§ \(f_i = f_{i-1}\)ÔºåÁÑ∂ÂêéÊ£ÄÊü•‰∏Ä‰∏ã \(f_i\) ËÉΩ‰∏çËÉΩÂ¢ûÂ§ßÔºåÂ¶ÇÊûúËÉΩÂ¢ûÂ§ßÂ∞±‰∏ÄÁõ¥Â¢ûÂ§ßÂà∞‰∏çËÉΩÂ¢ûÂ§ßÂ∞±Ë°å‰∫Ü„ÄÇÊ£ÄÈ™åÂè™ÈúÄË¶ÅÂú® SAM ‰∏äÊâæÂà∞Ë¶ÅÊ£ÄÈ™åÁöÑ‰∏≤Âú®Êüê‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÊúÄÂêéÂá∫Áé∞‰ΩçÁΩÆÂ∞±Â•ΩÔºåËøôÂæàÂÆπÊòìÁî® SAM + Á∫øÊÆµÊ†ëÂÆûÁé∞Ôºà‰πüÂèØ‰ª•Áî®ÂÖ∂‰ªñÊñπÂºèÔºâ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™‰ºöÂ¢ûÂ§ß \(\mathcal O(n)\) Ê¨°ÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// ÊúâÊ≤°ÊúâÂè≥Á´ØÁÇπÂú® x Êàñ‰πãÂâçÁöÑint check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Êàë‰ª¨ÂÖà‰∏çË¶ÅËÄÉËôëËæπÊùÉ„ÄÇ ËÄÉËôëÁõ¥Êé• dpÔºå\(dp[u][i][j]\) Ë°®Á§∫ \(u\) ÁöÑÂ≠êÊ†ë‰∏≠‰øÆÊîπÂêéÊúâ \(i\) ‰∏™ÈªëÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøúÁöÑ‰∏éÂ≠êÊ†ë‰∏≠ÊâÄÊúâÈªëÁÇπË∑ùÁ¶ªÈÉΩÂ§ß‰∫é \(x\) ÁöÑÁ∫¢ÁÇπ‰∏éÊ†πÁöÑË∑ùÁ¶ª‰∏∫ \(j\)ÔºåÊúÄÂ∞èË¶Å‰øÆÊîπÂá†Ê¨°„ÄÇËΩ¨ÁßªÁöÑÊó∂ÂÄôÈúÄË¶ÅÂÜ≥ÂÆöË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÁ∫¢ÁÇπÔºåÊâÄ‰ª•ÈúÄË¶ÅÁü•ÈÅìË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÁöÑË∑ùÁ¶ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊàë‰ª¨ÂÜçËÆ∞‰∏Ä‰∏™ÊúÄËøëÈªëÁÇπÁöÑËØùÂ§çÊùÇÂ∫¶Â∞±ÁÇ∏‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞‰∏Ä‰∏™ÊÄßË¥®ÔºöÂ¶ÇÊûúÊ†πÊòØÁ∫¢ÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÊâÄÂú®ÁöÑ(Ê†πÁöÑÂÑøÂ≠êÁöÑ)Â≠êÊ†ë‰∏≠‰∏ÄÂÆöÊâÄÊúâÁ∫¢ÁÇπÈÉΩÂèØ‰ª•Âú®Ëøô‰∏™Â≠êÊ†ë‰∏≠ÊâæÂà∞Ë∑ùÁ¶ª‰∏çË∂ÖËøá \(x\) ÁöÑÈªëÁÇπ„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπ \(j = 0\) ÁöÑÊÉÖÂÜµÈ¢ùÂ§ñËÆ∞ÂΩï‰∏ãÊúÄËøëÁöÑÈªëÁÇπ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª• dp ‰∫Ü„ÄÇ Áé∞Âú®Êù•ËÄÉËôë‰∏Ä‰∏ãËæπÊùÉÔºåÊ≥®ÊÑèÂà∞Êàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåËøôÊ†∑Â∞±ËÉΩÂÅöÂ∏¶ÊùÉÁöÑÊÉÖÂÜµ‰∫Ü„ÄÇ ÂÜÖÂ≠òÈúÄË¶ÅÂç°‰∏Ä‰∏ã„ÄÇ È¢òËß£Á´üÁÑ∂ÊòØÂØπ \(500\) Á∫ßÂà´ÁöÑ‰∏úË•øË∑ëÂçïÁ∫ØÂΩ¢Ôºå‰∏çÂ§™ËÉΩÁêÜËß£Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇÁªèËøáËâ∞ÈöæÁöÑË∞ÉËØïÂíåÂç°Â∏∏Áªà‰∫é A ‰∫Ü„ÄÇÔºàÊó∂Èôê 1000 msÔºåÂºÄ Ofast 982 msÔºå‰∏çÂºÄ Ofast 998 msÔºåTATÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : Êúâ i ‰∏™ÈªëÁÇπÔºåÊâÄÊúâÁ∫¢ÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j // g : Êúâ i ‰∏™ÈªëÁÇπÔºåÊ≤°ÊúâÊú™ÂåπÈÖçÁ∫¢ÁÇπÔºåËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÈªëÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Âä®ÊÄÅËßÑÂàí</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÖàÊ±ÇÈáçÂøÉÔºöÈöè‰æøÊâæ‰∏™ÁÇπÔºåÊääÂ§öËæπÂΩ¢ÂàíÂàÜÊàêËã•Âπ≤‰∏™‰∏âËßíÂΩ¢ÔºåÊ±ÇÂá∫ÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºåÊåâÊúâÂêëÈù¢ÁßØÂä†ÊùÉÂπ≥Âùá„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁÇπ \((x_p,y_p)\)ÔºåËÆæ \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)„ÄÇÊääÂÆÉÁªï \((x_0,y_0)\) ÈÄÜÊó∂ÈíàÊóãËΩ¨ \(c\) ÂºßÂ∫¶ÔºåÁõ∏ÂΩì‰∫éÊää \(p\) Â∑¶‰πò‰∏Ä‰∏™Áü©Èòµ \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)„ÄÇÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ \(3 \times 3\) Áü©ÈòµÂ∞±ËÉΩÂø´ÈÄüËé∑ÂæóÊØè‰∏™ÁÇπÁöÑ‰ΩçÁΩÆ„ÄÇÊóãËΩ¨Êó∂ËÄÉËôë‰∏Ä‰∏ãÂõ∫ÂÆöÁöÑÁÇπÂíåÈáçÂøÉÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ Âê¨ÔºàÈ¢òËß£‰∏äÔºâËØ¥ÈúÄË¶ÅÊää‰∏Ä‰∏™ÁÇπÁßªÂà∞ \((0,0)\) ÈÅøÂÖçÁ≤æÂ∫¶ËØØÂ∑Æ„ÄÇ‰∏çÁü•ÈÅì‰∏çËøôÊ†∑ËÉΩ‰∏çËÉΩËøá„ÄÇ ÔºàÊ†∑‰æã 2 ÁúüÁöÑ‰ºöËΩ¨ÂêóÔºüÔºâ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n+m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // Áé∞Âú®Áî® p2 ÊóãËΩ¨ Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁúãÊàêÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™ÁÇπÊó∂‰ºöÁªôÂÆÉÊâÄÂú®ÁöÑËøûÈÄöÂùóÊØè‰∏™ÁÇπ‰∏Ä‰∏™Ë¥°ÁåÆ„ÄÇ ÂØπÊØè‰∏™ÁÇπÂØπ \((u,v)\) ËÆ°ÁÆó \(v\) ‰ºöÁªô \(u\) ‰∏Ä‰∏™Ë¥°ÁåÆÁöÑÊ¶ÇÁéáÔºå Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°à„ÄÇ È¢òÁõÆ‰∏≠ÁªôÂÆöÁöÑÂõæÊòØ‰∏ÄÊ£µÂü∫ÁéØÊ†ë„ÄÇ ÂØπ‰∫é \(u = v\)ÔºåËøô‰∏™Ê¶ÇÁéáÊòØ \(1\)„ÄÇÂØπ \(u \neq v\)ÔºåÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö ‰∏ÄÔºå \(u,v\) Âú®Âêå‰∏Ä‰∏™Â≠êÊ†ë‰∏≠„ÄÇÊää \(u\) Áúã‰ΩúÊ†πÔºåÈÇ£‰πàËøô‰∏™Ê¶ÇÁéáÂ∞±ÊòØÔºåÊØèÊ¨°‰ªéËøòÊú™Ë¢´Âà†Èô§ÁöÑÁÇπ‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÁÇπÔºåÂ∞ÜÂÖ∂Â≠êÊ†ëÂà†Èô§ÔºåÂΩì \(v\) Ë¢´Âà†Èô§Êó∂Ôºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÈô§‰∫Ü \(v\) ‰ª•Â§ñÁöÑÁÇπÈÉΩËøòÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéá„ÄÇËÆæÊÄªÂÖ±Êúâ \(n\) ‰∏™ÁÇπÔºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÊúâ \(k\) ‰∏™ÁÇπÔºåÁ±ª‰ººÁåé‰∫∫ÊùÄ‰∏ÄÈ¢ò‰∏≠ÁöÑÊäÄÂ∑ßÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìËøô‰∏™Ê¶ÇÁéáÁ≠â‰∫é‰∏çÊñ≠‰ªé \([1,n]\) ‰∏≠Á≠âÊ¶ÇÁéáÈöèÊú∫Âèñ‰∏Ä‰∏™Êï¥Êï∞Ôºå‰∏ÄÊó¶Âá∫Áé∞ \(v\) Êàñ \(v\) ÁöÑÁ•ñÂÖàÂ∞±ÂÅúÊ≠¢ÔºåÂÅúÊ≠¢Êó∂Èô§ \(v\) ‰ª•Â§ñ \(v\) ÁöÑÊâÄÊúâÁ•ñÂÖàÈÉΩÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéáÔºåÂç≥ \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)„ÄÇ ‰∫åÔºå\(u,v\) ‰∏çÂú®Âêå‰∏ÄÂ≠êÊ†ë‰∏≠Ôºå‰∏éÊÉÖÂÜµ‰∏ÄÁ±ª‰ººÔºå‰ΩÜÊòØ‰∏çÂêåÁöÑÊòØÊ≠§Êó∂ \(u\) Âà∞ \(v\) Êúâ‰∏§Êù°Ë∑ØÂæÑÔºåÂè™Ë¶ÅÂÖ∂‰∏≠‰∏ÄÊù°Â≠òÂú®Â∞±ÊúâË¥°ÁåÆ„ÄÇÂèØ‰ª•ÂÆπÊñ•ÊàêÁ¨¨‰∏ÄÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂä†‰∏äÁ¨¨‰∫åÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂáèÂéª‰∏§Êù°ÈÉΩÂ≠òÂú®ÁöÑÊ¶ÇÁéá„ÄÇËøô‰∏â‰∏™ÈóÆÈ¢òÈÉΩÂèØ‰ª•Á±ª‰ººÊÉÖÂÜµ‰∏ÄÂú∞Ëß£ÂÜ≥„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n^2)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÊú¨È¢ò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊÉ≥‰∫ÜÊå∫‰πÖÂè™‰ºöËÉ°‰∏™ \(\mathcal O(n \sqrt n \log n)\) ÁöÑËé´Èòü + Áª¥Êä§ huffman Ê†ëÔºåÂéªÁúã‰∫ÜÁúºÂà´‰∫∫ÁöÑÈ¢òËß£ÂèëÁé∞‰πüÊúâÊòØËøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ.....‰∏çËøáÊØîÊàëËÉ°ÁöÑÂ¶ôÂ§ö‰∫ÜÔºå‰∏ãÈù¢ÂÜôÁöÑÊòØÁúãÂà∞ÁöÑÂà´‰∫∫ÁöÑÂÅöÊ≥ï„ÄÇ Áî®Ëé´ÈòüÂ§ÑÁêÜËØ¢ÈóÆÔºåÁª¥Êä§‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÔºåÂπ∂ËÆ∞ÂΩï‰∏ãÂΩìÂâçÂá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞„ÄÇÂØπÊ¨°Êï∞‰∏çË∂ÖËøá \(x\) ÁöÑÊï∞ÔºåËÆ∞‰∏Ä‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÁÑ∂Âêé \(\mathcal O(x)\) ÁÆóÂá∫ÂêàÂπ∂‰ª£‰ª∑„ÄÇËΩ¨Âåñ‰∏∫Âè™ÊúâÂá∫Áé∞Ê¨°Êï∞Ë∂ÖËøá \(x\) ÁöÑÊï∞ÁöÑÊÉÖÂÜµÔºåËøôÊó∂ÊúÄÂ§öÂè™Êúâ \(\frac n x\) ‰∏™Êï∞ÔºåË¥™ÂøÉÂêàÂπ∂Âç≥ÂèØ„ÄÇËØ¢ÈóÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(x + \frac n x \log n)\)ÔºåÂèñ \(x = \sqrt {n \log n}\)ÔºåÂàô‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\sqrt {n \log n}\)„ÄÇ Ëé´ÈòüÁª¥Êä§Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞Êó∂ÂèØ‰ª•‰ΩøÁî®ÈìæË°®ÔºåËøôÊ†∑ÁöÑËØùËé´ÈòüÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï È¢òÁõÆ‰∏≠ÁöÑËøûËæπÊñπÂºèÂèØ‰ª•Ê¶ÇÊã¨‰∏∫ÔºåÂ¶ÇÊûú(ÂºÄ)Âå∫Èó¥ \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∫§‰∏ç‰∏∫Á©∫Ôºå‰∏î \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∏çÊòØ‰∏ÄÂØπÂ≠òÂú®ÂåÖÂê´ÂÖ≥Á≥ªÁöÑÂå∫Èó¥ÔºåÈÇ£‰πàËøô‰∏§‰∏™Âå∫Èó¥‰πãÈó¥Êúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇÂê¶ÂàôÔºåÂ¶ÇÊûú \((l_1,r_1)\) Ë¢´ \((l_2,r_2)\) ÂåÖÂê´Ôºå\((l_1,r_1)\) Âà∞ \((l_2,r_2)\) Êúâ‰∏ÄÊù°ÊúâÂêëËæπ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™‰ªÖÁî±ÂèåÂêëËæπÊûÑÊàêÁöÑËøûÈÄöÂùóÔºåËÆæËøô‰∏™ËøûÈÄöÂùó‰∏≠ÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂‰∏∫ \((L,R)\)ÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ§‰∏∫Áé∞Âú®Â∞±Â≠òÂú®ËøôÊ†∑‰∏Ä‰∏™Âå∫Èó¥ \((L,R)\)„ÄÇÂõ†‰∏∫ÈïøÂ∫¶ÊòØÈÄíÂ¢ûÁöÑÔºåÂ¶ÇÊûú‰πãÂêéÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ \((a,b)\)Ôºå\(a\) Ë¢´ \((L,R)\) ÂåÖÂê´ÊàñËÄÖ \(b\) Ë¢´ \((L,R)\) ÂåÖÂê´ÔºåÈÇ£‰πà \((a,b)\) ‰∏éËøô‰∏™ËøûÈÄöÂùó‰∏≠ÁöÑÊüê‰∏™ÁÇπÊúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇ‰∏çÈöæÂèëÁé∞Ôºå‰∏Ä‰∏™Âå∫Èó¥ \(a\) ËÉΩÂà∞ËææÂå∫Èó¥ \(b\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(a\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Ë¢´ \(b\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂ÂåÖÂê´„ÄÇËøôÊ†∑Êàë‰ª¨Âè™Ë¶ÅÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ËøûÈÄöÂùóÔºåÂπ∂ËÆ∞ÂΩï‰∏Ä‰∏ãËøûÈÄöÂùóÁöÑÂπ∂ÁöÑÂ∑¶Âè≥Á´ØÁÇπÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ËÉΩÂê¶Âà∞Ëææ‰∫Ü„ÄÇ update : ‰ªîÁªÜËØÅ‰∫Ü‰∏Ä‰∏ã‰πãÂêé‰ºº‰πéËøô‰∏ÄÁªìËÆ∫ÂÜç‰∏§‰∏™ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Áõ∏ÂêåÊó∂‰∏çÊàêÁ´ãÔºåÈúÄË¶ÅÁâπÂà´Âà§‰∏Ä‰∏ã‰ºö‰∏ç‰ºöÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂè™Êúâ‰∏Ä‰∏™ÁÇπ„ÄÇ Êàë‰ª¨Áî®Á∫øÊÆµÊ†ëÁª¥Êä§ÔºåÂØπ‰∫éÊØè‰∏™ÁÇπÊúâÂì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´Ëøô‰∏™ÁÇπ„ÄÇËøôÂèØ‰ª•ÈÄöËøáÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™ÁÇπÂºÄ‰∏Ä‰∏™ vector Êù•ÂÆûÁé∞ÔºåÊü•ËØ¢Âì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´‰∏Ä‰∏™ÁÇπÊó∂ÔºåÂè™ÈúÄÂèñËøô‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâ vector ÁöÑÂπ∂Âç≥ÂèØ„ÄÇÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÔºåÂ∞±ÂØπÂ∑¶Âè≥Á´ØÁÇπÊü•‰∏Ä‰∏ãÔºåÊääÂæóÂà∞ÁöÑËøûÈÄöÂùóÂêàÂπ∂ÔºåÁÑ∂ÂêéÂÜçÊääÊñ∞ÁöÑËøûÈÄöÂùóÂä†ÂÖ•Á∫øÊÆµÊ†ë„ÄÇÁî±‰∫éÊâÄÊúâË¢´‰Ω†Êü•ËøáÁöÑÁÇπ vector ‰∏≠ÊâÄÊúâÁÇπÈÉΩ‰ºöË¢´‰Ω†ÂêàÂπ∂ÔºåÊâÄ‰ª•‰Ω†ÊØèÊü•ËØ¢‰∏Ä‰∏™ÁÇπÁöÑ vector Â∞±ÂèØ‰ª•ÊääÂÆÉÁöÑ vector Ê∏ÖÁ©∫ÔºåËÄåÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÊúÄÂ§öÂ¢ûÂä†‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†Âè™‰ºöÁªô \(\mathcal O(\log n)\) ‰∏™ÁÇπÁöÑ vector Ê∑ªÂä†ÂÖÉÁ¥†„ÄÇÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n \alpha (n))\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x ÊòØÊ†πÔºåÊää y Âä†ÂÖ• xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰ΩúÈáçÈìæÂâñÂàÜÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÈáçÈìæÂâñÂàÜÂêéÁöÑ dfs Â∫è„ÄÇ ‰∏ÄÊù°ÈìæÂèØ‰ª•ÊãÜÊàê dfs Â∫è‰∏ä \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥„ÄÇ Êåâ dfs Â∫èÊääÊØè‰∏™ÁÇπÁöÑÂ≠óÁ¨¶ÊéíÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\)ÔºåÈ¢ÑÂÖàÂª∫‰∏Ä‰∏™ËÉΩ \(\mathcal O(1)\) ËØ¢ÈóÆ \(s\) ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcpÔºåËØ¢ÈóÆ \(s^R\) ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcp ÂíåËØ¢ÈóÆ‰∏Ä‰∏™ \(s\) ÁöÑÂêéÁºÄÂíå \(s^R\) ÁöÑ‰∏Ä‰∏™ÂêéÁºÄÁöÑ lcp ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂèØ‰ª•ÂØπ \(ss^R\) Âª∫Ê†ëÁä∂Êï∞ÁªÑÔºåÂõ†‰∏∫Êàë‰∏çÊìÖÈïøÂÜôÊ†ëÁä∂Êï∞ÁªÑÔºåÊâÄ‰ª•ÊàëÂØπÂÆÉ‰ª¨Áî® SAM Ê±ÇÂá∫‰∫ÜÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂÜô‰∫Ü‰∏Ä‰∏™ \(\mathcal O(n\log n) - \mathcal O(1)\) lca„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆÔºå‰∏ÄÊù°ÈìæÔºåÂèØ‰ª•ÁúãÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÔºåÊâÄ‰ª•Â∞±ÂèòÊàê‰∫Ü‰∏§ÁªÑËã•Âπ≤‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÁöÑ‰∏≤Ë¶ÅÊ±Ç lcpÔºåÂà©Áî®È¢ÑÂ§ÑÁêÜÁöÑ‰ø°ÊÅØ‰ªéÂâçÂæÄÂêé‰æùÊ¨°Ê±ÇÂ∞±Ë°å‰∫Ü„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // ÂÜô‰∏Ä‰∏™Áªô‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊîØÊåÅËØ¢ÈóÆ LCP ÁöÑ‰∏úË•ø int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind ÊòØÊ≠£‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ // rind ÊòØÂèç‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôëÊåâ‰∏≤ÈïøÊ†πÂè∑ÂàÜÁ±ª„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ§ß‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåËøôÊ†∑ÁöÑ‰∏≤‰∏ç‰ºöÂæàÂ§öÔºåÊûö‰∏æÊØè‰∏™ËøôÊ†∑ÁöÑ‰∏≤ÔºåÁî® AC Ëá™Âä®Êú∫ÁªüËÆ°ÂÖ∂‰ªñÊØè‰∏™‰∏≤‰Ωú‰∏∫Ëøô‰∏™‰∏≤Â≠ê‰∏≤Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÆó‰∏Ä‰∏ãÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÂõûÁ≠î‰∏Ä‰∏ãÂÖ≥‰∫éËøô‰∏™‰∏≤ÁöÑÊâÄÊúâËØ¢ÈóÆ„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ∞è‰∫éÁ≠â‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåÊääËØ¢ÈóÆ \([l,r]\) ÊãÜÊàê \([1,r]\) Âíå \([1,l-1]\) Áõ∏ÂáèÔºåÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÊØè‰∏™ÂâçÁºÄÔºåÂõûÁ≠î‰∏éÊØè‰∏™ÂâçÁºÄÁõ∏ÂÖ≥ÁöÑÊâÄÊúâÂõûÁ≠î„ÄÇÂú®Êâ´ÂâçÁºÄÁöÑËøáÁ®ã‰∏≠ÔºåÁî®‰∏Ä‰∏™ AC Ëá™Âä®Êú∫ \(\mathcal O(‰∏≤Èïø)\) ËØ¢ÈóÆËøô‰∏™ÂâçÁºÄ‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êüê‰∏™‰∏≤ÁöÑÂ≠ê‰∏≤Âç≥ÂèØ„ÄÇÈÇ£‰πàÂè™ÈúÄË¶ÅÂú® AC Ëá™Âä®Êú∫‰∏äÂÆûÁé∞‰∏Ä‰∏™ fail Ê†ë‰∏äÁöÑÂ≠êÊ†ëÂä†ÔºàÂä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑ‰∏≤ÔºâÔºåÂú® dfs Â∫è‰∏äËΩ¨‰∏∫Âå∫Èó¥Âä†ÔºåÁî®ÂàÜÂùóÂÅöÂà∞ \(\mathcal O(\sqrt n)\) Âå∫Èó¥Âä†Ôºå \(\mathcal O(1)\) ÂçïÁÇπËØ¢ÈóÆÂ∞±Ë°å‰∫Ü„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÂèØ‰ª•‰∫åÂàÜÁ≠îÊ°àÔºåËΩ¨Âåñ‰∏∫ËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºöÊØè‰∏™ËæπÁöÑËæπÊùÉÊòØÊ≠£Ë¥ü‰∏ÄÔºåÂà§Êñ≠ÊòØÂê¶ÊúâÈïøÂ∫¶Âú® \(l\) Âà∞ \(r\) ‰πãÈó¥ÁöÑË∑ØÂæÑÔºåÊùÉÂÄº‰πãÂíåÈùûË¥ü„ÄÇ ‰ªé‰∏ãÂæÄ‰∏äÂêàÂπ∂ÔºåÊØèÊ¨°ËÄÉËôëÂΩìÂâçÁÇπ‰Ωú‰∏∫ lca ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊääÂ≠êÊ†ëÂêàÂπ∂ÔºåÁî±‰∫é‰Ω†ÂêàÂπ∂Êó∂Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁÇπÂ≠êÊ†ë‰∏≠ÊØè‰∏™Ê∑±Â∫¶Âà∞Ê†πÊùÉÂÄºÂíåÊúÄÂ§ßÁöÑÁÇπÔºåÂèØ‰ª•Áî®ÈïøÈìæÂâñÂàÜÊù•Áª¥Êä§Ê∑±Â∫¶‰ø°ÊÅØ„ÄÇÂêàÂπ∂ÁöÑÊó∂ÂÄôÈ°∫‰æøËØ¢ÈóÆ‰∏Ä‰∏ãÁ≠îÊ°àÔºåÈïøÈìæÂâñÂàÜ + Á∫øÊÆµÊ†ëÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÈïøÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁÇπÂàÜÊ≤ª‰∏Ä‰∏ãÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãÈóÆÈ¢òÔºö Êúâ‰∏§‰∏™Èïø‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a_1\) Âíå \(d_1\)Ôºå‰∏§‰∏™Èïø‰∏∫ \(m\) ÁöÑÊï∞ÁªÑ \(a_2\) Âíå \(d_2\)ÔºåÊ±ÇÔºö \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] Êûö‰∏æ‰∏Ä‰∏ã \(i\)ÔºåÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂΩ¢Â¶Ç \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) ÁöÑ‰∏úË•ø„ÄÇ Ê≥®ÊÑèÂà∞ \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) ËÆæ \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) ÊòØÂæàÂÆπÊòìÂ§ÑÁêÜÁöÑÔºåÂè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(1\ldots m\) ‰∏≠ÁöÑÊï∞ \(i\) ËÄÉËôë \(d_2[i]\phi(a_2[i])\) ÂØπÊØè‰∏™ \(s\) ‰∏≠ \(i\) ÁöÑÁ∫¶Êï∞‰∏ãÊ†á‰ΩçÁΩÆÁöÑË¥°ÁåÆÂç≥ÂèØ„ÄÇ Â¶ÇÊûúÊö¥ÂäõËÆ°ÁÆó‰∏äÂºèÔºåÂ§çÊùÇÂ∫¶‰∏∫ \(1 \ldots n\) ‰∏≠ÊØè‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞‰πãÂíå‰πò‰ª•ÁÇπÂàÜÊ≤ªÁöÑ‰∏Ä‰∏™ \(\log\)„ÄÇÂâçÈù¢ÁöÑÈÉ®ÂàÜÂ§çÊùÇÂ∫¶ÊòØ \(\log^2\) ÁöÑÔºàËÄÉËôë \((\sum \frac 1 i )^2\)ÔºâÔºå‰ªéËÄåÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\log^3 n)\)„ÄÇ ÁªßÁª≠ÂØπ‰∏äÂºèÂèòÂΩ¢Ôºö ËÆæ \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)Ôºå\(t_k\) ÊòØ‰∏Ä‰∏™Â∏∏Êï∞„ÄÇ \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] ËÄÉËôëÂØπ \(t\) ËøõË°åÈ¢ÑÂ§ÑÁêÜ„ÄÇ\(t\) ÊòØ‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞ÔºàÂõ†‰∏∫ÂÆÉÊòØ‰∏§‰∏™ÁßØÊÄßÂáΩÊï∞ÁöÑÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºâÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•ÊääÂÆÉÁ≠õÂá∫Êù•„ÄÇ ‰ΩÜÊòØÂõ†‰∏∫ÊàëÊáíÔºåÊàëÈÄâÊã©Áõ¥Êé•Êö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(t\)ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;„ÄÇÔºå &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Êï∞ËÆ∫</tag>
        <tag>ÁÇπÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Èöè‰æøÂèñ‰∏Ä‰∏™ÁÇπ‰ΩúÊ†πÔºåÁî®Á∫øÊÆµÊ†ëÊåâ dfs Â∫èÁª¥Êä§Â≠òÂú®ÁöÑÁÇπÔºåÁª¥Êä§‰∏Ä‰∏ãÊâÄÊúâÂ≠òÂú®ÁöÑÁÇπÁöÑ lca ÂíåÂà∞Ê†πÁöÑË∑ØÂæÑÁöÑÂπ∂ÁöÑÈïøÂ∫¶Âç≥ÂèØ„ÄÇ ËØØ‰ª•‰∏∫Ë¶ÅÂáèÂéªÁÇπÊï∞ * lca ÁöÑÊ∑±Â∫¶ÔºåË∞É‰∫ÜÂ•Ω‰πÖ... ‰∏ÄÁõ¥Ë∞É‰∏çÂá∫Êù•ÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•‰∏Ä‰∏ãÊòØ‰∏çÊòØÂì™ÈáåÊÉ≥Èîô‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈúÄË¶ÅÁªèÂ∏∏Â§ç‰π†ÁöÑ‰∏úË•ø]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÊÑüËßâËá™Â∑±ËÄÉËØïÁöÑÊó∂ÂÄôÂæàÈöæÁã¨Á´ãÊÉ≥Âá∫Êù•‰ΩÜÊòØÂèàÁªèÂ∏∏‰ºöÂøòÁöÑ‰∏úË•ø„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπËßÅ ËøôÁØá blogÔºåËÄÉÂâçÂ§ç‰π†Áî®„ÄÇ Ê•ºÊàøÈáçÂª∫ÁöÑÂÅöÊ≥ï (2020.03.09) ÊîØÈÖçÊ†ë ‰ºØÂä™Âà©Êï∞‰∏éËá™ÁÑ∂Êï∞ÂπÇÂíå Ëá™ÁÑ∂Êï∞ÁöÑÔºàÂèØÈáç / ‰∏çÂèØÈáçÔºâÊó†Â∫èÊãÜÂàÜÔºöÊ†πÂè∑ÂÅöÊ≥ï‰∏é \(\log\) ÂÅöÊ≥ï jlsÁ∫øÊÆµÊ†ë ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó‰∏éÁ±ªÊ¨ßÂá†ÈáåÂæó Â§ÑÁêÜÂàÜÊØçÁ≠âÂ∑ÆÁîüÊàêÂáΩÊï∞ÁöÑÊñπÊ≥ï ‰Ω†ÁöÑÂêçÂ≠ó ÈÇ£‰∏™È¢òÁöÑÂÅöÊ≥ï ÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÊãìÊâëÂ∫è(ÊåáÊåâÁºñÂè∑‰ªéÂ∞èÂà∞Â§ßÊääÊØè‰∏™ÁÇπÂú®ÊãìÊâëÂ∫è‰∏äÁöÑ‰ΩçÁΩÆÂÜô‰∏ãÊù•ÁöÑÂ∫èÂàó)ÔºåËßÅ agc001_f Âà©Áî®Êó∂Èó¥Êà≥Á∫øÊÄßÂü∫ (ÊåâÊØè‰∏™ÂÖÉÁ¥†Ë¢´Âà†Èô§ÁöÑÊó∂Èó¥) ÂÆûÁé∞Á¶ªÁ∫øËøõË°å‰∏çÂ∏¶ log ÁöÑÁ∫øÊÄßÂü∫ÊèíÂÖ•Âà†Èô§ Âà§Á∫øÊÄßÊó†ÂÖ≥Êó∂ÊääÂÆûÊï∞ÊîπÊàêÂèñÊ®°Âπ∂‰∏ç‰ºöÊúâÂ§™Â§ßÊçüÂ§±ÔºåÁ±ª‰ººÂìàÂ∏åÔºàÈÄêÊ≠•ËÄÉËôëÁü©ÈòµÁöÑÂèòÂåñ~ÔºåÂÖ∂ÂÆûÂè™Ë¶Å‰∏çÂá∫Áé∞Ê®°Êï∞ÂÄçÊï∞Â∞±Ë°å Èìæ‰∏äËØ¢ÈóÆ / Âå∫Èó¥ËØ¢ÈóÆÂ∞è‰∫éÁ≠â‰∫é \(k\) (k ÊØèÊ¨°ÁªôÂÆö) ÁöÑÂÖÉÁ¥†ÁöÑ‰ø°ÊÅØ (‰∏çÂèØÂáè)ÔºåÊúâÂäûÊ≥ï‰∏Ä‰∏™ \(\log\) ÁÇπÂèåËÅîÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï (ÂÜô‰∫ÜÁØáÂÖ¨ÂºÄ blog) ‰∏ÄÁ±ª‰∫åÂàÜÂá∏‰ºòÂåñËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ï ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÂÖ∂Êâ©Â±ï ËÆ∞ÂæóÂç∑ÁßØÂΩ¢ÂºèÁöÑ dp ÂèØ‰ª•ÂàÜÊ≤ª fft ‰ºòÂåñ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éÂõûÊªöÊìç‰ΩúÁöÑÊäÄÂ∑ßÂú®ÈúÄË¶ÅÂõûÊªöÁöÑÊï∞ÁªÑÊØîËæÉÂ§öÁöÑÊó∂ÂÄô‰∏Ä‰∏™‰∏Ä‰∏™ÂºÄÊ†àÂõûÊªö‰ºöÊØîËæÉÈ∫ªÁÉ¶ÔºåÂèØ‰ª•ËØïÁùÄ‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; ËøôÊ†∑ËøòÂéüÁöÑÊó∂ÂÄô‰πüÂè™ÈúÄË¶ÅÊ†πÊçÆÊåáÈíàÊêû‰∏ÄÊêûÂ∞±Â•ΩÔºåÂè™ÈúÄË¶ÅÂºÄ‰∏Ä‰∏™Ê†àÂ∞±Ë°å‰∫ÜÔºåÊ≥®ÊÑè \(k\) ‰∏çË¶ÅÂºÄÂ∞è„ÄÇ ÊúâÊó∂ÂÄô‰Ω†ÈúÄË¶ÅËÆ∞ÂΩï‰∏Ä‰∏™ÊîØÊåÅÈöèÊó∂Ê∏ÖÁ©∫ÁöÑ \(01\) Êï∞ÁªÑÔºåËøôÊó∂ÂèØ‰ª•‰∏çÈ¢ùÂ§ñÂºÄÊ†áËÆ∞Êï∞ÁªÑ„ÄÇËÆ∞‰∏Ä‰∏™ÂèòÈáè \(tim\)ÔºåËµã \(1\) ÁöÑÊó∂ÂÄôÂ∞±ËÆæ‰∏∫ \(tim\)ÔºåÂà§Êñ≠ÊòØ \(0\) ËøòÊòØ \(1\) Â∞±ÁúãÊòØÂê¶Á≠â‰∫é \(tim\)ÔºåÊ∏ÖÁ©∫Â∞± \(tim \leftarrow tim + 1\)„ÄÇ ‰∏ä‰∏ãÁïåË¥πÁî®ÊµÅÔºåÂØπÊØèÊù°ÂøÖÈ°ªËæπ‰∏çË¶ÅÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂØπÊØè‰∏Ä‰∏™ÁÇπËÆ∞‰∏Ä‰∏™Â∫¶Êï∞ÔºåÂÖ®ÈÉ®Ê∑ªÂä†‰πãÂêéÂÜçÊ†πÊçÆÂ∫¶Êï∞ÂÜ≥ÂÆöÊØè‰∏™ÁÇπÂà∞Ë∂ÖÁ∫ßÊ∫êËøòÊòØË∂ÖÁ∫ßÊ±áÔºåËøûÂ§öÂ§ßÊµÅÈáèÁöÑËæπÔºåËøôÊ†∑ÂèØ‰ª•Â§ßÂ§ßÂáèÂ∞ëËæπÊï∞„ÄÇ Âú®ÂÅö dinic Êó∂‰ª•‰∏ã‰∏§‰ªΩ‰ª£Á†ÅÊúâÂ∑®Â§ßÂ∏∏Êï∞Â∑ÆË∑ùÔºå‰∏ãÈù¢ÁöÑÊúâÊó∂ÁîöËá≥ÂèØ‰ª•ÊØî‰∏äÈù¢ÁöÑÂø´ÂçÅÂÄçÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà„ÄÇ 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊääÊìç‰ΩúÁ¶ªÁ∫øÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºåÊääÈóÆÈ¢òÂèòÊàêÂè™ÈúÄË¶ÅÊîØÊåÅÂä†ËæπÔºåÂõûÊªöÔºåÁª¥Êä§‰∏§ÁÇπÈó¥ÊúÄÂ∞è \(xor\) Ë∑ØÂæÑ„ÄÇ Âú®ËØ¢ÈóÆ \(u,v\) ‰∏≠Ôºå‰Ω†ÂèØ‰ª•‰ªé \(u\) Ëµ∞Âà∞ \(t\) ÁÑ∂ÂêéËµ∞Âõû \(u\)ÔºåË∑ØÂæÑ‰∏äÊØèÊù°ËæπÈÉΩË¢´ÁªèËøá‰∏§Ê¨°ÔºåÊâÄ‰ª•Ë∑ØÂæÑ‰∏äÁöÑËæπË¥°ÁåÆ‰∏∫ \(0\)„ÄÇÂõ†Ê≠§Â¶ÇÊûúÊúâ‰∏ÄÊù° \(xor\) ‰∏∫ \(x\) ÁöÑ \(u,v\) Ë∑ØÂæÑÔºåÊúâ‰∏Ä‰∏™ \(xor\) ‰∏∫ \(c\) ÁöÑÁéØÔºåÂ∞±Â≠òÂú®‰∏ÄÊù° \(xor\) ‰∏∫ \(x\oplus c\) ÁöÑË∑ØÂæÑ„ÄÇ ‰ªªÊÑèËÄÉËôë‰∏ÄÊ£µÁîüÊàêÊ†ëÔºåÂØπ‰∫é‰∏Ä‰∏™ÈùûÊ†ëËæπ \(u,v,w\)ÔºåËÆæ \(u\) Âà∞ \(v\) ÁöÑÊ†ë‰∏äË∑ØÂæÑ \(xor\) ‰∏∫ \(x\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ \(xor\) ‰∏∫ \(x \oplus w\) ÁöÑÁéØÔºåÂõ†Ê≠§Â¶ÇÊûúÁªèËøá‰∫ÜËøôÊù°ÈùûÊ†ëËæπÔºåÊàë‰ª¨‰∏çÂ¶®ÊääÂÆÉÁúãÊàêÊòØÊ≤øÁùÄÊ†ë‰∏äË∑ØÂæÑ‰ªé \(u\) Ëµ∞Âà∞ \(v\)„ÄÇ‰πãÂêéÂÜçÂºÇÊàñ‰∏äËøô‰∏™Êç¢ÁöÑÊùÉÂÄº„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÊää \(u\) Âà∞ \(v\) ‰πãÈó¥ÁöÑÊ†ë‰∏äË∑ØÂæÑÂºÇÊàñ‰∏ä‰∏Ä‰∫õÁî±‰∏ÄÊù°ÈùûÊ†ëËæπ‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\)ÔºåÁ≠îÊ°àÊúÄÂ∞èÊòØ‰ªÄ‰πà„ÄÇ Áª¥Êä§ÊâÄÊúâÈùûÊ†ëËæπÂä†‰∏ä‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\) ÁöÑÁ∫øÊÄßÂü∫Âç≥ÂèØ„ÄÇ ÁÑ∂ÂêéËÄÉËôëÊÄé‰πàÂä†ËæπÁª¥Êä§Ëøô‰∏™‰∏úË•ø„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂõûÊªöÔºåÂùáÊëäÁÆóÊ≥ïÔºàÂ¶Ç LCTÔºåË∑ØÂæÑÂéãÁº©ÁöÑÂπ∂Êü•ÈõÜÔºâÊó†Ê≥ï‰ΩøÁî®„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊîØÊåÅËØ¢ÈóÆ‰∏§ÁÇπÊòØÂê¶ËøûÈÄöÔºåËØ¢ÈóÆ‰∏§ÁÇπ‰πãÈó¥ÁöÑ \(xor\)ÔºåÂä†ËæπÂíåÂõûÊªöÂç≥ÂèØ„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁªôÁÇπ \(i\) Áª¥Êä§‰∏Ä‰∏™ÂÄº \(v_i\)ÔºåÂàùÂßãÊó∂ÊâÄÊúâÁÇπÁöÑÂÄº \(=0\)ÔºåÁî®ÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÊù•Áª¥Êä§ËøûÈÄöÊÄß„ÄÇÊàë‰ª¨ÂßãÁªàË¶Å‰øùËØÅÂØπ‰∫é‰ªªÊÑèÁöÑ \(u,v\)ÔºåÂ¶ÇÊûú \(u,v\) ËøûÈÄöÔºåÈÇ£‰πà \(u,v\) ‰πãÈó¥Ê†ë‰∏äË∑ØÂæÑÁöÑ \(xor\) Á≠â‰∫é \(v_u \oplus v_v\)„ÄÇÊØèÊ¨°Âä†ËæπÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰∏§‰∏™ËøûÈÄöÂùóÂπ∂Êàê‰∫Ü‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†ÂèØ‰ª•ÈÄöËøáÊääÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑ \(v_i\) ÂºÇÊàñ‰∏ä‰∏Ä‰∏™Êï∞Êù•‰øùÊåÅËøô‰∏ÄÊÄßË¥®„ÄÇÊåâÁß©ÂêàÂπ∂Êó∂Êâì‰∏™ tag Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å ËøôÊ¨°Â∞ùËØï‰∫Ü‰∏ÄÁßçÊñ∞ÁöÑÁ†ÅÈ£é„ÄÇÁúã‰∏äÂéªÂ≠óÁ¨¶ÈáèÂ∞ë‰∫Ü‰∏çÂ∞ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // ÂáÜÂ§áÂ∑¶Âå∫Èó¥ for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // ÂáÜÂ§áÂè≥Âå∫Èó¥ for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊÑüËßâÊØî E È¢òÈöæ‰ΩÜÊòØËøáÁöÑ‰∫∫ËøúÊØî E È¢òÂ§ö... ‰∏çÁü•ÈÅì piece ÊÄé‰πàÁøªËØëÔºåÂêéÈù¢Áî®Áü≥Â≠ê‰ª£Êåá piece„ÄÇ ÂÖàÊûö‰∏æ‰∏Ä‰∏™ÁÇπ \(r\)ÔºåÁÑ∂ÂêéËÄÉËôëÊääÊâÄÊúâÁü≥Â≠êÈÉΩÁßªÂä®Âà∞ÁÇπ \(r\) ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÊää \(r\) ‰Ωú‰∏∫Ê†πÔºåËÄÉËôëÊØè‰∏™Áü≥Â≠êÂà∞ \(r\) ÁöÑË∑ùÁ¶ª‰πãÂíå \(s\)ÔºåÊòæÁÑ∂Êìç‰Ωú‰∏ç‰ºöÊîπÂèò \(s\) ÁöÑÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Â¶ÇÊûú \(s\) ÊòØÂÅ∂Êï∞Ôºå‰∏çÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°à„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°àÔºåÈÇ£‰πàÊúÄÂ∞ëÊ≠•Êï∞ÂøÖÁÑ∂ÊòØ \(\frac s 2\)ÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰∏™ÊñπÊ°à‰∏≠Êúâ‰∏ÄÊ¨°‰Ωø‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ∞èÔºåÂè¶‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ§ßÔºå‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏Ä‰∏™Ê≠•Êï∞Êõ¥Â∞ëÁöÑÁöÑÊñπÊ°à„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âè™ÈúÄËÄÉËôëÂ¶Ç‰ΩïÊ£ÄÈ™åÊñπÊ°àÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™ËÄÉËôë‰∏Ä‰∏™Â≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºå‰∏çÈöæÂèëÁé∞ÊúÄ‰ºòÊñπÊ°à‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏ÄÁßçÂÖàËøõË°åÂÆåÂÖ®Âú®Êüê‰∏™ÂÑøÂ≠êÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÔºåÂÜçËøõË°å‰∏§‰∏™Áü≥Â≠êÂú®‰∏çÂêåÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÁöÑÊñπÊ°à„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂÅöÊ†ëÂΩ¢ dpÔºåËÆæ \(f_{ij}\) Ë°®Á§∫ÊòØÂê¶ÂèØ‰ª•ÂØπ \(i\) ÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÁü≥Â≠êËøõË°åÊìç‰ΩúÔºå‰ΩøÂæó \(i\) Â≠êÊ†ëÂÜÖÈÉ®Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ª‰πãÂíå‰∏∫ \(j\)„ÄÇËÄÉËôëÊÄé‰πàËΩ¨ÁßªÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∫ÜÁÇπ \(u\) ÊØè‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºåÁªèËøáËøô‰∫õÊìç‰ΩúÊó∂ÂÄôÁ¨¨ \(i\) ‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÁü≥Â≠êÂà∞ \(u\) Ë∑ùÁ¶ª‰πãÂíå‰∏∫ \(s_i\)ÔºåÂÖ±Êúâ \(c\) ‰∏™ÂÑøÂ≠êÔºåËÆæ \(\max s_i = t\)ÔºåÂèØ‰ª•ËØÅÊòéÔºå\(f_{uj} = 1\)ÔºåÂΩì‰∏î‰ªÖÂΩì \(j\) ‰∏é \(\sum s_i\) Â•áÂÅ∂ÊÄßÁõ∏ÂêåÔºå‰∏î \(j \ge 2t - \sum s_i\)„ÄÇËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â§™Â§ß‰∫ÜÔºå‰∏çÈöæÂΩíÁ∫≥ËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(f_{ij} = 1\) ÁöÑ \(j\) ÂøÖÁÑ∂ÊòØÊüê‰∏™Âå∫Èó¥ÂÜÖÁöÑÊâÄÊúâÂ•áÊï∞ / ÂÅ∂Êï∞„ÄÇÂà©Áî®Ëøô‰∏™ÊÄßË¥®ÔºåÊàë‰ª¨ dp ‰ΩøÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™Âå∫Èó¥Âç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóËøô‰∏™Âå∫Èó¥ÁöÑÂè≥ËæπÁïåÊó∂ÔºåÂè™ÈúÄÊääÊâÄÊúâÂÑøÂ≠êÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁü≥Â≠êÂà∞Ëøô‰∏™ÂÑøÂ≠êÁöÑË∑ùÁ¶ª‰πãÂíåÈÉΩÂèñÂà∞ÊúÄÂ§ßÂç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóÂ∑¶ËæπÁïåÊó∂ÔºåÊûö‰∏æÂèñÂà∞Â∑¶ËæπÁïåÁöÑÊñπÊ°à‰∏≠Âì™‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) ÊúÄÂ§ßÔºåËÆ©ÂÖ∂‰ªñÂÑøÂ≠êÁöÑ \(s_i\) ÈÉΩÂ∞ΩÈáèÂ∞èÔºåËøô‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) Âú®Â§ß‰∫éÁ≠â‰∫éÂÖ∂‰ªñÂÑøÂ≠êÁöÑÂâçÊèê‰∏ãÂ∞ΩÈáèÂ∞èÔºåÊõ¥Êñ∞‰∏Ä‰∏ãÂ∑¶ËæπÁïåÂç≥ÂèØ„ÄÇÂÖ∑‰ΩìÂÆûÁé∞ÂèØ‰ª•Áúã‰ª£Á†Å„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂæàÊúâÂêØÂèëÊÄßÁöÑÈóÆÈ¢ò...ÂÅö‰∫Ü‰∏ÄÈÅçÊääÂØπ FWT ÁêÜËß£ÁöÑ‰∏çÂΩªÂ∫ïÁöÑÂú∞ÊñπÈÉΩÊêûÊ∏ÖÊ•ö‰∫Ü„ÄÇ ÂÄíËøáÊù•ÁúãÔºåËÆ°ÁÆóÊØè‰∏™Êï∞ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåÊòæÁÑ∂Á≠îÊ°àÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ È¶ñÂÖàËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Âàó \(2^n\) ÂÖÉÁ∫øÊÄßÊñπÁ®ãÁªÑÂéªËß£Ôºå‰ΩÜÊòØÊö¥ÂäõÈ´òÊñØÊ∂àÂÖÉÁöÑÂ§çÊùÇÂ∫¶Â§™È´ò‰∫Ü„ÄÇ Êàë‰ª¨ËÆæ \(f_i\) Ë°®Á§∫ \(i\) ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞Ôºå\(p_i\) Ë°®Á§∫ÈöèÊú∫Êï∞ÁîüÊàêÂô®ÁîüÊàê \(i\) ÁöÑÊ¶ÇÁéá„ÄÇÈÇ£‰πàÂèØ‰ª•ÂèëÁé∞ \(f\) Êï∞ÁªÑÊª°Ë∂≥ÊñπÁ®ã \(f = f\cdot p + w x^0 + \sum x^S\)„ÄÇÂÖ∂‰∏≠‰πòÊ≥ïË°®Á§∫ÈõÜÂêàÂºÇÊàñÂç∑ÁßØ„ÄÇ ÁßªÈ°πÂæóÂà∞ \((x^0-p)f = w x^0 + \sum x^S\)ÔºåÂØπ‰∏§ËæπÂêåÊó∂ FWTÔºåÂæó \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)„ÄÇÊòæÁÑ∂ \(\hat{p}_{0} = \sum p_S= 1\)Ôºå‰ªéËÄå \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)ÔºåËøôÂ∞±Êé®Âá∫‰∫Ü \(w = -2^n\)„ÄÇÊòæÁÑ∂ \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)Ôºå‰ªéËÄåÂèØ‰ª•Êé®Âá∫ \(\hat{f}_S\) ÁöÑÂÄº„ÄÇÊé•‰∏ãÊù•ÔºåÂè™Ë¶ÅÁü•ÈÅì \(\hat f_0\) Â∞±ÂèØ‰ª• IFWT Âá∫ \(f\) ‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞Ôºå\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)ÔºåÂè™ÈúÄÈöè‰æøÁªô \(\hat f_0\) ËÆæ‰∏Ä‰∏™ÂÄºÔºåÁÑ∂Âêé IFWT Âá∫‰∏Ä‰∏™Êï∞ÁªÑ \(f\)ÔºåÂØπÊØè‰∏™ \(i\) Êää \(f_i\) ÂáèÂéª \(f_0\) Âç≥ÂèØ„ÄÇÔºàËøôÈáåÁî®Âà∞‰∫Ü \(f_0 = 0\) ÁöÑÊù°‰ª∂Ôºâ Ê®°Êï∞ÂÜôÊàê \(10^9+7\) ËøòË∞É‰∫ÜÂ•Ω‰πÖ...ÊàëÁúüÁöÑÊòØ zz„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc È¢òÂè∑ÂæàÁ•ûÂ•á...‰ª•ÈìæÊé•‰∏≠ÁöÑ‰∏∫ÂáÜ„ÄÇ È¢òËß£ ÁªôÁÇπ \(i\) ‰∏Ä‰∏™ÊùÉÈáç \(w_i\)ÔºåÈáçÊñ∞ÂÆö‰πâ \(D_i = \sum_k w_k dis(i,k)\)„ÄÇÂàùÂßãÊó∂ÂØπ‰∫éÊâÄÊúâÁöÑ \(i\)Ôºå\(w_i = 1\)„ÄÇ‰ªªÊÑèÊó∂ÂàªÔºå\(\sum_i w_i = n\)„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁÇπ \(v\) ‰∏éÁÇπ \(u\) Áõ∏ÈÇªÔºå‰ª•ÁÇπ \(u\) ‰∏∫Ê†πÊó∂ÁÇπ \(v\) ÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáç‰πãÂíå‰∏∫ \(s\)ÔºåÂàô \(D_v - D_u = n - 2s\)„ÄÇ ÊâæÂà∞ \(D_u\) ÊúÄÂ§ßÁöÑÁÇπ \(u\)ÔºåÁî±‰∫é‰ªª‰Ωï‰∏é \(v\) Áõ∏ÈÇªÁöÑÁÇπÈÉΩÊª°Ë∂≥ \(D_v - D_u \le 0\)ÔºåÊâÄ‰ª•‰ª• \(u\) ‰∏∫Ê†π \(v\) Â≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáçÂíåËá≥Â∞ë‰∏∫ \(\frac n 2\)ÔºåÊâÄ‰ª• \(u\) Ëá≥Â§öÊúâ‰∏Ä‰∏™Áõ∏ÈÇªÁÇπ„ÄÇÊàë‰ª¨‰∏çËÄÉËôë \(n = 1\) ÁöÑÊÉÖÂÜµ„ÄÇ\(u\) ÊòØ‰∏Ä‰∏™Âè∂Â≠ê„ÄÇ ÂÅáËÆæ‰∏é \(u\) Áõ∏ÈÇªÁöÑÁÇπÊòØ \(f\)ÔºåÈÇ£‰πà \(D_f-D_u = 2w_u - n\)ÔºåÁî±‰∫é \(D_i\) ‰∫í‰∏çÁõ∏ÂêåÔºåËøôÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü \(u\) ÁöÑÁà∂‰∫≤ \(f\)„ÄÇÊàë‰ª¨ËÆ∞ÂΩï‰∏Ä‰∏ãÁÇπ \(u\) ÂíåÁÇπ \(f\) Ëøû‰∏ÄÊù°ËæπÔºåÊääÁÇπ \(f\) ÁöÑÊùÉÈáçÂä†‰∏äÁÇπ \(u\) ÁöÑÊùÉÈáçÔºåÁÑ∂ÂêéÊääÁÇπ \(u\) Âà†Âéª„ÄÇËøôÊ†∑ÂØπËøòÂú®Ê†ë‰∏äÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÁÇπ \(i\)ÔºåÁªèËøáËøôÊ¨°Êìç‰Ωú \(D_i\) ÊÅ∞Â•ΩÂáèÂ∞ë‰∫Ü \(w_u\)„ÄÇÊõ¥Êñ∞‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰∏ÄÁõ¥ËøôÊ†∑Êìç‰Ωú‰∏ãÂéªÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü‰∏ÄÊ£µÊ†ëÔºåÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÔºàÊáíÂæóÂà§ÁâπÊÆäÊÉÖÂÜµÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõÈ™åËØÅ‰∫ÜÔºâ ÂÆûÈôÖ‰∏ä‰∏çÈúÄË¶ÅÊõ¥Êñ∞ \(D_i\)ÔºåÂõ†‰∏∫ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØÊï¥‰ΩìÂä†ÔºåËÄåÊàë‰ª¨ÂßãÁªàÂè™‰ºöÁî®Âà∞ \(D_i\) ÁöÑÁõ∏ÂØπÂ§ßÂ∞èÂÖ≥Á≥ªÂíå \(D_f-D_u\) ÁöÑÂÄº„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ËÆæ \(f_{ij}\) Ë°®Á§∫ \(A_i &lt; A_j\) ÁöÑÊ¶ÇÁéá„ÄÇ ÊØèÊ¨°‰øÆÊîπ \(\mathcal O(n)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ ÊúÄÂêéÊ±ÇÂá∫ÈÄÜÂ∫èÂØπ‰∏™Êï∞ÁöÑÊúüÊúõÔºå‰πò‰ª• \(2^q\) Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÁªìËÆ∫ÔºåÊääËæìÂÖ•ÁöÑÊï∞ÁªÑÁúã‰Ωú \(n\) ‰∏™Ê†ºÂ≠êÔºåÊØè‰∏™Ê†ºÂ≠êÈáåÂ°´‰∫Ü‰∏Ä‰∏™Êï∞Â≠ó„ÄÇÂØπÊ†ºÂ≠êÈªëÁôΩÊüìËâ≤ÔºåÁ¨¨‰∏Ä‰∏™Ê†ºÂ≠êÊòØÈªëËâ≤ÔºåÁõ∏ÈÇª‰∏§‰∏™Ê†ºÂ≠êÈ¢úËâ≤‰∏çÂêå„ÄÇ ‰∏çÈöæÂèëÁé∞ÁªìËÆ∫ÔºöÂ¶ÇÊûú \(n\) ‰∏∫ÂÅ∂Êï∞ÔºåÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÂæóÂà∞ÁöÑÊî∂ÁõäÊòØÈªëÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏éÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíåÁöÑÊúÄÂ§ßÂÄº„ÄÇÂ¶ÇÊûú \(n\) ‰∏∫Â•áÊï∞ÔºåËÆæÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏∫ \(s\)ÔºåÂÖàÊâãËÉΩÂ§üËé∑ÂæóËá≥Â∞ë \(x\) ÁöÑÊî∂ÁõäÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏ÄÁßçÈÄâÂá∫Ëã•Âπ≤‰∏™ÁôΩÊ†ºÂ≠êÁöÑÊñπÊ°àÔºåÁî®Ëøô‰∫õÁôΩÊ†ºÂ≠êÊää \(n\) ‰∏™Ê†ºÂ≠êÂàÜÊàêËã•Âπ≤‰∏™ËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÂÜÖÈªëÊ†ºÂ≠êÁöÑÂíåÂáèÂéªÁôΩÊ†ºÂ≠êÁöÑÂíåÈÉΩÂ§ß‰∫éÁ≠â‰∫é \(x-s\)„ÄÇ ËØÅÊòéÊØîËæÉÊòæÁÑ∂ÔºåÂÖ∑‰ΩìËøáÁ®ã‰∏çÂÜôÂá∫‰∫Ü„ÄÇÂ§ßÊ¶ÇÊÄùË∑ØÂ∞±ÊòØË¶ÅËØÅÊòéÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÁöÑÊî∂ÁõäÊòØ \(x\)ÔºåÂè™ÈúÄÂÖàÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•ÔºåÊó†ËÆ∫ÂêéÊâãÊÄé‰πàÊìç‰ΩúËá≥Â∞ëËÉΩÂ§ü \(x\) ÁöÑÊî∂ÁõäÔºåÂêéÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•Êó†ËÆ∫ÂÖàÊâãÊÄé‰πàÊìç‰Ωú‰∏ÄÂÆöËÉΩ‰ΩøÂÖàÊâãËé∑ÂæóËá≥Â§ö \(x\) ÁöÑÊî∂Áõä„ÄÇ\(n\) ‰∏∫Â•áÊï∞Áõ¥Êé•ÂÅöÔºå\(n\) ‰∏∫ÂÅ∂Êï∞‰∫åÂàÜ dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂèØ‰ª•ÂèëÁé∞ÔºåÂÅáËÆæÊúÄÁªàËÉΩÂèòÊàê 0ÔºåÂ¶ÇÊûúÊúâ 000ÔºåÁ¨¨‰∏ÄÊ≠•Êìç‰ΩúÊääÂÆÉÂèòÊàê 0 ‰∏ÄÂÆöÊúÄÁªà‰ªçÁÑ∂ËÉΩÂèòÊàê 0„ÄÇËøôÊòØÂõ†‰∏∫ÔºåÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™Á¨¨‰∏ÄÊ≠•‰∏çÊòØÂØπËøô‰∏â‰∏™Êï∞Êìç‰ΩúÔºåËÄÉËôëÁ¨¨‰∏ÄÊ¨°ÂΩ±ÂìçÂà∞Ëøô‰∏â‰∏™Êï∞‰∏≠Êüê‰∏™Êï∞ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøô‰∏™Êìç‰ΩúÂ∞±ÊòØÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0ÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ÊääËøôÊ¨°Êìç‰ΩúÁßªÂä®Âà∞Á¨¨‰∏ÄÊ¨°Êìç‰Ωú„ÄÇÂê¶ÂàôÁöÑËØùÔºåÈÇ£‰πàÊääËøôÊ¨°Êìç‰ΩúÊîπ‰∏∫ÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0 ËÇØÂÆö‰∏ç‰ºöÊõ¥Âä£„ÄÇÔºàÂõ†‰∏∫ÊääÂ∫èÂàó‰∏äÁöÑ‰∏Ä‰∏™ 0 Êîπ‰∏∫ 1 ÂæóÂà∞ÁöÑÂ∫èÂàó‰∏ÄÂÆö‰∏ç‰ºöÊõ¥Âä£ÔºâÁî®Á±ª‰ººÁöÑÊÄùË∑ØÂèØ‰ª•ËØÅÊòéÔºåÂ¶ÇÊûúÊúâ 010ÔºåÁ¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 0 ‰πü‰∏ç‰ºöÊõ¥Âä£ÔºåÂ¶ÇÊûúÊúâ 101 Á¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 1 ‰πü‰∏ç‰ºöÊõ¥Âä£„ÄÇ ËÄÉËôë‰∏Ä‰∏™Â∫èÂàóÔºåÂèçÂ§çËøõË°å‰ª•‰∏ä‰∏âÁßçÊìç‰ΩúÁõ¥Âà∞‰∏çËÉΩÊìç‰ΩúÔºåÊääÂæóÂà∞ÁöÑÂ∫èÂàóÂàíÂàÜ‰∏∫Ëã•Âπ≤‰∏™ 0 / 1 ÁöÑËøûÁª≠ÊÆµÔºåÈô§‰∫ÜÂºÄÂ§¥ÂíåÁªìÂ∞æÁöÑËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ \(2\)Ôºå‰∏î 0 ÁöÑËøûÁª≠ÊÆµÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá \(2\)„ÄÇÊòæÁÑ∂Êää 111 ÂèòÊàê 1 ÊòØ‰∏ç‰ºòÁöÑ„ÄÇ‰∏çÈöæÁî®ÂΩíÁ∫≥Ê≥ïËØÅÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÔºåÈÉΩ‰∏ç‰ºöÂá∫Áé∞ 000„ÄÇÔºàËÄÉËôëÂú®ËøõË°å‰∏ÄÊ≠•Êìç‰Ωú‰πãÂêéÔºåÂà©Áî® 010 Âèò‰∏∫ 0 ÁöÑÁªìËÆ∫ÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰ΩúÔºåËøôÊ†∑Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™Êõ¥Áü≠ÁöÑÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºâËÄåÂÖ∂‰ªñÊìç‰ΩúÈÉΩ‰ºö‰Ωø 0 ÁöÑ‰∏™Êï∞Âíå 1 ÁöÑ‰∏™Êï∞ÂêåÊó∂ÂáèÂ∞ë 1„ÄÇËøôÂ∞±ËØ¥ÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÊúÄÁªàËÉΩÂèòÊàê 1ÔºåÂΩì‰∏î‰ªÖÂΩì 1 ÁöÑ‰∏™Êï∞Â§ß‰∫é 0 ÁöÑ‰∏™Êï∞„ÄÇÔºàÈïøÂ∫¶ÂøÖ‰∏∫Â•áÊï∞Ôºâ ÂØπËøô‰∏™‰∏úË•ø dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂâçÁºÄ 1 ÁöÑ‰∏™Êï∞ÂáèÂéª 0 ÁöÑ‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫é \(2\)ÔºåËøô‰∏™Â∫èÂàóÂøÖÁÑ∂ÂèØ‰ª•ÂèòÊàê 0„ÄÇÊâÄ‰ª•ÂÆûÈôÖÈúÄË¶ÅËÆ∞ÁöÑÁä∂ÊÄÅÊï∞ÂæàÂ∞ë„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂØπ‰∫é \(i, j\)ÔºåËÄÉËôë \(P_i &gt; P_j\) ÁöÑÊñπÊ°àÊï∞„ÄÇÂè™ÈúÄËÄÉËôë \(A_i \le A_j\) ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇËøôÁõ∏ÂΩì‰∫éÊòØÊää \(A_j\) Êîπ‰∏∫ \(A_i\) ‰πãÂêéÊª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÈôêÂà∂ÁöÑÊéíÂàóÊï∞Èô§‰ª• \(2\)„ÄÇ Êää \(1 \ldots n\) Êåâ \(A_i\) ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåËÆæÊéíÂ∫èÂêéÁ¨¨ \(i\) ‰∏™Êï∞ÊòØ \(p_i\)„ÄÇÊòæÁÑ∂Êª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÊéíÂàóÊÄªÊï∞‰∏∫ \(\prod_i A_{p_i}-i+1\)„ÄÇËÆæÊÄªÊï∞‰∏∫ \(C\)„ÄÇ ËÆæ \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) ÂØπÊâÄÊúâÊª°Ë∂≥ \(p_i &lt; p_j\) ÁöÑ \((i,j)\) ËÆ°ÁÆó \(P_{p_i} &gt; P_{p_j}\) ÁöÑÊéíÂàóÊï∞„ÄÇÂØπ‰∫éÊØè‰∏ÄÂØπ \(i &lt; j\)ÔºåÂ¶ÇÊûú \(p_i &lt; p_j\)ÔºåÈÇ£‰πàÂÆÉÁöÑË¥°ÁåÆÊòØ \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)„ÄÇ\(p_i &gt; p_j\) ÁöÑÊÉÖÂÜµÊ≤°ÊúâÂæàÂ§ßÂå∫Âà´ÔºåÂÖ∑‰ΩìÂºèÂ≠êÂ∞±‰∏çÂÜôÂá∫Êù•‰∫Ü„ÄÇÊûö‰∏æ \(j\)ÔºåÁî®Á∫øÊÆµÊ†ëÂØπÊØè‰∏™ \(p_i\) Áª¥Êä§‰∏ãËøô‰∏™ÂºèÂ≠êÔºåÊØèÊ¨°ÁßªÂä® \(j\) ÁöÑÊó∂ÂÄôÂå∫Èó¥‰πòÊõ¥Êñ∞ÔºåÁªüËÆ°Á≠îÊ°àÊó∂Âå∫Èó¥Ê±ÇÂíåÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ update: ÊÑüËßâÊàëÂÅöÈ∫ªÁÉ¶‰∫ÜÔºåÈ¢òËß£ÂÅöÊ≥ïÂ•ΩÁÆÄÂçï„ÄÇËøôÁØá blog Â∞±‰∏¢ËøôÂêß‚Ä¶..ÊÑüËßâÊ≤°‰ªÄ‰πàÈîôËØØ„ÄÇ Â¶ÇÊûúÂè™Êää \(0\) ÂèòÊàê \(1\) ËÄå‰∏çÊää \(1\) ÂèòÊàê \(0\)Ôºå‰ºöÂØºËá¥ \(0\) ÁöÑ‰∏™Êï∞ÂáèÂ∞ëÔºåËøò‰∏çÂ¶Ç‰∏çÊîπÂèòÂéüÂ∫èÂàó„ÄÇ Â¶ÇÊûúÊó¢Âá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ‰πüÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\)ÔºåËÆæÊüê‰∏Ä‰∏™Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_1\)ÔºåÊüê‰∏Ä‰∏™Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_2\)„ÄÇ ‰∏çÂ¶®ËÆæ \(p_1 &lt; p_2\)„ÄÇÔºàÂ¶ÇÊûú \(p_1 &gt; p_2\)Ôºå‰∫§Êç¢ÂéüÂ∫èÂàóÂíåÊñ∞Â∫èÂàóÂ∞±Âíå‰∏ÄÁßç \(p_1 &lt; p_2\) ÁöÑÊÉÖÂÜµÁ≠â‰ª∑‰∫ÜÔºâ ËÆæ \(f[l,r]\) Ë°®Á§∫ÂéüÂ∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶Ôºå\(g[l,r]\) Ë°®Á§∫Êñ∞Â∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ ÂÆö‰πâ \(f[l,r] = g[l,r] = 0(l &gt; r)\)„ÄÇ ÈÇ£‰πà \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)„ÄÇ Âõ†Ê≠§Êñ∞Â∫èÂàó‰∏ä \([p_1,p_2]\) ‰∏≠ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂøÖÁÑ∂Ë¶ÅÂåÖÂê´ \(p_1\) Âíå \(p_2\)Ôºå‰ΩÜÊòØÊñ∞Â∫èÂàó‰∏ä \(p_1\) ‰ΩçÁΩÆ‰∏∫ \(1\)Ôºå\(p_2\) ‰ΩçÁΩÆ‰∏∫ \(0\)ÔºåËøôÊòØ‰∏çÂèØËÉΩÁöÑ„ÄÇ Âõ†Ê≠§ÔºåÂè™‰ºöÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆÔºå‰∏ç‰ºöÂá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ„ÄÇ ËÄÉËôëÊää‰∏Ä‰∏™‰ΩçÁΩÆÂú®ÂéüÂ∫èÂàóÂ∑¶Á´ØÊàñÂ∑¶Ëæπ‰∏ç‰∏∫ \(1\) ÁöÑ \(1\) ÂèòÊàê \(0\)Ôºå‰∏çÂØπ‰ªªÊÑèÂå∫Èó¥ÂÜÖÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàó‰∫ßÁîüÂΩ±ÂìçÁöÑÊù°‰ª∂„ÄÇ ÂÅáËÆæËøô‰∏™‰ΩçÁΩÆÊòØ \(p\)„ÄÇÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö \(p &lt; n\) ‰∏î‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(1\). \(p = n\) Êàñ‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\). ÂÖàÁúãÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ„ÄÇÊää‰ΩçÁΩÆ \(p\) ‰∏äÁöÑ \(1\) ÂèòÊàê \(0\) Áúã‰ΩúÊñ∞Â∫èÂàóÔºàÁî® \(g[l,r]\) ÊèèËø∞Êñ∞Â∫èÂàó‰∏äÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºâ„ÄÇÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)ÔºåËÄåÊñ∞Â∫èÂàó‰∏ä‰ΩçÁΩÆ \(p\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøôËØ¥Êòé \([i,p-1]\) Â≠òÂú®ÁªìÂ∞æ‰∏∫ \(0\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂç≥ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÁ≠â‰∫é \([i, p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞„ÄÇÂèØ‰ª•ËØÅÊòéËøô‰∏™Êù°‰ª∂ÂØπ‰ªªÊÑèÁöÑ \(i &lt; p\) ÈÉΩÊàêÁ´ãÁöÑÂÖÖË¶ÅÊù°‰ª∂‰∏∫ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\([i,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºöÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑÔºåÂè™ÈúÄËØÅÂÖÖÂàÜÊÄßÔºåÂÅáËÆæ \([i, p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂ§ß‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºå‰ªªÂèñ‰∏Ä‰∏™ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂÆÉÂøÖÁÑ∂ÂåÖÂê´‰∏Ä‰∏™ \(1\)ÔºåËÆæÁ¨¨‰∏Ä‰∏™ \(1\) ‰ΩçÁΩÆ‰∏∫ \(k\)ÔºåÈÇ£‰πàËøô‰∏™Â≠êÂ∫èÂàó \(k\) ‰πãÂâçÁöÑÂÖÉÁ¥†ÂÜçÊãº‰∏ä \([k,p-1]\) ‰∏≠ÊâÄÊúâÁöÑ \(0\) ÂøÖÁÑ∂ÊòØ‰∏Ä‰∏™ÂÖ® \(0\) ÁöÑ‰∏ç‰ºöÊõ¥Áü≠ÁöÑÂ≠êÂ∫èÂàóÔºàÂõ†‰∏∫ \([k,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºâÔºåËøô‰∏é‰∏çÂ≠òÂú®ÂÖ®‰∏∫ \(0\) ÁöÑ‰∏çÈôçÂ≠êÂ∫èÂàóÁüõÁõæ„ÄÇ‰∏çÈöæÈ™åËØÅËøô‰πüÊòØÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏≠ËÉΩÊää \(p\) ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂„ÄÇ Á¨¨‰∫åÁßçÊÉÖÂÜµÊòæÁÑ∂‰πüÂøÖÈ°ªË¶ÅÊª°Ë∂≥Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑÊù°‰ª∂„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÁî±‰∫é‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøòÈúÄÊª°Ë∂≥ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &gt; p\)Ôºå\([p+1,i]\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºà‰∏éÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑËØÅÊòéÁ±ª‰ººÔºåËØ¶ÁªÜËøáÁ®ãÂ∞±‰∏çÂÜô‰∫ÜÔºâ„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ë¥™ÂøÉÔºåÂØπ‰∫é‰∏Ä‰∏™‰ΩçÁΩÆÔºåÂ¶ÇÊûúÂÆÉÊòØ \(1\)Ôºå‰∏îËÉΩÂ§ü‰øùÊåÅ‰ªªÊÑèÂå∫Èó¥ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏çÂèòÂú∞Âèò‰∏∫ \(0\)ÔºåÂ∞±ÊääÂÆÉÂèòÊàê \(0\)„ÄÇ‰∏çÈöæËØÅÊòéËøôÁßçË¥™ÂøÉÊòØÊ≠£Á°ÆÁöÑÔºåËØ¶ÁªÜËØÅÊòéËøôÈáå‰∏çÂÜô‰∫Ü„ÄÇÔºàÊèêÁ§∫ÔºöËÄÉËôëÊúÄ‰ºòËß£‰∏≠ \(1\rightarrow0\) ÁöÑÊúÄÂ∞è‰ΩçÁΩÆÔºâ Âà§Êñ≠ÊòØÂê¶Â≠òÂú®ÂâçÁºÄ / ÂêéÁºÄ \(0\) ÁöÑ‰∏™Êï∞Â§ö‰∫é / Â∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºåÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÊØè‰∏™ÂâçÁºÄ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞Âáè \(1\) ÁöÑ‰∏™Êï∞ÂæàÂÆπÊòìÂú∞Â§ÑÁêÜ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[ËøòÊ≤°ÂÜôËøá„ÄÇÂ¶ÇÊûúÊúâÈîôËØØÂèØ‰ª• QQ / ËØÑËÆ∫ÂëäËØâÊàë„ÄÇ È¢òËß£ ËøôÊ†∑ÁêÜËß£Ëøô‰∏™ÈóÆÈ¢òÔºöÂàùÂßãÊó∂Êó∂Èó¥‰∏∫Á¨¨ \(0\) Áßí„ÄÇÊØèÁßí‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™ \(i\)ÔºåÁÑ∂ÂêéÊää \(a_i\) Âä†‰∏ä \(k\)ÔºåÊé•‰∏ãÊù•ÂÜçÊääÊâÄÊúâ \(a_i\) ÂáèÂéª \(1\)„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÂÅúÊ≠¢Ëøô‰∏™ËøáÁ®ãÔºåÂπ∂ÊääÂΩìÂâçÁöÑ \(a\) Êï∞ÁªÑ‰Ωú‰∏∫ÁªìÊûú„ÄÇÈóÆÂú®‰∏çÁªèËøá‰ªª‰ΩïÂ≠òÂú® \(a_i &lt; 0\) ÁöÑÁä∂ÊÄÅÁöÑÂâçÊèê‰∏ãÔºåËÉΩÂ§üÂæóÂà∞Â§öÂ∞ëÁßç‰∏çÂêåÁöÑÁªìÊûú„ÄÇ ‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÔºåÂ¶ÇÊûú‰∏çËÄÉËôë \(+k\) Êìç‰ΩúÔºåÊØèÁßíÊØè‰∏™ \(a_i\)ÈÉΩ‰ºöÂáèÂ∞ë \(1\)„ÄÇ ËÆæ \(c_{t,i}\) Ë°®Á§∫Ââç \(t\) Áßí \(a_i\) Ë¢´ÊâßË°å \(+k\) Êìç‰ΩúÁöÑÊ¨°Êï∞„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúËøô‰∏™ËøáÁ®ãÂú®ËøõË°å‰∫Ü \(T\) Áßí‰πãÂêéÁªìÊùüÔºå\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)Ôºå‰πüÂ∞±ÊòØËØ¥ \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)„ÄÇ ‰∏çÈöæËØÅÊòéÂ≠òÂú®ÁªèËøá \(T\) ÁßíÊ≤°ÊúâÂá∫Áé∞ËøáË¥üÊï∞ÁöÑÊñπÊ°àÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºö \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] ÂØπ‰∫é \(t \in \mathbb{N}\)Ôºå\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) ÊòØÂê¶ÊàêÁ´ãÊòØ‰∏é \(T\) Êó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåË¶Å‰πàÂØπÊâÄÊúâÁöÑ \(T\) ÈÉΩÂ≠òÂú®‰∏çÁªèËøáË¥üÊï∞ÁöÑÊñπÊ°àÔºåË¶Å‰πàÂ≠òÂú®‰∏Ä‰∏™ÈùûË¥üÊï¥Êï∞ \(T_0\)ÔºåÂΩì \(T \le T_0\) Êó∂Â≠òÂú®ÊñπÊ°àÔºå\(T &gt; T_0\) Êó∂‰∏çÂ≠òÂú®ÊñπÊ°à„ÄÇ Â§™Êôö‰∫ÜÂÖàÁù°‰∫Ü„ÄÇÂùëÂæÖÂ°´„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[Âè£ËÉ°ÁöÑÊ≤°ÂÆûÁé∞ËøáÔºåÂ¶ÇÊúâÈîôËØØËØ∑ QQ ÊàñËØÑËÆ∫ÂëäËØâÊàëÔºÅ È¢òËß£ ËÄÉËôëÂè™Êúâ‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÁöÑÊÉÖÂÜµ„ÄÇ Á¨¨‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_1, a_1b_1, a_1b_1^2, \ldots\) Á¨¨‰∫å‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_2,a_2b_2,a_2b_2^2,\ldots\) ÂÅáËÆæ \(v\) ÂêåÊó∂Âá∫Áé∞Âú®‰∏§‰∏™Á≠âÊØîÊï∞Âàó‰∏≠ÔºåÈÇ£‰πà \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)„ÄÇ ËÆæ \(p_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™Á¥†Êï∞„ÄÇ \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) ËÄÉËôë‰ªªÊÑè‰∏§‰∏™‰∏çÂêåÁ¥†Êï∞ \(p_i\) Âíå \(p_j\)ÔºåÂÅáËÆæ \(p_i\) Âú® \(a_1,a_2\) ‰∏≠Âá∫Áé∞Ê¨°Êï∞ÂàÜÂà´ÊòØ \(w_{1i},w_{2i}\)„ÄÇ ÈÇ£‰πàÊúâ \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] ËøôÊòØ‰∏Ä‰∏™‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑ„ÄÇÂÅáËÆæ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåËøô‰∏™ÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ ÂÅáËÆæÂ≠òÂú® \(i &lt; j\)Ôºå \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåÈÇ£‰πàËß£Âá∫Ëøô‰∏™ÊñπÁ®ã„ÄÇËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÂîØ‰∏Ä‰∏Ä‰∏™ÂèØËÉΩÊòØÊâÄÊúâÁ≠âÊØîÊï∞ÂàóÂÖ±ÊúâÂÖÉÁ¥†ÁöÑÊï∞ÔºàÁöÑÁ¥†Âõ†Êï∞ÂàÜËß£ÔºâÔºåÁÑ∂ÂêéÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; j\) ÈÉΩÊúâ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÁõ∏ÂÖ≥„ÄÇ ÈÇ£‰πàÂ≠òÂú®Ê≠£Êï¥Êï∞ \(w\)Ôºå\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)„ÄÇ \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] ‰∏çÂ¶®ËÆæ \(a_1 \le a_2\)„ÄÇÈÇ£‰πà‰∏ÄÂÆöÊúâ \(a_1 \mid a_2\)„ÄÇ ËÆæ \(\frac {a_2} {a_1} = x\)ÔºåÂ¶ÇÊûúÊúâËß£ÔºåÂøÖÊúâ \(x = w^n, n \in \mathbb{N}\)„ÄÇ ÊñπÁ®ãÂèò‰∏∫ \(k_1i_1-k_2i_2 = n\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰∏çÂÆöÊñπÁ®ã„ÄÇ‰∏çÈöæÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑ‰∏ÄÁªÑËß£ \(k_1= x, k_2 = y\)„ÄÇÔºàÂÖ∑‰ΩìÊù•ËØ¥ÂÖàÊâæÂà∞ \(k_1i_1-k_2i_2=1\) ÁöÑËß£ÔºåÁÑ∂ÂêéÂú®‰∏§Ëæπ‰πò‰ª• \(n\)Ôºâ ÈÇ£‰πàËøô‰∏™ÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)„ÄÇ ‰∏çÈöæÊâæÂà∞ \(k_1\) ÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞Ëß£ÔºåÂÅáËÆæËøôÊó∂ \(a_1w^{k_1c_1}=t\)„ÄÇËøôÊ†∑‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÂ∞±Ë¢´ÂêàÂπ∂‰∏∫‰∫Ü‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)„ÄÇ ÁªßÁª≠ÊääÂêàÂπ∂ÂæóÂà∞ÁöÑÁ≠âÊØîÊï∞ÂàóÂíåÂÖ∂‰ªñÁ≠âÊØîÊï∞ÂàóËøõË°åÁõ∏ÂêåÁöÑÊìç‰ΩúÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÊîØÈÖçÊ†ë]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÊîØÈÖçÊ†ëÁöÑÁÆóÊ≥ïÂæàÂ¶ô„ÄÇÂÆÉÁöÑËØÅÊòéÂÆûÂú®Â§™Èïø‰∫Ü‚Ä¶.ÂÆåÊï¥ÂÜô‰∏ÄÈÅçÊØîËæÉË¥πÊó∂Èó¥ÔºåËøôÈáåÂ∞±Âè™ÂÜôÁªìËÆ∫‰∫Ü„ÄÇ ÊòæÁÑ∂ÊîØÈÖçÂÖ≥Á≥ªÊûÑÊàê‰∏ÄÊ£µÊ†ë„ÄÇ ÂÆö‰πâ \(sdom(u)\) ÊòØËÉΩÂ§ü‰ªé \(v\) Âá∫ÂèëÂè™ÁªèËøá \(dfn\) ÊØî \(u\) Â§ßÁöÑÂà∞Ëææ \(u\)Ôºà\(u\) Âíå \(v\) ‰∏çÁÆóÂú®ÈáåÈù¢ÔºâÁöÑ \(dfn\) ÊúÄÂ∞èÁöÑ \(v\)„ÄÇ \(sdom(u)\) Ë¶Å‰πàÊòØËÉΩÂ§üÈÄöËøá‰∏ÄÊù°ÂâçÂêëËæπ / Ê†ëËæπÁõ¥Êé•Âà∞Ëææ \(u\) ÁöÑÁÇπÔºåË¶Å‰πàÊòØÊª°Ë∂≥Â≠êÊ†ë‰∏≠Â≠òÂú®Ëá≥Â∞ë‰∏Ä‰∏™ÁÇπËÉΩÂ§üÁõ¥Êé•Ëµ∞Âà∞ \(u\) ‰∏î \(dfn\) ÊØî \(u\) Â§ßÁöÑÁÇπÁöÑ \(sdom\)„ÄÇÊ†πÊçÆËøô‰∏ÄÁÇπÂèØ‰ª•Âπ∂Êü•ÈõÜËÆ°ÁÆó \(sdom\)„ÄÇÂπ∂Êü•ÈõÜÁª¥Êä§ÁöÑÊòØÈìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇ ËÆæ \(v\) ÊòØ \(u\) Âà∞ \(sdom(u)\) ÁöÑÈìæ‰∏äÔºà‰∏çÂê´ \(sdom(u)\)Ôºâ\(sdom\) ÊúÄÂ∞èÁöÑÁÇπ ÔºåÈÇ£‰πàÂ¶ÇÊûú \(sdom(v) = sdom(u)\)Ôºå\(idom(u) = sdom(u)\)ÔºåÂê¶Âàô \(idom(u) = idom(v)\)„ÄÇËøô‰∏™‰∏úË•ø‰πüÊòØË¶ÅÊ±Ç‰∏Ä‰∏™Èìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇÂèØ‰ª•Ê±Ç \(sdom\) ÁöÑÊó∂ÂÄôÈ°∫‰æøÁª¥Êä§‰∏Ä‰∏ã„ÄÇ Âú®Ëøô‰ªΩ‰ª£Á†Å‰∏≠ \(sdom\) Â≠òÁöÑÊòØ \(dfn\) ÊúÄÂ∞èÁöÑÁÇπÁöÑ \(dfn\) ËÄå‰∏çÊòØÁºñÂè∑ÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè„ÄÇ ÔºàÂê¨ËØ¥ËøôÈ¢òÊï∞ÊçÆÂæàÊ∞¥‚Ä¶ËØ¥‰∏çÂÆöÊúâÈîôÊ≤°Ë¢´Êü•Âá∫Êù•Ôºâ Ëøô‰ªΩ‰ª£Á†ÅË¢´Êèê‰∫§Âà∞ „ÄêÊ®°Êùø„ÄëÊîØÈÖçÊ†ë„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT ÈóÆÈ¢òÊÄªÁªì]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥‰ª•Êù•ÂØπ 2-SAT ÁöÑÁêÜËß£ÊØîËæÉÊ®°Á≥äÔºåÊâÄ‰ª•ÂÜôËøôÊ†∑‰∏Ä‰∏™Â∞ΩÂèØËÉΩÊ∏ÖÊô∞ÁöÑÊÄªÁªìÊù•ÁêÜÊ∏ÖÊÄùË∑Ø„ÄÇ 2-SAT ÈóÆÈ¢òÁöÑÂÆö‰πâÔºöÊúâ \(n\) ‰∏™ÈÄªËæëÂèòÈáèÔºåÁî® \(b_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™ÈÄªËæëÂèòÈáè„ÄÇ\(m\) ‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏Ä‰∏™ÈôêÂà∂Êù°‰ª∂ÂΩ¢Â¶ÇÔºö\((\neg)b_i \to (\neg) b_j\)„ÄÇÈóÆÊòØÂê¶Â≠òÂú®Êª°Ë∂≥ÈôêÂà∂ÁöÑ \(b\)„ÄÇ Áî®ÂõæÊù•ÊèèËø∞ÈôêÂà∂Êù°‰ª∂„ÄÇÂØπÊØè‰∏™ÈÄªËæëÂèòÈáèÂª∫‰∏§‰∏™ÁÇπÔºåÂàÜÂà´‰ª£Ë°®ÂèñÂÄº‰∏∫ \(0\) ÂíåÂèñÂÄº‰∏∫ \(1\)„ÄÇ‰ª£Ë°® \(b_i=0\) ÁöÑÁÇπ‰∏∫ \(p_i\)Ôºå‰ª£Ë°® \(b_i = 1\) ÁöÑÁÇπ‰∏∫ \(q_i\)„ÄÇÂØπÊØè‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÂú®Âõæ‰∏äËøû‰∏ÄÊù°ÊúâÂêëËæπÔºåË°®Á§∫‰∏Ä‰∏™ÂëΩÈ¢òÊé®Âá∫Âè¶‰∏Ä‰∏™ÂëΩÈ¢òÔºåÁÑ∂ÂêéÂÜçÂä†‰∏ÄÊù°ËæπË°®Á§∫ËØ•ÈôêÂà∂Êù°‰ª∂ÁöÑÈÄÜÂê¶ÂëΩÈ¢ò„ÄÇ‰∏æ‰æãÊù•ËØ¥ÔºåÂ¶ÇÊûúÊúâÈôêÂà∂Êù°‰ª∂ \(\neg b_i \rightarrow b_j\)ÔºåÂ∞±Âä†ÂÖ• \((p_i, q_j)\) Âíå \((p_j, q_i)\) Ëøô‰∏§Êù°ÊúâÂêëËæπ„ÄÇÈóÆÈ¢òÂ∞±Âèò‰∏∫Âà§ÂÆöÊòØÂê¶Â≠òÂú®ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)ÔºåÊÅ∞Â•ΩÂåÖÂê´ \(p_i\) Âíå \(q_i\) ‰∏≠ÁöÑ‰∏Ä‰∏™ÁÇπÁöÑÈó≠ÂêàÂ≠êÂõæ„ÄÇ ÂÆöÁêÜÔºö2-SAT ÊúâËß£ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂú®Âêå‰∏ÄÂº∫ËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ ÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑ„ÄÇ ‰∏ãÈù¢Áî®ÊûÑÈÄ†ËØÅÊòéÂÖÖÂàÜÊÄßÔºö ÂÖà tarjan Ê±ÇÂá∫Âº∫ËøûÈÄöÂàÜÈáèÔºåÊääÊØè‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÁº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÁî±‰∫é‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÁöÑÁÇπÂØπÂ∫îÁõ∏ÂèçÂèñÂÄºÁöÑÁÇπ‰πüÊûÑÊàê‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÔºåÊâÄ‰ª•Áº©ÁÇπÂêéÔºåËøô‰∏™ÈóÆÈ¢òÂèò‰∏∫‰∫Ü‰∏Ä‰∏™Êõ¥Â∞èÁöÑ 2-SAT ÈóÆÈ¢ò„ÄÇÂè™ÈúÄË¶ÅËß£ÂÜ≥ÂõæÊòØ DAG Êó∂ÁöÑÈóÆÈ¢òÂç≥ÂèØ„ÄÇ ÊääÊâÄÊúâÁöÑËæπÊñπÂêëÂèçËøáÊù•„ÄÇ‰∏ãÈù¢ÊâÄÊúâÁöÑËÆ®ËÆ∫ÈÉΩÊòØÂú®ÂèçÂõæ‰∏äÁöÑ„ÄÇ Áî®Á¨¶Âè∑ \(v^r\) Ë°®Á§∫‰∏éÁÇπ \(v\) ÂØπÂ∫îÁöÑÁÇπÔºö\(p_i^r = q_i, q_i^r = p_i\)„ÄÇ Ê±ÇÂá∫ÊãìÊâëÂ∫èÔºåÊåâÊãìÊâëÂ∫è‰æùÊ¨°Â§ÑÁêÜÊØè‰∏™ÁÇπÔºöÂ¶ÇÊûúÂΩìÂâçÁÇπ \(u\) Ë¢´Êâì‰∫ÜÊ†áËÆ∞ÔºåÈÇ£‰πà‰∏çÈÄâÔºõÂê¶ÂàôÈÄâÊã© \(u\)ÔºåÂπ∂Êää \(u^r\) ‰ª•Âèä \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÊâÄÊúâÁÇπÊâì‰∏äÊ†áËÆ∞ÔºàÈÄíÂΩíËøõË°åÔºåÂ¶ÇÊûúÂ∑≤ÁªèË¢´ÊâìËøáÊ†áËÆ∞Â∞±Ë∑≥ËøáÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºöË¢´Ê†áËÆ∞‰∏ÄÊ¨°Ôºâ„ÄÇ ËøôÊ†∑ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂèØËÉΩÂêåÊó∂Ë¢´ÈÄâÔºåÂ∑≤ÈÄâÁöÑÁÇπ‰πü‰∏ç‰∏éÈôêÂà∂ÁüõÁõæÔºåÂè™ÈúÄË¶ÅËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(u\)Ôºå\(u\) Âíå \(u^r\) ‰∏≠Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÈÄâÂç≥ÂèØ„ÄÇ Â¶ÇÊûú \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´Ê†áËÆ∞ÁöÑÂéüÂõ†ÊòØ \(v\) Ë¢´ÈÄâÊã©Ôºå ÈÇ£‰πà \(u\) ÊòØ \(v^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºåÁî± 2-SAT ÁöÑÊÄßË¥®ÂèØÂæó \(v\) ÊòØ \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºå‰ªéËÄå \(v\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†Âêé„ÄÇ ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ \(u\)Ôºå\(u\) Âíå \(u^r\) ÈÉΩË¢´Ê†áËÆ∞‰∫ÜÔºåÊ†áËÆ∞ \(u\) ÁöÑÂéüÂõ†ÊòØ \(v_1\) ÊòØË¢´ÈÄâÊã©ÔºåÊ†áËÆ∞ \(u^r\) ÁöÑÂéüÂõ†ÊòØ \(v_2\) Ë¢´ÈÄâÊã©„ÄÇÈÇ£‰πà \(v_1\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºå\(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u\) Èù†Âêé„ÄÇ‰∏çÂ¶®ËÆæ \(u\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÈÇ£‰πà \(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÂú®Â§ÑÁêÜ \(v_2\) ‰πãÂâçÂ∞±‰ºöÂÖàÂ§ÑÁêÜ \(u^r\)ÔºåÁüõÁõæ„ÄÇ ÊâÄ‰ª•ËØ•ÁÆóÊ≥ï‰ºöÂæóÂà∞‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊñπÊ°à„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢ò]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Áî®Êù•ËÆ∞ÂΩïÂè£ËÉ°ÁöÑÈ¢òÁõÆ„ÄÇ Â¶ÇÊúâÈîôËØØËØ∑Âä°ÂøÖ qq ÊàñËÄÖËØÑËÆ∫ÂëäËØâÊàëÔºåË∞¢Ë∞¢ÔºÅ JOISC 2018 Day4 T1 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Â¶ÇÊûúËÆ§‰∏∫Áõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥Êúâ‰∏ÄÊù°ËæπÔºåÊú¨È¢òÂ∞±ÂèØ‰ª•ÁúãÊàêÊ±ÇÊúÄÂ§ßÊùÉÁÇπÁã¨Á´ãÈõÜ„ÄÇ ÊòæÁÑ∂‰∏ÄÊù°ÈìæÊòØ‰∫åÂàÜÂõæÔºåÈÇ£‰πàÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫Áî®Ë¥πÁî®ÊµÅÊ±ÇÊúÄÂ∞èÊùÉÁÇπË¶ÜÁõñÈõÜ„ÄÇ ËÆ∞ÂΩïÁõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥ËæπÁöÑÊñπÂêëÔºåÊääËøûÁª≠‰∏ÄÊÆµÊñπÂêëÁõ∏ÂêåÁöÑËßÜ‰Ωú‰∏Ä‰∏™ÊÆµ„ÄÇÁî®Á∫øÊÆµÊ†ëÁª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÊØèÊ¨°ÊúâÊÆµÂèëÁîüÂèòÊõ¥Êó∂Â∞±ËØ¢ÈóÆËøô‰∏™ÊÆµÔºåÁÑ∂Âêé‰øÆÊîπÁ∫øÊÆµÊ†ë‰∏äÁöÑ‰ø°ÊÅØ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Áª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÂ∞±Âú® \(\mathcal O(n \log n)\) ÁöÑÊó∂Èó¥Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ JOISC 2018 Day4 T2 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Áúã‰ΩúÊòØËØ¢ÈóÆ‰∏ÄÊù°Èìæ‰∏ä‰∏ÄÈÉ®ÂàÜÁÇπÁöÑÂØºÂá∫Â≠êÂõæÁöÑËøûÈÄöÂùóÊï∞„ÄÇ‰æùÊ¨°Âä†ÁÇπÔºåÈÄöËøá‰∫åÂàÜÊ±ÇÂá∫Êñ∞Âä†ÁöÑÁÇπÂíåÂ∑≤ÊúâÁÇπÊûÑÊàêÁöÑËøûÈÄöÂùó‰πãÈó¥ÁöÑËøûËæπ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™Êúâ \(n-1\) Êù°ËæπÔºåËØ¢ÈóÆÊ¨°Êï∞‰∏ç‰ºöË∂ÖËøá \(\lceil \log n\rceil (n-1)\)„ÄÇ LOJ 6191 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÈÖçÂØπÊ∏∏Êàè ÁÇπÂáªÊü•ÁúãÈ¢òËß£ ÊúÄÂêé‰∏ÄÂÆö‰ºöÂèòÊàê &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;„ÄÇ \(f_{i,j}\) Ë°®Á§∫Ââç \(i\) ‰∏™Ê∂àÂÆåÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶ÊúÄÂêéÊúâËøûÁª≠ \(j\) ‰∏™ &gt;ÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶‰∏≠ &lt; ÁöÑÊï∞ÈáèÁöÑÊúüÊúõ„ÄÇ ÊúÄÂêéÂæàÂÆπÊòìÁªüËÆ°Á≠îÊ°à„ÄÇ LOJ 6192 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÂüéÂ∏ÇÁΩëÁªú Ê≤°Âï•Â•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÂÄçÂ¢û‰∏Ä‰∏ã„ÄÇ LOJ 6194 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÊéíÂàó ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Êåâ \(a_i\) ‰∏∫Á¨¨‰∏ÄÂÖ≥ÈîÆÂ≠óÔºå\(b_i\) ‰∏∫Á¨¨‰∫åÂÖ≥ÈîÆÂ≠óÊéíÂ∫è„ÄÇÈáçÊñ∞ÁªôÁÇπÁºñÂè∑„ÄÇ ÂÅáËÆæ‰Ωø saved ÂèòÂä®ÁöÑÁÇπÁöÑÁºñÂè∑ÂàÜÂà´ÊòØ \(c_1, \ldots, c_k\)ÔºåÊúâ \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)„ÄÇ ËÄÉËôëÂØπ‰∫éÁªôÂÆöÁöÑ \(c_i\) Âíå \(k\)ÔºåÂ¶Ç‰ΩïËÆ°ÁÆó \(p\) ÁöÑÊï∞Èáè„ÄÇ ËÆæ \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)ÔºåÂÆö‰πâ \(d_0 = n\)„ÄÇ Â¶ÇÊûú \(d_k &gt; 1\)Ôºå\(p\) ÁöÑÊï∞Èáè‰∏∫ \(0\)„ÄÇ Âê¶Âàô \(p\) ÁöÑÊï∞Èáè‰∏∫ \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÆπÊòì \(dp\) Â§ÑÁêÜÁöÑÂºèÂ≠ê„ÄÇÂàÜÊ≤ª‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ÂÅöÂÆå‰∫Ü„ÄÇ LOJ 6212 „ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçmelon ÁÇπÂáªÊü•ÁúãÈ¢òËß£ \(n \le L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(n\)Ôºå\(L &lt; n \le 2L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(L\)Ôºå‰∏ãÈù¢ËÆ®ËÆ∫ \(n &gt; 2L\) ÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûú Alice ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæÁìúÁöÑÊï∞ÈáèÂ§ß‰∫é \(2L\)ÔºåÂèñËµ∞‰∏Ä‰∏™ÁìúÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÁìúÔºåÂ∞±ËÉΩ‰øùËØÅËá≥Â∞ëÊãøÂà∞ \(\lceil \frac {n} 2\rceil\) ‰∏™Áìú„ÄÇÔºàÂõ†‰∏∫ËøôÊ†∑ Alice ÊãøÂà∞ÁöÑÁìú‰∏ÄÂÆö‰∏ç‰ºöÊØî Bob Â∞ëÔºâ Â¶ÇÊûú Bob ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæ Alice ÂàöÂàöÊãøËµ∞‰∫Ü \(x\) ‰∏™ÁìúÔºåÁé∞Âú®ËøòÂâ©‰∏ã \(c\) ‰∏™ÁìúÔºåÂ¶ÇÊûú \(c-x \ge 2L\)ÔºåÈÇ£‰πàÂèñËµ∞ \(x\) ‰∏™ÁìúÔºõÂê¶ÂàôÂÖàÂèñËµ∞ \(x-1\) ‰∏™ÁìúÔºåÂêÉÂÆåÂêéÔºåÂâ©‰ΩôÁìúÊï∞‰∏∫ \(c-(x-1)\)ÔºåÂõ†‰∏∫ \(c-x &lt; 2L\)ÔºåÊâÄ‰ª• \(c-x+1 \le 2L\)ÔºåÂ¶ÇÊûú \(c-x+1 \le L\)ÔºåÁõ¥Êé•ÂèñËµ∞Ââ©‰ΩôÂÖ®ÈÉ®ÁìúÔºåËøôÁßçÊÉÖÂÜµ‰∏ã Bob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÔºåÂõ†‰∏∫ \(c-x+1 \le 2L\)ÔºåÂú®Ââ©‰ΩôÁöÑ \(c-x+1\) ‰∏™Áìú‰∏≠ÔºåBob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÊúÄÂùè‰πüÂè™ÊòØÁî±‰∫é‰∏ä‰∏ÄÊ¨° Alice Êìç‰ΩúÁöÑÊó∂ÂàªÔºåAlice ÂèñËµ∞‰∫Ü \(x\) ‰∏™ËÄå Bob ÂèñËµ∞‰∫Ü \(x-1\) ‰∏™ÔºåBob ÊØî Alice ÊãøÁöÑÁìúÂ∞ë‰∫Ü‰∏Ä‰∏™„ÄÇÊâÄ‰ª• Bob ÊãøÁöÑÁìúÁöÑÊï∞ÈáèÊúÄÂùèÊØî Alice Â∞ë \(1\)„ÄÇ Âõ†Ê≠§ÔºåÂú®ÂèåÊñπÈÉΩÈááÂèñÊúÄ‰ºòÁ≠ñÁï•Êó∂ÔºåAlice ËÉΩËé∑ÂæóÊÅ∞Â•Ω \(\lceil \frac{n} 2\rceil\) ‰∏™Áìú„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂΩì \(n \le L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(n\)ÔºõÂΩì \(L &lt; n \le 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(L\)ÔºõÂΩì \(n &gt; 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(\lceil \frac {n} 2\rceil\)„ÄÇ CF 1215F Radio Stations ÈùûÂ∏∏Â¶ôÁöÑ 2SAT È¢òÔºåÊ≤°ÊÉ≥Âá∫Êù•„ÄÇÁúã‰∫ÜÈ¢òËß£ËßâÂæóÂæà nb„ÄÇÂÖ∑‰ΩìÂÅöÊ≥ïÂ∞±‰∏çÂÜô‰∫Ü„ÄÇÂèØ‰ª•ÁúãÂÆòÊñπÈ¢òËß£„ÄÇ CF 1188E Problem from Red Panda ÂæÖÂ°´Âùë„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á±ªÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥Áî®‰∏ÄÁõ¥Êã∑Êùø...ÈúÄË¶ÅË°•‰∏ÄË°•‰∫Ü„ÄÇ ÈóÆÈ¢ò Ê±Ç \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] Âç≥Âú®‰∏ÄÊù°Áõ¥Á∫ø‰∏ãÁöÑÊï¥ÁÇπÊï∞. ÂÅöÊ≥ï Â¶ÇÊûú \(a \ge c\) Êàñ \(b \ge c\)ÔºåÂàô \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) Âê¶Âàô \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] ÔºàÂõ†‰∏∫ \(i\) ‰ªé \(0\) ÂºÄÂßãÔºåÊâÄ‰ª•Ë¶ÅÁî®Â∞è‰∫éÂè∑Ôºâ ËøôÊ†∑ÊØèÈÄíÂΩí‰∏§Ê¨°Ôºå\((a,c)\) Â∞±ÂèòÊàê \((c, a\bmod c)\)ÔºåÂõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(O(\log (a+c))\). Áî±‰∫é \(a &lt; c, b &lt; c\)ÔºåÊâÄ‰ª• \(n\) ÁöÑÂÄº‰∏ç‰ºöÂ¢ûÂ§ßÔºåÊó†ÈúÄÊãÖÂøÉÁàÜ long long.]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] ÂÆåÁæéÁöÑÈòüÂàó]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òËß£ Â§çÊùÇÂ∫¶ËÆ®ËÆ∫‰∏≠ÈªòËÆ§ \(n,m\) ÂêåÈò∂„ÄÇ ÂÆö‰πâÁ¨¨ \(i\) ‰∏™Êìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥‰∏∫ \(i\)„ÄÇ Ê±ÇÂá∫ÊØèÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÊñ∞ÁöÑ \(x\) ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥ÔºåÂ∞±ÂæàÂ•ΩÊ±ÇÁ≠îÊ°à‰∫Ü„ÄÇ ‰ªéÂêéÂæÄÂâçËÄÉËôëÊØè‰∏™Êìç‰ΩúÔºåËÆ°ÁÆóËøôÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥„ÄÇ ÂÆö‰πâ‰∏Ä‰∏™ÈòüÂàó \(i\) ÁöÑÂºπÂá∫Êó∂Èó¥‰∏∫‰ªéÂΩìÂâçÊìç‰ΩúÂºÄÂßãÔºåÂæÄÂêéÁ¨¨ \(a_i\) ‰∏™ÂΩ±ÂìçÈòüÂàó \(i\) ÁöÑÊìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥„ÄÇ ÂàÜÂùóÔºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØè‰∏™Êìç‰ΩúÔºåÂàÜÂà´Áª¥Êä§ÊØè‰∏ÄÂùó‰∏≠ÁöÑÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄº„ÄÇÊàë‰ª¨Êää‰∏ÄÂùó‰∏≠ÊâÄÊúâÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄºÁß∞‰∏∫Ëøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Âú®Âä†ÂÖ•Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂêéÔºåÁ¨¨ \(i\) ‰∏™Âùó \([a_i,b_i]\) Áª¥Êä§ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t_i\)ÔºåËÆæ \(c_p\) ‰∏∫Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂà∞Á¨¨ \(t_i-1\) ‰∏™Êìç‰Ωú‰∏≠Á¨¨ \(p\) ‰∏™ÈòüÂàóË¢´ push ÁöÑÊ¨°Êï∞ÔºåÁª¥Êä§ \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)„ÄÇÂêåÊó∂Áª¥Êä§ \(c_p\) ÁöÑÂÄº„ÄÇÔºàÈÄöËøáÊâìÊ†áËÆ∞Ôºâ ËÄÉËôëÂú®Âä†ÂÖ•Êìç‰Ωú \(i\) ÂêéÔºåÂ¶Ç‰ΩïÊõ¥Êñ∞ÊØèÂùóÁª¥Êä§ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÅáËÆæËøô‰∏™ÂùóÊòØÁ¨¨ \(k\) ‰∏™Âùó„ÄÇ ÂØπ‰∫éËøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â§ß‰∫éÁ≠â‰∫é \(m\) ÁöÑÊÉÖÂÜµÈ¢ÑÂÖàÂ§ÑÁêÜÂ•Ω„ÄÇ‰∏ãÈù¢Âè™ËÆ®ËÆ∫ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â∞è‰∫é \(m\) ÁöÑÊÉÖÂÜµ„ÄÇ Êõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ Â¶ÇÊûúËøô‰∏™ÂùóË¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êõ¥Êñ∞ \(mn_k \leftarrow mn_k+1\)„ÄÇÊõ¥Êñ∞ \(c_p\) ÁöÑÂÄºÔºåÂç≥Êâì‰∏Ä‰∏™Êï¥ÂùóÂä† \(1\) Ê†áËÆ∞„ÄÇ Â¶ÇÊûúËøô‰∏™ÂùóÊú™Ë¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êö¥ÂäõÈáçÊûÑÔºåÊõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ„ÄÇ Êõ¥Êñ∞ \(t_k\) Êåâ‰ª•‰∏ãÊ≠•È™§ËøõË°åÔºö Â¶ÇÊûú \(mn_k \ge 0\)ÔºåËØ¥Êòé \(t_k\) ÂèØ‰ª•ÂáèÂ∞èÔºåÈÇ£‰πà \(t_k \leftarrow t_k-1\)„ÄÇÂê¶Âàô‰∏çÁî®Êõ¥Êñ∞ÔºåÁªìÊùüÊìç‰Ωú„ÄÇ Â¶ÇÊûúÁ¨¨ \(t_k\) Ê¨°Êìç‰ΩúÂåÖÂê´Êï¥‰∏™ÂùóÔºåÈÇ£‰πà \(mn_k \leftarrow mn_k-1\)ÔºåÊâì \(-1\) Ê†áËÆ∞Êõ¥Êñ∞ \(c_p\) ÁöÑÂÄº„ÄÇÂê¶ÂàôÊö¥ÂäõÈáçÊûÑÊõ¥Êñ∞ \(mn_k\) Âíå \(c_p\) ÁöÑÂÄº„ÄÇ ËΩ¨Âà∞Êìç‰Ωú 1„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂú® \(O(n \sqrt n)\) Êó∂Èó¥ÂÜÖÁª¥Êä§ÊØè‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Ââ©‰ΩôÁöÑÈóÆÈ¢òÊòØ: Â¶Ç‰ΩïÂú®‰ªéÂè≥ÂæÄÂ∑¶Âä†ÂÖ•Êìç‰ΩúÁöÑËøáÁ®ã‰∏≠ÔºåÊîØÊåÅÊü•ËØ¢‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇÊääÂå∫Èó¥ÊãÜÊàêËã•Âπ≤‰∏™ÂùóÂíå‰∏çË∂ÖËøá \(2 \sqrt n\) ‰∏™Â§öÂá∫Êù•ÁöÑÁÇπ„ÄÇÂØπ‰∫éËøô‰∫õÂùóÔºåÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ÔºåÂèñ \(\max\) Âç≥ÂèØ„ÄÇÂØπ‰∫éËøô‰∫õÂ§öÂá∫Êù•ÁöÑÁÇπÔºåÈúÄË¶ÅÂä®ÊÄÅËØ¢ÈóÆ‰ªñ‰ª¨ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Â§ÑÁêÜÂçïÁÇπ‰ø°ÊÅØ Ë¶ÅÊîØÊåÅ‰ªéÂêéÂæÄÂâçÊ∑ªÂä†Êìç‰ΩúÔºåËØ¢ÈóÆÂçï‰∏™ÈòüÂàóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ ÂêåÊ†∑ÂàÜÂùóÁª¥Êä§„ÄÇÂØπÊØè‰∏™ÂùóÂºÄ‰∏Ä‰∏™ vectorÔºåÂØπÊØè‰∏™ÈòüÂàóÂºÄ‰∏Ä‰∏™ vector„ÄÇÂú®ËøõË°å‰øÆÊîπÊó∂ÔºåÂØπÂÆåÊï¥ÂåÖÂê´ÁöÑÊØè‰∏™ÂùóÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑ÔºåÂÜçÂØπ‰∏§ËæπÂ§öÂá∫ÁöÑ \(O (\sqrt n)\) ‰∏™ÈòüÂàóÂØπÂ∫îÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑„ÄÇ ÈÇ£‰πà‰∏Ä‰∏™ÈòüÂàóÁöÑÊìç‰ΩúÂ∫èÂàóÂ∞±ÊòØÂÆÉÁöÑ vector ÂíåÂÆÉÊâÄÂú®ÁöÑÂùóÁöÑ vector ÂΩíÂπ∂ÂêéÁöÑÁªìÊûú„ÄÇÂØπÊØè‰∏™ÁÇπËÆ∞ÂΩïÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t\) (ÊØèÊ¨°ËØ¢ÈóÆÊó∂Êõ¥Êñ∞Ôºå‰øÆÊîπÊó∂‰∏ç‰∏ÄÂÆöÊòØÊúÄÊñ∞ÁöÑ)ÔºåÂÆÉÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâçÁöÑ‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_1\)ÔºåÂÆÉÊâÄÂú®ÂùóÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâç‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_2\)„ÄÇÂØπÊØè‰∏™ÂùóËÆ∞ÂΩïËøô‰∏™Âùó‰∏≠ÁöÑÈòüÂàóÂú®‰∏ä‰∏ÄÊ¨°Êõ¥Êñ∞‰ø°ÊÅØ‰πãÂêé‰øÆÊîπÁöÑÊ¨°Êï∞ \(c\)„ÄÇÈÇ£‰πà‰øÆÊîπÁöÑÊó∂ÂÄôÂØπÊï¥ÂùóÂè™ÈúÄË¶Å \(c \leftarrow c+1\)ÔºåÂØπ‰∏§Á´ØÁöÑÂùóÊõ¥Êñ∞ÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™ÈòüÂàóÁöÑ \(t, p_1, p_2\)ÔºåÂπ∂Êää \(c\) ËÆæ‰∏∫ \(0\)„ÄÇÊõ¥Êñ∞ÊñπÊ≥ïÂ§ßËá¥‰∏∫ÔºöÂØπ‰∫é‰∏Ä‰∏™ÈòüÂàóÔºåÂÖàÂà§Êñ≠ \(t\) ÊòØÂú®ÂÆÉ vector ‰∏≠ËøòÊòØÂú®ÂùóÁöÑ vector ‰∏≠ÔºàÈÄöËøá \(p_1, p_2\) ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ÔºâÔºåËøô‰∏§ÁßçÊÉÖÂÜµÂå∫Âà´‰∏çÂ§ßÔºåÊâÄ‰ª•ËøôÈáåÂè™ÂÜôÂú®Âùó vector ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÂÆö‰πâ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáè \(t = c\)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂùóÁöÑ vector ‰∏≠ÁöÑÁ¨¨ \(p_2+t\) È°πÁöÑÂ∞è‰∫éËøô‰∏™ÈòüÂàóÁöÑ vector ‰∏≠ÁöÑ \(p_1\) È°πÔºåÈÇ£‰πà \(p_1 \leftarrow p_1+1\)ÔºåÁÑ∂Âêé \(t \leftarrow t-1\)ÔºåÁÑ∂ÂêéÂÜçÊ¨°Ê£ÄÊü•ÔºåËøôÊ†∑Âæ™ÁéØÁõ¥Âà∞ÂèØ‰ª•Áõ¥Êé•Êää \(p_2\) Êîπ‰∏∫ \(p_2+t\) ÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ \(p_2\) Â∞±ÂÆåÊàê‰∫ÜÊõ¥Êñ∞„ÄÇ ‰∏Ä‰∏™ÈòüÂàóË¢´Êõ¥Êñ∞Êó∂ËøõË°åÁöÑÂà§Êñ≠ÁöÑÊÄªÊ¨°Êï∞‰∏éÂÆÉÁöÑ vector ‰∏≠ÂÖÉÁ¥†‰∏™Êï∞ÂêåÁ∫ßÔºåÊâÄ‰ª•Êõ¥Êñ∞ÁöÑÊÄªÂ§çÊùÇÂ∫¶ÊòØ \(O(n)\) ÁöÑ„ÄÇÔºà‰ΩÜÊòØÁª¥Êä§ vector ÂíåËøõË°åÊìç‰ΩúÊòØ \(O(\sqrt n)\) ÁöÑÔºâ„ÄÇ ËøôÊ†∑Â∞±‰ª• \(O(n \sqrt n)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ÂÆûÁé∞ 1ÂæÖÂ°´]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊìç‰ΩúÊ®°Êùø]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI ÂâçÂ§ç‰π†„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //ÊúÄÂ§ßÂ§öÈ°πÂºèÈïøÂ∫¶ÔºåÂÄçÊï∞ÈóÆÈ¢òÂ∑≤ÁªèËÄÉËôëconst int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé®]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[Â§öÈ°πÂºèÂèñÊ®°‰ºòÂåñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // ÁâπÂæÅÂ§öÈ°πÂºèint wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //‰πò‰ª• A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÈîôËØØËÆ∞ÂΩï]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ÊØîËæÉÂáΩÊï∞ÂÆö‰πâ‰∏ç‰∏•Ê†ºÔºåÂ≠òÂú®ËøîÂõûÁõ∏Á≠â‰ΩÜÊòØÂÆûÈôÖ‰∏äÊúâÂå∫Âà´ÁöÑÊÉÖÂÜµ„ÄÇËøôÂèØËÉΩÂØºËá¥ÂèåÂ†ÜÁª¥Êä§Âà†Èô§Êìç‰ΩúÊó∂Âá∫Áé∞ÈóÆÈ¢ò„ÄÇÔºàÂ∫îÂΩìÂêåÊó∂ÂºπÊ†à‰ΩÜÊòØÊ†àÈ°∂ÂÖÉÁ¥†‰∏çÁõ∏Á≠âÔºâ for (int i = 1; i &lt;= n; i++) a[n] = inf„ÄÇ Âú®‰∏Ä‰∫õÂõûÊ∫ØÊó∂ÈúÄË¶ÅÊí§ÈîÄÊìç‰ΩúÁöÑ dfs ‰∏≠ÔºåÂõ†‰∏∫ÂÖ∂‰ªñÂéüÂõ† return ÁöÑÊó∂ÂÄôÊ≤°ÊúâÊí§ÈîÄÊìç‰Ωú„ÄÇ Âæ™ÁéØ/if ÈáåÂ±ÇÂ§ñÂ±ÇÂèòÈáèÂêçÊ∑∑Ê∑Ü„ÄÇ ËøõË°å dfs / ÈÄíÂΩíÊó∂ÔºåÂõ†‰∏∫‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè‰∏ãÂ±Ç dfs Êó∂Á†¥Âùè‰∫Ü‰∏äÂ±Ç‰πãÂêéË¶ÅÁî®Âà∞ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÆπÊñ•Êó∂ÔºåÂè™Êûö‰∏æ‰∫ÜÈõÜÂêàÂ§ßÂ∞èÂøòËÆ∞‰∫Ü‰πòÁªÑÂêàÊï∞„ÄÇ ÊèíÂ§¥ dp ‰∏çË¶ÅÂøòËÆ∞ËøûÊé•‰∏§‰∏™Â∑¶Êã¨Âè∑ÊàñËÄÖËøûÊé•‰∏§‰∏™Âè≥Êã¨Âè∑ÁöÑÊÉÖÂÜµ„ÄÇ Ê†ëÈìæÂâñÂàÜÊó∂ÔºåËØ¢ÈóÆÈìæÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèÊòØÊØîËæÉÈáçÈìæÈ°∂Á´ØÊ∑±Â∫¶Â§ßÂ∞èÔºå‰∏çËÉΩÁõ¥Êé•ÊØîËæÉ‰∏§‰∏™ÁÇπÊ∑±Â∫¶Â§ßÂ∞è„ÄÇ sort Êó∂ÂøòËÆ∞Âä†ÊØîËæÉÂáΩÊï∞„ÄÇ Áª¥Êä§Áü©Èòµ‰πòÊ≥ïÊó∂Â∑¶‰πòÂè≥‰πòÊêûÈîô„ÄÇ Á∫øÊÆµÊ†ëÂêàÂπ∂Êó∂ÔºåÂ¶ÇÊûúË¶ÅÂèØÊåÅ‰πÖÂåñÔºåÁ©∫Èó¥Ë¶ÅÂºÄ‰∏§ÂÄç„ÄÇ Âú®Â§ÑÁêÜÊ∂âÂèä‰∏çÂêåÈïøÂ∫¶Â≠óÁ¨¶‰∏≤ÁöÑÂ≠óÁ¨¶‰∏≤ÂìàÂ∏åÊó∂Ôºå‰∏ÄÂÆöË¶ÅÁî® str[i] - 'a' + 1 ËÄå‰∏çÊòØ str[i] - 'a' Âú®Â§ÑÁêÜÂ≠êÊ†ëÊúÄÈïø‰ªéÊ†πÂºÄÂßãË∑ØÂæÑ‰πãÁ±ªÁöÑÈóÆÈ¢òÊó∂ÔºåÂ¶ÇÊûúËøô‰∏™Â≠êÊ†ë‰∏çËÉΩÈÄâÔºådp ÂÄºËÆæ‰∏∫ \(0\) ‰ªç‰ºö +1 Âêë‰∏äË¥°ÁåÆ Âú®Áî® new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Âá∫Áé∞Ë∂äÁïå„ÄÇËøôÊó∂‰∏ç‰ºöÊä•ÈîôÔºåÂá∫Áé∞ new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Ôºå‰∏ÄÂÆöË¶ÅË∞®ÊÖéËÆ°ÁÆóÊØèÊ¨°Ë∞ÉÁî®ÁöÑÂ§ßÂ∞è„ÄÇÔºàÂ∞§ÂÖ∂ÊòØÂÜôÂ§öÈ°πÂºèÊó∂Ôºâ Áª¥Êä§Á∫øÊÆµÊ†ëÂå∫Èó¥Âä†Êó∂ÔºåÁªìÊûúÂèØËÉΩÂæàÂ§ßÁöÑÊó∂ÂÄô modify ÂáΩÊï∞ÂèÇÊï∞‰∏çÂºÄ long long]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[ÂèëËøôÁØáÂçöÂÆ¢‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆ∞ÂΩï‰∏Ä‰∏™ÊûÅ‰∏∫ÈöêËîΩÁöÑÈîôËØØ„ÄÇ ÂÜôÊØîËæÉÂáΩÊï∞‰∏ÄÂÆöË¶Å‰øùËØÅÊòØ‰∏•Ê†ºÁöÑÂ∞è‰∫éÂè∑„ÄÇË¶ÅÁâπÂà´Â§ÑÁêÜÁ≠â‰∫é„ÄÇÂê¶ÂàôÂú®ÈÅáÂà∞Â†ÜÊâìÊ†áËÆ∞Âà†Èô§ËøôÁßçÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÂÖÉÁ¥†Âú®Â†Ü‰∏≠ÁöÑÈ°∫Â∫è‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] „ÄåZJOI2017„ÄçÂ≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÂÅöÊ≥ï ‰∏çÈöæËØÅÊòéÂ¶ÇÊûú‰∏Ä‰∏™Â≠ê‰∏≤ \(s\) Êúâ‰∏§‰∏™ÂêéÁºÄ \(s_1, s_2\)Ôºå\(s_2\) ÊòØ \(s_1\) ÁöÑ border ‰∏î \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)ÔºåÈÇ£‰πàÂØπ‰∫é‰ªªÊÑèÁöÑÂ≠óÁ¨¶‰∏≤ \(t\)Ôºå\(s_2\) ‰∏çÂèØËÉΩÊòØ \(st\) ÁöÑÊúÄÂ∞èÂêéÁºÄ„ÄÇ Áî®‰∏Ä‰∏™Á∫øÊÆµÊ†ëÁª¥Êä§ÊØè‰∏™Âå∫Èó¥ÂÜÖÂèØËÉΩÊàê‰∏∫ÊúÄÂ∞èÂêéÁºÄÁöÑÁÇπÔºåËøôÊ†∑ÁöÑÁÇπÂè™Êúâ \(\mathcal O (\log n)\) ‰∏™„ÄÇpush up ÁöÑÊó∂ÂÄôÊö¥ÂäõÂêàÂπ∂Âç≥ÂèØ„ÄÇ ÊØîËæÉÂ§ßÂ∞èÁöÑÊó∂ÂÄôÈúÄË¶ÅÊü• lcpÔºåÂàÜÂùóÁª¥Êä§ÂâçÁºÄÂìàÂ∏åÂç≥ÂèØÂÅöÂà∞ \(\mathcal O(\sqrt n)\) ‰øÆÊîπÔºå\(\mathcal O(\log n)\) ËØ¢ÈóÆÔºàË∞ÉÊï¥ÂùóÂ§ßÂ∞èÂ∫îËØ•ÂèØ‰ª•ÂÅöÂà∞Êõ¥‰ºòÁöÑÂ§çÊùÇÂ∫¶Ôºâ„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)„ÄÇ ÔºàÁúüÁöÑÊØíÁò§Ôºâ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø]-Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ ÁÆÄÂçïÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] Âå∫Èó¥Á¥†Êï∞‰∏™Êï∞]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ËØïÁùÄÂÆûÁé∞‰∏ã min_25 Á≠õÁöÑÁ¨¨‰∏ÄÊ≠•„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/problemset/problem/715/E È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏§‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàó \(p_1\) Âíå \(p_2\)ÔºåÂÖ∂‰∏≠Êúâ‰∏Ä‰∫õ‰ΩçÁΩÆË¢´ÊåñÁ©∫ÔºåËÆ©‰Ω†Ëá™Â∑±Â°´Êï∞Â≠ó„ÄÇ ËØ∑‰Ω†ÂØπÊØè‰∏™ \(k\) ËæìÂá∫ÔºåÊúâÂ§öÂ∞ëÁßçÂ°´Êï∞Â≠óÊñπÊ°àÔºå‰ΩøÂæó \(p_1\) ÊúÄÂ∞ë‰∫§Êç¢ \(k\) Ê¨°ÂèØ‰ª•ÂèòÊàê \(p_2\)„ÄÇ \(n \le 250\)„ÄÇ Ëß£Ê≥ï È¶ñÂÖàÈ¢òÁõÆ‰øùËØÅËá≥Â∞ëÂ≠òÂú®‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°à‰ΩøÂæó \(p_1\) Âíå \(p_2\) ÊòØÊéíÂàóÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊï∞‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµ„ÄÇ ÂÆπÊòìÁúãÂá∫‰∫§Êç¢Ê¨°Êï∞ \(n-(p_1p_2^{-1}\) ÁöÑËΩÆÊç¢Êï∞\()\)„ÄÇ ÈóÆÈ¢òÂèòÊàê‰∫ÜÊ±ÇÊª°Ë∂≥ \(p_1p_2^{-1}\) ÊÅ∞Â•ΩÂèØ‰ª•ÂàÜËß£‰∏∫ \(k\) ‰∏™‰∏çÁõ∏‰∫§ËΩÆÊç¢ÁöÑÊñπÊ°àÊï∞„ÄÇ ËÆæ \(p_1p_2^{-1}=w\)ÔºåÂàô \(p_1=wp_2\)ÔºåÂç≥ \(p_1[i]=w[p_2[i]]\)„ÄÇ ËÆæÊâÄÊúâ \(p_1\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_1\)ÔºåÊâÄÊúâ \(p_2\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_2\)„ÄÇ ÂÅáËÆæ \(w\) ÊòØÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊéíÂàó„ÄÇÈÇ£‰πàÂØπ‰∫é \(i \in S_1\)ÔºåÊúâ \(p_2[i]=w^{-1}[p_1[i]]\)ÔºõÂØπ‰∫é \(i \in S_2\)ÔºåÊúâ \(p_1[i]=w[p_2[i]]\)„ÄÇÊâÄ‰ª• \(\forall i \in S_1 \cap S_2\)Ôºå\(p_1[i]\) Âíå \(p_2[i]\) ÈÉΩÊòØÁ°ÆÂÆöÁöÑ„ÄÇÂØπ‰∫é \(p_1\) Êù•ËØ¥ÔºåËøòÊúâ \(n-\lvert S_1\cup S_2 \rvert\) ‰∏™‰ΩçÁΩÆË¶ÅÂ°´ÁöÑÊï∞Ê≤°ÊúâÁ°ÆÂÆö„ÄÇÈÇ£‰πàÂ¶ÇÊûúÂ≠òÂú®Ëá≥Â∞ë‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°àÔºåÂ∞±ÊÅ∞Â•ΩÊúâ \((n-\lvert S_1\cup S_2 \rvert)!\) Áßç‰ΩøÂæó \(p_1p_2^{-1}=w\) ÁöÑÂ°´Êï∞ÊñπÊ°à„ÄÇ ÂÜçËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÂêàÊ≥ïÁöÑ \(w\)„ÄÇÂØπ‰∫é \(i \in S_1\cap S_2\)Ôºå\(w[p_2[i]]=p_1[i]\)„ÄÇÊâÄ‰ª• \(w\) ÁöÑ‰∏Ä‰∫õ‰ΩçÁΩÆÂ∑≤ÁªèÁ°ÆÂÆö‰∫Ü„ÄÇÂêåÊó∂ \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)„ÄÇ\(w\) ‰∏≠Á°ÆÂÆöÁöÑ‰ΩçÁΩÆÂ∑≤ÁªèÊûÑÊàê‰∫Ü‰∏Ä‰∫õÈìæÂíå‰∏Ä‰∫õÁéØ„ÄÇÊûÑÊàêÁéØÂêé‰∏çÂèØËÉΩ‰∏éÂÖ∂‰ªñÁÇπËøûËæπÔºåÂèØ‰ª•Áõ¥Êé•ÂøΩÁï•„ÄÇÈìæÂèØ‰ª•Áº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÈÇ£‰πàÈóÆÈ¢òËΩ¨Âåñ‰∏∫ÔºåÁªôÂÆö‰∏§‰∏™ÈõÜÂêà \(A\) Âíå \(B\)ÔºåÊ±ÇÊúâÂ§öÂ∞ë‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàóÔºåÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÊéíÂàóÔºåÊª°Ë∂≥ \(\forall i \in A, w[i] \notin B\)„ÄÇÊòæÁÑ∂Ëøô‰∏™ÈóÆÈ¢òÂè™‰∏é \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) ÊúâÂÖ≥„ÄÇ ÂÖàËÄÉËôë \(A\cap B =\emptyset\)„ÄÇÂÆπÊñ•‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] ÂÜçËÄÉËôë \(A\cap B \neq \emptyset\)„ÄÇÊääÈôêÂà∂Êù°‰ª∂Áúã‰Ωú \(\forall i \in A\setminus B,w[i]\notin B\) Âíå \(\forall i \in A \cap B, w[i] \notin B\)„ÄÇÂØπÁ¨¨‰∫å‰∏™Êù°‰ª∂ÂÆπÊñ•„ÄÇËÆæ \(G(n, c, i)\) ‰∏∫ \(n\) ‰∏™Êï∞ÁöÑÊéíÂàóÔºåÂÜ≥ÂÆö \(c\) ‰∏™‰ΩçÁΩÆÂ°´‰ªÄ‰πàÔºå‰ΩøÂ∑≤ÁªèÂÜ≥ÂÆöÁöÑËæπÊûÑÊàê \(i\) ‰∏™ÁéØÊñπÊ°àÊï∞ÔºàÊòæÁÑ∂Ê≠§Êó∂Êúâ \(n-c\) Êù°ÈìæÔºâ„ÄÇ \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) ÂÆûÈôÖÂè™Êúâ \(n^2\) ÁßçÔºåÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(F\) Âç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n^3)\)„ÄÇ ÂÜçËÄÉËôë \(G\) ÊÄé‰πàËÆ°ÁÆó„ÄÇ\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) ËÆ°ÁÆóÈùûÂ∏∏Êñπ‰æø„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï È¶ñÂÖàÔºå‰∏Ä‰∏™‰ª• \(A\) ‰∏∫ÂºÄÂ§¥‰ª• \(B\) ‰∏∫ÁªìÂ∞æÁöÑÂ∫èÂàóÊòØÂê¶Â≠òÂú®Ôºå‰ªÖ‰∏é \(A\oplus B\) ÊúâÂÖ≥„ÄÇ Â¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÈÇ£‰πà \(A\oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏ÄÂÆöÊòØÂ•áÊï∞„ÄÇ ‰∏Ä‰∏™ÁªìËÆ∫ÊòØÔºåÂ¶ÇÊûú \(A \oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÈÇ£‰πàÊª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàó‰∏ÄÂÆöÂ≠òÂú®„ÄÇ ‰∏ãÈù¢ÈÄíÂΩíÂú∞ÁªôÂá∫ÊûÑÈÄ†„ÄÇ ÂÆö‰πâ \(build(n,A,B)\) ËøîÂõû‰∏Ä‰∏™ \(0 \ldots 2^n-1\) ÁöÑ‰ª• \(A\) ‰∏∫ÂºÄÂ§¥Ôºå\(B\) ‰∏∫ÁªìÂ∞æÁöÑÊéíÂàó„ÄÇÔºà\(A\oplus B\) ‰∏≠ÊúâÂ•áÊï∞‰∏™ \(1\)Ôºâ Ëã• \(n=1\)ÔºåÂ¶ÇÊûú \(A = 0\)ÔºåËøîÂõû \(A, B\)„ÄÇ Ëã• \(A \oplus B\) ‰∏≠ÊÅ∞Êúâ‰∏Ä‰∏™ \(1\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^{n-1}\)ÔºàÂÖ∂‰ªñÊÉÖÂÜµÂè™ÈúÄË¶ÅÊääÊâÄÊúâÊï∞ÂºÇÊàñ‰∏ä \(A\) Âπ∂Êää \(1\) ÊâÄÂú®Âú®‰ΩçÂíåÊúÄÈ´ò‰Ωç‰∫§Êç¢Âç≥ÂèØÔºâ„ÄÇ ËÆæ \(a=build(n-1, 0, 1)\)ÔºåÈÇ£‰πà \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠Â≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæÂÖ∂‰∏≠ \(0\) Âú®ÊúÄ‰Ωé‰Ωç‰∏ä‰∏î \(A\) ÁöÑÊúÄ‰Ωé‰Ωç‰∏∫ \(0\)„ÄÇ ËÆæ \(a = build(n-1, \frac A 2, \frac B 2)\)Ôºå\(b = build(n-1, a_1, a_2)\)„ÄÇ ÈÇ£‰πà \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠‰∏çÂ≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^n-1\)„ÄÇ ËÆæ \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)„ÄÇ Âàô \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊéíÂàó„ÄÇ Áî®‰∏ªÂÆöÁêÜÂèØ‰ª•ÂàÜÊûêÂá∫Áõ¥Êé•ÈÄíÂΩíÁöÑÂ§çÊùÇÂ∫¶Âπ∂‰∏çÈ´ò„ÄÇÊâÄ‰ª•Áõ¥Êé•ÈÄíÂΩí‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï ËÆæ \(f_{i,j}\) Ë°®Á§∫Êää \(p_i \ldots p_n\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÊéíÂ∫èÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇ ËÆæ \(k\) ÊòØ \(p_i \ldots p_n\) ‰∏≠Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÁöÑ‰ΩçÁΩÆÔºå\(p_i\ldots p_k\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÂÖ±Êúâ \(c\) ‰∏™„ÄÇ \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] È¢ÑÂ§ÑÁêÜÂá∫ \(p\) Âíå \(c\)Ôºå\(n^2\) dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ È¢òÁõÆÂ§ßÊÑè Áªô‰Ω†‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÔºåËæπ‰∏äÊúâÂ≠óÁ¨¶„ÄÇÂÆö‰πâË∑ØÂæÑ \(u\) Âà∞ \(v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Â∞±ÊòØÊääË∑ØÂæÑ‰∏äÁöÑÂ≠óÁ¨¶‰æùÊ¨°Êé•Ëµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁªôÂÆö \(m\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s_1,s_2\ldots s_m\)„ÄÇ\(q\) Ê¨°ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏â‰∏™Êï∞ \(i, j, k\)ÔºåËØ¢ÈóÆÂú®Ë∑ØÂæÑ \(i\) Âà∞ \(j\) ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠Ôºå\(s_k\) Âá∫Áé∞‰∫ÜÂá†Ê¨°„ÄÇ Ëß£Ê≥ï Á¨¶Âè∑ËØ¥ÊòéÔºö\(s^R\) Ë°®Á§∫ \(s\) ÁöÑÂèç‰∏≤„ÄÇ\(pre(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂâçÁºÄÔºå\(suf(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂêéÁºÄ„ÄÇ\(s+t\) Ë°®Á§∫ÊääÂ≠óÁ¨¶‰∏≤ \(s\) ÂíåÂ≠óÁ¨¶‰∏≤ \(t\) ÊãºËµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇ ÂÖàÂÅö‰∏ÄÊ¨°ÁÇπÂàÜÊ≤ªÂ∞±ÂèØ‰ª•ÊääÈóÆÈ¢òËΩ¨Âåñ‰∏∫ \(u \rightarrow v\) ÁªèËøáÊ†πÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•Âè™ËÆ®ËÆ∫ÁªèËøáÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ËÆæÊ†π‰∏∫ \(r\)ÔºåËØ¢ÈóÆÁöÑË∑ØÂæÑ‰∏∫ \(u \rightarrow v\)ÔºåËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(s_k\)„ÄÇ ÂèØ‰ª•Êää \(s_k\) Âú®Ë∑ØÂæÑ \(u \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÂàÜÊàê‰∏âÈÉ®ÂàÜËÆ°ÁÆóÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØÂú® \(u\rightarrow r\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∫åÈÉ®ÂàÜÊòØÂú® \(r \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∏âÈÉ®ÂàÜÊòØÂú®Ë∑®Ëøá \(r\) ÁöÑÂåπÈÖç„ÄÇ Ââç‰∏§ÈÉ®ÂàÜÊòØÊØîËæÉÂ•ΩËÆ°ÁÆóÁöÑ„ÄÇÁ¶ªÁ∫ø‰∏Ä‰∏ãÔºåÂØπÊâÄÊúâÁöÑ \(s_i\) Âª∫ACËá™Âä®Êú∫ÔºåÂú®Ê†ë‰∏ädfsÔºåÊØèÊ¨°Âú®ACËá™Âä®Êú∫‰∏äËµ∞‰∏ÄÊù°ËΩ¨ÁßªËæπÔºåÁî® BIT Áª¥Êä§‰∏Ä‰∏ãÊØè‰∏™ÁÇπË¢´Ëµ∞‰∫ÜÂá†Ê¨°ÔºåÂú® dfs Âà∞ÁÇπ \(x\) Êó∂ÔºåÂè™ÈúÄ‰Ωú‰∏ÄÊ¨°Â≠êÊ†ëËØ¢ÈóÆÂç≥ÂèØÂø´ÈÄüÂæóÂà∞ \(s_k\) Âú® \(r\rightarrow x\) ‰∏äÂá∫Áé∞‰∫ÜÂá†Ê¨°ÔºàÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØ¢ÈóÆ \(s_k\) ÁöÑÂèç‰∏≤Âá∫Áé∞‰∫ÜÂá†Ê¨°Ôºâ„ÄÇ ÊØîËæÉÁÆÄÂçïÂ∞±‰∏çËØ¶ÁªÜÊèèËø∞‰∫Ü„ÄÇ Á¨¨‰∏âÈÉ®ÂàÜÊØîËæÉÂ§çÊùÇ„ÄÇËÆæË∑ØÂæÑ \(u\rightarrow r\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(x\)ÔºåË∑ØÂæÑ \(r \rightarrow v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(y\)„ÄÇËÆæ \(p\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(pre(s_k,p)=suf(x,p)\) ÁöÑÊï¥Êï∞Ôºå\(q\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(suf(s_k,q)=pre(y,q)\) ÁöÑÊï¥Êï∞„ÄÇÈÇ£‰πàËÆ°ÁÆóÁ¨¨‰∏âÈÉ®ÂàÜÂèØ‰ª•ËΩ¨Âåñ‰∏∫ËÆ°ÁÆó \(s_k\) Âú® \(suf(x,p)+pre(y,q)\) ‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞„ÄÇ ËÆæ \(t_i\) Ë∑ØÂæÑË°®Á§∫ \(r\rightarrow i\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂàô \(suf(x,p)+pre(y,q)\) ÂèØ‰ª•Ë°®Á§∫‰∏∫ \(pre(s_k,p)+suf(s_k,q)\)ÔºåËøôÊ†∑Â∞±ËΩ¨Âåñ‰∏∫‰∫ÜÂè™‰∏é \(s_k\) Áõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ\(p\)„ÄÅ\(q\) ÁöÑÂÖ∑‰ΩìÊ±ÇÊ≥ïÂêéÈù¢‰ºöËØ¶ÁªÜÊèèËø∞„ÄÇÂÅáËÆæÂ∑≤ÁªèÊ±ÇÂæó‰∫Ü \(p\)„ÄÅ\(q\)ÔºåËÄÉËôëÊÄé‰πàÂø´ÈÄüÂæóÂà∞Á¨¨‰∏âÈÉ®ÂàÜÁöÑÂåπÈÖçÊ¨°Êï∞„ÄÇ ÊääËØ¢ÈóÆÁ¶ªÁ∫ø„ÄÇÂØπÊØè‰∏™ \(i\)ÔºåÂª∫‰∏ÄÊ£µ \(s_i\) ÁöÑÂêéÁºÄÊ†ëÂíå \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë„ÄÇÂú® \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë‰∏ä \(dfs\)Ôºå\(dfs\) ÁöÑËøáÁ®ã‰∏≠ÔºåÁª¥Êä§‰∏ÄÊ£µÁ∫øÊÆµÊ†ë„ÄÇÂ¶ÇÊûú \(dfs\) Âà∞‰∏Ä‰∏™‰ª£Ë°® \(s_i^R\) ÂêéÁºÄÁöÑÁÇπÔºåËÆæËøô‰∏™ÁÇπÂØπÂ∫îÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ \(l\)ÔºåÈÇ£‰πàÂ∞±Âú®Á∫øÊÆµÊ†ë‰∏äÊää \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÂØπÂ∫î \(s_i[l+1\ldots \lvert s_i \rvert]\) ÁöÑÁÇπÁöÑÂ≠êÊ†ë \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂä†‰∏Ä„ÄÇÔºàÂèØËÉΩÊèèËø∞ÁöÑ‰∏çÊòØÂæàÊ∏ÖÊ•ö...Êàë‰πü‰∏çÁü•ÈÅìÊÄé‰πàÊèèËø∞‰∫ÜÔºâÂõûÊ∫ØÊó∂Êí§ÈîÄÊìç‰Ωú„ÄÇÁÑ∂ÂêéÂØπÊØè‰∏™ËØ¢ÈóÆ \(p, q\)ÔºåÂè™Ë¶ÅÂú® \(dfs\) Âà∞ \(s_i^R\) ÈïøÂ∫¶‰∏∫ \(p\) ÁöÑÂêéÁºÄÊó∂ÔºåËØ¢ÈóÆ‰∏Ä‰∏ã \(s_i\) ÈïøÂ∫¶‰∏∫ \(q\) ÁöÑÂêéÁºÄÂú® \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÁöÑ \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÁöÑÂÄºÂç≥ÂèØ„ÄÇ ËÄÉËôëÂ¶Ç‰ΩïÊ±Ç \(p\)„ÄÅ\(q\)„ÄÇÁî±‰∫éÊ±Ç \(q\) ÁöÑËøáÁ®ãÂíåÊ±Ç \(p\) Á±ª‰ººÔºåËøôÈáåÂè™ËØ¶ÁªÜÊèèËø∞Ê±Ç \(p\) ÁöÑËøáÁ®ã„ÄÇÂØπÊâÄÊúâ \(s_i\) ‰ª•Âèä \(s_i^R\) Âª∫Âá∫‰∏Ä‰∏™Âπø‰πâSAM„ÄÇÁÑ∂ÂêéÁ±ª‰ººACËá™Âä®Êú∫+BITÁöÑËøáÁ®ãÂú∞ÔºåÁª¥Êä§‰∏Ä‰∏™‰ª•parentÊ†ë \(dfs\) Â∫è‰∏∫‰∏ãÊ†áÁöÑÁ∫øÊÆµÊ†ë„ÄÇÁÑ∂ÂêéÂú®ÁÇπÂàÜÊ≤ªÂêéÂæóÂà∞ÁöÑËøûÈÄöÂùó‰∏ä \(dfs\)Ôºå\(dfs\) Âà∞ \(u\) Êó∂Áª¥Êä§ \(r\rightarrow u\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Âú®SAM‰∏äÁöÑ‰ΩçÁΩÆÔºåÂπ∂ÊääÂÆÉÁöÑÂ≠êÊ†ëÂú® \(dfs\) Â∫è‰∏äÁöÑ‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÂ≠êÊ†ëÂØπÈïøÂ∫¶Âèñ \(max\)„ÄÇÁÑ∂ÂêéÊ±Ç \(p\) Êó∂Âè™ÈúÄË¶ÅËØ¢ÈóÆ‰∏Ä‰∏ã \(s_k^R\) Âú® \(SAM\) ‰∏äÁöÑ‰ΩçÁΩÆÂú®parent tree‰∏≠ÁöÑ \(dfs\) Âú®Á∫øÊÆµÊ†ë‰∏äÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• „ÄåPKUWC2018„ÄçMinimax„ÄÇ Â§ßËá¥ÊÄùË∑Ø&amp;&amp;ÂêêÊßΩ Á∫øÊÆµÊ†ëÂêàÂπ∂ÔºåÁª¥Êä§Êüê‰∏™ÁÇπÊúÄÂêéÁöÑÂÄºÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™Âå∫Èó¥ÁöÑÊ¶ÇÁéá„ÄÇ merge ÁöÑÊó∂ÂÄôËÆ∞‰∏Ä‰∏ãÂâçÂêéÁºÄÊ¶ÇÁéáÂ∞±ËÉΩËΩ¨Áßª‰∫Ü„ÄÇ ‰ª£Á†ÅËÉΩÂäõÁúüÊòØË∂äÊù•Ë∂äÂ∑Æ‰∫Ü..Á∫øÊÆµÊ†ëÂêàÂπ∂ÈÉΩÂÜô‰∏çÁÜü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 Êï¥Êï∞]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) ‰∏™ \(bit\) Âéã‰∏ÄËµ∑ÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥Â∑¶ËæπËøûÁª≠ \(0\) Âíå \(2^{30}-1\) ÁöÑ‰∏™Êï∞„ÄÇ ‰ª£Á†ÅËÉΩÂäõÂ§™Ëèú‰∫ÜË°•Ë°•Ê∞¥È¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ Ë¥®Êï∞Âà§ÂÆö„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] ÂèçÂõûÊñá‰∏≤]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄåSDOI2018„ÄçÂèçÂõûÊñá‰∏≤„ÄÇ È¢òËß£ ËÄÉËôë‰ªÄ‰πàÊ†∑ÁöÑÂõûÊñá‰∏≤Âú®Âæ™ÁéØÁßª‰Ωç \(k\) ‰ΩçÂêéËøòÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤„ÄÇ ËÆæ \(s\) ÊòØ‰∏Ä‰∏™Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶‰∏∫ \(n\) ÂõûÊñá‰∏≤„ÄÇ ËÆ∞Â≠óÁ¨¶‰∏≤ \(a\) ÁöÑÂèç‰∏≤‰∏∫ \(a^R\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØÂõûÊñá‰∏≤ÔºåÂØπ‰∫é \(1\le i \le n\)Ôºå\(s[i]=s[n-i+1]\)„ÄÇ ÂèàÂõ†‰∏∫ \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤Ôºö ÂØπ‰∫é \(1 \le i \le n-2k\)Ôºö \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) ÂØπ‰∫é \(n-2k &lt; i \le n-k\)Ôºö \(s[i] = s[2n-2k-i+1] = s[i+2k]\) ÂØπ‰∫é \(n-k&lt;i \le n\)Ôºö \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) ÂèØ‰ª•ÁúãÂá∫ \(2k\) ÊòØ \(s\) ÁöÑÂë®ÊúüÔºå‰∏î \(s\) Âæ™ÁéØÂè≥Áßª \(2k\) ‰ΩçÂêéÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤‰∏é \(s\) Áõ∏Á≠â„ÄÇÂõ†Ê≠§ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÊòØ \(n\) ÁöÑÁ∫¶Êï∞„ÄÇËÆæ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÈïøÂ∫¶‰∏∫ \(t\)Ôºå\(t \mid n\)„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûú \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰Ωç‰ªçÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÈÇ£‰πà \(t \mid 2k\)„ÄÇÊúâ \(t\) Áßç‰∏çÂêåÁöÑ‰∏é \(s\) Âæ™ÁéØÂêåÊûÑÁöÑ‰∏≤„ÄÇËã• \(t\) ‰∏∫ÂÅ∂Êï∞ÔºåÈÇ£‰πà \(s\) Âæ™ÁéØÂè≥Áßª \(\frac t 2\) ‰ΩçÊàñÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇÂê¶ÂàôÂè™ÊúâÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇ ‰∏∫‰∫ÜËÆ°ÁÆó‰∏éÊüê‰∏™ÂõûÊñá‰∏≤Âæ™ÁéØÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÔºåËÄÉËôëÊûö‰∏æÂõûÊñá‰∏≤Âπ∂ËÆ°ÁÆó‰∏éËøô‰∏™ÂõûÊñá‰∏≤ÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤ÊúâÂ§öÂ∞ëÁßçÔºåËøôÊ†∑ÊúÄÂ∞èÂë®ÊúüÊòØÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤‰ºöË¢´ÁÆóÊÅ∞Â•Ω‰∏§Ê¨°ÔºåÂÖ∂‰ªñÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤Âè™‰ºöË¢´ÁÆó‰∏ÄÊ¨°„ÄÇÁâπÂà§ÊúÄÂ∞èÂë®Êúü‰∏∫ÂÅ∂Êï∞ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå‰∏çÂèØËÉΩÊûö‰∏æÊâÄÊúâÁöÑÂõûÊñá‰∏≤„ÄÇËÄÉËôëÊääÊúÄÂ∞èÂë®ÊúüÁõ∏ÂêåÁöÑÂõûÊñá‰∏≤ÊîæÂú®‰∏ÄËµ∑Êûö‰∏æ„ÄÇËÆæÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è‰∏∫ \(K\)ÔºåÊúÄÂ∞èÂë®Êúü‰∏∫ \(i\) ÁöÑÁ∫¶Êï∞ÁöÑÂõûÊñá‰∏≤Êúâ \(K^{\lceil \frac i 2 \rceil}\) ‰∏™„ÄÇËé´ÊØî‰πåÊñØÂèçÊºî‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå \(n\) ÈùûÂ∏∏ÁöÑÂ§ßÔºåÊ≤°ÊúâÂäûÊ≥ïÁõ¥Êé•ÂèçÊºîÂá∫‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ ÊääÁ≠îÊ°àÂÜôÂá∫Êù•ÂåñÁÆÄÔºö \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] Êûö‰∏æ \(d\)„ÄÇ \(d\) ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)„ÄÇ \(d\) ‰∏∫Â•áÊï∞Êó∂ÔºåËã• \(n\) ‰∏∫Â•áÊï∞Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)ÔºåÂê¶Âàô \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)„ÄÇ \(Pollard-Rho\) ÂàÜËß£Á¥†Âõ†Êï∞ÂêéÁÆÄÂçïÁªüËÆ°‰∏Ä‰∏ãÁ≠îÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [Ynoi2016]Èïú‰∏≠ÁöÑÊòÜËô´„ÄÇ ËÆ∞ÂΩïÊØè‰∏™ÁÇπ \(i\) ÂâçÈù¢Á¨¨‰∏Ä‰∏™‰∏é‰ªñÂêåËâ≤ÁöÑ‰ΩçÁΩÆ \(pre_i\)„ÄÇËØ¢ÈóÆÂå∫Èó¥È¢úËâ≤Êï∞ÂèòÊàêËØ¢ÈóÆÂå∫Èó¥ÂÜÖÊúâÂ§öÂ∞ë‰∏™ \(pre_i &lt;l\)ÔºåËøôÊòØ‰∏Ä‰∏™‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò„ÄÇÊ≥®ÊÑèÂà∞‰øÆÊîπ \(pre\) Êï∞ÁªÑÊ¨°Êï∞ÂùáÊëä \(\mathcal O (n)\)ÔºåÁî® \(set\) Áª¥Êä§ÊØè‰∏ÄÊÆµÔºåcdqÂàÜÊ≤ªÊàñËÄÖÊ†ëÂ•óÊ†ëÂÅö‰∏Ä‰∏ã‰∫åÁª¥ÂÅèÂ∫èÂç≥ÂèØ„ÄÇ ËøôÈ¢òÊúâ‰∏ÄÁÇπÂç°Â∏∏..cdqÂàÜÊ≤ªÂÜôÂΩíÂπ∂ÈÄüÂ∫¶‰ºöÂø´ÂæàÂ§ö„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //Á¶ªÊï£Âåñint pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //ÂØπ l+1-r ÁöÑpreÊõ¥Êñ∞ set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[È¢òËß£] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[ËôΩÁÑ∂ÂâçÈù¢ËøòÊúâÂæàÂ§öÂùëÊ≤°Ë°•ÂÆå...‰ΩÜÊòØÊàëÂèëÁé∞Ëá™Â∑±‰ª£Á†ÅËÉΩÂäõÈóÆÈ¢òÊØîËæÉ‰∏•Èáç„ÄÇÊâÄ‰ª•Êù•ÂÅöÂÅöynoi„ÄÇ ÂùëÂÖàÊîæÂú®Ëøô...Ê∏ÖÈÜíÁöÑÊó∂ÂÄôÊÖ¢ÊÖ¢Â°´„ÄÇ [YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢„ÄÇ ÂÖàÂíïÁùÄ„ÄÇ„ÄÇ„ÄÇ‰∏á‰∏ÄÈÅá‰∏äÁé∞Êé®Âêß„ÄÇ]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÊâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ„ÄÇ ËøôÈ¢òÁõÆÊúâÈóÆÈ¢òÂêß....Ê®°Êï∞ÂèØ‰ª•ÁàÜ long long ÁöÑ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÂêéÁºÄËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂêéÁºÄËá™Âä®Êú∫„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Splay(Áª¥Êä§Â∫èÂàó)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [NOI2005]Áª¥Êä§Êï∞Âàó„ÄÇ Â∏∏Êï∞ÈùûÂ∏∏ÈùûÂ∏∏Â§ß.....ÂÖàÂΩìÊùøÂ≠êËÉå‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèexp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÂØπÊï∞ÂáΩÊï∞„ÄÇ ‰ª£Á†ÅÁâπÂà´‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊ±ÇÈÄÜ]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÊ±ÇÈÄÜ„ÄÇ \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) ‰ª£Á†Å‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ‰ªªÊÑèÈïøÂ∫¶DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm Ê±Ç \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) ËÆæ \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)„ÄÇ Âàô \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)„ÄÇ \(i-k\) ÂèØËÉΩ‰ºöÂá∫Áé∞Ë¥üÊï∞„ÄÇÂπ≥Áßª‰∏ãÂÅö‰∏™Âç∑ÁßØÂç≥ÂèØ„ÄÇ ÊáíÂæóÂÜôQAQ„ÄÇÔºàÂ•ΩÂÉè‰πüÊ≤°Âï•Â•ΩÂÜôÁöÑÔºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] NTTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∏™ÊôÆÈÄöÁöÑ NTT Ê®°Êùø„ÄÇ‰ª£Á†ÅÈùûÂ∏∏‰∏ë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FFTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÁúÅÈÄâÂâçÂ§ç‰π†„ÄÇËøôÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ fft Ê®°Êùø„ÄÇ ÔºàÂèëÁé∞Ëá™Â∑±Â∑ÆÁÇπfftÊ®°Êùø‰∏ç‰ºöÊâì‰∫ÜÔºâ Âõ†‰∏∫Ê≤°ÊúâÈ¢ÑÂ§ÑÁêÜ&amp;&amp;Áî®‰∫ÜcomplexÁ±ªÂèØËÉΩÂ∏∏Êï∞ÊØîËæÉÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÊàëÂèëÁé∞Ëá™Â∑±ÁöÑ‰ª£Á†ÅËÉΩÂäõÂ§™Âº±‰∫Ü...... Êúâ‰∫õÊ®°ÊùøÈúÄË¶ÅÂπ≥Êó∂ÂÜô‰∏Ä‰∏ãÔºå‰∏çËÉΩÁé∞Âú∫ÂÜôÔºåÂê¶Âàô‰∏ç‰∏ÄÂÆöË∞ÉÁöÑÂá∫Êù•„ÄÇËøôÈáåÂàóÂá∫‰∏Ä‰∫õÂ∏∏Áî®Ê®°Êùø„ÄÇÔºà‰ºòÂåñÂ∏∏Êï∞&amp;&amp;‰ºòÂåñ‰ª£Á†ÅÂ§çÊùÇÂ∫¶&amp;&amp;ËÉå‰∏ãÊù•Ôºâ„ÄÇ Â§öÈ°πÂºèÔºö FFT NTT Â§öÈ°πÂºèÊ±ÇÈÄÜ Â§öÈ°πÂºèln Â§öÈ°πÂºèexp Â§öÈ°πÂºèÂèñÊ®° Â§öÈ°πÂºèÂ§öÁÇπÊ±ÇÂÄº Â§öÈ°πÂºèÂø´ÈÄüÊèíÂÄº Â§öÈ°πÂºèÂ§çÂêàÈÄÜ Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé® Êï∞ËÆ∫Ôºö LucasÂÆöÁêÜ exCRT ÊùúÊïôÁ≠õ Pollard-Rho Miller-Rabin min_25Á≠õ Á±ªÊ¨ßÂá†ÈáåÂæó ‰∫åÊ¨°Ââ©‰Ωô Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºö Á∫øÊÆµÊ†ëÂêàÂπ∂ Ê†ëÁä∂Êï∞ÁªÑ Splay LCT ETT ÁÇπÂàÜÊ†ë Ê†ëÈìæÂâñÂàÜ Âä®ÊÄÅdp Â≠óÁ¨¶‰∏≤Ôºö ÂêéÁºÄËá™Âä®Êú∫ Âª∫ÂêéÁºÄÊ†ë ÂêéÁºÄÊï∞ÁªÑ trieÊ†ëSAM ACËá™Âä®Êú∫ ÂõûÊñáÊ†ë ÂÖ∂‰ªñÔºö FWT ÂçäÂπ≥Èù¢‰∫§ Áü©Èòµ-Ê†ëÂÆöÁêÜ ÂõæËÆ∫Ôºö ÊîØÈÖçÊ†ë ÂúÜÊñπÊ†ë ËæπÂèå]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢òÁõÆ]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑËøô‰πàËèú‰∫ÜËøòÂè£ËÉ°È¢òÁõÆ...Â§ßÊ¶Ç‰ºöË∂äÊù•Ë∂äËèúÂêß.. 2019.3.29 CF 1097G \(k\) Ê¨°ÊñπÁúã‰ΩúÊòØÈÄâ \(k\) Êù°Ëæπ„ÄÇËÄÉËôëÊâÄÊúâ \(k\) Êù°ËæπÁöÑÊúâÂ∫èÂØπÔºåËÆ°ÁÆóÂåÖÂê´ÂÆÉ‰ª¨ÁöÑÈõÜÂêàÊï∞„ÄÇËÉåÂåÖ \(dp\) ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇÊ†πÊçÆÊüêËÄÉËøáÂæàÂ§öÊ¨°ÁöÑÂ§çÊùÇÂ∫¶ÂàÜÊûêÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ \(\mathcal O (nk)\)„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Ôºö https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf È¢òÁõÆÂ§ßÊÑè ËæìÂÖ•‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ≠óÁ¨¶‰∏≤ \(s\)„ÄÇ‰Ω†Êúâ‰∏Ä‰∏™Á©∫‰∏≤ \(t\)Ôºå‰Ω†Ë¶ÅÊääÂÆÉÂèòÊàêËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂèØ‰ª•ËøõË°å‰ª•‰∏ãÂá†ÁßçÊìç‰ΩúÔºö Âú® \(t\) ÁöÑÂºÄÂ§¥ÊàñËÄÖÊú´Â∞æÊ∑ªÂä†‰∏Ä‰∏™Â≠óÁ¨¶„ÄÇ Êää \(t\) ÁøªËΩ¨ËøáÊù•ÔºåÁÑ∂ÂêéÊé•Âú®ÂéüÊù•ÁöÑ \(t\) ÁöÑÂºÄÂ§¥ÊàñÊú´Â∞æ„ÄÇ Ê±ÇÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ \(n \le 10^5\) Ëß£Ê≥ï Âú®ÊúÄÂêéËøûÁª≠ÁöÑËã•Âπ≤Ê¨°Âä†Â≠óÁ¨¶Êìç‰Ωú‰πãÂâçÔºå\(t\) ‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÂÄíËøáÊù•ËÄÉËôëÔºåÁî®ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞Êää \(s\) ÂèòÊàêÁ©∫‰∏≤„ÄÇÂè™ÈúÄË¶ÅÂàÜÂà´ËÄÉËôëÊØè‰∏™ÂõûÊñá‰∏≤ÁöÑÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Âª∫Á´ãÂõûÊñáÊ†ë„ÄÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏âÁßçËΩ¨ÁßªÔºö ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤Âèò‰∏∫‰ªñÁöÑ‰∏ÄÂçä„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂéªÊéâ‰ªñ‰∏§Á´ØÁöÑÂ≠óÁ¨¶„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåËΩ¨ÁßªÂà∞‰ªñÁöÑÊúÄÈïøÂõûÊñáÂâçÁºÄ„ÄÇ ÊåâÈïøÂ∫¶‰ªéÂ∞èÂà∞Â§ßÈ°∫Â∫è \(dp\)„ÄÇÂêé‰∏§ÁßçËΩ¨ÁßªÂèØ‰ª•Áõ¥Êé•ËÆ°ÁÆó„ÄÇÂØπÁ¨¨‰∏ÄÁßçËΩ¨ÁßªÔºåÂÄçÂ¢û‰∏Ä‰∏ãÂà§Êñ≠ \(fail\) Ê†ë‰∏äÊúâÊ≤°ÊúâÈïøÂ∫¶ÊÅ∞Â•Ω‰∏∫‰∏ÄÂçäÁöÑÁ•ñÂÖàÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØÂÅáÁöÑ„ÄÇË¶ÅÁúÅÈÄâ‰∫Ü..ÂÖàË°•ÁÇπÂà´ÁöÑÂÜçÊù•ÊâìËøôÈ¢òQAQ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â≠óÁ¨¶‰∏≤ÊäÄÂ∑ß„ÄÅÊÄùÊÉ≥„ÄÅÁü•ËØÜÁÇπÊï¥ÁêÜ]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon wordÁöÑ‰∏Ä‰∫õÊÄßË¥®]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Lyndon_word ÂÆö‰πâ Â¶ÇÊûú‰∏Ä‰∏™‰∏≤ÊúÄÂ∞èÂêéÁºÄÊòØÂÆÉÊú¨Ë∫´ÔºåÈÇ£‰πàÁß∞‰ªñ‰∏∫ Lyndon word„ÄÇÔºà‰∏é‰∏•Ê†ºÊúÄÂ∞èÂæ™ÁéØÁßª‰ΩçÁöÑÂÆö‰πâÊòØÁ≠â‰ª∑ÁöÑÔºâ Áõ∏ÂÖ≥ÊÄßË¥®ÂíåÁÆóÊ≥ï ÊÄßË¥®1 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºåÈÇ£‰πà \(s\) ‰∏çÂ≠òÂú® border„ÄÇ ÊÄßË¥®2 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºå\(s=uv\) ‰∏î \(u\) Âíå \(v\) ÈùûÁ©∫ÔºåÈÇ£‰πà \(u&lt;v\)„ÄÇ ÊÄßË¥®3 Â¶ÇÊûú \(s,t\) ÊòØ Lyndon word ‰∏î \(s &lt; t\)ÔºåÈÇ£‰πà \(st\) ‰πüÊòØ Lyndon word„ÄÇ ÊÄßË¥®4 ‰∏Ä‰∏™ÈïøÂ∫¶Â§ß‰∫éÁ≠â‰∫é \(2\) Â≠óÁ¨¶‰∏≤ÁöÑ \(s\) ÊòØ Lyndon word ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå\(s\) ÂèØ‰ª•ÊãÜÊàê‰∏§‰∏™ÈùûÁ©∫‰∏≤ \(u,v\)ÔºåÊª°Ë∂≥ \(u &lt; v\) ‰∏î \(u\) Âíå \(v\) ÈÉΩÊòØ Lyndon word„ÄÇ ËØÅÊòé ÂÖÖÂàÜÊÄßÂç≥‰∏ä‰∏ÄÊù°ÊÄßË¥®ÔºåÂè™ËØÅÂøÖË¶ÅÊÄß„ÄÇ ËÆæ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(n\)ÔºåÂêéÁºÄ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄ„ÄÇ ÂÅáËÆæ \(s[1..i-1]\) ÊúâÈïøÂ∫¶‰∏∫ \(k\) ÁöÑ borderÔºåÂç≥ \(s[1..k]=s[i-k..i-1]\)„ÄÇ Âõ†‰∏∫ \(k &lt; i-1\)ÔºåÊâÄ‰ª• \(k+1 \neq i\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØ Lyndon wordÔºå\(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊâÄ‰ª• \(s[i..n]&lt;s[k+1..n]\)„ÄÇÂèàÂõ†‰∏∫ \(s[i-k..i-1]=s[1..k]\)ÔºåÊâÄ‰ª• \(s[i-k..n]&lt;s[1..n]\)ÔºåËøô‰∏é \(s\) ÊòØ Lyndon word ÁüõÁõæ„ÄÇÊâÄ‰ª• \(s[1..i-1]\) Ê≤°Êúâ border„ÄÇ Ê†πÊçÆ Lyndon word ÁöÑÂÆö‰πâÂèä \(s[1..i-1]\) Ê≤°Êúâ borderÔºåÊúâ \(\forall 1 &lt; j \le i-1\)Ôºå\(\exists j \le k \le i-1\)ÔºåÊª°Ë∂≥ \(s[k] &gt; s[k-j+1]\)ÔºåÂç≥ \(s[j..i-1] &gt; s[1..i-1]\)„ÄÇÊâÄ‰ª• \(s[1..i-1]\) ÊòØ Lyndon word„ÄÇ Âõ†‰∏∫ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊòæÁÑ∂‰∏çÂ≠òÂú® \(j&gt;i\) Êª°Ë∂≥ \(s[j..n]&lt;s[i..n]\)ÔºåÊâÄ‰ª• \(s[i..n]\) ÊòØ Lyndon word„ÄÇ ÊâÄ‰ª• \(u=s[1..i-1],v=s[i..n]\) ÊòØ‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊãÜÂàÜÔºåÂøÖË¶ÅÊÄßÂæóËØÅ„ÄÇ ÊÄßË¥®5 ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\) ÈÉΩÂèØ‰ª•ÂîØ‰∏ÄÂú∞ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÂÖ∏Â∫è‰∏çÂ¢ûÁöÑ Lyndon Word„ÄÇ ÊàëÊäΩ‰ª£Â§™Ëèú‰∫Ü...ÂÖ∂‰ªñÁöÑÊÄßË¥®‰ª•ÂêéÂÜçË°•Âêß„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon ÂàÜËß£]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ëß£Ê≥ï ÂÖ≥‰∫é Lyndon word ÁöÑ‰∏Ä‰∫õÁªìËÆ∫ÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/D È¢òÁõÆÂ§ßÊÑè ÁªôÂÆö‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÔºå‰ª• \(1\) ‰∏∫Ê†πÁöÑÊ†ëÔºåÁ¨¨ \(i\) ‰∏™ÁÇπÊúâ‰∏Ä‰∏™‰ª∑Ê†º \(c_i\)„ÄÇ ‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™‰∫∫‰ºöÁªôÊØè‰∏™Âè∂ËäÇÁÇπËÆæÁΩÆ‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ‰Ω†Âè™ËÉΩÂØπÂ∑≤ÁªèÈÄâÊã©ÁöÑÁÇπÂÅöÂ≠êÊ†ëÂä†‰ªªÊÑèÊï∞Â≠óÁöÑÊìç‰Ωú„ÄÇ ‰Ω†Ë¶ÅÈÄöËøáËã•Âπ≤Ê¨°Êìç‰ΩúÊääÊâÄÊúâÂè∂Â≠êËäÇÁÇπ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\)„ÄÇ ÈóÆÔºöË¶ÅÁ°Æ‰øùÂè¶‰∏Ä‰∏™‰∫∫Êó†ËÆ∫ÊÄé‰πàÊìç‰Ωú‰Ω†ÈÉΩËÉΩÊääÂè∂Â≠ê‰∏äÁöÑÊï∞ÂèòÊàê \(0\)Ôºå‰Ω†ÈÄâÊã©ÁöÑÁÇπ‰ª∑Ê†ºÊÄªÂíåÊúÄÂ∞èÊòØ‰ªÄ‰πàÔºüÊúâÂì™‰∫õÁÇπË¢´Ëá≥Â∞ë‰∏ÄÁßçÊúÄÂ∞è‰ª∑Ê†ºÁöÑÊñπÊ°àÂåÖÂê´Ôºü \(n \le 200000\)Ôºå\(0\le c_i \le 10^9\)„ÄÇ Ëß£Ê≥ï Ëøô‰∏™ÈóÆÈ¢òÂèØ‰ª•ÁúãÊàêÔºå‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπ‰Ωú‰∏∫Êú™Áü•Êï∞ÔºåÊØè‰∏™Âè∂Â≠êÁöÑÈôêÂà∂ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÊñπÁ®ãÔºå‰Ω†Ë¶ÅËÆ©Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÊª°Ë∂≥ÔºåÊó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåËøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Âõ†‰∏∫‰ª∑Ê†ºÊòØÈùûË¥üÊï¥Êï∞ÔºåÂ¶ÇÊûúÁ≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÁõ∏ÂÖ≥ÔºåÂøÖÂèØ‰ª•Âà†Èô§Êüê‰∏ÄÂàóÔºåÂç≥ÂèØ‰ª•Â∞ëÈÄâ‰∏Ä‰∏™ÁÇπÔºåËøôÊ†∑‰∏ÄÂÆö‰∏ç‰ºöÂèòÁöÑÊõ¥Â∑ÆÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥„ÄÇÂõ†‰∏∫Êó†ËÆ∫Â∏∏Êï∞È°πÁöÑÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩË¶ÅÊúâËß£ÔºåÊâÄ‰ª•Ë°åÊï∞Á≠â‰∫éÂàóÊï∞„ÄÇ ÁªìËÆ∫ ËÆæÂè∂ËäÇÁÇπ‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∏Ä‰∏™ÂåÖÂê´ÊÅ∞Â•Ω \(x\) ‰∏™ÁÇπÁöÑÈÄâÂèñÊñπÊ°àËÉΩ‰øùËØÅÂèØ‰ª•Â∞ÜÊâÄÊúâÂè∂Â≠ê‰∏äÁöÑÊï∞Â≠óÂèòÊàê \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÔºåÂ≠òÂú®Ë¢´ÈÄâÂèñÁöÑÁÇπÔºå‰∏îÊ∑±Â∫¶ÊúÄÂ§ßÁöÑË¢´ÈÄâÂèñÁÇπ‰∏çÂêå„ÄÇ ËØÅÊòé ÂøÖË¶ÅÊÄßÊòæÁÑ∂„ÄÇ ÂÖÖÂàÜÊÄßÔºöÊääÊñπÁ®ãÁªÑÁöÑÊú™Áü•Êï∞Êåâ‰ªªÊÑè‰∏ÄÁßç \(dfs\) Â∫èÊéíÂàóÔºåÁ≥ªÊï∞Áü©Èòµ‰∏≠ÔºåÊØè‰∏ÄË°åÁöÑÁ¨¨‰∏Ä‰∏™Èùû \(0\) ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂàóÈÉΩ‰∏çÂêåÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥ÔºåÂèàÂõ†‰∏∫Ë°åÊï∞Á≠â‰∫éÂàóÊï∞ÔºåÊâÄ‰ª•Êó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Áä∂ÊÄÅ \(dp[i][j][k]\) Ôºö \(i\) Ë°®Á§∫Âè™ËÄÉËôë‰ª• \(i\) ‰∏∫Ê†πÁöÑÂ≠êÊ†ë„ÄÇ \(j\) Ë°®Á§∫ \(i\) ÊòØÂê¶Ë¢´ÈÄâÊã©„ÄÇ \(k\) Ë°®Á§∫ÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Âè∂Â≠êÔºå‰ªñÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏≠Ê≤°ÊúâÁÇπË¢´ÈÄâÊã©„ÄÇ \(dp\) Êï∞ÁªÑ‰∏≠Â≠òÁöÑÊòØÔºåÊª°Ë∂≥‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏äÊ∑±Â∫¶ÊúÄÂ§ßÁöÑÁ•ñÂÖà‰∏çÂêåÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÁúã‰Ωú \(0\)ÔºâÁöÑÊúÄÂ∞è‰ª∑Ê†ºÂíå„ÄÇ \(dp\) ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéËÆ∞ÂΩïÂì™‰∫õËΩ¨ÁßªÂèØ‰ª•ÂèñÂà∞ÊúÄ‰ºòÂÄºÔºåÊúÄÂêé‰ªéÊ†πÂºÄÂßã \(dfs\) ‰∏ÄÈÅçÊ±ÇÊñπÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ÔºàÂ∑®‰∏ëÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/C È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s\)„ÄÇ ËØ∑‰Ω†Êää \(s\) ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÁ¨¶‰∏≤ \(s=t_1t_2\cdots t_k\)„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∏≤ÔºåËã• \(t_i\) ÊòØ \(t_1t_2\cdots t_{i-1}\) ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(b\) ÁöÑ‰ª£‰ª∑ÔºåÂê¶Âàô \(t_i\) ÈïøÂ∫¶ÂøÖÈ°ª‰∏∫ \(1\)Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(a\) ÁöÑ‰ª£‰ª∑„ÄÇÊ±ÇÊúÄÂ∞è‰ª£‰ª∑„ÄÇ \(n \le 5000\)ÔºåÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è \(26\)„ÄÇ Ëß£Ê≥ï ËÆæ \(dp_i\) Ë°®Á§∫Ââç \(i\) ‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂ∞èÂàíÂàÜÔºåÂú®Ê±ÇÂá∫ \(dp_i\) ÂêéÁî® \(kmp\) ÊâæÊúÄÈïøÂú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑ‰ªé \(i+1\) ÂºÄÂßãÁöÑ‰∏≤ÔºåÊõ¥Êñ∞ÊâÄÊúâ \(dp_j\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÊï¥ÁêÜÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Impartial_game impartial game ÊòØÊåáÊª°Ë∂≥Â¶Ç‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÔºö - ‰∏§‰∏™Áé©ÂÆ∂ËΩÆÊµÅÊìç‰ΩúÔºåÁõ¥Âà∞ËææÂà∞‰∏çËÉΩÊìç‰ΩúÁöÑÁä∂ÊÄÅÔºàterminal positionÔºâ„ÄÇ - ÂΩì‰∏Ä‰∏™Áé©ÂÆ∂‰∏çËÉΩÊìç‰ΩúÊó∂Ôºåwinner Â∞±Ë¢´Á°ÆÂÆö‰∫Ü„ÄÇ - ÊØè‰∏™Áä∂ÊÄÅÁöÑÊìç‰ΩúÊï∞ÂíåÁä∂ÊÄÅÊÄªÊï∞ÊòØÊúâÈôêÁöÑ„ÄÇ - ÊâÄÊúâÁöÑÊìç‰ΩúÂøÖÈ°ªÂêåÊó∂ËÉΩË¢´‰∏§‰∏™Áé©ÂÆ∂ËøõË°å„ÄÇ - ÊâÄÊúâÊìç‰ΩúÁöÑÁªìÊûúÈÉΩÊòØÁ°ÆÂÆöÊÄßÁöÑ„ÄÇ Normal play convention wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Normal_play_convention Impartial game ÁöÑ Normal play convention ÔºöÊúÄÂêé‰∏Ä‰∏™ÂèØ‰ª•Êìç‰ΩúÁöÑÁé©ÂÆ∂Ëé∑ËÉú„ÄÇ NimÊ∏∏Êàè wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Nim ÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅÂèñÁü≥Â≠ê„ÄÇÊØèÊ¨°ËΩÆÂà∞ÁöÑ‰∫∫ÂèØ‰ª•ÈÄâÊã©‰ªéÊüê‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Ëã•Âπ≤È¢óÁü≥Â≠êÔºà‰∏çËÉΩ‰∏çÊãøÔºâÔºå‰∏çËÉΩÊåâËßÑÂàôÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ Nim Ê∏∏ÊàèÂ±û‰∫é Impartial game„ÄÇ NimÊ∏∏ÊàèÁöÑËÉúÂà©Êù°‰ª∂ ÂÆöÁêÜÔºöÂΩì‰∏î‰ªÖÂΩìÊØèÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) Êó∂ÔºåÂÖàÊâãÂøÖËÉú„ÄÇ ËØÅÊòéÔºö ÂØπ‰∫é terminal positionÔºåÂç≥Ê≤°ÊúâÁü≥ÁöÑÊÉÖÂÜµÔºåÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåËΩÆÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑ‰∫∫Ëæì„ÄÇÂÆöÁêÜÂØπ terminal position ÊàêÁ´ã„ÄÇ ÂºïÁêÜ1 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\)ÔºåÂàôÂÆÉÂøÖÂÆöÂèØ‰ª•ËΩ¨ÁßªÂà∞‰∏Ä‰∏™Áü≥Â≠ê‰∏™Êï∞‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\)„ÄÇ ËÆæ \(s\) ÊúÄÈ´òÁöÑ‰∫åËøõÂà∂‰ΩçÊòØÁ¨¨ \(k\) ‰ΩçÔºà‰ªé‰ΩéÂà∞È´òÔºåÊúÄ‰Ωé‰Ωç‰∏∫Á¨¨ \(0\) ‰ΩçÔºâ„ÄÇ ‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÂ†ÜÁü≥Â≠ê‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∫åËøõÂà∂‰∏ã \(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)„ÄÇ Èô§‰∫ÜËøôÂ†ÜÁü≥Â≠êÂ§ñÔºåÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\oplus x\)„ÄÇ \(s\oplus x\) Âíå \(x\) Âú®ÊâÄÊúâÊØîÁ¨¨ \(k\) ‰ΩçÈ´òÁöÑ‰∫åËøõÂà∂‰Ωç‰∏äÁõ∏Á≠âÔºå\(s\oplus x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(0\)Ôºå\(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)ÔºåÊâÄ‰ª• \(s \oplus x &lt; x\)„ÄÇ ÂèØ‰ª•‰ªéËøôÂ†ÜÁü≥Â≠ê‰∏≠ÂèñËµ∞ \(x-s\oplus x\) ‰∏™Áü≥Â≠êÔºå‰ΩøÂºÇÊàñÂíåÂèò‰∏∫ \(0\)„ÄÇ ÂºïÁêÜ2 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÈÉΩ‰ºöËΩ¨ÁßªÂà∞‰∏Ä‰∏™ÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊìç‰ΩúÁöÑÂ†ÜÂú®Êìç‰ΩúÂâçÊúâ \(x\) È¢óÁü≥Â≠ê„ÄÇ ÈÇ£‰πàÈô§‰∫ÜËøôÂ†Ü‰ª•Â§ñÁöÑÂÖ∂‰ªñÂ†ÜÁü≥Â≠êÊï∞ÂºÇÊàñÂíå‰πü‰∏∫ \(x\)„ÄÇ Âú®ÂèñÁü≥Â≠êÂêéÔºåËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏ÄÂÆö‰∏ç‰∏∫ \(x\)„ÄÇ Âè™ÊúâËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏∫ \(x\) Êó∂Ôºå‰∏éÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíåÊâç‰ºö‰∏∫ \(0\)„ÄÇ ÊâÄ‰ª•Êìç‰ΩúÂêéÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏ÄÂÆöÈùû \(0\)„ÄÇ Ê†πÊçÆÁªìÊûÑÂΩíÁ∫≥Ê≥ïÂèØÁü•ÂÆöÁêÜÊàêÁ´ã„ÄÇ Sprague‚ÄìGrundy ÂÆöÁêÜ wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Sprague‚ÄìGrundy_theorem ÂÆö‰πâ \(mex\) ËøêÁÆóÔºå‰∏Ä‰∏™ÈõÜÂêàÁöÑ \(mex\) ÂÄºÊòØÊúÄÂ∞èÁöÑÊ≤°ÊúâÂá∫Áé∞Âú®Ëøô‰∏™ÈõÜÂêà‰∏≠ÁöÑËá™ÁÑ∂Êï∞„ÄÇ ÂÆö‰πâ Sprague-Grundy ÂáΩÊï∞ÔºöÂØπ‰∫é‰∏Ä‰∏™Áä∂ÊÄÅ \(x\)ÔºåÂΩì \(x\) ÊòØ terminal position Êó∂Ôºå\(SG(x)=mex\{SG(y)|x\) ÂèØ‰ª•ËΩ¨ÁßªÂà∞ \(y\}\)„ÄÇ ÂèØ‰ª•Áî® Sprague-Grundy ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏™Áä∂ÊÄÅÊòØÂøÖËÉúÁä∂ÊÄÅËøòÊòØÂøÖË¥•Áä∂ÊÄÅÔºåÂõ†‰∏∫ÂøÖËÉúÁä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏ç‰∏∫ \(0\)ÔºåÂøÖË¥•Áä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏∫ \(0\)„ÄÇ ÂÆö‰πâ‰∏§‰∏™Ê∏∏ÊàèÁöÑ disjunctive sum ‰∏∫‰∏Ä‰∏™Ê∏∏ÊàèÔºöËΩÆÂà∞ÊØè‰∏™Áé©ÂÆ∂ÁöÑÊó∂ÂÄôÔºå‰ªñÂèØ‰ª•ÈÄâÊã©‰∏§‰∏™Ê∏∏Êàè‰∏≠ÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Ê∏∏Êàè‰∏äÊìç‰Ωú‰∏ÄÊ≠•ÔºåÊó†Ê≥ïÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÊòæÁÑ∂ disjunctive sum Êª°Ë∂≥‰∫§Êç¢ÂæãÂíåÁªìÂêàÂæã„ÄÇ ÂÆöÁêÜ Êúâ \(n\) ‰∏™Ê∏∏Êàè \(G_1,G_2,\cdots,G_n\)ÔºåËÆæ‰ªñ‰ª¨ÁöÑ disjunctive sum ‰∏∫ \(G\)„ÄÇÈÇ£‰πà \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)„ÄÇ ËØÅÊòéÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ Ëøô‰πüËØ¥Êòé‰∫ÜÊØè‰∏Ä‰∏™ normal play convention ‰∏ãÁöÑ impartial game ÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰∏™NimÊ∏∏Êàè„ÄÇ]]></content>
      <tags>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
