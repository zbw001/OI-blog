<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[CF1349D] Slime and Biscuits]]></title>
    <url>%2F2020%2F05%2F13%2FCF1349D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(\sum a_i = s\)„ÄÇ ÊòæÁÑ∂Âú®‰ªª‰Ωï‰∏Ä‰∏™Êó∂ÂàªÂè™ÊúâËá≥Â§ö‰∏Ä‰∏™‰∫∫Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤„ÄÇ ËÆæ‰ªé‰∏Ä‰∏™Â≠òÂú®‰∏Ä‰∏™‰∫∫Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÁä∂ÊÄÅÂºÄÂßãÔºåÂÅáËÆæÊ∏∏Êàè‰∏ç‰ºöÁªìÊùüÔºå\(k\) Ê≠•‰πãÂêéÂ≠òÂú®‰∏Ä‰∏™Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑ‰∫∫Ôºå‰∏îËøôÊòØËøô‰∏™‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéá‰∏∫ \(q_k\) (\(q_0=1\))ÔºåËÆæ \(Q(x) = \sum_{k \ge 0} q_k x^k\)„ÄÇ ËÆæÁ¨¨ \(k\) Ê≠•Êó∂Á¨¨‰∏ÄÊ¨°Âá∫Áé∞‰∏Ä‰∏™Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑ‰∫∫ÁöÑÊ¶ÇÁéá‰∏∫ \(f_k\) (Âç≥Ê∏∏Êàè \(k\) Ê≠•ÁªìÊùüÁöÑÊ¶ÇÁéá)ÔºåËÆæ \(F(x) = \sum_{k\ge 0} f_kx^k\)„ÄÇ ËÆæ \(p_{i,k}\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™‰∫∫ \(k\) Ê≠•ÂêéÁ¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéáÔºåËÆæ \(P_i(x) = \sum_{k \ge 0} p_{i,k}x^k\)„ÄÇ ÈÇ£‰πà \(F(x) Q(x) = \sum P_i(x)\)ÔºåÊâÄ‰ª• \(F(x) = \frac{\sum P_i(x)}{Q(x)}\)„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \(F&#39;(1)\)„ÄÇÁî±ÂàÜÂºèÊ±ÇÂØºÂÖ¨ÂºèÈóÆÈ¢òË¢´ËΩ¨Âåñ‰∏∫Ê±Ç \(P_i(1), P&#39;_i(1), Q(1), Q&#39;(1)\)„ÄÇ ÊòæÁÑ∂ \(P_i(1) = 1, Q(1) = n\)ÔºåËÄÉËôë \(P&#39;_i(x), Q&#39;(x)\) ÁöÑÂÆûÈôÖÊÑè‰πâÔºåÈóÆÈ¢òÂèòÊàêÊ±Ç‰∏Ä‰∏™ÂàùÂßãÊúâ \(x\) ‰∏™È•ºÂπ≤ÁöÑ‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåËøôËøô‰∏™ÂÄº‰∏∫ \(x_i\)ÔºåÈÇ£‰πàÊúâ \[ x_s = 0\\ x_i = 1 + \frac 1 {n(n-1)}[(n-i)(n-2)x_i + i(n-1)x_{i-1}+(n-i)x_{i+1}]\\ P&#39;_i(1) = x_{a_i}, Q&#39;(1) = (n-1) x_0 \] Ëß£ÊñπÁ®ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n + \sum a_i)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;const int maxn = 300010;int n, a[maxn], x[maxn], k[maxn], b[maxn], s;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; y &gt;&gt;= 1; x = 1LL * x * x % mod; &#125; return ret;&#125;int inv(ll x) &#123; return qpow(x % mod, mod - 2);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; &#125; k[0] = 1; for (int i = 0; i &lt; s; i++) &#123; int k1 = 1LL * (mod + 1 - 1LL * (s-i) * inv(s) % mod * (n-2) % mod * inv(n-1) % mod) % mod * inv(1LL * (s-i) * inv(s) % mod * inv(n-1) % mod) % mod; int k2 = 1LL * (mod-i) * (n-1) % mod * inv(s - i) % mod; int _b = 1LL * (n-1) * (mod - s) % mod * inv(s - i) % mod; k[i+1] = (k[i+1] + 1LL * k1 * k[i] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k1 * b[i] % mod) % mod; if (i &gt; 0) &#123; k[i+1] = (k[i+1] + 1LL * k2 * k[i-1] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k2 * b[i-1] % mod) % mod; &#125; b[i+1] = (b[i+1] + _b) % mod; &#125; int t = 0; x[0] = 1LL * (mod - b[s]) * qpow(k[s], mod - 2) % mod; for (int i = 1; i &lt;= s; i++) &#123; x[i] = (1LL * k[i] * x[0] + b[i]) % mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; t = (t + x[a[i]]) % mod; &#125; int ans = 1LL * (t - 1LL * (n-1) * x[0] % mod + mod) % mod * inv(n) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏ÄÁ±ªÂå∫Èó¥Âä†Âå∫Èó¥ËØ¢ÈóÆÈóÆÈ¢òÁöÑÈÄöÁî®Â§ÑÁêÜÊñπÊ≥ï]]></title>
    <url>%2F2020%2F05%2F13%2F%E4%B8%80%E7%B1%BB%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4%E8%AF%A2%E9%97%AE%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êï¥ÁêÜ‰∏Ä‰∏ãËøô‰∏ÄÁ±ªÈóÆÈ¢òÁöÑÁêÜËß£ÊñπÂºè..‰ª•‰æø‰ª•ÂêéÊõ¥ÂÆπÊòìÊÉ≥Ê∏ÖÊ•öËøôÁ±ªÈóÆÈ¢ò„ÄÇ ‰Ω†Ë¶ÅÁª¥Êä§‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a\)ÔºåËøô‰∏™Êï∞ÁªÑÊúâ‰∏Ä‰∏™ÂàùÂßãÂÄº„ÄÇÊúâ‰∏§‰∏™‰∫åÁª¥Êï∞ÁªÑ \(p[c][n]\) Âíå \(q[d][n]\)„ÄÇ ‰Ω†Ë¶ÅÊîØÊåÅ‰∏§ÁßçÊìç‰Ωú 1. ÁªôÂÆö \(l, r, k, x\)Ôºå\(1 \le k \le c\)ÔºåÂØπÊØè‰∏™ \(l \le i \le r\)ÔºåÊää \(a[i]\) ÊîπÊàê \(a[i] + x\cdot p[k][i]\) 2. ÁªôÂÆö \(l, r, k\)Ôºå\(1 \le k \le d\)ÔºåÊ±Ç \(\sum_{i=l}^r q[k][i]\cdot a[i]\) Ëøô‰∏™ÂΩ¢ÂºèÁöÑÈóÆÈ¢òÂú®‰∏Ä‰∏ãÊØîËæÉÂ§çÊùÇÁöÑÊ†ë‰∏äÈóÆÈ¢òÁöÑÁª¥Êä§‰∏≠ÂæàÂ∏∏ËßÅ„ÄÇÂ§ßÈÉ®ÂàÜËøôÊ†∑ÁöÑÈóÆÈ¢ò‰∏≠ÈÉΩÊúâ \(c = 1\) Êàñ \(d = 1\)„ÄÇ Êàë‰ª¨ÂÖàÊù•ÂÆö‰πâ‰∏ÄÊ£µÁª¥Êä§‰∏Ä‰∏™ \(a\) Êï∞ÁªÑÔºåÊîØÊåÅÂΩ¢Â¶Ç \(l,r,x\)ÔºåÊääÊâÄÊúâ \(l \le i\le r\) ÁöÑ \(a[i]\) ÊîπÊàê \(a[i] + x \cdot k[i]\) (\(k\) ÊòØ‰∏Ä‰∏™È¢ÑÂÖàÁ°ÆÂÆöÁöÑÊï∞ÁªÑ) ÁöÑÊìç‰ΩúÁöÑÁ∫øÊÆµÊ†ë„ÄÇÂè™Ë¶ÅËÆ∞ÂΩï‰∏Ä‰∏ãÊØè‰∏™Á∫øÊÆµÊ†ë‰∏äÁÇπÂØπÂ∫îÂå∫Èó¥ÂÜÖ \(k\) ÁöÑÂíåÂ∞±ÂæàÂÆπÊòìÊâìÊâì tag ÂÆûÁé∞ÔºåË∑ëËµ∑Êù•ÊïàÁéáÂíåÊôÆÈÄöÁ∫øÊÆµÊ†ëÊ≤°Êúâ‰ªÄ‰πàÂå∫Âà´„ÄÇÊàë‰∏ÄËà¨ÊòØËøôÊ†∑ÂÆûÁé∞ÁöÑÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct segTree &#123; ll k[maxn], iv[maxn], sk[maxn &lt;&lt; 2], sum[maxn &lt;&lt; 2], add[maxn &lt;&lt; 2]; void build(int l, int r, int rt) &#123; if (l == r) &#123; sk[rt] = k[l]; sum[rt] = iv[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); sk[rt] = sk[rt&lt;&lt;1] + sk[rt&lt;&lt;1|1]; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void modify(int rt, ll v) &#123; add[rt] += v; sum[rt] += sk[rt] * v; &#125; void pushDown(int rt) &#123; if (add[rt]) &#123; modify(rt&lt;&lt;1, add[rt]); modify(rt&lt;&lt;1|1, add[rt]); add[rt] = 0; &#125; &#125; void upd(int p, ll v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] += sk[rt] * v; return; &#125; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) &#123; upd(p, v, l, m, rt&lt;&lt;1); &#125; else &#123; upd(p, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void upd(int L, int R, ll v, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify(rt, v); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) &#123; upd(L, R, v, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; upd(L, R, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; ll qry(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; ll ret = 0; if (L &lt;= m) &#123; ret += qry(L, R, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; ret += qry(L, R, m+1, r, rt&lt;&lt;1|1); &#125; return ret; &#125;&#125;; ÂÖ∂‰∏≠ \(iv\) Êï∞ÁªÑÊòØ \(a\) ÁöÑÂàùÂßãÂÄº„ÄÇ ‰∏ãÈù¢ÁªôÂá∫‰∏Ä‰∏™ÈúÄË¶ÅÂºÄ \(c\cdot d\) Ê£µÁ∫øÊÆµÊ†ëÁöÑÂÆûÁé∞ÔºöÂØπÊØè‰∏™ \(1 \le x \le c, 1\le y \le d\)ÔºåÂºÄ‰∏ÄÊ£µÁ∫øÊÆµÊ†ë \((x,y)\)ÔºåÁª¥Êä§ÁöÑÊï∞ÁªÑÂç≥‰πãÂâçÂÆö‰πâÁöÑ \(a\) Êï∞ÁªÑÔºå\(k[i] = p[x][i]\cdot q[y][i]\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™ËØ¢ÈóÆ \(l,r,y\)ÔºåÊàë‰ª¨Â∞±ÂØπÊØè‰∏™ \(x\)ÔºåÂú®Á∫øÊÆµÊ†ë \((x,y)\) ‰∏äËØ¢ÈóÆÂå∫Èó¥ \(l,r\)ÔºåÊääÂæóÂà∞ÁöÑÁªìÊûúÂä†Ëµ∑Êù•„ÄÇËøôÊ†∑Âú®Â§ÑÁêÜ‰∏Ä‰∏™‰øÆÊîπ \(l,r,x,a\) ÁöÑÊó∂ÂÄôÔºåÂè™Ë¶ÅÂØπÊØè‰∏™ \(1 \le y \le d\) ÈÉΩÂú®Á∫øÊÆµÊ†ë \((x,y)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>ËÉ°Ë®Ä‰π±ËØ≠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2504] „Äå2018 ÈõÜËÆ≠Èòü‰∫íÊµã Day 5„ÄçÂ∞è H Áà±ÊüìËâ≤]]></title>
    <url>%2F2020%2F05%2F12%2Floj2504%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÁºñÂè∑ÊúÄÂ∞èÈªëÁêÉÁºñÂè∑‰∏∫ \(k\) ÁöÑÊñπÊ°àÊúâ \(\binom{n-k+1}m^2 - \binom {n-k}m^2\) Áßç„ÄÇ Á≠îÊ°à‰∏∫ \[ \sum_{k \ge 1} (\binom{n-k+1}m^2 - \binom {n-k}m^2) F(k) \] Ê≥®ÊÑèÂà∞ \((\binom{n-k+1}m^2 - \binom {n-k}m^2) F(k)\) ÊòØ‰∏Ä‰∏™ÂÖ≥‰∫é \(k\) ÁöÑ \(3m\) Ê¨°Â§öÈ°πÂºèÔºåÊàë‰ª¨Ë¶ÅÊ±ÇËøô‰∏™Â§öÈ°πÂºèÁöÑ‰∏Ä‰∏™ÂâçÁºÄÂíåÔºåËøô‰∏™Â§öÈ°πÂºèÁöÑÂâçÁºÄÂíåÊòØ‰∏Ä‰∏™ \(3m+1\) Ê¨°Â§öÈ°πÂºèÔºåËÆæÂÆÉ‰∏∫ \(G(k)\)„ÄÇÂ¶ÇÊûúÊàë‰ª¨Áü•ÈÅì \(F(0) \ldots F(3m+1)\) Â∞±ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞ÂæóÂà∞ \(G(0) \ldots G(3m+1)\)ÔºåÁÑ∂ÂêéÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂæóÂà∞ \(G(n)\)„ÄÇ ‰ΩÜÊòØÊàë‰ª¨Âè™Áü•ÈÅì \(F(0) \ldots F(m)\)„ÄÇËÄÉËôëÂ¶Ç‰ΩïËÆ°ÁÆó \(F(m+1) \ldots F(3m+1)\)„ÄÇ \[ F(x) = \sum_{i=0}^m F(i) \prod_{j \neq i, 0 \le j\le m} \frac{x-j}{i-j} \\\\ \text{ÂØπ‰∫é $m &lt; x \le 3m+1$} \\\\ F(x) = \sum_{i=0}^m F(i) \frac {(-1)^{m-i}x^{\underline{m+1}}} {(x-i)i!(m-i)!}=x^{\underline{m+1}} \sum_{i=0}^m \frac{(-1)^{m-i}}{i!(m-i)!} \frac 1 {x-i} \] ËøôÂèØ‰ª•Áî® NTT ‰ºòÂåñÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(m \log m)\)„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6363] „ÄåÂú∞Â∫ïËî∑Ëñá„Äç]]></title>
    <url>%2F2020%2F05%2F11%2Floj6363%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(A(x) = \sum_k a_k\frac{x^k}{k!}\)ÔºåÁÇπÂèåËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(B(x) = \sum_{k} b_k \frac{x^k}{k!}\) (Âùá‰∏çÂê´Á©∫ÂõæÔºå‰∏Ä‰∏™ÁÇπ‰∏çÁÆóÁÇπÂèåËøûÈÄöÂõæ) Âàô \[ A(x) = x\sum_{k \ge 0} \frac{(\sum_{s \ge 2} A(x)^{s-1}\frac {b_s} {(s-1)!})^k}{k!} = x \exp(B&#39;(A(x))) \\\\ B&#39;(A(x)) = \ln(\frac {A(x)} x) \] Áî®ÊãâÊ†ºÊúóÊó•ÂèçÊºîÊ±Ç \([x^n]B(x)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)Ôºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ \(i \in S\) ‰ª• \(\mathcal O(i \log i)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ËÆ°ÁÆó \([x^i]B(i)\)ÔºåÁÑ∂Âêé‰ªÖ‰øùÁïôËøô‰∫õÈ°πÂæóÂà∞‰∏Ä‰∏™È¢òÁõÆÂÖÅËÆ∏ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁîüÊàêÂáΩÊï∞ \(C(x)\)„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÂ§ßÂ∞èÈÉΩÂú® \(S\) ÂÜÖÁöÑÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ \(D(x)\) (‰∏ãÈù¢Áî® \(D(x)^{-1}\) Ë°®Á§∫ \(D(x)\) ÁöÑÂ§çÂêàÈÄÜ) : \[ C&#39;(D(x)) = \ln(\frac {D(x)} x) \\\\ C&#39;(x) = \ln (\frac {x}{D(x)^{-1}}) \\\\ D(x)^{-1} = \frac x {\exp C&#39;(x)} \] ÊâÄ‰ª• \(D(x)\) ÊòØ \(\frac x {\exp C&#39;(x)}\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O((n + \sum_{x \in S} x) \log n)\) ‰∏•ÈáçÂç°Â∏∏„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wn[100];int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpow(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;int w[maxn * 8];unsigned long long _a[maxn * 8];void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) _a[rev[i]] = a[i]; int _ = 0; for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int _wn = wn[++ _]; w[0] = 1; for (int i = 1; i &lt; len; i++) &#123; w[i] = 1LL * w[i-1] * _wn % mod; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; unsigned long long v1 = _a[i+j], v2 = _a[i+j+(len&gt;&gt;1)]*w[j]%mod; _a[i+j] = v1 + v2; _a[i+j+(len &gt;&gt; 1)] = v1 + mod - v2; &#125; &#125; if (len == (1 &lt;&lt; 15)) &#123; for (int j = 0; j &lt; (1&lt;&lt;l); j++) &#123; _a[j] = _a[j] % mod; &#125; &#125; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i++) &#123; a[i] = _a[i] % mod; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;poly A, lnA, dlnA;int ok[maxn], fac[maxn], ifac[maxn];void init(int n) &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly tmp(n + 2); for (int i = 0; i &lt;= n + 1; i++) &#123; tmp.a[i] = 1LL * ifac[i] * qpow(2, 1LL * i * (i - 1) / 2) % mod; &#125; poly lnt = polyLn(tmp); A = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; A.a[i] = 1LL * (i + 1) * lnt.a[i + 1] % mod; &#125; lnA = polyLn(A); dlnA = poly(n); for (int i = 0; i &lt; n; i++) &#123; dlnA.a[i] = 1LL * (i + 1) * lnA.a[i + 1] % mod; &#125;&#125;int cal(int n) &#123; poly nA(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nA.a[i] = 1LL * lnA.a[i] * (mod - n) % mod; &#125; poly T = polyExp(nA) * dlnA; return 1LL * qpow(n, mod-2) % mod * T.a[n - 1] % mod;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); ok[x] = 1; &#125; for (int i = 0; i &lt;= 20; i++) wn[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); init(n); poly dC(n + 1); for (int i = 0; i &lt;= n; i++) &#123; if (ok[i + 1]) &#123; dC.a[i] = cal(i); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; dC.a[i] = 1LL * dC.a[i] * n % mod; &#125; poly t = polyExp(dC); int ans = 1LL * t.a[n - 1] * fac[n - 1] % mod * qpow(n, mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÁõ∏ÂÖ≥ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F11%2FLagrange%2F</url>
    <content type="text"><![CDATA[ÊäÄÂ∑ß ÊèèËø∞ÊñπÂºè Â∞ΩÈáè‰ΩøÁî®Â§çÂêàÈÄÜÁöÑÊ¶ÇÂøµÊù•ÊèèËø∞ÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºåËøôÊ†∑ÂèØ‰ª•ÁúÅÂéªÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ ÂÆö‰πâËÆ∞Âè∑ \(F(x)^{-1}\) Ë°®Á§∫ \(F(x)\) ÁöÑÂ§çÂêàÈÄÜ (Ê≥®ÊÑè‰∏çË¶Å‰∏éÂÄíÊï∞Ê∑∑Ê∑Ü)Ôºå‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÊãâÊ†ºÊúóÊó•ÂèçÊºîÂÖ¨ÂºèÂèØ‰ª•Ë°®Á§∫‰∏∫ \[ [x^n]F(x)^{-1} = \frac 1 n[x^{-1}] \frac 1 {F^n(x)} \\\\ [x^n]G(F(x)^{-1}) = \frac 1 n [x^{-1}] \frac{G&#39;(x)}{F^n(x)} \] ÈÄöËøá‰∏éÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÂá†‰πéÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑËØÅÊòéÊñπÊ≥ïÂèØ‰ª•ËØÅÊòéÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÁöÑ‰∏Ä‰∏™Êâ©Â±ïÔºöËã• \(F(G(x)) = H(x)\)ÔºåÂàô \([x^n]F(x) = \frac 1 n [x^{-1}] \frac{H&#39;(x)}{G^n(x)}\)„ÄÇÁ¨¨‰∫å‰∏™ÂºèÂ≠ê‰∏éËøô‰∏ÄÁªìËÆ∫ÊòØÁ≠â‰ª∑ÁöÑÔºå‰ΩÜÊòØÂª∫ËÆÆÂ∞ΩÂèØËÉΩ‰ΩøÁî®Á¨¨‰∫å‰∏™ÂºèÂ≠êËÄå‰∏çË¶Å‰ΩøÁî®Ëøô‰∏™ÁªìËÆ∫„ÄÇ Êé®ÂØºÊäÄÂ∑ß Èô§‰∫ÜÁßªÈ°πÁ≠âÂèòÂΩ¢‰πãÂ§ñÔºåËøòÂèØ‰ª•Âà©Áî®Â§çÂêàËøõË°åÂåñÁÆÄ„ÄÇÁî®Â§çÂêàÂåñÁÆÄÊó∂Ê≥®ÊÑèË¶ÅÁÅµÊ¥ª‰ΩøÁî®Â∑¶Âè≥ÈÄÜÔºåÂç≥ÁÅµÊ¥ª‰ΩøÁî® \(A(x) = B(x) \Rightarrow F(A(x))= F(B(x))\) Âíå \(A(x) = B(x) \Rightarrow A(F(x)) = B(F(x))\)ÔºåÈÅøÂÖç‰∏ÄÁõ¥Âè™ÊÉ≥Âà∞ÂÖ∂‰∏≠‰∏ÄÁßçÁöÑÊÉÖÂÜµ„ÄÇ ÂØπ‰∫é \(F(G(x)) = H(x)\)ÔºåÁü• \(H(x), F(x)\) Ê±Ç \([x^n] G(x)\) ÁöÑÊÉÖÂÜµÔºåÁõÆÂâçÊöÇ‰∏çÁü•Êúâ‰ªÄ‰πàÂ•ΩÁöÑÂÅöÊ≥ïÔºå‰ΩÜÊòØÂØπ‰∫é‰∏Ä‰∫õ \(H(x)\) ‰∏é \(G(x)\) ÊúâËæÉ‰∏∫ÁÆÄÂçïÁöÑÂÖ≥Á≥ªÁöÑÈóÆÈ¢òÊòØÂèØÂÅöÁöÑ„ÄÇ ‰æãÂ¶Ç \(F(G(x)) = xG(x) \Rightarrow F(G(G(x)^{-1})) = G^{-1}(x)G(G(x)^{-1}) \Rightarrow F(x) = x G(x)^{-1}\)ÔºåÂç≥ \(G\) ÊòØ \(\frac {F(x)} x\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5827] ÁÇπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F11%2FLuogu5827%2F</url>
    <content type="text"><![CDATA[ÂàöÂºÄÂßã‰ª•‰∏∫ÂíåËæπÂèåÊ≤°Âï•Â∑ÆÂà´..ÁªìÊûúÂêéÊù•Êêû‰∫ÜÂ•Ω‰πÖ„ÄÇ UPDÔºöÂ•ΩÂÉèÂ≠òÂú®Êõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ï„ÄÇ ÂÅöÊ≥ï ËÆæ \(n\) ‰∏™ÁÇπÁöÑÁÇπÂèåËøûÈÄöÂõæÊúâ \(f_n\) ‰∏™ÔºåËøûÈÄöÂõæÊúâ \(g_n\) ‰∏™ÔºåÂÆÉ‰ª¨ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÈí¶ÂÆöÊ†π) Êàë‰ª¨ËÆ§‰∏∫‰∏Ä‰∏™ÁÇπÁöÑÂõæ‰∏çÁÇπÂèåËøûÈÄöÔºå‰∏îËøô‰∏Ä‰∏™ÁÇπ‰∏∫Ââ≤ÁÇπ„ÄÇÁî±‰∫éÈ¢òÁõÆÈáå‰∏Ä‰∏™ÁÇπÊòØÁÆóÁÇπÂèåËøûÈÄöÂõæÁöÑÔºåË¶ÅÁâπÂà§‰∏ã„ÄÇ ËÆæ \(n\) ‰∏™ÁÇπÁöÑÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæ‰∏™Êï∞‰∏∫ \(b_n\)ÔºåÂÖ∂ EGF ‰∏∫ \(B(x)\)„ÄÇÊ†πÊçÆÂâ≤ÁÇπÁöÑÂÆö‰πâÔºåÂéªÊéâÊ†π‰πãÂêéÁöÑÁÇπÊûÑÊàê‰∏Ä‰∏™ËøûÈÄöÂõæÔºåÊâÄ‰ª• \(b_n = \frac n {n!}(2^{n-1}-1)(n-1)!g_{n-1}=(2^{n-1}-1)g_{n-1}\ (n \ge 2)\)„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåÂåÖÂê´‰∏çÊòØÂâ≤ÁÇπÁöÑÁÇπÁöÑÁÇπÂèåÊòØÂîØ‰∏ÄÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Êûö‰∏æÂåÖÂê´Ê†πÁöÑÁÇπÂèåÁöÑÂ§ßÂ∞èÊù•ËÆ°ÁÆó \(B(x)\)„ÄÇËÆæ \(H(x) = G&#39;(x)\) (ÂØπ EGF Ê±ÇÂØºÁõ∏ÂΩì‰∫éÂπ≥Áßª‰∫Ü)ÔºåÂåÖÂê´Ê†πÁöÑÁÇπÂèåÂ§ßÂ∞è‰∏∫ \(n\) ‰∏îÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(n\frac{f_n}{n!}x^n H^{n-1}(x)\) (ËÄÉËôëÂÜ≥ÂÆöÊ†πÔºåÁÑ∂ÂêéÂÜ≥ÂÆöËøô‰∏™ÁÇπÂèå‰∏≠Èô§‰∫ÜÊ†π‰ª•Â§ñÊØè‰∏™ÁÇπÊåÇÁöÑËøûÈÄöÂõæ)„ÄÇ ËÆæ \(C(x) = \frac{B(x)}x\)ÔºåÂàô \[ B(x) = \sum_{n \ge 1} n\frac{f_n}{n!} x^n H^{n-1}(x) = xF&#39;(xH(x)) \\\\ xC(x) = xF&#39;(xH(x)) \\\\ C(x) = F&#39;(xH(x)) \] ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \[ [x^n] F(x) = \frac 1 n[x^{n-1}] F&#39;(x)=\frac 1 {n(n-1)}[x^{-1}]\frac{C&#39;(x)}{(xH(x))^{n-1}} \] ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; const int N = 100000; poly tmp(N + 1); for (int i = 0; i &lt;= N; i++) &#123; tmp.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnT = polyLn(tmp); poly G(N + 1); for (int i = 1; i &lt;= N; i++) &#123; // G.a[i] = 1LL * lnT.a[i] * i % mod; G.a[i] = lnT.a[i]; &#125; poly H(N); for (int i = 0; i &lt; N; i++) &#123; H.a[i] = 1LL * (i + 1) * G.a[i+1] % mod; &#125; poly B(N+1); int _ = 1; for (int i = 1; i &lt;= N; i++) &#123; B.a[i] = 1LL * (_ - 1) * G.a[i-1] % mod; _ = 1LL * _ * 2 % mod; &#125; poly C(N); for (int i = 0; i &lt; N; i++) &#123; C.a[i] = B.a[i+1]; &#125; poly lnH = polyLn(H); poly dC(N-1); for (int i = 0; i &lt; N-1; i++) &#123; dC.a[i] = 1LL * C.a[i+1] * (i+1) % mod; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); if (n == 1) &#123; puts("1"); continue; &#125; poly nH = poly(n); for (int i = 0; i &lt; n; i++) &#123; nH.a[i] = 1LL * lnH.a[i] * (mod - (n - 1)) % mod; &#125; poly res = polyExp(nH) * dC; int ans = 1LL * res.a[n - 2] * qpow(n - 1, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5828] ËæπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F10%2FLuogu5828%2F</url>
    <content type="text"><![CDATA[‰πãÂâçËØïÂõæÈÄöËøáÁî®Ê†ëÁöÑÁîüÊàêÂáΩÊï∞Â§çÂêàËæπÂèåÁöÑÁîüÊàêÂáΩÊï∞Êù•ÂæóÂà∞Á≠îÊ°à...‰ΩÜÊòØÈóÆÈ¢ò‰ºº‰πéÁ≠â‰ª∑‰∫éÂ∑≤Áü• \(F(x), H(x)\)Ôºå\(F(G(x)) = H(x)\)ÔºåÊ±Ç \([x^n] G(x)\)„ÄÇÊàë‰∏çÊòØÂæà‰ºöÔºåÂ¶ÇÊûúÊúâ‰∫∫‰ºöÁöÑËØùÊ±ÇÊïôÊàë‰∏Ä‰∏ã /kel„ÄÇ ‰∏ãÈù¢ÂÜôÁöÑÊòØÈ¢òËß£ÂÅöÊ≥ï„ÄÇ UPDÔºöÊ†ëÁöÑÁîüÊàêÂáΩÊï∞ÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁúãÂÅö‰∏Ä‰∏™ÊãâÊ†ºÊúóÊó•ÂèçÊºîÁöÑÁªìÊûú..ÊâÄ‰ª•ÊÑüÊÄßÁêÜËß£‰∏Ä‰∏ãÂèØ‰ª•ÁªïËøá‰∏äÈù¢ÈÇ£‰∏™ÂºèÂ≠êÊòØ‰∏Ä‰∏™ÂæàËá™ÁÑ∂ÁöÑ‰∏úË•ø„ÄÇ(Á∫ØÂ±ûËÉ°Ë®Ä‰π±ËØ≠) ÂÅöÊ≥ï ËÆæÊúâÊ†πËæπÂèåÂíåÊúâÊ†πËøûÈÄöÂõæ (ÊúâÊ†πÂ∞±ÊòØÈí¶ÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπ‰ΩúÊ†π) ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÂåÖÂê´Á©∫Âõæ) ‰ºóÊâÄÂë®Áü•ÔºåËÆæÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(H(x)\)ÔºåÂàôËøûÈÄöÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(\ln H(x)\)ÔºåÊâÄ‰ª• \(G(x) = \frac {xH&#39;(x)} {H(x)}\) (‰∏çÁî®ÁúüÁöÑÊåâÁÖßËøô‰∏™ÂºèÂ≠êÂéªÁÆóÔºåÂ∞±ÊòØÁ¨¨ \(i\) È°π‰πò‰ª• \(i\) ÁöÑÊÑèÊÄù)„ÄÇ ËÄÉËôëÊ†πÊâÄÂú®ÁöÑËæπÂèåÊÅ∞Â•Ω‰∏∫ \(n\) ÁöÑËøûÈÄöÂõæÊï∞ÔºåËøôÊ†∑ÁöÑËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ÊòØ \(x^n f_n \sum_k n^k \frac{G^k(x)}{k!}=x^nf_n\exp(nG(x))\)„ÄÇ ÊâÄ‰ª•Êúâ \(G(x) = \sum_{n \ge 1} f_n (x\exp G(x))^n=F(x\exp G(x))\)„ÄÇ ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \([x^n] F(x) = \frac 1 n[x^{-1}]\frac {G&#39;(x)}{(x\exp G(x))^n}\) ÊàëÈÄâÊã©Ë¥¥Êùø üíäüíäüíä ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; poly G, dG; &#123; int n = 100000; poly H(n + 1); for (int i = 0; i &lt;= n; i++) &#123; H.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnH = polyLn(H); G = poly(n + 1); for (int i = 1; i &lt;= n; i++) &#123; G.a[i] = 1LL * lnH.a[i] * i % mod; &#125; dG = poly(n); for (int i = 0; i &lt; n; i++) &#123; dG.a[i] = 1LL * G.a[i+1] * (i+1) % mod; &#125; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); poly nG = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nG.a[i] = 1LL * G.a[i] * (mod - n) % mod; &#125; poly res = polyExp(nG) * dG; int ans = 1LL * res.a[n-1] * qpow(n, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3684] Â§ßÊúãÂèãÂíåÂ§öÂèâÊ†ë]]></title>
    <url>%2F2020%2F05%2F10%2Fbzoj3684%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÁÇπÊùÉ‰∏∫ \(k\) ÁöÑÊ†ëÊúâ \(a_k\) Ê£µÔºåËÆæ \(A(x) = \sum_{i\ge 1} a_i x^i\) ËÆæ \(D(x) = \sum x^{d_i}\) Êúâ \(A(x) = D(A(x)) + x\)„ÄÇËÆæ \(C(x) = x - D(x)\)ÔºåÂàô \(C(A(x)) = x\) ÂÖ∂‰∏≠ \(C\) Âíå \(A\) ÈÉΩÊòØÊ≤°ÊúâÂ∏∏Êï∞È°π‰∏î‰∏ÄÊ¨°È°π‰∏∫ \(1\) ÁöÑÂ§öÈ°πÂºè„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \([x^s] A(x)\)Ôºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºö\([x^s] A(x) = \frac 1 s [x^{-1}] \frac 1 {C^s(x)}\) ËÆæ \(C(x) = xP(x)\)ÔºåÂàô \([x^s]A(x) = \frac 1 s [x^{s-1}] \frac 1 {P^s(x)}\) Ê±Ç‰∏™ÈÄÜÁÑ∂ÂêéÂ§öÈ°πÂºèÂø´ÈÄüÂπÇ‰∏Ä‰∏ãÂç≥ÂèØÔºå‰πüÂèØ‰ª•ÂÖà \(\ln\) ÂÜç \(\exp\)„ÄÇ BZOJ ‰∏äÂø´ÈÄüÂπÇ T ‰∫ÜÔºå‰ΩÜÊòØË¥¥‰∫Ü‰∏™ÊùøÂ≠êÊîπÊàê \(\ln\) + \(\exp\) Â∞±Ëøá‰∫ÜÔºåÁúã‰∫ÜÁ°ÆÂÆûÊòØÊØîÂø´ÈÄüÂπÇÂø´ÁöÑ„ÄÇ (BZOJ Á°ÆÂÆûÂ§™ÊÖ¢‰∫Ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 950009857;const int maxn = 100010;int g = 0;int s, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int wl[21];vector&lt;int&gt; vp;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int checkg(int g) &#123; int ok = 1; for (int i = 0; i &lt; vp.size(); i++) &#123; int p = vp[i]; if (qpow(g, (mod - 1) / p) == 1) &#123; ok = 0; &#125; &#125; return ok;&#125;struct poly &#123; int *a, len; poly (int len_=0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int _wl = wl[++ _]; for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = mo(v1 + v2); a[s + i + (len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL * w * _wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * inv * a[i] % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l - i]); &#125; &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int _l = 0; while ((1 &lt;&lt; _l) &lt; ret.len) &#123; ++ _l; &#125; int l = (1 &lt;&lt; _l); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, _l, 1), ntt(wb, _l, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, _l, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly qpow(poly p, int x) &#123; int l = p.len; poly ret(1); ret.a[0] = 1; while (x) &#123; if (x &amp; 1) &#123; ret = ret * p; ret.len = l; &#125; x &gt;&gt;= 1; p = p * p; p.len = l; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0 (tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; v0.a[0] = (v0.a[0] + mod - 2) % mod; for (int i = 0; i &lt; p.len; i++) &#123; v0.a[i] = (mod - v0.a[i]) % mod; &#125; v0.len = p.len; poly v1 = v0 * r0; v1.len = p.len; return v1;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;int main() &#123; &#123; int _ = mod - 1; for (int i = 2; i * i &lt;= _; i++) &#123; if (_ % i == 0) &#123; vp.push_back(i); while (_ % i == 0) &#123; _ /= i; &#125; &#125; &#125; if (_ &gt; 1) &#123; vp.push_back(_); &#125; for (int i = 2; i &lt;= mod; i++) &#123; if (checkg(i)) &#123; g = i; break; &#125; &#125; &#125; for (int i = 0; i &lt;= 20; i++) &#123; wl[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; scanf("%d%d", &amp;s, &amp;m); poly P(s); for (int i = 1; i &lt;= m; i++) &#123; int x = 0; scanf("%d", &amp;x); P.a[x - 1] = mod - 1; &#125; P.a[0] = 1; poly lnP = polyLn(P); int t = (mod - s) % mod; for (int i = 0; i &lt; lnP.len; i++) &#123; lnP.a[i] = 1LL * lnP.a[i] * t % mod; &#125; poly res = polyExp(lnP); int ans = 1LL * qpow(s, mod-2) * res.a[s-1] % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(C(x) = \sum x^{c_i}\)Ôºå\(a_i\) ÊòØÊùÉÂÄºÂíå‰∏∫ \(i\) ÁöÑ‰∫åÂèâÊ†ëÊï∞Èáè (ÁâπÂà´Âú∞ÔºåÁ©∫‰∫åÂèâÊ†ëÁÆó‰Ωú‰∏ÄÁßçÊùÉÂÄºÂíå‰∏∫ \(0\) ÁöÑ‰∫åÂèâÊ†ë)Ôºå\(A(x) = \sum_{i \ge 0} a_ix^i\)„ÄÇ Âàô \(A(x) = A^2(x)C(x)+ 1\)Ôºå\(C(x)A^2(x)-A(x)+1=0\)„ÄÇÁî±‰∏ÄÂÖÉ‰∫åÊ¨°ÊñπÁ®ãÊ±ÇÊ†πÂÖ¨ÂºèÂæó \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)ÔºåÁî±‰∫éÂàÜÊØçÊ≤°ÊúâÂ∏∏Êï∞È°πÔºåËøôÈáåÂ∫îËØ•ÂèñË¥üÂè∑„ÄÇ ‰∫éÊòØÂ§öÈ°πÂºèÂºÄÊ†π‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇ(Âõ†‰∏∫ \([x^0] (1-4C(x)) = 1\)ÔºåÂè™Â≠òÂú®‰∏§‰∏™ÁöÑÂ§öÈ°πÂºè \(F(x)\) Êª°Ë∂≥ \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)Ôºå‰∏ÄÊ≠£‰∏ÄË¥ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[Á•û‰ªôÈ¢òÔºå‰πãÂâçÂê¨‰∫∫ÊèêËøá„ÄÇ‰ΩÜÊòØÂá∏ÊÄßÂÆåÂÖ®‰∏ç‰ºöËØÅÔºå‰ºö‰∫Ü‰πãÂêéË°•‰∏ä QwQ„ÄÇ ÂÅöÊ≥ï ÊòæÁÑ∂‰Ωø \(\sum s_i^2\) ÂèñÂà∞ÊúÄÂ∞èÂÄºÁöÑÂàíÂàÜ‰∏ÄÂÆöÊª°Ë∂≥Êù°‰ª∂„ÄÇ ÊâÄ‰ª•‰∫åÂàÜÊñúÁéáÊ±ÇÂá∫ \(\sum s_i^2\) ÊúÄÂ∞èÁöÑÂ∫èÂàóÂ∞±Ë°å‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éÊàëÊ∞¥Âπ≥Â§™‰ΩéÊôÆÂèäÁªÑÁü•ËØÜÁÇπÈÉΩÊ≤°ÊéåÊè°Ôºå‰ªäÂ§©Áªà‰∫éÊêûÊáÇ‰∫Ü‰∏ÄÁÇπÊâÄ‰ª•ÊâìÁÆóËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢ËÆ®ËÆ∫ÁöÑÈÉΩÊòØÊó†ÂêëÂõæÔºåÁî±‰∫éËøûÈÄöÂùóÈó¥Áã¨Á´ãÔºåÊàë‰ª¨Âè™ËÄÉËôëËøûÈÄöÂõæÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûúÁÇπÊï∞‰∏∫ \(1\)ÔºåÂú®Êüê‰∫õÈóÆÈ¢ò‰∏ãÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Âè™ËÄÉËôëÁÇπÊï∞‰∏ç‰∏∫ \(1\) ÁöÑÊÉÖÂÜµ„ÄÇ ÂÆö‰πâ 1 ÂØπ‰∫é‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\)ÔºåÂ¶ÇÊûú‰ªé \(G\) Âà†ÂéªÁÇπ \(u\) ÂíåÊâÄÊúâ‰∏éÂÆÉÁõ∏ÈÇªÁöÑËæπÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄöÔºåÂ∞±Áß∞ \(u\) ÊòØ \(G\) ÁöÑ‰∏Ä‰∏™Ââ≤ÁÇπ„ÄÇ ÂÆö‰πâ 2 Ëã•ËøûÈÄöÂõæ \(G\) ‰∏≠‰∏çÂ≠òÂú®Ââ≤ÁÇπÔºåÂàôÁß∞ \(G\) ÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂõæ„ÄÇ ÂÆö‰πâ 3 Áß∞ËøûÈÄöÂõæ \(G\) ÁöÑÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂõæÂ≠êÂõæ‰∏∫ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇ ÊÄßË¥® 1 ‰∏§‰∏™‰∏çÂêåÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑ‰∫§Ëá≥Â§öÂåÖÂê´‰∏Ä‰∏™ÁÇπ„ÄÇ ËØÅÊòé ÂÅáËÆæ‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè \(A\) Âíå \(B\) Êúâ‰∫§ÔºåËÆæËøô‰∏§‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂπ∂‰∏∫ \(H\)ÔºåÊ†πÊçÆÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂÆö‰πâÔºå\(H\) ‰∏ÄÂÆö‰∏çÊòØÁÇπÂèåËøûÈÄöÂõæÔºåÊâÄ‰ª•Â≠òÂú®‰∏Ä‰∏™ÁÇπ \(u\)Ôºå‰ªé \(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂêéÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄö„ÄÇ\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæÂç≥‰∏∫ \(A\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) Âíå \(B\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) ÂæóÂà∞ÁöÑÂõæÁöÑÂπ∂„ÄÇÂ¶ÇÊûú \(A\) Âíå \(B\) ÁöÑ‰∫§Â§ß‰∫é \(1\)ÔºåÁî±‰∫é‰∏§‰∏™Êúâ‰∫§ÁöÑËøûÈÄöÂõæÁöÑÂπ∂‰ªç‰∏∫ËøûÈÄöÂõæÔºå\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæ‰πüÊòØËøûÈÄöÂõæÔºåËøôÂ∞±ÂØºÂá∫‰∫ÜÁüõÁõæ„ÄÇ ÊÄßË¥® 2 Âú®‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\) ‰∏≠ÔºåÂØπ‰∫é‰ªªÊÑè‰∏ÄÊù°Ëæπ \(e\)ÔºåÊÅ∞Êúâ‰∏Ä‰∏™ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÂåÖÂê´Ëæπ \(e\)„ÄÇ ËØÅÊòé Ëæπ \(e\) ÁöÑ‰∏§‰∏™È°∂ÁÇπÁöÑÂØºÂá∫Â≠êÂõæÂ∞±ÊòØ‰∏Ä‰∏™ \(G\) ÁöÑÂ§ßÂ∞è‰∏∫ \(2\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª•‰πü‰∏ÄÂÆöÂ≠òÂú®ÂåÖÂê´Ëæπ \(e\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÁî±ÊÄßË¥® 1 ÂèØÁü•‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏çÂèØËÉΩÂåÖÂê´Âêå‰∏ÄÊù°Ëæπ„ÄÇ Áî±‰∫éÁÇπÂèåËøûÈÄöÂàÜÈáèÊòØËøûÈÄöÁöÑÔºåÂè™Ë¶ÅÁ°ÆÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâËæπÔºåÁÇπ‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÂõæ \(G\) ÁöÑÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÊûÑÊàêËæπÈõÜÁöÑ‰∏Ä‰∏™ÂàíÂàÜ„ÄÇ Âú®Âõæ‰∏ä‰Ωú DFSÔºåÂèñ‰∏ÄÊ£µ‰ª• \(r\) ‰∏∫Ê†πÁöÑ DFS Ê†ëÔºåËÆæÁÇπ \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´ËÆøÈóÆÊó∂Èó¥‰∏∫ \(dfn_u\)Ôºå\(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÈÄöËøá‰∏ÄÊù°ËøîÁ•ñËæπËÉΩÂ§üÂà∞ËææÁöÑ dfn ÊúÄÂ∞èÁöÑÁÇπÁöÑ dfn ‰∏é \(dfn_u\) ÁöÑÊúÄÂ∞èÂÄº‰∏∫ \(low_u\) (Ê≥®ÊÑèËøîÁ•ñËæπÊåáÁöÑÊòØÈùûÊ†ëËæπÔºå‰∏çÂåÖÂê´ \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÔºåÂÆûÁé∞Êó∂Ë¶ÅÁâπÂà§)„ÄÇ ËÆæÁÇπ \(u\) Âú®ËøôÊ£µ DFS Ê†ë‰∏äÁöÑÁà∂‰∫≤‰∏∫ \(fa(u)\)„ÄÇ ÂØπ‰∫éÁÇπ \(u \neq r, fa(u) \neq r\)ÔºåÂ¶ÇÊûú \(low_u &lt; dfn_{fa(u)}\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ÁÇπ \(u, fa(u), fa(fa(u))\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºå‰ªéËÄå \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÂíå \(fa(u)\) Âà∞Áà∂‰∫≤ÁöÑËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ Âú® DFS ÁöÑËøáÁ®ã‰∏≠ÔºåÊØèÁªèËøá‰∏ÄÊù°Ê†ëËæπÂ∞±ÊääËøôÊù°Ê†ëËæπÊîæÂÖ•‰∏Ä‰∏™Ê†à‰∏≠„ÄÇÂú®ÁÇπ \(u\) ÂõûÊ∫ØÊó∂ÔºåÊ£ÄÊü•‰∏Ä‰∏ãÊòØÂê¶Êúâ \(low_u \ge dfn_{fa(u)}\) (Â¶ÇÊûúÊòØÊ†πÁöÑËØù‰∏çÁî®Ê£ÄÊü•‰∫Ü)„ÄÇ ËÄÉËôëÁ¨¨‰∏ÄÊ¨°Êª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂõûÊ∫ØÔºåÊ≠§Êó∂ÁÇπ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπÈÉΩÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÔºåÂõ†Ê≠§Â≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæ„ÄÇÂõ†‰∏∫‰∏çÂ≠òÂú®Ë∑®Ëøá \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÁöÑÈùûÊ†ëËæπÔºåËøô‰∏™ÁÇπÂèåËøûÈÄöÂ≠êÂõæÊòØ‰∏Ä‰∏™ÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª• \(u\) ÁöÑÂ≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊàë‰ª¨ÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÁÇπ‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂Âêé‰ªéÊ†à‰∏≠ÂºπÂá∫ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπ„ÄÇ Âú®‰πãÂêéÁöÑÂõûÊ∫Ø‰∏≠ÔºåÂ¶ÇÊûúÊª°Ë∂≥ \(low_u \ge dfn_{fa(u)}\)ÔºåÈÇ£‰πàÊ≠§Êó∂Ê†à‰∏≠ÊâÄÊúâÊ†ëËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠Ôºå‰∏îËøô‰∫õËæπÁöÑÊâÄÊúâÁ´ØÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰øùÂ≠ò‰∏ãÊù•ÁÑ∂ÂêéÊääÊ†à‰∏≠ÊâÄÊúâ \(u\) Â≠êÊ†ë‰∏≠ÁöÑËæπÂºπÂá∫Âç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n+m)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫‰∫ÜÊØè‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁÇπÈõÜ„ÄÇ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑËæπÂ∞±ÊòØËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÂÜÖÈÉ®ÁöÑÊ†ëËæπÂä†‰∏äËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâÁÇπÁöÑËøîÁ•ñËæπÔºåËøôÂæàÂÆπÊòìÂ§ÑÁêÜ„ÄÇÔºàÊ≥®ÊÑèËøôÈáåËøîÁ•ñËæπÁöÑÂÆö‰πâÊòØ‰ªéÊüê‰∏™ÁÇπÂá∫ÂèëÂà∞ÂÆÉÁ•ñÂÖàÁöÑÈùûÊ†ëËæπÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÊØèÊù°ÈùûÊ†ëËæπÊòØÊÅ∞Â•Ω‰∏Ä‰∏™ÁÇπÁöÑËøîÁ•ñËæπÔºâ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏Ä‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°àÊï∞Á≠â‰∫éÂêÑ‰∏™ÁÇπÂèåÁöÑÊüìËâ≤ÊñπÊ°àÊï∞‰πòÁßØÈô§‰ª•È¢úËâ≤Êï∞ÁöÑ(ÁÇπÂèåÊï∞ - ËøûÈÄöÂùóÊï∞)Ê¨°ÊñπÔºàËÄÉËôëÂØπÊØè‰∏™ËøûÈÄöÂùóÂú®ÂúÜÊñπÊ†ë‰∏ä‰ªé‰∏äÂæÄ‰∏ãÂØπÊØè‰∏™ÁÇπÂèåÊüìËâ≤Ôºâ„ÄÇ Ê†πÊçÆÈ¢òÁõÆ‰∏≠ÁöÑÊù°‰ª∂Ôºå‰∏Ä‰∏™ÁÇπÂèåÁöÑÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøá \(7\)ÔºåÊö¥ÂäõÊûö‰∏æÈõÜÂêàÂàíÂàÜÂèØ‰ª•Ê±ÇÂá∫‰∏Ä‰∏™ÁÇπÂèåÁöÑËâ≤Â§öÈ°πÂºèÔºåÂàÜÊ≤ª fft ‰∏Ä‰∏ãÂç≥ÂèØÂæóÂà∞ÁªôÂÆöÁöÑÂõæÁöÑËâ≤Â§öÈ°πÂºèÔºåÁÑ∂ÂêéÂ§öÁÇπÊ±ÇÂÄº‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ (‰∏∫Âï•‰∏ÄÂÆöË¶ÅÁªôÂêÑÁßçÊüìËâ≤ÊñπÊ°àÊï∞È¢òÂ•ó‰∏™Â§öÁÇπÊ±ÇÂÄº...Â•ΩÊó†ËÅä) ÂÆåÂÖ®‰∏ç‰ºöÂÜôÁÇπÂèå..Ë∞É‰∫Ü‰∏ÄÂ§©„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// Á¨¨‰∏ÄÁ±ªÊñØÁâπÊûóÊï∞int S[10][10];// ‰∏ãÈôçÂπÇÁ≥ªÊï∞int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268E] Expected Value]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(f_i\) ÊòØÁ¨¨ \(i\) Ê≠•Êó∂ÊÅ∞Â•ΩÂà∞ËææÁÇπ \(n\) ÁöÑÊ¶ÇÁéáÔºåÊòæÁÑ∂Êï∞Âàó \(\{f_i\}\) Êª°Ë∂≥‰∏Ä‰∏™‰∏çË∂ÖËøá \(n\) Èò∂ÁöÑÁ∫øÊÄßÈÄíÊé®„ÄÇ Âõ†‰∏∫ÁªôÂÆöÁöÑÂõæÊòØÂπ≥Èù¢ÂõæÔºåÊâÄ‰ª• \(m = \mathcal O(n)\)ÔºåÊàë‰ª¨ÂèØ‰ª•Êö¥ÂäõÊ±ÇÂá∫ \(f\) ÁöÑÂâç \(2n\) È°πÔºåÁÑ∂Âêé BM Âá∫ÈÄíÊé®Âºè„ÄÇÂæóÂà∞ÈÄíÊé®Âºè‰πãÂêé‰πüÂ∞±ÂæóÂà∞‰∫ÜÁîüÊàêÂáΩÊï∞ÔºåÊ±Ç‰∏™ÂØºÊää \(x=1\) ‰ª£ÂÖ•Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[ÂêêÊßΩÔºöËøôÈ¢òÁõÆÂêçÂèñÁöÑ„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÂÅöÊ≥ï Ë¶ÅÊòØ‰∏çÊòØÈ¢ÑÂÖàÁü•ÈÅìÊòØ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖç‰º∞ËÆ°‰∏ÄÊòüÊúüÈÉΩÊÉ≥‰∏çÂà∞„ÄÇ„ÄÇ ËÄÉËôëÊûÑÈÄ†‰∏Ä‰∏™Êó†ÂêëÂõæÔºåÁÑ∂ÂêéÁî®‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖçÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ ÂØπÊØè‰∏™ . Âª∫‰∏Ä‰∏™ÁÇπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ +ÔºåÈÇ£‰πàÂª∫‰∏§‰∏™Êñ∞ÁöÑÁÇπÔºå‰∏§‰∏™Êñ∞ÁöÑÁÇπÈÉΩÂêëÂÆÉÂõõÂë®ÁöÑ . ÂØπÂ∫îÁöÑÁÇπËøûËæπÔºåÁÑ∂Âêé‰∏§‰∏™Êñ∞ÁÇπ‰πãÈó¥Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ *ÔºåÂª∫‰∏§‰∏™Êñ∞ÁÇπÔºå‰∏Ä‰∏™Âêë‰∏ä‰∏ãÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°ËæπÔºå‰∏Ä‰∏™ÂêëÂ∑¶Âè≥ÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°Ëæπ„ÄÇËøôÊ†∑Ëøô‰∏™ÂõæÁöÑÊúÄÂ§ßÂåπÈÖçÂáèÂéª * Âíå + ÁöÑ‰∏™Êï∞Â∞±ÊòØÁ≠îÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÁêÜËÆ∫ÂèØ‰ª•ÂÅöÂà∞ \(\mathcal O(n^2m^2)\)ÔºåÂèØËøá„ÄÇ ÁÑ∂ËÄåÊàëÂÜôÁöÑËøô‰∏™Â∏¶Ëä±Ê†ë‰ºº‰πéÊòØ‰∏âÊñπÁöÑÔºå‰ΩÜÂÆÉ‰πüËøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]„ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçtree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫é‰∏ÄÊù°ÈìæÔºåÂÅáËÆæÂÆÉ‰ªéÊüê‰∏ÄÁ´ØÂºÄÂßãÁ¨¨‰∏Ä‰∏™Â§ß‰∫é \(1\) ÁöÑÁÇπÁöÑÁÇπÊùÉ‰∏∫ \(x\)ÔºåËøô‰∏™ÁÇπ(ÂºÄÂßãÁöÑÈÇ£‰∏ÄÁ´ØÂà∞ÂÆÉ)‰πãÂâçÊúâ \(k\) ‰∏™ÁÇπÔºå‰πãÂêéÊúâ \(l\) ‰∏™ÁÇπÔºå‰πãÂêé \(l\) ‰∏™ÁÇπÁÇπÊùÉ‰πòÁßØ‰∏∫ \(s\)„ÄÇ ÂÅáËÆæËøôÊù°ÈìæÁöÑÁ≠îÊ°àÊØîËøô‰∏™ÁÇπÂ∑¶ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÂíåÂè≥ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÁöÑÁ≠îÊ°àÈÉΩË¶Å‰∏•Ê†º‰ºò„ÄÇ ÈÇ£‰πà \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] ÊâÄ‰ª• \(k = l\)„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰∏ÄÊù°ÈìæÊØîÂÆÉÁöÑÊâÄÊúâÂ≠êÈìæÈÉΩ‰∏•Ê†º‰ºòÔºå‰∏îËøôÊù°Èìæ‰∏äÂ≠òÂú®ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÔºåÈÇ£‰πà‰ªéÂÆÉ‰∏§Á´ØÂºÄÂßãÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÈÉΩÊòØ‰∏≠ÁÇπ„ÄÇ ÊâÄ‰ª•Âè™ÈúÄËÄÉËôëÂÖ® \(1\) ÈìæÂíå‰ª•Êüê‰∏™ÁÇπ‰∏∫‰∏≠ÁÇπÔºåÂÖ∂‰ªñÁÇπÈÉΩÊòØ \(1\) ÁöÑÈìæ„ÄÇ Êç¢Ê†π dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea Êï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[Â§™Á•û‰ªô‰∫ÜÔºåÁúã sol ‰∫Ü„ÄÇ ÂÅöÊ≥ï ÂÖàËßÑÂÆöÂΩì‰∏§‰∏™Áü≥Â≠êË∑ùÁ¶ª‰∏∫ \(1\) Êó∂Ôºå‰∏çËÉΩÁßªÂä®ÂùêÊ†áÂ∞èÁöÑÁü≥Â≠ê„ÄÇËøôÊ†∑Â∞±Âè™ÈúÄË¶ÅÂØπÊìç‰ΩúÂ∫èÂàóËÆ°Êï∞‰∫Ü„ÄÇ ËÄÉËôëÂØπÊúâ \(K\) ‰∏™ÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÊñπÊ°àËÆ°Êï∞„ÄÇ\(K = N\) ÁöÑÊÉÖÂÜµÂæàÂÆπÊòìÂçïÁã¨ËÄÉËôë„ÄÇ ÂØπ‰∫é \(K &lt; N\) ÁöÑÊÉÖÂÜµÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÁ°ÆÂÆö‰∫ÜÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÔºåËÄÉËôë‰∏Ä‰∏™Â∫èÂàó \(s\)ÔºåËã•Á¨¨ \(i\) ‰∏™ÊääÊüêÁü≥Â≠êÂùêÊ†á \(+1\) Êìç‰ΩúÁßªÂä®ÁöÑÊòØÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÔºå\(s_i = -1\)ÔºåÂê¶Âàô \(s_i = 1\)„ÄÇËøôÊ†∑ÁöÑ‰∏Ä‰∏™Â∫èÂàó \(s\) ÊòæÁÑ∂Êª°Ë∂≥ \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)„ÄÇÂØπ‰∫é‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂ∫èÂàó \(s\)ÔºåÊàë‰ª¨Êù•ËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊää‚ÄúÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂùêÊ†áÂ§ßÁöÑÁü≥Â≠êÁöÑ‰ΩçÁΩÆ‚ÄùÁöÑÊìç‰ΩúÊèíÂÖ•Âà∞Ëøô‰∏™ÔºàÂè™ÂåÖÂê´ÊääÊüêÁü≥Â≠êÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÔºâÊìç‰ΩúÂ∫èÂàó‰πã‰∏≠ÁöÑÊñπÊ°à„ÄÇÊòæÁÑ∂ \(s\) ‰∏≠Êúâ \(B\) ‰∏™ \(1\)Ôºå\(K-B\) ‰∏™ \(-1\)„ÄÇÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÊèíÂú® \(s_i\) ÂØπÂ∫îÁöÑÊìç‰ΩúÂíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥ÔºåÈÇ£‰πà \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)„ÄÇËÆæ \(t_i = \sum_{k \le i} s_k\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êìç‰ΩúË¢´ÊèíÂÖ•Âú® \(s_i\) Âíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥Ôºå‰∏îÂ≠òÂú® \(j &gt; i\)Ôºå\(t_j \le t_i\)ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∫èÂàó‰∏ÄÂÆö‰∏çÂêàÊ≥ï„ÄÇÊâÄ‰ª•ÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰Ωú‰∏ÄÂÆöÂú® \(t_i = B-(K-B)-(B-A)=B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥ÔºåÂÖ∂‰ªñÊìç‰ΩúÂøÖÈ°ªÊèíÂÖ•ÊúÄÂêé‰∏Ä‰∏™ \(t_i = x, x \le B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥Ôºå‰∏îÂè™Ë¶ÅÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÂæóÂà∞ÁöÑÂ∞±ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ‰∫éÊòØÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÊ±ÇÊää \(N-K-1\) ÊãÜÊàê \(B+A-K+1\) ‰∏™ÈùûË¥üÊï¥Êï∞‰πãÂíåÁöÑÊñπÊ°àÊï∞ÔºåËøôÂæàÂÆπÊòìÁî®‰∏Ä‰∏™ÁªÑÂêàÊï∞ËÆ°ÁÆó„ÄÇÊ≥®ÊÑèÂà∞ÂØπ‰∫é‰∏çÂêåÁöÑ \(s\)ÔºåÊèíÂÖ•Êìç‰ΩúÁöÑÊñπÊ°à‰πãÂíå \(K\) ÊúâÂÖ≥ÔºåÊâÄ‰ª•Êàë‰ª¨Êûö‰∏æ \(K\) ÁªüËÆ°Á≠îÊ°àÂç≥ÂèØ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂØπÂ∫îÁöÑ \(K\)ÔºåËÆ°ÁÆóÂØπÂ∫îÁöÑ \(s\) ÁöÑ‰∏™Êï∞ÊòØ‰∏Ä‰∏™Á±ª‰ººÂç°ÁâπÂÖ∞Êï∞ÁöÑÈóÆÈ¢òÔºå‰∏ç‰ºöÁöÑËØùÂèØ‰ª•ÂéªÁúãÁúã AGC021E„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ balancer \((x_i,y_i)\)ÔºåÂ∞±Âú®ÁÇπ \(x_i\) ÂíåÁÇπ \(y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Ê†áÂè∑‰∏∫ \(i\) ÁöÑÊó†ÂêëËæπ„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö\(T=1\) ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëÊâÄÊúâË¢´Áî®Ëøá balancerÔºåÂèØ‰ª•ÂèëÁé∞ÂÆÉ‰ª¨ÂØπÂ∫îÁöÑËæπÊûÑÊàêÁöÑÂ≠êÂõæ‰∏ÄÂÆöÊòØ \(G\) ÁöÑ‰∏ÄÊ£µÁîüÊàêÊ†ëÔºå‰∏îÂ¶ÇÊûúÊääÊúÄÂêéÁªàÊ≠¢ÁöÑ wire ‰Ωú‰∏∫Ê†πÔºåÊØè‰∏™ÁÇπÂà∞ÂÆÉÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÈÉΩÂ∞è‰∫éÂÆÉÁà∂‰∫≤Âà∞ÂÆÉÁà∂‰∫≤ÁöÑÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ„ÄÇÂèçËøáÊù•ÔºåÂÆπÊòìÈ™åËØÅÂ¶ÇÊûúÂ≠òÂú®‰∏ÄÊ£µËøôÊ†∑ÁöÑÁîüÊàêÊ†ëÔºåÈÇ£‰πà‰πüÂ≠òÂú®‰∏ÄÁßçÂêàÊ≥ïÊñπÊ°à„ÄÇ Êää balancer ‰Ωú‰∏∫ÁÇπÂª∫‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂ¶ÇÊûú balancer \(i,j\) ÈÉΩËøûÊé•‰∫ÜÊüê‰∏™ wireÔºå‰∏î \(i &lt; j\)ÔºåÂ∞±‰ªé \(j\) Âà∞ \(i\) Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÂêàÊ≥ïÊñπÊ°àÔºå‰∏ÄÂÆöÂèØ‰ª•‰ªéËøô‰∏™Âõæ‰∏äÊüê‰∏™ÁÇπÂá∫ÂèëÔºåÂà∞Ëææ‰∏éÊØè‰∏™ wire Áõ∏ËøûÁöÑËá≥Â∞ë‰∏Ä‰∏™ balancer„ÄÇÂèçËøáÊù•ÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÊ†∑‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨‰ªéËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancer ÂºÄÂßãÔºåÊåâÁºñÂè∑‰ªéÂ§ßÂà∞Â∞èËÄÉËôëÊØè‰∏™ balancer„ÄÇÁª¥Êä§‰∏Ä‰∏™ balancer ÁöÑÈõÜÂêàÔºåÂàùÂßãÊó∂Âè™ÊúâËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancerÔºåËÄÉËôëÂà∞‰∏Ä‰∏™ balancer Êó∂ÔºåÂ¶ÇÊûúÂÆÉËøûÊé•ÁöÑ‰∏Ä‰∏™ wire ÊòØÂΩìÂâçÁª¥Êä§ÁöÑÈõÜÂêà‰∏≠Êüê‰∏™ balancer ÁöÑÁ´ØÁÇπÔºåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÂ∞±ÊääËøô‰∏™ balancer Âä†ÂÖ•ÈõÜÂêà„ÄÇÊúÄÂêéÂæóÂà∞ÁöÑÈõÜÂêàÊòæÁÑ∂ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÁîüÊàêÊ†ë„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑ balancerÔºåÁÑ∂ÂêéÁî®‰ª•‰∏äÁÆóÊ≥ïÊûÑÈÄ†Âç≥ÂèØ„ÄÇ‰ºòÂåñ‰∏Ä‰∏ãÂª∫ËæπÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ wireÔºåÊää‰∏éÂÆÉÁõ∏ÈÇªÁöÑ balancer ÊéíÂ∫èÔºåÂè™ËÄÉËôëÁõ∏ÈÇªÁöÑ balancer ‰πãÈó¥ÁöÑÊúâÂêëËæπ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ DAG ‰∏ä DP ÈóÆÈ¢òÔºåÁõ¥Êé•ÂÅöÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(nm)\)ÔºåÁî® bitset ‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ËÉΩËøá‰∫Ü„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÔºö\(T=2\) ÂΩì \(n \ge 3\) Êó∂Ôºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØèÊù°ËæπÔºåÂèØ‰ª•ÂèëÁé∞ÊÄªÂ≠òÂú®‰∏ÄÁßçÊñπÊ°à‰ΩøÊâÄÊúâ wire ÊúÄÁªà‰∏çÊ±áËÅöÂú®Âêå‰∏Ä‰∏™ÁÇπ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁâπÂà§Êéâ‰∏§Ê£µÊ†ë‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊÉÖÂÜµ„ÄÇ Êûö‰∏æÁ¨¨‰∏Ä‰∏™Êìç‰ΩúÁöÑÁÇπÂèäÂÖ∂Êìç‰ΩúÊñπÂºèÔºåËÆæËøô‰∏™ÁÇπ‰∏∫ \(r\)„ÄÇÊàë‰ª¨ËÄÉËôëËøõË°åÂÆåÁ¨¨‰∏ÄÊ¨°Êìç‰ΩúÂêéÁöÑ‰∏§Ê£µÊ†ë„ÄÇ ËÆæÁ¨¨‰∏ÄÊ£µÊ†ë‰∏∫ \(T_A\)ÔºåÁ¨¨‰∫åÊ£µÊ†ë‰∏∫ \(T_B\)ÔºåÊää \(r\) ‰Ωú‰∏∫‰∏§Ê£µÊ†ëÁöÑÊ†π„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âú®ÊúâÊ†πÊ†ë‰∏äËÄÉËôëÈóÆÈ¢ò„ÄÇ ÂÅáËÆæÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°à‰∏≠Ôºå‰Ω†Âú®Êüê‰∏™Êó∂ÂàªÊääÁÇπ \(u\) ÊüìÈªëÂπ∂Êé•Âà∞ÁÇπ \(v\)ÔºåÈÇ£‰πàÂú®Ëøô‰πãÂêé \(v\) ‰ª•ÂèäÂÖ∂Á•ñÂÖà‰∏ÄÂÆöÈÉΩ‰∏çÂèØËÉΩÊòØÂè∂Â≠êÔºåÊâÄ‰ª•Ê≠§Êó∂ \(T_A\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑÁ≠â‰∫é \(T_B\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑ„ÄÇÂõ†Ê≠§ \(v\) ÂøÖÈ°ªÊòØ \(u\) Âú® \(T_B\) ‰∏äÁöÑÁà∂‰∫≤„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™ÁÇπÂàùÂßãÊó∂Âà∞Ê†πÁöÑË∑ØÂæÑÔºàÁªèËøáÁöÑÁÇπÁöÑÂ∫èÂàóÔºâÂú®‰∏§Ê£µÊ†ë‰∏ä‰∏çÂêåÔºåÊàë‰ª¨Áß∞ÂÆÉ‰∏∫‰∏çÂ•ΩÁöÑÔºåÂê¶ÂàôÊàë‰ª¨Áß∞ÂÆÉ‰∏∫Â•ΩÁöÑ„ÄÇÊòæÁÑ∂Êàë‰ª¨‰∏ç‰ºöÊüìÈªëÂ•ΩÁöÑÁÇπÔºåËÄå‰∏çÂ•ΩÁöÑÁÇπÂøÖÈ°ªË¶ÅË¢´ÊüìÈªë„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËß£ÂÜ≥ÂèØË°åÊÄßÈóÆÈ¢ò„ÄÇ ‰∫ãÂÆû‰∏äÔºåÂ≠òÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°àÁ≠â‰ª∑‰∫éÂ≠òÂú®‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÁöÑÊéíÂàóÔºå‰ΩøÂæóÔºö - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_A\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂâç„ÄÇ - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_B\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂêé„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÊòØÂê¶Â≠òÂú®ÊãìÊâëÂ∫èÁöÑÈóÆÈ¢òÔºåÂà§‰∏Ä‰∏ã DAG Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(Tn^3)\)„ÄÇÁî±‰∫éÊàëÊáíÂÜô‰∫Ü \(\mathcal O(Tn^4)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫éÁªôÂÆöÁöÑÂ∫èÂàó \(a\)ÔºåÊàë‰ª¨ÊääÂÆÉÊãÜÊàê‰∏§‰∏™ÈùûË¥üÂ∫èÂàó \(x\) Âíå \(y\) ÁöÑÂíå„ÄÇÁÑ∂Âêé‰ªÖÁî®‰∏çÂáèÂ∫èÂàóÂéªÂæóÂà∞ \(x\)Ôºå‰ªÖÁî®‰∏çÂ¢ûÂ∫èÂàóÂæóÂà∞ \(y\)„ÄÇ ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫éÈïø‰∏∫ \(k\) Â∫èÂàó \(a\) (ÂÆö‰πâ \(a_0 = a_{k+1} = 0\))ÔºåÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂâçÁºÄ‰∏çÂáèÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)ÔºõÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂêéÁºÄ‰∏çÂ¢ûÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÔºåËÄÉËôë \(i\) ‰ªéÂ∞èÂà∞Â§ßÂú∞ÂÜ≥ÂÆö \(x\) Âíå \(y\) ÁöÑÁ¨¨ \(i\) È°πÔºåÁÑ∂Âêé‰ΩøÂæóÂâç \(i\) È°π \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Â∞ΩÂèØËÉΩÂ∞è„ÄÇÁÑ∂ËÄåÁõ¥Êé•Ë¥™ÂøÉÊòØ‰∏çÂØπÁöÑ„ÄÇÊ≥®ÊÑèÂà∞ÔºåÂØπ‰∫é‰∏§Áßç \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Áõ∏Á≠âÁöÑÊñπÊ°àÔºå\(x_i\) ËæÉÂ∞èÁöÑ‰∏ÄÂÆöÊØîËæÉ‰ºòÔºåËÄå‰∏îÂ¶ÇÊûúÂâç \(i\) È°π‰∏Ä‰∏™ÊñπÊ°àÁöÑ‰ª£‰ª∑ÊØîÂâç \(i\) È°πÊúÄÂ∞è‰ª£‰ª∑ÊñπÊ°àÁöÑ‰ª£‰ª∑ËøòË¶ÅÂ§ßË∂ÖËøá \(2\)ÔºåÂÆÉ‰∏ÄÂÆö‰∏ç‰ºò„ÄÇÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊàë‰ª¨ÂèØ‰ª•Âè™‰øùÁïô‰∏â‰∏™ÊñπÊ°àÔºå‰ΩøÂæóÂÖ∂‰∏≠‰∏ÄÂÆöÊúâ‰∏Ä‰∏™Âú®‰πãÂêéÂèØ‰ª•ÂèòÊàêÊúÄ‰ºòÊñπÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // ÂÖàÂà§Êñ≠ÊòØÂê¶ÂèØËÉΩ‰∏çÂ¢ûÂä† // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // ÂÜçÂà§Êñ≠Âè™Â¢ûÂä†‰∏ÄÈ°πÔºåx ÁöÑÊúÄÂ∞èÂÄºÔºàÊòæÁÑ∂ÂèØ‰ª•Âè™Â¢ûÂä†‰∏ÄÈ°πÔºâ ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏çÂ¶®ÂÅáËÆæ \(n \ge m\)„ÄÇ Âè™‰ºö \(\mathcal O(n \log^2 n)\) Ëá™Èó≠‰∫ÜÔºåÂéªÁúãÈ¢òËß£‰∫Ü„ÄÇ Áî±‰∫é‰Ω†ÁöÑÂÜ≥Á≠ñ‰∏ç‰ºöÂΩ±Âìç‰πãÂêéÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°àÔºåÊâÄ‰ª•ÊòæÁÑ∂ÊØèÊ¨°ÈÄâÊ¶ÇÁéáÂ§ßÁöÑÂ∞±ÊØîËæÉÂ•Ω„ÄÇ ËÆæÁ¨¨ \(k+1\) ‰∏™ÈóÆÈ¢òËÉΩÂ§üÁ≠îÂØπÁöÑÊ¶ÇÁéá‰∏∫ \(p_k\)ÔºåÂÅáËÆæÂâç \(k\) ‰∏™ÈóÆÈ¢ò‰∏≠Á≠îÂØπ‰∫Ü \(a\) ‰∏™ÔºåÈÇ£‰πà \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] ÂàÜ‰∏∫ \(n - a &lt; m - (k - a)\) Âíå \(n-a \ge m - (k - a)\) ËÆ°ÁÆóË¥°ÁåÆ„ÄÇ ËÆæ \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] Á¨¨‰∫åÈÉ®ÂàÜ \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] Âø´ÈÄüËÆ°ÁÆó \(H,G\) ÁöÑÊÑè‰πâÊòØÊúâÂ§öÂ∞ëÊù°‰ªé \((0,0)\) Âà∞ \((n,m)\) ÁöÑÈùûÈôçË∑ØÂæÑ‰∏éÁõ¥Á∫ø \(x+y = s\) ÁöÑ‰∫§ÁÇπÁöÑÊ®™ÂùêÊ†áÂú®Êüê‰∏™ËåÉÂõ¥ÂÜÖ„ÄÇ Áî±Ëøô‰∏™ÁªÑÂêàÊÑè‰πâÂæàÂÆπÊòìÂæóÂá∫ \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] ÊâÄ‰ª•Êàë‰ª¨‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æ \(k\) Á∫øÊÄßÁª¥Êä§ \(H\) Âíå \(G\) ÈúÄË¶ÅÁî®Âà∞ÁöÑÂÄºÔºåÂ∞±Âú® \(\mathcal O(n)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∫§Êç¢ÔºåÂ¶ÇÊûú‰∫§Êç¢ÁöÑÊòØ \(a_i\) Âíå \(a_j\)ÔºåÂú®ÁÇπ \(i\) ÂíåÁÇπ \(j\) ‰πãÈó¥Ëøû‰∏ÄÊù°ËæπÔºåÊ†áÂè∑‰∏∫ \(i\)„ÄÇ ËÆæ \(S_1\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_2\) ÊòØÊâÄÊúâ‰∏§‰∏™Â∫èÂàó‰∏≠ÈÉΩÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_3\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêà„ÄÇ \(S_1\) Âíå \(S_3\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(1\)Ôºå\(S_2\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(2\)„ÄÇ‰∏çÈöæËØÅÊòéÔºåÂ¶ÇÊûúÊúÄÁªà‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ \(G\) ÁöÑ‰∏Ä‰∏™ËøûÈÄöÂùóË¶Å‰πàÊòØ‰∏ÄÊù° \(S_1\) ‰∏≠ÁÇπÂà∞ \(S_3\) ‰∏≠ÁÇπÁöÑË∑ØÂæÑÔºåË¶Å‰πàÊòØ‰∏Ä‰∏™ \(S_2\) ÂÜÖÈÉ®ÁöÑÁéØ„ÄÇ ËÄÉËôëÂØπËÉΩ‰Ωø‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ÁöÑÂõæÁöÑÂΩ¢ÊÄÅÂíåËæπÁöÑÊ†áÂè∑ËÆ°Êï∞ÔºåÈÇ£‰πàÔºåÂØπ‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂõæ \(G\)Ôºå‰∏Ä‰∏™ÁéØ‰∏äÁöÑÊ†áÂè∑È°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºå‰∏ÄÊù°ÈìæÊ†áÂè∑‰∏ÄÂÆöÊòØ‰ªé \(S_1\) ‰∏Ä‰æßÂà∞ \(S_3\) ‰∏Ä‰æßÈÄíÂ¢û„ÄÇÊâÄ‰ª•Â¶ÇÊûúÂÜ≥ÂÆö‰∫Ü \(G\)ÔºåÂèØ‰ª•ÂÖàÂÜ≥ÂÆöÊØè‰∏™ËøûÈÄöÂùóÁöÑËæπÁî®Âì™‰∫õÊ†áÂè∑ÔºåÁÑ∂ÂêéÂØπ‰∫éÁéØÂèØ‰ª•‰ªªÊÑèÊéíÂàóÔºåÈìæÂè™Êúâ‰∏ÄÁßçÊ†áÂè∑ÊñπÂºè„ÄÇ ËÄÉËôëÂÜ≥ÂÆö \(S_2\) ‰∏≠ÁöÑÂõæÁöÑÁªìÊûÑÔºåÊàë‰ª¨ÂèØ‰ª•ÂÜôÂá∫ÁéØÂíåÈìæÁöÑ EGFÔºå\(C(x)\) Âíå \(P(x)\)„ÄÇ \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) È¢òÁõÆ‰∏≠Ë¶ÅÊ±ÇÁöÑÂç≥ÊòØ \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)„ÄÇ NTT ‰∏Ä‰∏ãÂç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇÔºàÂÖ∂ÂÆûÁõ¥Êé•ÂÜô‰∏äÁ≥ªÊï∞Â∞±ÊòØ‰∫ÜÔºåÂâçÈù¢Êé®ÁöÑÂÆåÂÖ®Áî®‰∏çÂà∞...Ôºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂêêÊßΩÔºö‰∏∫Âï•ËøôÁßçÊ≤°Âï•ÊÑèÊÄùÁöÑÈ¢ò‰ºöÊòØ agc ÁöÑ F È¢ò„ÄÇ Ëøô‰∏™Ê∏∏ÊàèÊòØ‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÁöÑÂíåÔºåÊâÄ‰ª•Âè™Ë¶Å‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏Êàè SG ÂÄº‰∏ç‰∏ÄÊ†∑Â∞±Ë°å„ÄÇ ËÄÉËôëÊåâ \(SG\) ÂÄº \(dp\)Ôºå\(dp_{S}\) Ë°®Á§∫ÈõÜÂêà \(S\) ‰∏≠‰ªª‰ΩïÁöÑÁÇπ SG ÂÄºÈÉΩÊØî \(S\) Â§ñ‰ªª‰ΩïÁÇπÊ∂àÔºåËá≥Â∞ë‰∏ÄÁ´ØÂú® \(S\) ‰∏≠ÁöÑËæπÁöÑÊñπÊ°àÊï∞„ÄÇ ËΩ¨ÁßªÂ∞±ÊòØÊûö‰∏æ SG ‰∏∫ \(S\) ‰∏≠ÊúÄÂ§ß SG ÂÄºÂä†‰∏ÄÁöÑÁÇπÁöÑÈõÜÂêàÔºåÁÑ∂ÂêéËøô‰∏™ÈõÜÂêàÂÜÖÈÉ®ÊâÄÊúâËæπÈÉΩ‰∏çÈÄâÔºåÊâÄÊúâ‰∏çÂú®Ëøô‰∏™ÈõÜÂêàÂÜÖ‰πü‰∏çÂú® \(S\) ÂÜÖÁöÑÁÇπÂà∞Ëøô‰∏™ÈõÜÂêàËá≥Â∞ëÊúâ‰∏ÄÊù°ËæπÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞ÔºõËøô‰∏™ÈõÜÂêàÂà∞‰∏çÂú®Ëøô‰∏™ÈõÜÂêà‰∏≠‰πü‰∏çÂú® \(S\) ‰∏≠ÁöÑÁÇπÁöÑËæπÂèØÈÄâÂèØ‰∏çÈÄâÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞„ÄÇÊ≥®ÊÑè \(1,2\) ‰∏çËÉΩÂêåÊó∂Âú®Ëøô‰∏™ÈõÜÂêà„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n3^n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÈóÆÈ¢òÊîæÂà∞‰∏Ä‰∏™Êó†ÂêëÂõæ‰∏äËÄÉËôëÔºåÂ¶ÇÊûúÁ¨¨ \(i\) ‰∏™‰∫∫ÈÄâ‰∫ÜÁÅ´È∏° \(x_i,y_i\)ÔºåÂ∞±Âú® \(x_i,y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Êó†ÂêëËæπÔºåÊàë‰ª¨Áß∞ËøôÊù°ËæπÁöÑÊó∂Èó¥‰∏∫ \(i\)„ÄÇ ËÄÉËôë‰∏Ä‰∏™ÁÅ´È∏° \(s\) Âπ∏Â≠òÁöÑÊù°‰ª∂ÔºöÂ¶ÇÊûú \(s\) Âú®Êó∂Âàª \(t\) Ê≤°Ë¢´ÂêÉÊéâÔºåÂØπ‰∫éÊØè‰∏ÄÊù°Ëæπ \(\{s,v\}\)ÔºåÂ¶ÇÊûúËøôÊù°ËæπÁöÑÊó∂Èó¥Â∞è‰∫éÁ≠â‰∫é \(t\)ÔºåË¢´ÂêÉÊéâÁöÑÈÉΩÊòØÁÅ´È∏° \(v\)Ôºå‰∫éÊòØÁÅ´È∏° \(v\) Ë¶ÅÂú®ËøôÊù°ËæπÁöÑÊó∂Èó¥Âπ∏Â≠òÔºåÂ¶ÇÊ≠§‰º†ÈÄí‰∏ãÂéªÔºåÊúÄÁªà‰ºöÂæóÂà∞Ëã•Âπ≤Êù°Ë¢´ÂêÉÊéâÁöÑÁÅ´È∏°Á°ÆÂÆöËæπÔºåËøô‰∫õËæπ‰ºöÊûÑÊàê‰∏ÄÊ£µÊ†ëÔºàÂ¶ÇÊûú‰∏çÊûÑÊàê‰∏ÄÊ£µÊ†ëÁöÑËØùÁÅ´È∏° \(s\) ‰∏çÂèØËÉΩÂπ∏Â≠òÔºâ„ÄÇÊòæÁÑ∂Âè™Ë¶ÅËøô‰∏™Ê†ë‰∏äÁöÑËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Êª°Ë∂≥‰∫ÜÊù°‰ª∂Ôºå\(s\) ‰πü‰∏ÄÂÆö‰ºöÂπ∏Â≠ò„ÄÇÂõ†Ê≠§ÁÅ´È∏° \(s\) Âíå \(t\) ÂêåÊó∂Âπ∏Â≠òÁöÑÊù°‰ª∂Â∞±ÊòØÂÆÉ‰ª¨ÂØπÂ∫îÁöÑÁ°ÆÂÆöÁöÑËæπÊ≤°ÊúâÂÜ≤Á™Å„ÄÇ Áî±‰∫é‰∏Ä‰∏™ÁÅ´È∏°Âπ∏Â≠òÁöÑÊù°‰ª∂‰∏≠ÊúÄÂ§ö \(n-1\) Êù°ËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Ë¢´Á°ÆÂÆöÔºåÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊ£ÄÊü•‰∏§‰∏™ÁÅ´È∏°ÊòØÂê¶ÂèØ‰ª•ÂêåÊó∂Âπ∏Â≠òÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â¶ÇÊûúÁ∫¢Ê†ë‰∏äÊúâ‰∏ÄÊù°Ëæπ \((u,v)\)Ôºå\(u\) Âíå \(v\) Âú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\)ÔºåÈÇ£‰πà Sigma Ëµ∞Âà∞ \(u\) Êàñ \(v\) Â∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª‰∫Ü„ÄÇ Êàë‰ª¨ÊääÂ≠òÂú®‰∏ÄÊù°Áõ∏ÈÇªÁ∫¢ËæπÂú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\) ÁöÑÁÇπÊ†áËÆ∞‰∏Ä‰∏ãÔºåÂè™Ë¶ÅÂà∞ËææËøôÁßçÁÇπÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥ÂæÄ‰∏ãË∑ë„ÄÇ ÂÅáËÆæ Sigma Âú®ÁÇπ \(X\)ÔºåSugim Âú®ÁÇπ \(Y\)ÔºåËÄÉËôëËìùÊ†ëÂéªÊéâÁÇπ \(Y\) ÂêéÂΩ¢ÊàêÁöÑËã•Âπ≤‰∏™ËøûÈÄöÂùóÔºåSigma Êó†Ê≥ï‰ªé‰∏Ä‰∏™ËøûÈÄöÂùóÁöÑÊú™Ê†áËÆ∞ÁÇπÂà∞Âè¶‰∏Ä‰∏™ËøûÈÄöÂùó„ÄÇÊâÄ‰ª•ÊòæÁÑ∂ Sugim ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØÔºåÊØèÊ¨°Âú®ËìùÊ†ë‰∏äÂêë \(X\) ÊâÄÂú®ÁöÑÊñπÂêëËµ∞‰∏ÄÊ≠•„ÄÇSigma ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØ‰∏ç‰ºöÈáçÂ§çÁªèËøáËµ∞ËøáÁöÑÁÇπÁöÑ„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞Ê±ÇÂá∫ Sigma ÂèØËÉΩËµ∞Âà∞Âì™‰∫õÁÇπÔºåÂ¶ÇÊûú‰ªñËÉΩËµ∞Âà∞‰∏Ä‰∏™Ê†áËÆ∞ÁÇπÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª„ÄÇÂê¶ÂàôÁ≠îÊ°àÂ∞±ÊòØËÉΩËµ∞Âà∞ÁöÑÁÇπÂú®ËìùÊ†ë‰∏ä‰∏é \(Y\) ÁöÑÊúÄËøúË∑ùÁ¶ª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // Ê≠§Êó∂ Y ÁöÑÊ∑±Â∫¶‰∏∫ T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÖ≥‰∫éÊúÄÈïøÂèçÈìæÊñπÊ°àÁöÑÊûÑÈÄ†]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏Ä‰∫õÊ±ÇÊúÄÈïøÂèçÈìæÁöÑÈ¢òÁõÆ‰ºöËÆ©‰Ω†ÊûÑÈÄ†ÊñπÊ°àÔºåÊØîÂ¶Ç [CTSC2008] Á•≠Á•Ä Âíå CF590E Birthday„ÄÇ ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÂÜôÁöÑÊØîËæÉÊ∏ÖÊô∞ÁöÑÂÅöÊ≥ïÔºår-64 ÁöÑ uoj blog„ÄÇ Â§ßÊ¶ÇÊòØËØ¥Âª∫Âá∫‰∫åÂàÜÂõæÊ±ÇÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÊâÄÊúâ‰∏§ÈÉ®‰∏≠ÂØπÂ∫îÁöÑÁÇπÈÉΩÂú®Áã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÊûÑÊàêÊúÄÈïøÂèçÈìæ„ÄÇ ÊûÑÊàêÂèçÈìæÊòØÊòæÁÑ∂ÁöÑÔºåÊûÑÊàêÊúÄÈïøÂèçÈìæÁöÑÁêÜÁî±‰ºº‰πé‰∏çÂ§™ÂÆåÊï¥Ôºà‰πüÊúâÂèØËÉΩÊòØ‰ΩúËÄÖËßâÂæóËøôËøá‰∫éÊòæÁÑ∂‰∫ÜÔºâÔºåÂùë‰∫ÜÊàëÂæà‰πÖÔºåËøôÈáåËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ËÆæÂéüÂõæÁÇπÊï∞‰∏∫ \(n\)Ôºå‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç‰∏∫ \(m\)ÔºåÈÇ£‰πàÊúÄÂ∞èÈìæË¶ÜÁõñÂ§ßÂ∞è‰∏∫ \(n-m\)ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞è‰∏∫ \(2n - m\)„ÄÇÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÂ∑¶Âè≥ÈÉ®‰∏≠ÂØπÂ∫îÁÇπÈÉΩÂú®ÂÖ∂‰∏≠ÁöÑÁÇπÊúâ \(n-m\) ‰∏™„ÄÇÈ¶ñÂÖàÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÂÆÉÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπËá≥Â∞ëÊúâ‰∏Ä‰∏™Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÔºàÈÇ£ÁØá blog ‰∏≠‰ºº‰πéÁº∫Â∞ë‰∫ÜËøô‰∏ÄÊ≠•ÔºâÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÁÇπÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÈÉΩ‰∏çÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠Ôºå‰∏ÄÂÆöÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Â∑¶ÈÉ®ÂØπÂ∫îÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπÊúâËæπÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπ \(a\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºå‰πüÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÊúâËæπÁöÑÁÇπ \(b\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠„ÄÇÁî±ÂÅèÂ∫èÂÖ≥Á≥ªÁöÑ‰º†ÈÄíÊÄßÂèØÁü• \(a\) Âíå \(b\) Âú®‰∫åÂàÜÂõæ‰∏äÊúâ‰∏ÄÊù°ËæπÔºå‰∏éÊúÄÂ§ßÁã¨Á´ãÈõÜÁöÑÂÆö‰πâÁüõÁõæ„ÄÇÂõ†Ê≠§ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞èÁ≠â‰∫é \(n + Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁÇπÈÉΩÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÁöÑÊï∞Èáè\)Ôºå‰πüÂ∞±ËØÅÊòé‰∫ÜÊàë‰ª¨ÊûÑÈÄ†Âá∫ÁöÑÂèçÈìæÊòØÊúÄÈïøÂèçÈìæ„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] „ÄåJOISC 2017 Day 1„ÄçÂºÄËçíËÄÖ]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ‰∏úË•øÂçóÂåóÊñπÂêëÂêπÁöÑÊ¨°Êï∞ÂàÜÂà´‰∏∫ \(c_E, c_W, c_S, c_N\)„ÄÇ È¢òÊÑèÁõ∏ÂΩì‰∫éÊòØË¶ÅÊ±Ç \(c_E+c_W+c_S+c_N\) ÊúÄÂ∞èÁöÑ \(c_E,c_W,c_S,c_N\)Ôºå‰ΩøÂæóÂú®Âπ≥Èù¢‰∏äÊîæ \(n\) ‰∏™Áü©ÂΩ¢ÔºåÁ¨¨ \(i\) ‰∏™Áü©ÂΩ¢ÁöÑÊ®™ÂùêÊ†áËåÉÂõ¥‰∏∫ \([S_i - c_N, S_i + c_S]\)ÔºåÁ∫µÂùêÊ†áËåÉÂõ¥‰∏∫ \([E_i - c_W, E_i + c_E]\)ÔºåËÉΩÂ§üË¶ÜÁõñ‰ª• \((1,1)\) ‰∏∫Â∑¶‰∏äËßíÁöÑ \(R \times C\) Áü©ÂΩ¢„ÄÇ ÂÅáËÆæÊúâ‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëË∞ÉÊï¥„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[‰æãÈ¢ò LOJ6440 ÂÅöÊ≥ï ËÄÉËôëËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰Ωú‰∏ÄÊù°Â∞ÑÁ∫ø \(y = \frac{Px+R}Q\)ÔºåÂè™ËÄÉËôë \(x &gt; 0\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(y = i\) Â∞±ÊâßË°åÊìç‰Ωú \(A\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(x = i\) Â∞±ÊâßË°åÊìç‰Ωú \(B\)Ôºå\(i\) ÊòØÊ≠£Êï¥Êï∞„ÄÇ ‚ÄúÊìç‰ΩúÂ∫èÂàó‚ÄùÂØπÂ∫îÁöÑ‰ø°ÊÅØË¶ÅÂèØÂêàÂπ∂„ÄÇ ËÄÉËôëÈÄíÂΩíÂú∞Â§ÑÁêÜÈóÆÈ¢òÔºåËÆæ \(A\) Âíå \(B\) ÊòØ‰∏§‰∏™Êìç‰ΩúÂ∫èÂàóÂØπÂ∫îÁöÑ‰ø°ÊÅØ„ÄÇÂÆö‰πâ \(solve(P, Q, R, L, A, B)\) Ë°®Á§∫‰∏Ä‰∏™Âê´Êúâ \(L\) ‰∏™ \(B\)ÔºåÁ¨¨ \(k\) ‰∏™ \(B\) ÂíåÁ¨¨ \(k-1\) ‰∏™ \(B\) ‰πãÈó¥Êúâ \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) ‰∏™ \(A\) ÁöÑÊìç‰ΩúÂ∫èÂàóÁöÑ‰ø°ÊÅØÔºà\(k = 1\) Êó∂ÊòØÂºÄÂ§¥ \(A\) ÁöÑÊï∞ÈáèÔºâ„ÄÇÊää \(R\) ÂØπ \(Q\) ÂèñÊ®°‰∏ç‰ºöÊîπÂèòÁ≠îÊ°àÔºåÊää \(P\) ÂØπ \(Q\) ÂèñÊ®°Âè™Ë¶ÅÊää \(B\) ÂèòÊàê \(A^{\lfloor \frac P Q \rfloor}B\) Â∞±ÂèØ‰ª•ÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú„ÄÇ ÂÖàÂèñÊ®°Ôºå‰øùËØÅ \(P, R &lt; Q\)„ÄÇ ËÄÉËôë‰∫§Êç¢ \(A\) Âíå \(B\) ÁöÑÂú∞‰ΩçÔºåÂéüÊù•Êàë‰ª¨ÊòØËÄÉËôëÊØè‰∏™ \(B\) ÂâçÈù¢ÊúâÂá†‰∏™ \(A\)ÔºåÁé∞Âú®Êàë‰ª¨ËÄÉËôëÊØè‰∏™ \(A\) ÂâçÈù¢ÊúâÂá†‰∏™ \(B\)ÔºåÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂâçÈù¢ÁöÑÊù°‰ª∂ÊòØ \(i \le \frac{Pj+R}{Q}\)ÔºåÂç≥ \(j \ge \frac{Qi-R}P\)„ÄÇÈÇ£‰πàÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂêéÈù¢ÁöÑÊù°‰ª∂ÊòØ \(j &lt; \frac{Qi-R}P\)Ôºå‰ªéÁ¨¨ \(i\) ‰∏™ \(A\) ÂâçÈù¢Êúâ \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) ‰∏™ \(B\)„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÁâπÂà´ÂéªÂ§ÑÁêÜ‰∏Ä‰∏ãÊúÄÂêé‰∏Ä‰∏™ \(B\) Âíå \(Qi-R-1\) Â∞è‰∫é \(0\) ÁöÑÊÉÖÂÜµÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™ÂΩ¢Âºè‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇÁî±‰∫é \(R &lt; Q\)Ôºå\(i &gt; 0\) Êó∂ \(Qi-R-1 \ge 0\)„ÄÇ‰ΩÜÊòØ \(i = 0\) Êó∂Âá∫Áé∞Ë¥üÊï∞Êåâ‰πãÂâçÁöÑÂÆö‰πâ‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•Á¨¨‰∏Ä‰∏™ \(A\) ‰ª•ÂèäÂâçÈù¢ÁöÑÈÉ®ÂàÜÂçïÁã¨Â§ÑÁêÜÔºåË∞ÉÁî® \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)ÔºåÂ§ÑÁêÜ‰∏ãÂºÄÂ§¥ÁªìÂ∞æÂç≥ÂèØ„ÄÇË¶ÅÂà§‰∏Ä‰∏ãÊ≤°Êúâ \(A\) ÁöÑÊÉÖÂÜµ„ÄÇ Ê∂âÂèäÂà∞Ê±ÇÁü©ÈòµÂπÇÂèØ‰ª•Áõ¥Êé•Âø´ÈÄüÂπÇÔºåÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶‰ªçÊòØ‰∏Ä‰∏™ \(\log\)„ÄÇ ÂÖ≥‰∫éÂÄºÂüü Êú¨È¢òÁöÑÂÄºÂüüÁâπÂà´Â§ßÔºåË¶ÅÂ∞èÂøÉÁàÜ long long„ÄÇ ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûêÂêÑ‰∏™ÂèòÈáèÂÜçÈÄíÂΩíËøáÁ®ã‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Ëøô‰∏™È¢òÊØîËæÉÊ∞¥„ÄÇ ÂÅáËÆæÊ≤°ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôêÔºåÈÇ£‰πàÂÖ∂ÂÆûË¶ÅÁÆó‰∏ÄÂè™ pony ËÉΩÊî∂ÂèñÁöÑ manaÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìËøôÊ¨°Êî∂ÂèñÂíå‰∏äÊ¨°Êî∂ÂèñÁöÑÊó∂Èó¥Èó¥ÈöîÔºå‰πò‰∏ä \(r_i\) Âç≥ÂèØ„ÄÇ Êàë‰ª¨Ë¶ÅÂú®Êìç‰ΩúÊó∂Áª¥Êä§ÊâÄÊúâ pony ÁöÑÊúÄÂêéÊìç‰ΩúÊó∂Èó¥ÔºåËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂå∫Èó¥Ë¶ÜÁõñÈóÆÈ¢òÔºåÂæàÂÆπÊòìÂÜô‰∏Ä‰∏™ÂùáÊëä \(\mathcal O(n \log n)\) ÁöÑÂÆûÁé∞ÔºöÂª∫‰∏Ä‰∏™Á∫øÊÆµÊ†ëÔºå‰øÆÊîπÊó∂ÂÖàÊääËØ¢ÈóÆÂå∫Èó¥Âú®Á∫øÊÆµÊ†ë‰∏äÊãÜÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÔºåÂØπÊØè‰∏™Âå∫Èó¥ÔºåÂÅö‰∏Ä‰∏™ËøôÊ†∑ÁöÑËøáÁ®ãÔºöÂÖàËÄÉËôëÂΩìÂâçÂå∫Èó¥ÊâÄÊúâÁÇπÊòØ‰∏çÊòØÊúÄÁªà‰øÆÊîπÊó∂Èó¥Áõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÔºåÂ∞±Â§ÑÁêÜËøô‰∏™Âå∫Èó¥ÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Âå∫Èó¥‰∏äÊâìÊ†áËÆ∞ÔºåÂê¶ÂàôÂ∞±‰∏§ËæπÈÄíÂΩí‰∏ãÂéª„ÄÇÊØèÊ¨°ÂæÄ‰∏ãÈÄíÂΩíÈÉΩ‰ºö‰ΩøÂæó‰∏Ä‰∏™Á∫øÊÆµÊ†ë‰∏äÂå∫Èó¥‰∏≠‰∏çÂêåÁöÑÊúÄÁªà‰øÆÊîπÊó∂Èó¥Êï∞ÂáèÂ∞ë‰∏ÄÔºå‰ªéËÄåËøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶ÊòØÂùáÊëä \(\mathcal O(n \log n)\)„ÄÇ ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôê‰πüÂèØ‰ª•Á±ª‰ººÁöÑÂ§ÑÁêÜÔºå‰∏çÂêåÁöÑÊòØÔºåÂõ†‰∏∫Êúâ‰∫Ü‰∏äÈôêÔºåÈúÄË¶ÅÂØπÊØè‰∏™Âå∫Èó¥Áª¥Êä§‰∏Ä‰∏™‰ª• \(\lceil \frac {m_i}{r_i}\rceil\) ‰∏∫ÂÖ≥ÈîÆÂ≠óÊéíÂ•ΩÂ∫èÁöÑ‰∏úË•ø„ÄÇËøôÊ†∑‰Ω†ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ãÂâçÂ§öÂ∞ë‰∏™ÈÉΩÊòØÂú®ËøôÊÆµÊó∂Èó¥ÈáåÈù¢ mana Êª°‰∫ÜÁöÑÔºåÁõ¥Êé•Âä†ËøõÁ≠îÊ°àÔºåÁÑ∂ÂêéÂêéÈù¢ÁöÑÂè™ÈúÄË¶ÅÁªüËÆ°‰∏Ä‰∏ã \(r_i\) ÁöÑÂíå‰πò‰∏äÊó∂Èó¥Â∑ÆÂä†ËøõÁ≠îÊ°àÂç≥ÂèØ„ÄÇËøô‰∏™‰∏úË•øÂæàÂÆπÊòìÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ„ÄÇ ÂàùÂßãÂÄºË¶ÅÁâπÂà´Â§ÑÁêÜÔºåÂú®ÊØè‰∏™ÁÇπÁ¨¨‰∏ÄÊ¨°‰øÆÊîπÊó∂Êö¥ÂäõÁÆó‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÊÑüËßâÂÆûÈôÖ‰∏äÂèØ‰ª•Áî®Á∫øÊÆµÊ†ëÂàÜË£ÇÂíåÂêàÂπ∂ÂÅöÂà∞‰∏Ä‰∏™ \(\log\)„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊØíÁò§ÂàÜÁ±ªËÆ®ËÆ∫.... Â∞±Êîæ‰∏™‰ª£Á†Å..ÁªìËÆ∫Â§™È∫ªÁÉ¶Â∞±‰∏çÂÜô‰∫Ü TAT„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Á•û‰ªôÈ¢òÔºåÁúãÈ¢òËß£‰∫Ü„ÄÇ Âèñ‰ªªÊÑè‰∏Ä‰∏™ÁîüÊàêÊ†ëÔºåÂèñËøô‰∏™Ê†ëÁöÑÈáçÂøÉÂíåÊâÄÊúâË∑®ËøáËøô‰∏™ÈáçÂøÉÁöÑÈùûÊ†ëËæπÁöÑÁ´ØÁÇπÔºàÂÆûÈôÖ‰∏ä‰∏§‰∏™Á´ØÁÇπ‰∏≠Âè™Ë¶Å‰ªªÂèñ‰∏Ä‰∏™Â∞±Ë°åÔºåÂè™Ë¶Å‰øùËØÅÂ≠êÊ†ë‰∏çËøûÈÄöÔºâÔºåËÄÉËôëË∑®ËøáËøô‰∫õÁÇπÁöÑË∑ØÂæÑÔºåÁÑ∂ÂêéÂÜçÂØπÊØè‰∏™Â≠êÊ†ëÁÇπÂàÜ„ÄÇ Ê≥®ÊÑè‰∏çË¶ÅÊääËøô‰∫õÁÇπÂà†ÊéâÂÜçÂØπÊØè‰∏™ËøûÈÄöÂùóÂÅöÁÇπÂàÜÊ≤ªÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØËÉΩ‰∏Ä‰∏™ËøûÈÄöÂùó‰∏çÊòØ‰∏Ä‰∏™Ê†ë‰∏äËøûÈÄöÂùóÔºåÂ∞±‰∏çÊòØÂæàÂ•ΩÂ§ÑÁêÜÔºàÂ∫îËØ•‰πüËÉΩÂ§ÑÁêÜÔºâ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÉèÂä®ÊÄÅÁÇπÂàÜÊ≤ª‰∏ÄÊ†∑Áª¥Êä§Â∞±Ë°åÔºåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÂà†ÂéªÁöÑÁÇπ‰∏éÂΩìÂâçËøûÈÄöÂùó‰∏≠ÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ª„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(nk\log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // ÁÇπÂàÜÊ†ë‰∏äÁà∂‰∫≤Ôºå‰∏Ä‰∏™ÁÇπË¢´Âà†ÊéâÊó∂ÂØπÂ∫îÁÇπÂàÜÊ†ë‰∏äÂì™‰∏™ÁÇπvector&lt;int&gt; vimp[maxn], mn[maxn]; // ÁÇπÂàÜÊ†ë‰∏ä‰∏ÄÊ¨°Âà†ÂéªÁöÑÁÇπÔºå‰ª•ÂèäÂà∞ËøûÈÄöÂùóÂÜÖÊúÄËøëË¢´ mark ÁÇπÁöÑË∑ùÁ¶ªunordered_map&lt;ll, int&gt; mdis; // Ë¢´Âà†ÂéªÁöÑÁÇπÂà∞ÂÜÖÈÉ®‰∏Ä‰∏™ÁÇπÁöÑË∑ùÁ¶ªint vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // ÁÇπÂàÜÊ≤ªÁî®ÂèòÈáèvoid dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // ÂéüÊú¨ËøôÈáåÊòØÊääÊâÄÊúâÂ§ÑÁêÜÁöÑÁÇπÂà†ÊéâÁöÑÔºåÂÜôÂæóÂèØËÉΩÊúâÁÇπÂ•áÊÄ™ÔºåÊáíÂæóÊîπ‰∫Ü vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ∫¶Êï∞Â∫èÂàó \(d\)ÔºåÂ≠òÂú®‰∏ÄÊ£µÂØπÂ∫îÁöÑ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(1 \le d_i &lt; n\) ‰∏î \(\sum {d_i} = 2(n-1)\)Ôºà‰ªéÂè∂Â≠êÂΩíÁ∫≥Ôºâ„ÄÇ ËÄÉËôëÂéªÈí¶ÂÆöËøô‰∏™Ê†ëÁöÑ \(k\) ‰∏™ÂåπÈÖçÔºåÂ¶ÇÊûúËÉΩÈí¶ÂÆöÂá∫Êù•Â∞±ËØ¥ÊòéÁ≠îÊ°à \(\ge k\)„ÄÇÈí¶ÂÆö‰∏§‰∏™ÁÇπÂåπÈÖçÂèØ‰ª•Áúã‰ΩúËøô‰∏§‰∏™ÁÇπË¢´Áº©Âà∞‰∫Ü‰∏ÄËµ∑ÔºåÂèòÊàê‰∫Ü‰∏Ä‰∏™Â∫¶Êï∞Âíå‰∏∫‰∏§‰∏™ÁÇπÁöÑÂ∫¶Êï∞‰πãÂíåÂáèÂéª \(2\) ÁöÑÁÇπ„ÄÇÂè™Ë¶Å‰øùËØÅÊâÄÊúâÂåπÈÖçÁº©Ëµ∑Êù•‰πãÂêéÂæóÂà∞ÁöÑÂ∫¶Êï∞Â∫èÂàó‰æùÁÑ∂Êª°Ë∂≥‰πãÂâçÊâÄËØ¥ÁöÑÊù°‰ª∂Âç≥ÂèØ„ÄÇËøôÊòØ‰∏Ä‰∏™‰ºóÊâÄÂë®Áü•ÁöÑË¥™ÂøÉÈóÆÈ¢òÔºåÊéíÂ∫èÂêéË¥™ÂøÉÁî®Â∞èÁöÑÂåπÈÖçÂ§ßÁöÑÂç≥ÂèØ„ÄÇÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè \(1\) Âíå \(1\) Âú®ÁÇπÊï∞Â§ß‰∫é \(2\) Êó∂‰∏çËÉΩÂåπÈÖçÔºàÂõ†‰∏∫ \(1+1-2=0\)ÔºâÔºå‰ΩÜÊòØÁÇπÊï∞Á≠â‰∫é \(2\) Êó∂ÂèØ‰ª•ÂåπÈÖç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â•áÊÄ™ÁöÑÈ¢òÁõÆ... ÂÖàÊääÁÇπÊåâ \(a_i\) ‰ªéÂ∞èÂà∞Â§ßÈáçÊñ∞Ê†á‰∏™Âè∑„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨ÂÅáËÆæ \(a_i &lt; a_{i+1}\)„ÄÇ Êää \(1\) Áúã‰ΩúÊ†πÔºåÊòæÁÑ∂ÂèØ‰ª•ÈÄöËøáË∞ÉÊï¥‰ΩøÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ÁºñÂè∑ÈÉΩÊØî‰ªñÂ∞è„ÄÇ Êää‰∏§ÁßçË¥°ÁåÆ‰∏ÄËµ∑ËÄÉËôëÔºåÂÆö‰πâËæπ \(\{u, fa(u)\}\) ÁöÑË¥°ÁåÆ‰∏∫ \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)ÔºåÂØπÊØè‰∏™ \(u\) ÂéªÊâæËÉΩ‰Ωø‰ª£‰ª∑ÊúÄÂ∞èÁöÑ \(fa(u)\)„ÄÇÁî±‰∫éËøô‰∏™Ê†ëÁöÑÁâπÊÆäÊÄßË¥®ÔºåÁÇπ \(u\) ÊúÄ‰ºòÁöÑÁà∂‰∫≤‰∏ÄÂÆöÊòØÂéüÊ†ë‰∏ä \(u\) ÁöÑÁ•ñÂÖàÔºåÊâÄ‰ª•ÂÄçÂ¢û‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // Ë∑ùÁ¶ª‰∏çË∂ÖËøá 2^k ÁöÑÁÇπint cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™ \(n\) ‰∏™ÁÇπ \(m\) Êù°ËæπÁöÑÂ∏¶ÊùÉÁÆÄÂçïÊúâÂêëÂõæÔºåÊ±Ç‰∏Ä‰∏™ÊúÄÂ∞èËæπÊùÉÂíåÁöÑÊòØ‰ª• \(r\) ‰∏∫Ê†πÁöÑÂÜÖÂêëÁîüÊàêÊ†ë„ÄÇ Â§ñÂêëÊ†ëÁöÑÊÉÖÂÜµÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´ÔºåËæπÂèç‰∏ÄÂèçÂ∞±Â•Ω„ÄÇ Êó†Ê†πÁöÑÊÉÖÂÜµÂèØ‰ª•Âä†‰∏Ä‰∏™ÁÇπËΩ¨Âåñ‰∏∫ÊúâÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ÁÆóÊ≥ï Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæÊòØ DAGÔºå‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑË¥™ÂøÉÊòØÔºåÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ„ÄÇÊòæÁÑ∂ËøôÊ†∑‰ºöÊûÑÊàê‰∏ÄÊ£µÂÜÖÂêëÊ†ëÔºå‰∏î‰∏çÂèØËÉΩÊúâÊùÉÂÄºÂíåÊõ¥Â∞èÁöÑÂÜÖÂêëÊ†ë„ÄÇ Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæ‰∏çÊòØ DAGÔºåÁõ¥Êé•ÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ‰∏ç‰∏ÄÂÆö‰ºöÂæóÂà∞‰∏ÄÊ£µÊ†ëÔºåÊ≠§Êó∂ÂèØËÉΩ‰ºöÊúâÂ§ö‰∏™Âº±ËøûÈÄöÂùóÔºåÊØè‰∏™ËøûÈÄöÂùóÊòØ‰∏ÄÊù°ÈìæÔºàÂåÖÂê´ \(r\) ÁöÑÔºâÊàñËÄÖ‰∏ÄÊ£µÂü∫ÁéØÂÜÖÂêëÊ†ë„ÄÇÂ¶ÇÊûú‰Ω†ÂæóÂà∞‰∫Ü‰∏Ä‰∏™ÂÜÖÂêëÁîüÊàêÊ†ëÂ∞±Ê±ÇÂá∫‰∫ÜÁ≠îÊ°àÔºå‰∏ãÈù¢Êàë‰ª¨ËÄÉËôëËá≥Â∞ëÊúâ‰∏Ä‰∏™ÁéØÁöÑÊÉÖÂÜµ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫é‰∏Ä‰∏™ÔºàÊüê‰∏™Âü∫ÁéØÊ†ëËøûÈÄöÂùó‰∏≠ÁöÑÔºâÁéØÔºå‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÊÅ∞Â•ΩÂè™Êúâ‰∏ÄÊù°ÁéØ‰∏äËæπ‰∏çÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºåÊàë‰ª¨ÂÖàÂÅáËÆæËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºà‰Ω†ÂèØ‰ª•Âä†ÂÖ•‰∏Ä‰∏™ÂÖÖÂàÜÂ∞èÁöÑÂÅèÁßªÈáèÔºåÂú®‰∏çÂΩ±ÂìçÁ≠îÊ°àÁöÑÂâçÊèê‰∏ã‰ΩøËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºâÔºåËÆæÁÇπ \(u\) ÁöÑÊúÄÂ§ßÂá∫ËæπËøûÂêëÁÇπ \(f(u)\)ÔºåËÄÉËôë‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÁÇπ \(u \neq r\)Ôºå\(f(u)\) ‰∏çÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠Ôºå‰∏î \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÊàë‰ª¨ÂèØ‰ª•Êää \(u\) ÁöÑÁà∂‰∫≤Êîπ‰∏∫ \(f(u)\)ÔºåÂæóÂà∞‰∏Ä‰∏™Êõ¥Â∞èÁöÑÂÜÖÂêëÁîüÊàêÊ†ëÔºåËøô‰∏éËøô‰∏™Ê†ëÊòØÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÁüõÁõæ„ÄÇËøôËØ¥ÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁéØ‰∏äÁöÑÁÇπ \(u\)Ôºå‰ΩøÂæó \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ (ÁéØ‰∏äÁÇπËÇØÂÆö‰∏çÊòØ \(r\))Ôºå\(f(u)\) Ë¶Å‰πàÊòØ \(u\) ÁöÑÁà∂‰∫≤Ë¶Å‰πàÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠„ÄÇËÄÉËôë‰ªé \(u\) Âá∫ÂèëÔºåÊØèÊ¨°‰ªé \(u\) Ëµ∞Âêë \(f(u)\)ÔºåÂú®Ëµ∞Âõû \(u\) ‰πãÂâçÔºå‰∏ÄÂÆö‰∏ç‰ºöÁªèËøá‰∏Ä‰∏™ÁÇπ‰∏§Ê¨°Ôºå‰ªéËÄåË∑ØÂæÑ‰∏äÂè™ÊúâÁ¨¨‰∏ÄÊ¨°Ëµ∞ÁöÑÊó∂ÂÄô \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÂõ†Ê≠§ÁéØ‰∏äÂè™Êúâ‰∏ÄÊù°ËæπÊ≤°ÊúâÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠Âá∫Áé∞„ÄÇ Âõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁéØ‰∏äÂì™‰∏ÄÊù°ËæπÊ≤°ÊúâÂá∫Áé∞„ÄÇËÄÉËôëÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÂæóÂà∞‰∏Ä‰∏™‰∏éÂéüÂõæÁ≠â‰ª∑ÁöÑÂõæ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠ \(e\) ÊòØ‰∏çÂú®ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ‰∏≠ÁöÑËæπÔºå‰ªéÂõæ‰∏≠ÂèØ‰ª•ÂæàÊòéÊòæÂú∞ÁúãÂà∞ÔºåÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÊääÁº©ÂÆåÂêéÁöÑÁöÑÁÇπÁöÑÂá∫ËæπËæπÊùÉÂáèÂéªÂéüÊù•ËøôÊù°Âá∫ËæπÂØπÂ∫îÁöÑ \(e\) ÁöÑÊùÉÂÄºÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™Á≠â‰ª∑ÁöÑÂõæ„ÄÇ Êö¥ÂäõÁº©ÁÇπÂèØ‰ª•Áî® \(\mathcal O(nm)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ê±ÇÂá∫ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ„ÄÇ Â§çÊùÇÂ∫¶‰ºòÂåñ Áî®Âπ∂Êü•ÈõÜÁª¥Êä§Âº±ËøûÈÄöÂùóÔºåÂÜçÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ÂΩìÂâçÂì™‰∫õÁÇπË¢´Áº©Êàê‰∫Ü‰∏Ä‰∏™ÁÇπ„ÄÇÁî®ÂèØÂπ∂Â†ÜÁª¥Êä§ÂΩìÂâçÊØè‰∏™ÁÇπÁöÑÂá∫ËæπÔºåÁº©ÁÇπÊó∂Â∏¶ tag ÂêàÂπ∂‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÂá∫ËæπÔºåÂ¶ÇÊûúÂú®Âêå‰∏ÄÂº±ËøûÈÄöÂùóÂèàÂèØ‰ª•Áº©ÁÇπ‰∫ÜÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÂíåÂÖ∂‰ªñÂº±ËøûÈÄöÂùóÂêàÂπ∂Âú®‰∫Ü‰∏ÄËµ∑„ÄÇ Áº©‰∏ÄÊ¨°Ëá≥Â∞ëÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºåÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O((n+m) \log n)\)„ÄÇ ÂÆûÁé∞ ÂíïÂíïÂíï„ÄÇ Áî±‰∫éÂÆûÁé∞Âíï‰∫ÜÊâÄ‰ª•‰πü‰∏çËÉΩ‰øùËØÅ‰∏äÈù¢ËØ¥ÁöÑÊòØÂØπÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Áåú‰∫Ü‰∏™ÁªìËÆ∫Ôºå‰∏ç‰ºöËØÅ‰ΩÜÊòØÂèàÊÉ≥‰∏çÂà∞ÂÖ∂‰ªñÂÅöÊ≥ï..Áúã‰∫ÜÁúºÈ¢òËß£ÂèëÁé∞ÊòØÂØπÁöÑ„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñÔºåÂÅáËÆæ‰Ω†‰π∞‰∫Ü \(x\) Ê¨°Ôºå‰Ω†‰ªéËøô‰∏™ÊäΩÂ•ñ‰∏≠Ëé∑ÂæóÁöÑÈí±Êï∞ÁöÑÊúüÊúõÊòØ \(p_i\frac {x} {x + l_i}\)„ÄÇÂÅáËÆæ‰Ω†Â∑≤Áªè‰π∞‰∫ÜÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñ \(x\) Ê¨°ÔºåÂÜç‰π∞‰∏ÄÊ¨°ÔºåÊúüÊúõÁöÑÂ¢ûÂä†ÈáèÊòØ \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)„ÄÇÂÆπÊòìÂèëÁé∞Ëøô‰∏™Â¢ûÂä†ÈáèÂÖ≥‰∫é \(x\) ÂçïË∞ÉÈÄíÂáèÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÂØπ‰∫éÊâÄÊúâÁöÑ \(i\) Âíå \(x \le i\)ÔºåÊää \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) ‰∏¢Ëøõ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ªéÂ§ßÂà∞Â∞èÊéí‰∏™Â∫èÔºåÂâç \(t\) ‰∏™Êï∞‰πãÂíåÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ§çÊùÇÂ∫¶‰∏çËÉΩÊé•Âèó„ÄÇ Êàë‰ª¨ÂÖàÁÆóÂá∫ÂàùÂßãÊ∏ÖÁ©∫ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÁªôÁ¨¨ \(k\) ‰∏™ÊäΩÂ•ñÂéüÊúâÁöÑÁ•®Êï∞Âä†‰∏ÄÂáè‰∏Ä‰πãÂêéÔºåËÄÉËôë‰∏§ÁßçÊìç‰ΩúÔºö‰∏ÄÔºåÂ∞ë‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ§ö‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñÔºõ‰∫åÔºåÂ§ö‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ∞ë‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñ„ÄÇÊàë‰ª¨ÊâæÂà∞ËÉΩ‰ΩøÊúüÊúõÂ¢ûÂä†ÈáèÊúÄÂ§ßÁöÑÊìç‰ΩúÔºåËøôÂæàÂÆπÊòìÁî®Â†ÜÊù•Áª¥Êä§„ÄÇÂè™ÈúÄË¶ÅÁªèËøá‰∏ÄÊ¨°ËøôÊ†∑ÁöÑÊìç‰ΩúÂç≥ÂèØÂæóÂà∞ÊúÄ‰ºòÊñπÊ°àÔºåËØÅÊòéÂ∞±‰∏çÂÖ∑‰ΩìÂÜôÂá∫‰∫Ü„ÄÇÔºàÊØîÂ¶ÇËØ¥Â¶ÇÊûúÊòØËøõË°åÊìç‰Ωú‰∫åÔºå‰ªéËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÂêéÔºåÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÊØîÂú®‰øÆÊîπÁ•®Êï∞‰πãÂâçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÂ§ßÊù•ËÄÉËôëÂç≥ÂèØÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÔºåÂÖàÊääÈ¢òÁõÆ‰∏≠ÁªôÂÆö‰∏≤ÁøªËΩ¨‰∏Ä‰∏ãÔºåÂèòÊàêË¶ÅÊâæ‰∏Ä‰∏™ÊØè‰∏™‰∏≤ÊòØÂêé‰∏Ä‰∏™‰∏≤Â≠ê‰∏≤ÁöÑÂ∫èÂàó„ÄÇ ‰∏ãÈù¢Êàë‰ª¨ËÆ§‰∏∫ÔºåËøô‰∏™Â∫èÂàó‰∏≠ÁöÑÂÖÉÁ¥†ÊòØ‰∏Ä‰∏™(ÂåÖÂê´‰ΩçÁΩÆÁöÑ)Â≠ê‰∏≤„ÄÇÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤Âá∫Áé∞Âú®‰∏çÂêå‰ΩçÁΩÆË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÁöÑ„ÄÇ ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Â∫èÂàóÔºå‰Ω†‰∏ÄÂÆöÂèØ‰ª•Âú®‰∏çÊîπÂèòÈïøÂ∫¶ÁöÑÊÉÖÂÜµ‰∏ãÊääÂÆÉË∞ÉÊï¥ÊàêÁ¨¨ \(i\) ‰∏™Â≠ê‰∏≤Èïø‰∏∫ \(i\)„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ËÄÉËôëËøôÁ±ªÂ∫èÂàó„ÄÇ Áß∞‰∏Ä‰∏™Â≠ê‰∏≤ \(s[l..r]\) ÊòØÂèØËææÁöÑÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏Ä‰∏™ËøôÁ±ªÂ∫èÂàó‰ª• \(s[l..r]\) ÁªìÂ∞æ„ÄÇÈ¢òÁõÆÂ∞±ÊòØË¶ÅÊ±ÇÊúÄÈïøÂèØËææÁöÑÂ≠ê‰∏≤„ÄÇ Ê≥®ÊÑèÂà∞Â¶ÇÊûú \(l &lt; r\)Ôºå\(s[l..r]\) ÂèØËææÔºåÈÇ£‰πà \(s[l..r-1]\) Âíå \(s[l+1..r]\) ‰∏ÄÂÆöÂèØËææ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(l\) Ê±ÇÂá∫ÊúÄÂ§ßÁöÑ \(r\) ‰ΩøÂæó \(s[l..r]\) ÂèØËææÔºåËÆæÂØπ‰∫é \(l=i\) ÊúÄÂ§ßÁöÑ \(r\) ÊòØ \(f_i\)„ÄÇÂØπ \(f\) ‰Ωú dpÔºåÊòæÁÑ∂ \(f_i \ge f_{i-1}\)ÔºåÊâÄ‰ª•ÊØèÊ¨°ÂÖà‰ª§ \(f_i = f_{i-1}\)ÔºåÁÑ∂ÂêéÊ£ÄÊü•‰∏Ä‰∏ã \(f_i\) ËÉΩ‰∏çËÉΩÂ¢ûÂ§ßÔºåÂ¶ÇÊûúËÉΩÂ¢ûÂ§ßÂ∞±‰∏ÄÁõ¥Â¢ûÂ§ßÂà∞‰∏çËÉΩÂ¢ûÂ§ßÂ∞±Ë°å‰∫Ü„ÄÇÊ£ÄÈ™åÂè™ÈúÄË¶ÅÂú® SAM ‰∏äÊâæÂà∞Ë¶ÅÊ£ÄÈ™åÁöÑ‰∏≤Âú®Êüê‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÊúÄÂêéÂá∫Áé∞‰ΩçÁΩÆÂ∞±Â•ΩÔºåËøôÂæàÂÆπÊòìÁî® SAM + Á∫øÊÆµÊ†ëÂÆûÁé∞Ôºà‰πüÂèØ‰ª•Áî®ÂÖ∂‰ªñÊñπÂºèÔºâ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™‰ºöÂ¢ûÂ§ß \(\mathcal O(n)\) Ê¨°ÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// ÊúâÊ≤°ÊúâÂè≥Á´ØÁÇπÂú® x Êàñ‰πãÂâçÁöÑint check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Êàë‰ª¨ÂÖà‰∏çË¶ÅËÄÉËôëËæπÊùÉ„ÄÇ ËÄÉËôëÁõ¥Êé• dpÔºå\(dp[u][i][j]\) Ë°®Á§∫ \(u\) ÁöÑÂ≠êÊ†ë‰∏≠‰øÆÊîπÂêéÊúâ \(i\) ‰∏™ÈªëÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøúÁöÑ‰∏éÂ≠êÊ†ë‰∏≠ÊâÄÊúâÈªëÁÇπË∑ùÁ¶ªÈÉΩÂ§ß‰∫é \(x\) ÁöÑÁ∫¢ÁÇπ‰∏éÊ†πÁöÑË∑ùÁ¶ª‰∏∫ \(j\)ÔºåÊúÄÂ∞èË¶Å‰øÆÊîπÂá†Ê¨°„ÄÇËΩ¨ÁßªÁöÑÊó∂ÂÄôÈúÄË¶ÅÂÜ≥ÂÆöË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÁ∫¢ÁÇπÔºåÊâÄ‰ª•ÈúÄË¶ÅÁü•ÈÅìË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÁöÑË∑ùÁ¶ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊàë‰ª¨ÂÜçËÆ∞‰∏Ä‰∏™ÊúÄËøëÈªëÁÇπÁöÑËØùÂ§çÊùÇÂ∫¶Â∞±ÁÇ∏‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞‰∏Ä‰∏™ÊÄßË¥®ÔºöÂ¶ÇÊûúÊ†πÊòØÁ∫¢ÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÊâÄÂú®ÁöÑ(Ê†πÁöÑÂÑøÂ≠êÁöÑ)Â≠êÊ†ë‰∏≠‰∏ÄÂÆöÊâÄÊúâÁ∫¢ÁÇπÈÉΩÂèØ‰ª•Âú®Ëøô‰∏™Â≠êÊ†ë‰∏≠ÊâæÂà∞Ë∑ùÁ¶ª‰∏çË∂ÖËøá \(x\) ÁöÑÈªëÁÇπ„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπ \(j = 0\) ÁöÑÊÉÖÂÜµÈ¢ùÂ§ñËÆ∞ÂΩï‰∏ãÊúÄËøëÁöÑÈªëÁÇπ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª• dp ‰∫Ü„ÄÇ Áé∞Âú®Êù•ËÄÉËôë‰∏Ä‰∏ãËæπÊùÉÔºåÊ≥®ÊÑèÂà∞Êàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåËøôÊ†∑Â∞±ËÉΩÂÅöÂ∏¶ÊùÉÁöÑÊÉÖÂÜµ‰∫Ü„ÄÇ ÂÜÖÂ≠òÈúÄË¶ÅÂç°‰∏Ä‰∏ã„ÄÇ È¢òËß£Á´üÁÑ∂ÊòØÂØπ \(500\) Á∫ßÂà´ÁöÑ‰∏úË•øË∑ëÂçïÁ∫ØÂΩ¢Ôºå‰∏çÂ§™ËÉΩÁêÜËß£Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇÁªèËøáËâ∞ÈöæÁöÑË∞ÉËØïÂíåÂç°Â∏∏Áªà‰∫é A ‰∫Ü„ÄÇÔºàÊó∂Èôê 1000 msÔºåÂºÄ Ofast 982 msÔºå‰∏çÂºÄ Ofast 998 msÔºåTATÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : Êúâ i ‰∏™ÈªëÁÇπÔºåÊâÄÊúâÁ∫¢ÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j // g : Êúâ i ‰∏™ÈªëÁÇπÔºåÊ≤°ÊúâÊú™ÂåπÈÖçÁ∫¢ÁÇπÔºåËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÈªëÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Âä®ÊÄÅËßÑÂàí</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÖàÊ±ÇÈáçÂøÉÔºöÈöè‰æøÊâæ‰∏™ÁÇπÔºåÊääÂ§öËæπÂΩ¢ÂàíÂàÜÊàêËã•Âπ≤‰∏™‰∏âËßíÂΩ¢ÔºåÊ±ÇÂá∫ÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºåÊåâÊúâÂêëÈù¢ÁßØÂä†ÊùÉÂπ≥Âùá„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁÇπ \((x_p,y_p)\)ÔºåËÆæ \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)„ÄÇÊääÂÆÉÁªï \((x_0,y_0)\) ÈÄÜÊó∂ÈíàÊóãËΩ¨ \(c\) ÂºßÂ∫¶ÔºåÁõ∏ÂΩì‰∫éÊää \(p\) Â∑¶‰πò‰∏Ä‰∏™Áü©Èòµ \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)„ÄÇÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ \(3 \times 3\) Áü©ÈòµÂ∞±ËÉΩÂø´ÈÄüËé∑ÂæóÊØè‰∏™ÁÇπÁöÑ‰ΩçÁΩÆ„ÄÇÊóãËΩ¨Êó∂ËÄÉËôë‰∏Ä‰∏ãÂõ∫ÂÆöÁöÑÁÇπÂíåÈáçÂøÉÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ Âê¨ÔºàÈ¢òËß£‰∏äÔºâËØ¥ÈúÄË¶ÅÊää‰∏Ä‰∏™ÁÇπÁßªÂà∞ \((0,0)\) ÈÅøÂÖçÁ≤æÂ∫¶ËØØÂ∑Æ„ÄÇ‰∏çÁü•ÈÅì‰∏çËøôÊ†∑ËÉΩ‰∏çËÉΩËøá„ÄÇ ÔºàÊ†∑‰æã 2 ÁúüÁöÑ‰ºöËΩ¨ÂêóÔºüÔºâ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n+m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // Áé∞Âú®Áî® p2 ÊóãËΩ¨ Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁúãÊàêÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™ÁÇπÊó∂‰ºöÁªôÂÆÉÊâÄÂú®ÁöÑËøûÈÄöÂùóÊØè‰∏™ÁÇπ‰∏Ä‰∏™Ë¥°ÁåÆ„ÄÇ ÂØπÊØè‰∏™ÁÇπÂØπ \((u,v)\) ËÆ°ÁÆó \(v\) ‰ºöÁªô \(u\) ‰∏Ä‰∏™Ë¥°ÁåÆÁöÑÊ¶ÇÁéáÔºå Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°à„ÄÇ È¢òÁõÆ‰∏≠ÁªôÂÆöÁöÑÂõæÊòØ‰∏ÄÊ£µÂü∫ÁéØÊ†ë„ÄÇ ÂØπ‰∫é \(u = v\)ÔºåËøô‰∏™Ê¶ÇÁéáÊòØ \(1\)„ÄÇÂØπ \(u \neq v\)ÔºåÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö ‰∏ÄÔºå \(u,v\) Âú®Âêå‰∏Ä‰∏™Â≠êÊ†ë‰∏≠„ÄÇÊää \(u\) Áúã‰ΩúÊ†πÔºåÈÇ£‰πàËøô‰∏™Ê¶ÇÁéáÂ∞±ÊòØÔºåÊØèÊ¨°‰ªéËøòÊú™Ë¢´Âà†Èô§ÁöÑÁÇπ‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÁÇπÔºåÂ∞ÜÂÖ∂Â≠êÊ†ëÂà†Èô§ÔºåÂΩì \(v\) Ë¢´Âà†Èô§Êó∂Ôºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÈô§‰∫Ü \(v\) ‰ª•Â§ñÁöÑÁÇπÈÉΩËøòÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéá„ÄÇËÆæÊÄªÂÖ±Êúâ \(n\) ‰∏™ÁÇπÔºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÊúâ \(k\) ‰∏™ÁÇπÔºåÁ±ª‰ººÁåé‰∫∫ÊùÄ‰∏ÄÈ¢ò‰∏≠ÁöÑÊäÄÂ∑ßÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìËøô‰∏™Ê¶ÇÁéáÁ≠â‰∫é‰∏çÊñ≠‰ªé \([1,n]\) ‰∏≠Á≠âÊ¶ÇÁéáÈöèÊú∫Âèñ‰∏Ä‰∏™Êï¥Êï∞Ôºå‰∏ÄÊó¶Âá∫Áé∞ \(v\) Êàñ \(v\) ÁöÑÁ•ñÂÖàÂ∞±ÂÅúÊ≠¢ÔºåÂÅúÊ≠¢Êó∂Èô§ \(v\) ‰ª•Â§ñ \(v\) ÁöÑÊâÄÊúâÁ•ñÂÖàÈÉΩÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéáÔºåÂç≥ \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)„ÄÇ ‰∫åÔºå\(u,v\) ‰∏çÂú®Âêå‰∏ÄÂ≠êÊ†ë‰∏≠Ôºå‰∏éÊÉÖÂÜµ‰∏ÄÁ±ª‰ººÔºå‰ΩÜÊòØ‰∏çÂêåÁöÑÊòØÊ≠§Êó∂ \(u\) Âà∞ \(v\) Êúâ‰∏§Êù°Ë∑ØÂæÑÔºåÂè™Ë¶ÅÂÖ∂‰∏≠‰∏ÄÊù°Â≠òÂú®Â∞±ÊúâË¥°ÁåÆ„ÄÇÂèØ‰ª•ÂÆπÊñ•ÊàêÁ¨¨‰∏ÄÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂä†‰∏äÁ¨¨‰∫åÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂáèÂéª‰∏§Êù°ÈÉΩÂ≠òÂú®ÁöÑÊ¶ÇÁéá„ÄÇËøô‰∏â‰∏™ÈóÆÈ¢òÈÉΩÂèØ‰ª•Á±ª‰ººÊÉÖÂÜµ‰∏ÄÂú∞Ëß£ÂÜ≥„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n^2)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÊú¨È¢ò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊÉ≥‰∫ÜÊå∫‰πÖÂè™‰ºöËÉ°‰∏™ \(\mathcal O(n \sqrt n \log n)\) ÁöÑËé´Èòü + Áª¥Êä§ huffman Ê†ëÔºåÂéªÁúã‰∫ÜÁúºÂà´‰∫∫ÁöÑÈ¢òËß£ÂèëÁé∞‰πüÊúâÊòØËøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ.....‰∏çËøáÊØîÊàëËÉ°ÁöÑÂ¶ôÂ§ö‰∫ÜÔºå‰∏ãÈù¢ÂÜôÁöÑÊòØÁúãÂà∞ÁöÑÂà´‰∫∫ÁöÑÂÅöÊ≥ï„ÄÇ Áî®Ëé´ÈòüÂ§ÑÁêÜËØ¢ÈóÆÔºåÁª¥Êä§‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÔºåÂπ∂ËÆ∞ÂΩï‰∏ãÂΩìÂâçÂá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞„ÄÇÂØπÊ¨°Êï∞‰∏çË∂ÖËøá \(x\) ÁöÑÊï∞ÔºåËÆ∞‰∏Ä‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÁÑ∂Âêé \(\mathcal O(x)\) ÁÆóÂá∫ÂêàÂπ∂‰ª£‰ª∑„ÄÇËΩ¨Âåñ‰∏∫Âè™ÊúâÂá∫Áé∞Ê¨°Êï∞Ë∂ÖËøá \(x\) ÁöÑÊï∞ÁöÑÊÉÖÂÜµÔºåËøôÊó∂ÊúÄÂ§öÂè™Êúâ \(\frac n x\) ‰∏™Êï∞ÔºåË¥™ÂøÉÂêàÂπ∂Âç≥ÂèØ„ÄÇËØ¢ÈóÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(x + \frac n x \log n)\)ÔºåÂèñ \(x = \sqrt {n \log n}\)ÔºåÂàô‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\sqrt {n \log n}\)„ÄÇ Ëé´ÈòüÁª¥Êä§Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞Êó∂ÂèØ‰ª•‰ΩøÁî®ÈìæË°®ÔºåËøôÊ†∑ÁöÑËØùËé´ÈòüÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï È¢òÁõÆ‰∏≠ÁöÑËøûËæπÊñπÂºèÂèØ‰ª•Ê¶ÇÊã¨‰∏∫ÔºåÂ¶ÇÊûú(ÂºÄ)Âå∫Èó¥ \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∫§‰∏ç‰∏∫Á©∫Ôºå‰∏î \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∏çÊòØ‰∏ÄÂØπÂ≠òÂú®ÂåÖÂê´ÂÖ≥Á≥ªÁöÑÂå∫Èó¥ÔºåÈÇ£‰πàËøô‰∏§‰∏™Âå∫Èó¥‰πãÈó¥Êúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇÂê¶ÂàôÔºåÂ¶ÇÊûú \((l_1,r_1)\) Ë¢´ \((l_2,r_2)\) ÂåÖÂê´Ôºå\((l_1,r_1)\) Âà∞ \((l_2,r_2)\) Êúâ‰∏ÄÊù°ÊúâÂêëËæπ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™‰ªÖÁî±ÂèåÂêëËæπÊûÑÊàêÁöÑËøûÈÄöÂùóÔºåËÆæËøô‰∏™ËøûÈÄöÂùó‰∏≠ÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂‰∏∫ \((L,R)\)ÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ§‰∏∫Áé∞Âú®Â∞±Â≠òÂú®ËøôÊ†∑‰∏Ä‰∏™Âå∫Èó¥ \((L,R)\)„ÄÇÂõ†‰∏∫ÈïøÂ∫¶ÊòØÈÄíÂ¢ûÁöÑÔºåÂ¶ÇÊûú‰πãÂêéÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ \((a,b)\)Ôºå\(a\) Ë¢´ \((L,R)\) ÂåÖÂê´ÊàñËÄÖ \(b\) Ë¢´ \((L,R)\) ÂåÖÂê´ÔºåÈÇ£‰πà \((a,b)\) ‰∏éËøô‰∏™ËøûÈÄöÂùó‰∏≠ÁöÑÊüê‰∏™ÁÇπÊúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇ‰∏çÈöæÂèëÁé∞Ôºå‰∏Ä‰∏™Âå∫Èó¥ \(a\) ËÉΩÂà∞ËææÂå∫Èó¥ \(b\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(a\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Ë¢´ \(b\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂ÂåÖÂê´„ÄÇËøôÊ†∑Êàë‰ª¨Âè™Ë¶ÅÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ËøûÈÄöÂùóÔºåÂπ∂ËÆ∞ÂΩï‰∏Ä‰∏ãËøûÈÄöÂùóÁöÑÂπ∂ÁöÑÂ∑¶Âè≥Á´ØÁÇπÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ËÉΩÂê¶Âà∞Ëææ‰∫Ü„ÄÇ update : ‰ªîÁªÜËØÅ‰∫Ü‰∏Ä‰∏ã‰πãÂêé‰ºº‰πéËøô‰∏ÄÁªìËÆ∫ÂÜç‰∏§‰∏™ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Áõ∏ÂêåÊó∂‰∏çÊàêÁ´ãÔºåÈúÄË¶ÅÁâπÂà´Âà§‰∏Ä‰∏ã‰ºö‰∏ç‰ºöÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂè™Êúâ‰∏Ä‰∏™ÁÇπ„ÄÇ Êàë‰ª¨Áî®Á∫øÊÆµÊ†ëÁª¥Êä§ÔºåÂØπ‰∫éÊØè‰∏™ÁÇπÊúâÂì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´Ëøô‰∏™ÁÇπ„ÄÇËøôÂèØ‰ª•ÈÄöËøáÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™ÁÇπÂºÄ‰∏Ä‰∏™ vector Êù•ÂÆûÁé∞ÔºåÊü•ËØ¢Âì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´‰∏Ä‰∏™ÁÇπÊó∂ÔºåÂè™ÈúÄÂèñËøô‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâ vector ÁöÑÂπ∂Âç≥ÂèØ„ÄÇÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÔºåÂ∞±ÂØπÂ∑¶Âè≥Á´ØÁÇπÊü•‰∏Ä‰∏ãÔºåÊääÂæóÂà∞ÁöÑËøûÈÄöÂùóÂêàÂπ∂ÔºåÁÑ∂ÂêéÂÜçÊääÊñ∞ÁöÑËøûÈÄöÂùóÂä†ÂÖ•Á∫øÊÆµÊ†ë„ÄÇÁî±‰∫éÊâÄÊúâË¢´‰Ω†Êü•ËøáÁöÑÁÇπ vector ‰∏≠ÊâÄÊúâÁÇπÈÉΩ‰ºöË¢´‰Ω†ÂêàÂπ∂ÔºåÊâÄ‰ª•‰Ω†ÊØèÊü•ËØ¢‰∏Ä‰∏™ÁÇπÁöÑ vector Â∞±ÂèØ‰ª•ÊääÂÆÉÁöÑ vector Ê∏ÖÁ©∫ÔºåËÄåÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÊúÄÂ§öÂ¢ûÂä†‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†Âè™‰ºöÁªô \(\mathcal O(\log n)\) ‰∏™ÁÇπÁöÑ vector Ê∑ªÂä†ÂÖÉÁ¥†„ÄÇÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n \alpha (n))\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x ÊòØÊ†πÔºåÊää y Âä†ÂÖ• xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰ΩúÈáçÈìæÂâñÂàÜÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÈáçÈìæÂâñÂàÜÂêéÁöÑ dfs Â∫è„ÄÇ ‰∏ÄÊù°ÈìæÂèØ‰ª•ÊãÜÊàê dfs Â∫è‰∏ä \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥„ÄÇ Êåâ dfs Â∫èÊääÊØè‰∏™ÁÇπÁöÑÂ≠óÁ¨¶ÊéíÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\)ÔºåÈ¢ÑÂÖàÂª∫‰∏Ä‰∏™ËÉΩ \(\mathcal O(1)\) ËØ¢ÈóÆ \(s\) ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcpÔºåËØ¢ÈóÆ \(s^R\) ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcp ÂíåËØ¢ÈóÆ‰∏Ä‰∏™ \(s\) ÁöÑÂêéÁºÄÂíå \(s^R\) ÁöÑ‰∏Ä‰∏™ÂêéÁºÄÁöÑ lcp ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂèØ‰ª•ÂØπ \(ss^R\) Âª∫Ê†ëÁä∂Êï∞ÁªÑÔºåÂõ†‰∏∫Êàë‰∏çÊìÖÈïøÂÜôÊ†ëÁä∂Êï∞ÁªÑÔºåÊâÄ‰ª•ÊàëÂØπÂÆÉ‰ª¨Áî® SAM Ê±ÇÂá∫‰∫ÜÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂÜô‰∫Ü‰∏Ä‰∏™ \(\mathcal O(n\log n) - \mathcal O(1)\) lca„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆÔºå‰∏ÄÊù°ÈìæÔºåÂèØ‰ª•ÁúãÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÔºåÊâÄ‰ª•Â∞±ÂèòÊàê‰∫Ü‰∏§ÁªÑËã•Âπ≤‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÁöÑ‰∏≤Ë¶ÅÊ±Ç lcpÔºåÂà©Áî®È¢ÑÂ§ÑÁêÜÁöÑ‰ø°ÊÅØ‰ªéÂâçÂæÄÂêé‰æùÊ¨°Ê±ÇÂ∞±Ë°å‰∫Ü„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // ÂÜô‰∏Ä‰∏™Áªô‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊîØÊåÅËØ¢ÈóÆ LCP ÁöÑ‰∏úË•ø int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind ÊòØÊ≠£‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ // rind ÊòØÂèç‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôëÊåâ‰∏≤ÈïøÊ†πÂè∑ÂàÜÁ±ª„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ§ß‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåËøôÊ†∑ÁöÑ‰∏≤‰∏ç‰ºöÂæàÂ§öÔºåÊûö‰∏æÊØè‰∏™ËøôÊ†∑ÁöÑ‰∏≤ÔºåÁî® AC Ëá™Âä®Êú∫ÁªüËÆ°ÂÖ∂‰ªñÊØè‰∏™‰∏≤‰Ωú‰∏∫Ëøô‰∏™‰∏≤Â≠ê‰∏≤Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÆó‰∏Ä‰∏ãÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÂõûÁ≠î‰∏Ä‰∏ãÂÖ≥‰∫éËøô‰∏™‰∏≤ÁöÑÊâÄÊúâËØ¢ÈóÆ„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ∞è‰∫éÁ≠â‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåÊääËØ¢ÈóÆ \([l,r]\) ÊãÜÊàê \([1,r]\) Âíå \([1,l-1]\) Áõ∏ÂáèÔºåÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÊØè‰∏™ÂâçÁºÄÔºåÂõûÁ≠î‰∏éÊØè‰∏™ÂâçÁºÄÁõ∏ÂÖ≥ÁöÑÊâÄÊúâÂõûÁ≠î„ÄÇÂú®Êâ´ÂâçÁºÄÁöÑËøáÁ®ã‰∏≠ÔºåÁî®‰∏Ä‰∏™ AC Ëá™Âä®Êú∫ \(\mathcal O(‰∏≤Èïø)\) ËØ¢ÈóÆËøô‰∏™ÂâçÁºÄ‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êüê‰∏™‰∏≤ÁöÑÂ≠ê‰∏≤Âç≥ÂèØ„ÄÇÈÇ£‰πàÂè™ÈúÄË¶ÅÂú® AC Ëá™Âä®Êú∫‰∏äÂÆûÁé∞‰∏Ä‰∏™ fail Ê†ë‰∏äÁöÑÂ≠êÊ†ëÂä†ÔºàÂä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑ‰∏≤ÔºâÔºåÂú® dfs Â∫è‰∏äËΩ¨‰∏∫Âå∫Èó¥Âä†ÔºåÁî®ÂàÜÂùóÂÅöÂà∞ \(\mathcal O(\sqrt n)\) Âå∫Èó¥Âä†Ôºå \(\mathcal O(1)\) ÂçïÁÇπËØ¢ÈóÆÂ∞±Ë°å‰∫Ü„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÂèØ‰ª•‰∫åÂàÜÁ≠îÊ°àÔºåËΩ¨Âåñ‰∏∫ËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºöÊØè‰∏™ËæπÁöÑËæπÊùÉÊòØÊ≠£Ë¥ü‰∏ÄÔºåÂà§Êñ≠ÊòØÂê¶ÊúâÈïøÂ∫¶Âú® \(l\) Âà∞ \(r\) ‰πãÈó¥ÁöÑË∑ØÂæÑÔºåÊùÉÂÄº‰πãÂíåÈùûË¥ü„ÄÇ ‰ªé‰∏ãÂæÄ‰∏äÂêàÂπ∂ÔºåÊØèÊ¨°ËÄÉËôëÂΩìÂâçÁÇπ‰Ωú‰∏∫ lca ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊääÂ≠êÊ†ëÂêàÂπ∂ÔºåÁî±‰∫é‰Ω†ÂêàÂπ∂Êó∂Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁÇπÂ≠êÊ†ë‰∏≠ÊØè‰∏™Ê∑±Â∫¶Âà∞Ê†πÊùÉÂÄºÂíåÊúÄÂ§ßÁöÑÁÇπÔºåÂèØ‰ª•Áî®ÈïøÈìæÂâñÂàÜÊù•Áª¥Êä§Ê∑±Â∫¶‰ø°ÊÅØ„ÄÇÂêàÂπ∂ÁöÑÊó∂ÂÄôÈ°∫‰æøËØ¢ÈóÆ‰∏Ä‰∏ãÁ≠îÊ°àÔºåÈïøÈìæÂâñÂàÜ + Á∫øÊÆµÊ†ëÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÈïøÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁÇπÂàÜÊ≤ª‰∏Ä‰∏ãÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãÈóÆÈ¢òÔºö Êúâ‰∏§‰∏™Èïø‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a_1\) Âíå \(d_1\)Ôºå‰∏§‰∏™Èïø‰∏∫ \(m\) ÁöÑÊï∞ÁªÑ \(a_2\) Âíå \(d_2\)ÔºåÊ±ÇÔºö \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] Êûö‰∏æ‰∏Ä‰∏ã \(i\)ÔºåÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂΩ¢Â¶Ç \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) ÁöÑ‰∏úË•ø„ÄÇ Ê≥®ÊÑèÂà∞ \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) ËÆæ \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) ÊòØÂæàÂÆπÊòìÂ§ÑÁêÜÁöÑÔºåÂè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(1\ldots m\) ‰∏≠ÁöÑÊï∞ \(i\) ËÄÉËôë \(d_2[i]\phi(a_2[i])\) ÂØπÊØè‰∏™ \(s\) ‰∏≠ \(i\) ÁöÑÁ∫¶Êï∞‰∏ãÊ†á‰ΩçÁΩÆÁöÑË¥°ÁåÆÂç≥ÂèØ„ÄÇ Â¶ÇÊûúÊö¥ÂäõËÆ°ÁÆó‰∏äÂºèÔºåÂ§çÊùÇÂ∫¶‰∏∫ \(1 \ldots n\) ‰∏≠ÊØè‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞‰πãÂíå‰πò‰ª•ÁÇπÂàÜÊ≤ªÁöÑ‰∏Ä‰∏™ \(\log\)„ÄÇÂâçÈù¢ÁöÑÈÉ®ÂàÜÂ§çÊùÇÂ∫¶ÊòØ \(\log^2\) ÁöÑÔºàËÄÉËôë \((\sum \frac 1 i )^2\)ÔºâÔºå‰ªéËÄåÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\log^3 n)\)„ÄÇ ÁªßÁª≠ÂØπ‰∏äÂºèÂèòÂΩ¢Ôºö ËÆæ \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)Ôºå\(t_k\) ÊòØ‰∏Ä‰∏™Â∏∏Êï∞„ÄÇ \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] ËÄÉËôëÂØπ \(t\) ËøõË°åÈ¢ÑÂ§ÑÁêÜ„ÄÇ\(t\) ÊòØ‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞ÔºàÂõ†‰∏∫ÂÆÉÊòØ‰∏§‰∏™ÁßØÊÄßÂáΩÊï∞ÁöÑÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºâÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•ÊääÂÆÉÁ≠õÂá∫Êù•„ÄÇ ‰ΩÜÊòØÂõ†‰∏∫ÊàëÊáíÔºåÊàëÈÄâÊã©Áõ¥Êé•Êö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(t\)ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;„ÄÇÔºå &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Êï∞ËÆ∫</tag>
        <tag>ÁÇπÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Èöè‰æøÂèñ‰∏Ä‰∏™ÁÇπ‰ΩúÊ†πÔºåÁî®Á∫øÊÆµÊ†ëÊåâ dfs Â∫èÁª¥Êä§Â≠òÂú®ÁöÑÁÇπÔºåÁª¥Êä§‰∏Ä‰∏ãÊâÄÊúâÂ≠òÂú®ÁöÑÁÇπÁöÑ lca ÂíåÂà∞Ê†πÁöÑË∑ØÂæÑÁöÑÂπ∂ÁöÑÈïøÂ∫¶Âç≥ÂèØ„ÄÇ ËØØ‰ª•‰∏∫Ë¶ÅÂáèÂéªÁÇπÊï∞ * lca ÁöÑÊ∑±Â∫¶ÔºåË∞É‰∫ÜÂ•Ω‰πÖ... ‰∏ÄÁõ¥Ë∞É‰∏çÂá∫Êù•ÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•‰∏Ä‰∏ãÊòØ‰∏çÊòØÂì™ÈáåÊÉ≥Èîô‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈúÄË¶ÅÁªèÂ∏∏Â§ç‰π†ÁöÑ‰∏úË•ø]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÊÑüËßâËá™Â∑±ËÄÉËØïÁöÑÊó∂ÂÄôÂæàÈöæÁã¨Á´ãÊÉ≥Âá∫Êù•‰ΩÜÊòØÂèàÁªèÂ∏∏‰ºöÂøòÁöÑ‰∏úË•ø„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπËßÅ ËøôÁØá blogÔºåËÄÉÂâçÂ§ç‰π†Áî®„ÄÇ Ê•ºÊàøÈáçÂª∫ÁöÑÂÅöÊ≥ï (2020.03.09) ÊîØÈÖçÊ†ë ‰ºØÂä™Âà©Êï∞‰∏éËá™ÁÑ∂Êï∞ÂπÇÂíå Ëá™ÁÑ∂Êï∞ÁöÑÔºàÂèØÈáç / ‰∏çÂèØÈáçÔºâÊó†Â∫èÊãÜÂàÜÔºöÊ†πÂè∑ÂÅöÊ≥ï‰∏é \(\log\) ÂÅöÊ≥ï jlsÁ∫øÊÆµÊ†ë ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó‰∏éÁ±ªÊ¨ßÂá†ÈáåÂæó Â§ÑÁêÜÂàÜÊØçÁ≠âÂ∑ÆÁîüÊàêÂáΩÊï∞ÁöÑÊñπÊ≥ï ‰Ω†ÁöÑÂêçÂ≠ó ÈÇ£‰∏™È¢òÁöÑÂÅöÊ≥ï ÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÊãìÊâëÂ∫è(ÊåáÊåâÁºñÂè∑‰ªéÂ∞èÂà∞Â§ßÊääÊØè‰∏™ÁÇπÂú®ÊãìÊâëÂ∫è‰∏äÁöÑ‰ΩçÁΩÆÂÜô‰∏ãÊù•ÁöÑÂ∫èÂàó)ÔºåËßÅ agc001_f Âà©Áî®Êó∂Èó¥Êà≥Á∫øÊÄßÂü∫ (ÊåâÊØè‰∏™ÂÖÉÁ¥†Ë¢´Âà†Èô§ÁöÑÊó∂Èó¥) ÂÆûÁé∞Á¶ªÁ∫øËøõË°å‰∏çÂ∏¶ log ÁöÑÁ∫øÊÄßÂü∫ÊèíÂÖ•Âà†Èô§ Âà§Á∫øÊÄßÊó†ÂÖ≥Êó∂ÊääÂÆûÊï∞ÊîπÊàêÂèñÊ®°Âπ∂‰∏ç‰ºöÊúâÂ§™Â§ßÊçüÂ§±ÔºåÁ±ª‰ººÂìàÂ∏åÔºàÈÄêÊ≠•ËÄÉËôëÁü©ÈòµÁöÑÂèòÂåñ~ÔºåÂÖ∂ÂÆûÂè™Ë¶Å‰∏çÂá∫Áé∞Ê®°Êï∞ÂÄçÊï∞Â∞±Ë°å Èìæ‰∏äËØ¢ÈóÆ / Âå∫Èó¥ËØ¢ÈóÆÂ∞è‰∫éÁ≠â‰∫é \(k\) (k ÊØèÊ¨°ÁªôÂÆö) ÁöÑÂÖÉÁ¥†ÁöÑ‰ø°ÊÅØ (‰∏çÂèØÂáè)ÔºåÊúâÂäûÊ≥ï‰∏Ä‰∏™ \(\log\) ÁÇπÂèåËÅîÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï (ÂÜô‰∫ÜÁØáÂÖ¨ÂºÄ blog) ‰∏ÄÁ±ª‰∫åÂàÜÂá∏‰ºòÂåñËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ï ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÂÖ∂Êâ©Â±ï ËÆ∞ÂæóÂç∑ÁßØÂΩ¢ÂºèÁöÑ dp ÂèØ‰ª•ÂàÜÊ≤ª fft ‰ºòÂåñ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éÂõûÊªöÊìç‰ΩúÁöÑÊäÄÂ∑ßÂú®ÈúÄË¶ÅÂõûÊªöÁöÑÊï∞ÁªÑÊØîËæÉÂ§öÁöÑÊó∂ÂÄô‰∏Ä‰∏™‰∏Ä‰∏™ÂºÄÊ†àÂõûÊªö‰ºöÊØîËæÉÈ∫ªÁÉ¶ÔºåÂèØ‰ª•ËØïÁùÄ‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; ËøôÊ†∑ËøòÂéüÁöÑÊó∂ÂÄô‰πüÂè™ÈúÄË¶ÅÊ†πÊçÆÊåáÈíàÊêû‰∏ÄÊêûÂ∞±Â•ΩÔºåÂè™ÈúÄË¶ÅÂºÄ‰∏Ä‰∏™Ê†àÂ∞±Ë°å‰∫ÜÔºåÊ≥®ÊÑè \(k\) ‰∏çË¶ÅÂºÄÂ∞è„ÄÇ ÊúâÊó∂ÂÄô‰Ω†ÈúÄË¶ÅËÆ∞ÂΩï‰∏Ä‰∏™ÊîØÊåÅÈöèÊó∂Ê∏ÖÁ©∫ÁöÑ \(01\) Êï∞ÁªÑÔºåËøôÊó∂ÂèØ‰ª•‰∏çÈ¢ùÂ§ñÂºÄÊ†áËÆ∞Êï∞ÁªÑ„ÄÇËÆ∞‰∏Ä‰∏™ÂèòÈáè \(tim\)ÔºåËµã \(1\) ÁöÑÊó∂ÂÄôÂ∞±ËÆæ‰∏∫ \(tim\)ÔºåÂà§Êñ≠ÊòØ \(0\) ËøòÊòØ \(1\) Â∞±ÁúãÊòØÂê¶Á≠â‰∫é \(tim\)ÔºåÊ∏ÖÁ©∫Â∞± \(tim \leftarrow tim + 1\)„ÄÇ ‰∏ä‰∏ãÁïåË¥πÁî®ÊµÅÔºåÂØπÊØèÊù°ÂøÖÈ°ªËæπ‰∏çË¶ÅÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂØπÊØè‰∏Ä‰∏™ÁÇπËÆ∞‰∏Ä‰∏™Â∫¶Êï∞ÔºåÂÖ®ÈÉ®Ê∑ªÂä†‰πãÂêéÂÜçÊ†πÊçÆÂ∫¶Êï∞ÂÜ≥ÂÆöÊØè‰∏™ÁÇπÂà∞Ë∂ÖÁ∫ßÊ∫êËøòÊòØË∂ÖÁ∫ßÊ±áÔºåËøûÂ§öÂ§ßÊµÅÈáèÁöÑËæπÔºåËøôÊ†∑ÂèØ‰ª•Â§ßÂ§ßÂáèÂ∞ëËæπÊï∞„ÄÇ Âú®ÂÅö dinic Êó∂‰ª•‰∏ã‰∏§‰ªΩ‰ª£Á†ÅÊúâÂ∑®Â§ßÂ∏∏Êï∞Â∑ÆË∑ùÔºå‰∏ãÈù¢ÁöÑÊúâÊó∂ÁîöËá≥ÂèØ‰ª•ÊØî‰∏äÈù¢ÁöÑÂø´ÂçÅÂÄçÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà„ÄÇ 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊääÊìç‰ΩúÁ¶ªÁ∫øÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºåÊääÈóÆÈ¢òÂèòÊàêÂè™ÈúÄË¶ÅÊîØÊåÅÂä†ËæπÔºåÂõûÊªöÔºåÁª¥Êä§‰∏§ÁÇπÈó¥ÊúÄÂ∞è \(xor\) Ë∑ØÂæÑ„ÄÇ Âú®ËØ¢ÈóÆ \(u,v\) ‰∏≠Ôºå‰Ω†ÂèØ‰ª•‰ªé \(u\) Ëµ∞Âà∞ \(t\) ÁÑ∂ÂêéËµ∞Âõû \(u\)ÔºåË∑ØÂæÑ‰∏äÊØèÊù°ËæπÈÉΩË¢´ÁªèËøá‰∏§Ê¨°ÔºåÊâÄ‰ª•Ë∑ØÂæÑ‰∏äÁöÑËæπË¥°ÁåÆ‰∏∫ \(0\)„ÄÇÂõ†Ê≠§Â¶ÇÊûúÊúâ‰∏ÄÊù° \(xor\) ‰∏∫ \(x\) ÁöÑ \(u,v\) Ë∑ØÂæÑÔºåÊúâ‰∏Ä‰∏™ \(xor\) ‰∏∫ \(c\) ÁöÑÁéØÔºåÂ∞±Â≠òÂú®‰∏ÄÊù° \(xor\) ‰∏∫ \(x\oplus c\) ÁöÑË∑ØÂæÑ„ÄÇ ‰ªªÊÑèËÄÉËôë‰∏ÄÊ£µÁîüÊàêÊ†ëÔºåÂØπ‰∫é‰∏Ä‰∏™ÈùûÊ†ëËæπ \(u,v,w\)ÔºåËÆæ \(u\) Âà∞ \(v\) ÁöÑÊ†ë‰∏äË∑ØÂæÑ \(xor\) ‰∏∫ \(x\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ \(xor\) ‰∏∫ \(x \oplus w\) ÁöÑÁéØÔºåÂõ†Ê≠§Â¶ÇÊûúÁªèËøá‰∫ÜËøôÊù°ÈùûÊ†ëËæπÔºåÊàë‰ª¨‰∏çÂ¶®ÊääÂÆÉÁúãÊàêÊòØÊ≤øÁùÄÊ†ë‰∏äË∑ØÂæÑ‰ªé \(u\) Ëµ∞Âà∞ \(v\)„ÄÇ‰πãÂêéÂÜçÂºÇÊàñ‰∏äËøô‰∏™Êç¢ÁöÑÊùÉÂÄº„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÊää \(u\) Âà∞ \(v\) ‰πãÈó¥ÁöÑÊ†ë‰∏äË∑ØÂæÑÂºÇÊàñ‰∏ä‰∏Ä‰∫õÁî±‰∏ÄÊù°ÈùûÊ†ëËæπ‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\)ÔºåÁ≠îÊ°àÊúÄÂ∞èÊòØ‰ªÄ‰πà„ÄÇ Áª¥Êä§ÊâÄÊúâÈùûÊ†ëËæπÂä†‰∏ä‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\) ÁöÑÁ∫øÊÄßÂü∫Âç≥ÂèØ„ÄÇ ÁÑ∂ÂêéËÄÉËôëÊÄé‰πàÂä†ËæπÁª¥Êä§Ëøô‰∏™‰∏úË•ø„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂõûÊªöÔºåÂùáÊëäÁÆóÊ≥ïÔºàÂ¶Ç LCTÔºåË∑ØÂæÑÂéãÁº©ÁöÑÂπ∂Êü•ÈõÜÔºâÊó†Ê≥ï‰ΩøÁî®„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊîØÊåÅËØ¢ÈóÆ‰∏§ÁÇπÊòØÂê¶ËøûÈÄöÔºåËØ¢ÈóÆ‰∏§ÁÇπ‰πãÈó¥ÁöÑ \(xor\)ÔºåÂä†ËæπÂíåÂõûÊªöÂç≥ÂèØ„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁªôÁÇπ \(i\) Áª¥Êä§‰∏Ä‰∏™ÂÄº \(v_i\)ÔºåÂàùÂßãÊó∂ÊâÄÊúâÁÇπÁöÑÂÄº \(=0\)ÔºåÁî®ÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÊù•Áª¥Êä§ËøûÈÄöÊÄß„ÄÇÊàë‰ª¨ÂßãÁªàË¶Å‰øùËØÅÂØπ‰∫é‰ªªÊÑèÁöÑ \(u,v\)ÔºåÂ¶ÇÊûú \(u,v\) ËøûÈÄöÔºåÈÇ£‰πà \(u,v\) ‰πãÈó¥Ê†ë‰∏äË∑ØÂæÑÁöÑ \(xor\) Á≠â‰∫é \(v_u \oplus v_v\)„ÄÇÊØèÊ¨°Âä†ËæπÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰∏§‰∏™ËøûÈÄöÂùóÂπ∂Êàê‰∫Ü‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†ÂèØ‰ª•ÈÄöËøáÊääÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑ \(v_i\) ÂºÇÊàñ‰∏ä‰∏Ä‰∏™Êï∞Êù•‰øùÊåÅËøô‰∏ÄÊÄßË¥®„ÄÇÊåâÁß©ÂêàÂπ∂Êó∂Êâì‰∏™ tag Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å ËøôÊ¨°Â∞ùËØï‰∫Ü‰∏ÄÁßçÊñ∞ÁöÑÁ†ÅÈ£é„ÄÇÁúã‰∏äÂéªÂ≠óÁ¨¶ÈáèÂ∞ë‰∫Ü‰∏çÂ∞ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // ÂáÜÂ§áÂ∑¶Âå∫Èó¥ for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // ÂáÜÂ§áÂè≥Âå∫Èó¥ for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊÑüËßâÊØî E È¢òÈöæ‰ΩÜÊòØËøáÁöÑ‰∫∫ËøúÊØî E È¢òÂ§ö... ‰∏çÁü•ÈÅì piece ÊÄé‰πàÁøªËØëÔºåÂêéÈù¢Áî®Áü≥Â≠ê‰ª£Êåá piece„ÄÇ ÂÖàÊûö‰∏æ‰∏Ä‰∏™ÁÇπ \(r\)ÔºåÁÑ∂ÂêéËÄÉËôëÊääÊâÄÊúâÁü≥Â≠êÈÉΩÁßªÂä®Âà∞ÁÇπ \(r\) ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÊää \(r\) ‰Ωú‰∏∫Ê†πÔºåËÄÉËôëÊØè‰∏™Áü≥Â≠êÂà∞ \(r\) ÁöÑË∑ùÁ¶ª‰πãÂíå \(s\)ÔºåÊòæÁÑ∂Êìç‰Ωú‰∏ç‰ºöÊîπÂèò \(s\) ÁöÑÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Â¶ÇÊûú \(s\) ÊòØÂÅ∂Êï∞Ôºå‰∏çÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°à„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°àÔºåÈÇ£‰πàÊúÄÂ∞ëÊ≠•Êï∞ÂøÖÁÑ∂ÊòØ \(\frac s 2\)ÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰∏™ÊñπÊ°à‰∏≠Êúâ‰∏ÄÊ¨°‰Ωø‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ∞èÔºåÂè¶‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ§ßÔºå‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏Ä‰∏™Ê≠•Êï∞Êõ¥Â∞ëÁöÑÁöÑÊñπÊ°à„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âè™ÈúÄËÄÉËôëÂ¶Ç‰ΩïÊ£ÄÈ™åÊñπÊ°àÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™ËÄÉËôë‰∏Ä‰∏™Â≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºå‰∏çÈöæÂèëÁé∞ÊúÄ‰ºòÊñπÊ°à‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏ÄÁßçÂÖàËøõË°åÂÆåÂÖ®Âú®Êüê‰∏™ÂÑøÂ≠êÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÔºåÂÜçËøõË°å‰∏§‰∏™Áü≥Â≠êÂú®‰∏çÂêåÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÁöÑÊñπÊ°à„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂÅöÊ†ëÂΩ¢ dpÔºåËÆæ \(f_{ij}\) Ë°®Á§∫ÊòØÂê¶ÂèØ‰ª•ÂØπ \(i\) ÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÁü≥Â≠êËøõË°åÊìç‰ΩúÔºå‰ΩøÂæó \(i\) Â≠êÊ†ëÂÜÖÈÉ®Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ª‰πãÂíå‰∏∫ \(j\)„ÄÇËÄÉËôëÊÄé‰πàËΩ¨ÁßªÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∫ÜÁÇπ \(u\) ÊØè‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºåÁªèËøáËøô‰∫õÊìç‰ΩúÊó∂ÂÄôÁ¨¨ \(i\) ‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÁü≥Â≠êÂà∞ \(u\) Ë∑ùÁ¶ª‰πãÂíå‰∏∫ \(s_i\)ÔºåÂÖ±Êúâ \(c\) ‰∏™ÂÑøÂ≠êÔºåËÆæ \(\max s_i = t\)ÔºåÂèØ‰ª•ËØÅÊòéÔºå\(f_{uj} = 1\)ÔºåÂΩì‰∏î‰ªÖÂΩì \(j\) ‰∏é \(\sum s_i\) Â•áÂÅ∂ÊÄßÁõ∏ÂêåÔºå‰∏î \(j \ge 2t - \sum s_i\)„ÄÇËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â§™Â§ß‰∫ÜÔºå‰∏çÈöæÂΩíÁ∫≥ËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(f_{ij} = 1\) ÁöÑ \(j\) ÂøÖÁÑ∂ÊòØÊüê‰∏™Âå∫Èó¥ÂÜÖÁöÑÊâÄÊúâÂ•áÊï∞ / ÂÅ∂Êï∞„ÄÇÂà©Áî®Ëøô‰∏™ÊÄßË¥®ÔºåÊàë‰ª¨ dp ‰ΩøÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™Âå∫Èó¥Âç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóËøô‰∏™Âå∫Èó¥ÁöÑÂè≥ËæπÁïåÊó∂ÔºåÂè™ÈúÄÊääÊâÄÊúâÂÑøÂ≠êÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁü≥Â≠êÂà∞Ëøô‰∏™ÂÑøÂ≠êÁöÑË∑ùÁ¶ª‰πãÂíåÈÉΩÂèñÂà∞ÊúÄÂ§ßÂç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóÂ∑¶ËæπÁïåÊó∂ÔºåÊûö‰∏æÂèñÂà∞Â∑¶ËæπÁïåÁöÑÊñπÊ°à‰∏≠Âì™‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) ÊúÄÂ§ßÔºåËÆ©ÂÖ∂‰ªñÂÑøÂ≠êÁöÑ \(s_i\) ÈÉΩÂ∞ΩÈáèÂ∞èÔºåËøô‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) Âú®Â§ß‰∫éÁ≠â‰∫éÂÖ∂‰ªñÂÑøÂ≠êÁöÑÂâçÊèê‰∏ãÂ∞ΩÈáèÂ∞èÔºåÊõ¥Êñ∞‰∏Ä‰∏ãÂ∑¶ËæπÁïåÂç≥ÂèØ„ÄÇÂÖ∑‰ΩìÂÆûÁé∞ÂèØ‰ª•Áúã‰ª£Á†Å„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂæàÊúâÂêØÂèëÊÄßÁöÑÈóÆÈ¢ò...ÂÅö‰∫Ü‰∏ÄÈÅçÊääÂØπ FWT ÁêÜËß£ÁöÑ‰∏çÂΩªÂ∫ïÁöÑÂú∞ÊñπÈÉΩÊêûÊ∏ÖÊ•ö‰∫Ü„ÄÇ ÂÄíËøáÊù•ÁúãÔºåËÆ°ÁÆóÊØè‰∏™Êï∞ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåÊòæÁÑ∂Á≠îÊ°àÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ È¶ñÂÖàËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Âàó \(2^n\) ÂÖÉÁ∫øÊÄßÊñπÁ®ãÁªÑÂéªËß£Ôºå‰ΩÜÊòØÊö¥ÂäõÈ´òÊñØÊ∂àÂÖÉÁöÑÂ§çÊùÇÂ∫¶Â§™È´ò‰∫Ü„ÄÇ Êàë‰ª¨ËÆæ \(f_i\) Ë°®Á§∫ \(i\) ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞Ôºå\(p_i\) Ë°®Á§∫ÈöèÊú∫Êï∞ÁîüÊàêÂô®ÁîüÊàê \(i\) ÁöÑÊ¶ÇÁéá„ÄÇÈÇ£‰πàÂèØ‰ª•ÂèëÁé∞ \(f\) Êï∞ÁªÑÊª°Ë∂≥ÊñπÁ®ã \(f = f\cdot p + w x^0 + \sum x^S\)„ÄÇÂÖ∂‰∏≠‰πòÊ≥ïË°®Á§∫ÈõÜÂêàÂºÇÊàñÂç∑ÁßØ„ÄÇ ÁßªÈ°πÂæóÂà∞ \((x^0-p)f = w x^0 + \sum x^S\)ÔºåÂØπ‰∏§ËæπÂêåÊó∂ FWTÔºåÂæó \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)„ÄÇÊòæÁÑ∂ \(\hat{p}_{0} = \sum p_S= 1\)Ôºå‰ªéËÄå \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)ÔºåËøôÂ∞±Êé®Âá∫‰∫Ü \(w = -2^n\)„ÄÇÊòæÁÑ∂ \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)Ôºå‰ªéËÄåÂèØ‰ª•Êé®Âá∫ \(\hat{f}_S\) ÁöÑÂÄº„ÄÇÊé•‰∏ãÊù•ÔºåÂè™Ë¶ÅÁü•ÈÅì \(\hat f_0\) Â∞±ÂèØ‰ª• IFWT Âá∫ \(f\) ‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞Ôºå\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)ÔºåÂè™ÈúÄÈöè‰æøÁªô \(\hat f_0\) ËÆæ‰∏Ä‰∏™ÂÄºÔºåÁÑ∂Âêé IFWT Âá∫‰∏Ä‰∏™Êï∞ÁªÑ \(f\)ÔºåÂØπÊØè‰∏™ \(i\) Êää \(f_i\) ÂáèÂéª \(f_0\) Âç≥ÂèØ„ÄÇÔºàËøôÈáåÁî®Âà∞‰∫Ü \(f_0 = 0\) ÁöÑÊù°‰ª∂Ôºâ Ê®°Êï∞ÂÜôÊàê \(10^9+7\) ËøòË∞É‰∫ÜÂ•Ω‰πÖ...ÊàëÁúüÁöÑÊòØ zz„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc È¢òÂè∑ÂæàÁ•ûÂ•á...‰ª•ÈìæÊé•‰∏≠ÁöÑ‰∏∫ÂáÜ„ÄÇ È¢òËß£ ÁªôÁÇπ \(i\) ‰∏Ä‰∏™ÊùÉÈáç \(w_i\)ÔºåÈáçÊñ∞ÂÆö‰πâ \(D_i = \sum_k w_k dis(i,k)\)„ÄÇÂàùÂßãÊó∂ÂØπ‰∫éÊâÄÊúâÁöÑ \(i\)Ôºå\(w_i = 1\)„ÄÇ‰ªªÊÑèÊó∂ÂàªÔºå\(\sum_i w_i = n\)„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁÇπ \(v\) ‰∏éÁÇπ \(u\) Áõ∏ÈÇªÔºå‰ª•ÁÇπ \(u\) ‰∏∫Ê†πÊó∂ÁÇπ \(v\) ÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáç‰πãÂíå‰∏∫ \(s\)ÔºåÂàô \(D_v - D_u = n - 2s\)„ÄÇ ÊâæÂà∞ \(D_u\) ÊúÄÂ§ßÁöÑÁÇπ \(u\)ÔºåÁî±‰∫é‰ªª‰Ωï‰∏é \(v\) Áõ∏ÈÇªÁöÑÁÇπÈÉΩÊª°Ë∂≥ \(D_v - D_u \le 0\)ÔºåÊâÄ‰ª•‰ª• \(u\) ‰∏∫Ê†π \(v\) Â≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáçÂíåËá≥Â∞ë‰∏∫ \(\frac n 2\)ÔºåÊâÄ‰ª• \(u\) Ëá≥Â§öÊúâ‰∏Ä‰∏™Áõ∏ÈÇªÁÇπ„ÄÇÊàë‰ª¨‰∏çËÄÉËôë \(n = 1\) ÁöÑÊÉÖÂÜµ„ÄÇ\(u\) ÊòØ‰∏Ä‰∏™Âè∂Â≠ê„ÄÇ ÂÅáËÆæ‰∏é \(u\) Áõ∏ÈÇªÁöÑÁÇπÊòØ \(f\)ÔºåÈÇ£‰πà \(D_f-D_u = 2w_u - n\)ÔºåÁî±‰∫é \(D_i\) ‰∫í‰∏çÁõ∏ÂêåÔºåËøôÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü \(u\) ÁöÑÁà∂‰∫≤ \(f\)„ÄÇÊàë‰ª¨ËÆ∞ÂΩï‰∏Ä‰∏ãÁÇπ \(u\) ÂíåÁÇπ \(f\) Ëøû‰∏ÄÊù°ËæπÔºåÊääÁÇπ \(f\) ÁöÑÊùÉÈáçÂä†‰∏äÁÇπ \(u\) ÁöÑÊùÉÈáçÔºåÁÑ∂ÂêéÊääÁÇπ \(u\) Âà†Âéª„ÄÇËøôÊ†∑ÂØπËøòÂú®Ê†ë‰∏äÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÁÇπ \(i\)ÔºåÁªèËøáËøôÊ¨°Êìç‰Ωú \(D_i\) ÊÅ∞Â•ΩÂáèÂ∞ë‰∫Ü \(w_u\)„ÄÇÊõ¥Êñ∞‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰∏ÄÁõ¥ËøôÊ†∑Êìç‰Ωú‰∏ãÂéªÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü‰∏ÄÊ£µÊ†ëÔºåÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÔºàÊáíÂæóÂà§ÁâπÊÆäÊÉÖÂÜµÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõÈ™åËØÅ‰∫ÜÔºâ ÂÆûÈôÖ‰∏ä‰∏çÈúÄË¶ÅÊõ¥Êñ∞ \(D_i\)ÔºåÂõ†‰∏∫ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØÊï¥‰ΩìÂä†ÔºåËÄåÊàë‰ª¨ÂßãÁªàÂè™‰ºöÁî®Âà∞ \(D_i\) ÁöÑÁõ∏ÂØπÂ§ßÂ∞èÂÖ≥Á≥ªÂíå \(D_f-D_u\) ÁöÑÂÄº„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ËÆæ \(f_{ij}\) Ë°®Á§∫ \(A_i &lt; A_j\) ÁöÑÊ¶ÇÁéá„ÄÇ ÊØèÊ¨°‰øÆÊîπ \(\mathcal O(n)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ ÊúÄÂêéÊ±ÇÂá∫ÈÄÜÂ∫èÂØπ‰∏™Êï∞ÁöÑÊúüÊúõÔºå‰πò‰ª• \(2^q\) Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÁªìËÆ∫ÔºåÊääËæìÂÖ•ÁöÑÊï∞ÁªÑÁúã‰Ωú \(n\) ‰∏™Ê†ºÂ≠êÔºåÊØè‰∏™Ê†ºÂ≠êÈáåÂ°´‰∫Ü‰∏Ä‰∏™Êï∞Â≠ó„ÄÇÂØπÊ†ºÂ≠êÈªëÁôΩÊüìËâ≤ÔºåÁ¨¨‰∏Ä‰∏™Ê†ºÂ≠êÊòØÈªëËâ≤ÔºåÁõ∏ÈÇª‰∏§‰∏™Ê†ºÂ≠êÈ¢úËâ≤‰∏çÂêå„ÄÇ ‰∏çÈöæÂèëÁé∞ÁªìËÆ∫ÔºöÂ¶ÇÊûú \(n\) ‰∏∫ÂÅ∂Êï∞ÔºåÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÂæóÂà∞ÁöÑÊî∂ÁõäÊòØÈªëÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏éÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíåÁöÑÊúÄÂ§ßÂÄº„ÄÇÂ¶ÇÊûú \(n\) ‰∏∫Â•áÊï∞ÔºåËÆæÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏∫ \(s\)ÔºåÂÖàÊâãËÉΩÂ§üËé∑ÂæóËá≥Â∞ë \(x\) ÁöÑÊî∂ÁõäÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏ÄÁßçÈÄâÂá∫Ëã•Âπ≤‰∏™ÁôΩÊ†ºÂ≠êÁöÑÊñπÊ°àÔºåÁî®Ëøô‰∫õÁôΩÊ†ºÂ≠êÊää \(n\) ‰∏™Ê†ºÂ≠êÂàÜÊàêËã•Âπ≤‰∏™ËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÂÜÖÈªëÊ†ºÂ≠êÁöÑÂíåÂáèÂéªÁôΩÊ†ºÂ≠êÁöÑÂíåÈÉΩÂ§ß‰∫éÁ≠â‰∫é \(x-s\)„ÄÇ ËØÅÊòéÊØîËæÉÊòæÁÑ∂ÔºåÂÖ∑‰ΩìËøáÁ®ã‰∏çÂÜôÂá∫‰∫Ü„ÄÇÂ§ßÊ¶ÇÊÄùË∑ØÂ∞±ÊòØË¶ÅËØÅÊòéÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÁöÑÊî∂ÁõäÊòØ \(x\)ÔºåÂè™ÈúÄÂÖàÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•ÔºåÊó†ËÆ∫ÂêéÊâãÊÄé‰πàÊìç‰ΩúËá≥Â∞ëËÉΩÂ§ü \(x\) ÁöÑÊî∂ÁõäÔºåÂêéÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•Êó†ËÆ∫ÂÖàÊâãÊÄé‰πàÊìç‰Ωú‰∏ÄÂÆöËÉΩ‰ΩøÂÖàÊâãËé∑ÂæóËá≥Â§ö \(x\) ÁöÑÊî∂Áõä„ÄÇ\(n\) ‰∏∫Â•áÊï∞Áõ¥Êé•ÂÅöÔºå\(n\) ‰∏∫ÂÅ∂Êï∞‰∫åÂàÜ dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂèØ‰ª•ÂèëÁé∞ÔºåÂÅáËÆæÊúÄÁªàËÉΩÂèòÊàê 0ÔºåÂ¶ÇÊûúÊúâ 000ÔºåÁ¨¨‰∏ÄÊ≠•Êìç‰ΩúÊääÂÆÉÂèòÊàê 0 ‰∏ÄÂÆöÊúÄÁªà‰ªçÁÑ∂ËÉΩÂèòÊàê 0„ÄÇËøôÊòØÂõ†‰∏∫ÔºåÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™Á¨¨‰∏ÄÊ≠•‰∏çÊòØÂØπËøô‰∏â‰∏™Êï∞Êìç‰ΩúÔºåËÄÉËôëÁ¨¨‰∏ÄÊ¨°ÂΩ±ÂìçÂà∞Ëøô‰∏â‰∏™Êï∞‰∏≠Êüê‰∏™Êï∞ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøô‰∏™Êìç‰ΩúÂ∞±ÊòØÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0ÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ÊääËøôÊ¨°Êìç‰ΩúÁßªÂä®Âà∞Á¨¨‰∏ÄÊ¨°Êìç‰Ωú„ÄÇÂê¶ÂàôÁöÑËØùÔºåÈÇ£‰πàÊääËøôÊ¨°Êìç‰ΩúÊîπ‰∏∫ÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0 ËÇØÂÆö‰∏ç‰ºöÊõ¥Âä£„ÄÇÔºàÂõ†‰∏∫ÊääÂ∫èÂàó‰∏äÁöÑ‰∏Ä‰∏™ 0 Êîπ‰∏∫ 1 ÂæóÂà∞ÁöÑÂ∫èÂàó‰∏ÄÂÆö‰∏ç‰ºöÊõ¥Âä£ÔºâÁî®Á±ª‰ººÁöÑÊÄùË∑ØÂèØ‰ª•ËØÅÊòéÔºåÂ¶ÇÊûúÊúâ 010ÔºåÁ¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 0 ‰πü‰∏ç‰ºöÊõ¥Âä£ÔºåÂ¶ÇÊûúÊúâ 101 Á¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 1 ‰πü‰∏ç‰ºöÊõ¥Âä£„ÄÇ ËÄÉËôë‰∏Ä‰∏™Â∫èÂàóÔºåÂèçÂ§çËøõË°å‰ª•‰∏ä‰∏âÁßçÊìç‰ΩúÁõ¥Âà∞‰∏çËÉΩÊìç‰ΩúÔºåÊääÂæóÂà∞ÁöÑÂ∫èÂàóÂàíÂàÜ‰∏∫Ëã•Âπ≤‰∏™ 0 / 1 ÁöÑËøûÁª≠ÊÆµÔºåÈô§‰∫ÜÂºÄÂ§¥ÂíåÁªìÂ∞æÁöÑËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ \(2\)Ôºå‰∏î 0 ÁöÑËøûÁª≠ÊÆµÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá \(2\)„ÄÇÊòæÁÑ∂Êää 111 ÂèòÊàê 1 ÊòØ‰∏ç‰ºòÁöÑ„ÄÇ‰∏çÈöæÁî®ÂΩíÁ∫≥Ê≥ïËØÅÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÔºåÈÉΩ‰∏ç‰ºöÂá∫Áé∞ 000„ÄÇÔºàËÄÉËôëÂú®ËøõË°å‰∏ÄÊ≠•Êìç‰Ωú‰πãÂêéÔºåÂà©Áî® 010 Âèò‰∏∫ 0 ÁöÑÁªìËÆ∫ÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰ΩúÔºåËøôÊ†∑Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™Êõ¥Áü≠ÁöÑÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºâËÄåÂÖ∂‰ªñÊìç‰ΩúÈÉΩ‰ºö‰Ωø 0 ÁöÑ‰∏™Êï∞Âíå 1 ÁöÑ‰∏™Êï∞ÂêåÊó∂ÂáèÂ∞ë 1„ÄÇËøôÂ∞±ËØ¥ÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÊúÄÁªàËÉΩÂèòÊàê 1ÔºåÂΩì‰∏î‰ªÖÂΩì 1 ÁöÑ‰∏™Êï∞Â§ß‰∫é 0 ÁöÑ‰∏™Êï∞„ÄÇÔºàÈïøÂ∫¶ÂøÖ‰∏∫Â•áÊï∞Ôºâ ÂØπËøô‰∏™‰∏úË•ø dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂâçÁºÄ 1 ÁöÑ‰∏™Êï∞ÂáèÂéª 0 ÁöÑ‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫é \(2\)ÔºåËøô‰∏™Â∫èÂàóÂøÖÁÑ∂ÂèØ‰ª•ÂèòÊàê 0„ÄÇÊâÄ‰ª•ÂÆûÈôÖÈúÄË¶ÅËÆ∞ÁöÑÁä∂ÊÄÅÊï∞ÂæàÂ∞ë„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂØπ‰∫é \(i, j\)ÔºåËÄÉËôë \(P_i &gt; P_j\) ÁöÑÊñπÊ°àÊï∞„ÄÇÂè™ÈúÄËÄÉËôë \(A_i \le A_j\) ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇËøôÁõ∏ÂΩì‰∫éÊòØÊää \(A_j\) Êîπ‰∏∫ \(A_i\) ‰πãÂêéÊª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÈôêÂà∂ÁöÑÊéíÂàóÊï∞Èô§‰ª• \(2\)„ÄÇ Êää \(1 \ldots n\) Êåâ \(A_i\) ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåËÆæÊéíÂ∫èÂêéÁ¨¨ \(i\) ‰∏™Êï∞ÊòØ \(p_i\)„ÄÇÊòæÁÑ∂Êª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÊéíÂàóÊÄªÊï∞‰∏∫ \(\prod_i A_{p_i}-i+1\)„ÄÇËÆæÊÄªÊï∞‰∏∫ \(C\)„ÄÇ ËÆæ \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) ÂØπÊâÄÊúâÊª°Ë∂≥ \(p_i &lt; p_j\) ÁöÑ \((i,j)\) ËÆ°ÁÆó \(P_{p_i} &gt; P_{p_j}\) ÁöÑÊéíÂàóÊï∞„ÄÇÂØπ‰∫éÊØè‰∏ÄÂØπ \(i &lt; j\)ÔºåÂ¶ÇÊûú \(p_i &lt; p_j\)ÔºåÈÇ£‰πàÂÆÉÁöÑË¥°ÁåÆÊòØ \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)„ÄÇ\(p_i &gt; p_j\) ÁöÑÊÉÖÂÜµÊ≤°ÊúâÂæàÂ§ßÂå∫Âà´ÔºåÂÖ∑‰ΩìÂºèÂ≠êÂ∞±‰∏çÂÜôÂá∫Êù•‰∫Ü„ÄÇÊûö‰∏æ \(j\)ÔºåÁî®Á∫øÊÆµÊ†ëÂØπÊØè‰∏™ \(p_i\) Áª¥Êä§‰∏ãËøô‰∏™ÂºèÂ≠êÔºåÊØèÊ¨°ÁßªÂä® \(j\) ÁöÑÊó∂ÂÄôÂå∫Èó¥‰πòÊõ¥Êñ∞ÔºåÁªüËÆ°Á≠îÊ°àÊó∂Âå∫Èó¥Ê±ÇÂíåÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ËÆ°Êï∞</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ update: ÊÑüËßâÊàëÂÅöÈ∫ªÁÉ¶‰∫ÜÔºåÈ¢òËß£ÂÅöÊ≥ïÂ•ΩÁÆÄÂçï„ÄÇËøôÁØá blog Â∞±‰∏¢ËøôÂêß‚Ä¶..ÊÑüËßâÊ≤°‰ªÄ‰πàÈîôËØØ„ÄÇ Â¶ÇÊûúÂè™Êää \(0\) ÂèòÊàê \(1\) ËÄå‰∏çÊää \(1\) ÂèòÊàê \(0\)Ôºå‰ºöÂØºËá¥ \(0\) ÁöÑ‰∏™Êï∞ÂáèÂ∞ëÔºåËøò‰∏çÂ¶Ç‰∏çÊîπÂèòÂéüÂ∫èÂàó„ÄÇ Â¶ÇÊûúÊó¢Âá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ‰πüÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\)ÔºåËÆæÊüê‰∏Ä‰∏™Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_1\)ÔºåÊüê‰∏Ä‰∏™Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_2\)„ÄÇ ‰∏çÂ¶®ËÆæ \(p_1 &lt; p_2\)„ÄÇÔºàÂ¶ÇÊûú \(p_1 &gt; p_2\)Ôºå‰∫§Êç¢ÂéüÂ∫èÂàóÂíåÊñ∞Â∫èÂàóÂ∞±Âíå‰∏ÄÁßç \(p_1 &lt; p_2\) ÁöÑÊÉÖÂÜµÁ≠â‰ª∑‰∫ÜÔºâ ËÆæ \(f[l,r]\) Ë°®Á§∫ÂéüÂ∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶Ôºå\(g[l,r]\) Ë°®Á§∫Êñ∞Â∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ ÂÆö‰πâ \(f[l,r] = g[l,r] = 0(l &gt; r)\)„ÄÇ ÈÇ£‰πà \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)„ÄÇ Âõ†Ê≠§Êñ∞Â∫èÂàó‰∏ä \([p_1,p_2]\) ‰∏≠ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂøÖÁÑ∂Ë¶ÅÂåÖÂê´ \(p_1\) Âíå \(p_2\)Ôºå‰ΩÜÊòØÊñ∞Â∫èÂàó‰∏ä \(p_1\) ‰ΩçÁΩÆ‰∏∫ \(1\)Ôºå\(p_2\) ‰ΩçÁΩÆ‰∏∫ \(0\)ÔºåËøôÊòØ‰∏çÂèØËÉΩÁöÑ„ÄÇ Âõ†Ê≠§ÔºåÂè™‰ºöÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆÔºå‰∏ç‰ºöÂá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ„ÄÇ ËÄÉËôëÊää‰∏Ä‰∏™‰ΩçÁΩÆÂú®ÂéüÂ∫èÂàóÂ∑¶Á´ØÊàñÂ∑¶Ëæπ‰∏ç‰∏∫ \(1\) ÁöÑ \(1\) ÂèòÊàê \(0\)Ôºå‰∏çÂØπ‰ªªÊÑèÂå∫Èó¥ÂÜÖÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàó‰∫ßÁîüÂΩ±ÂìçÁöÑÊù°‰ª∂„ÄÇ ÂÅáËÆæËøô‰∏™‰ΩçÁΩÆÊòØ \(p\)„ÄÇÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö \(p &lt; n\) ‰∏î‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(1\). \(p = n\) Êàñ‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\). ÂÖàÁúãÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ„ÄÇÊää‰ΩçÁΩÆ \(p\) ‰∏äÁöÑ \(1\) ÂèòÊàê \(0\) Áúã‰ΩúÊñ∞Â∫èÂàóÔºàÁî® \(g[l,r]\) ÊèèËø∞Êñ∞Â∫èÂàó‰∏äÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºâ„ÄÇÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)ÔºåËÄåÊñ∞Â∫èÂàó‰∏ä‰ΩçÁΩÆ \(p\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøôËØ¥Êòé \([i,p-1]\) Â≠òÂú®ÁªìÂ∞æ‰∏∫ \(0\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂç≥ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÁ≠â‰∫é \([i, p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞„ÄÇÂèØ‰ª•ËØÅÊòéËøô‰∏™Êù°‰ª∂ÂØπ‰ªªÊÑèÁöÑ \(i &lt; p\) ÈÉΩÊàêÁ´ãÁöÑÂÖÖË¶ÅÊù°‰ª∂‰∏∫ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\([i,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºöÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑÔºåÂè™ÈúÄËØÅÂÖÖÂàÜÊÄßÔºåÂÅáËÆæ \([i, p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂ§ß‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºå‰ªªÂèñ‰∏Ä‰∏™ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂÆÉÂøÖÁÑ∂ÂåÖÂê´‰∏Ä‰∏™ \(1\)ÔºåËÆæÁ¨¨‰∏Ä‰∏™ \(1\) ‰ΩçÁΩÆ‰∏∫ \(k\)ÔºåÈÇ£‰πàËøô‰∏™Â≠êÂ∫èÂàó \(k\) ‰πãÂâçÁöÑÂÖÉÁ¥†ÂÜçÊãº‰∏ä \([k,p-1]\) ‰∏≠ÊâÄÊúâÁöÑ \(0\) ÂøÖÁÑ∂ÊòØ‰∏Ä‰∏™ÂÖ® \(0\) ÁöÑ‰∏ç‰ºöÊõ¥Áü≠ÁöÑÂ≠êÂ∫èÂàóÔºàÂõ†‰∏∫ \([k,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºâÔºåËøô‰∏é‰∏çÂ≠òÂú®ÂÖ®‰∏∫ \(0\) ÁöÑ‰∏çÈôçÂ≠êÂ∫èÂàóÁüõÁõæ„ÄÇ‰∏çÈöæÈ™åËØÅËøô‰πüÊòØÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏≠ËÉΩÊää \(p\) ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂„ÄÇ Á¨¨‰∫åÁßçÊÉÖÂÜµÊòæÁÑ∂‰πüÂøÖÈ°ªË¶ÅÊª°Ë∂≥Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑÊù°‰ª∂„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÁî±‰∫é‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøòÈúÄÊª°Ë∂≥ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &gt; p\)Ôºå\([p+1,i]\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºà‰∏éÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑËØÅÊòéÁ±ª‰ººÔºåËØ¶ÁªÜËøáÁ®ãÂ∞±‰∏çÂÜô‰∫ÜÔºâ„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ë¥™ÂøÉÔºåÂØπ‰∫é‰∏Ä‰∏™‰ΩçÁΩÆÔºåÂ¶ÇÊûúÂÆÉÊòØ \(1\)Ôºå‰∏îËÉΩÂ§ü‰øùÊåÅ‰ªªÊÑèÂå∫Èó¥ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏çÂèòÂú∞Âèò‰∏∫ \(0\)ÔºåÂ∞±ÊääÂÆÉÂèòÊàê \(0\)„ÄÇ‰∏çÈöæËØÅÊòéËøôÁßçË¥™ÂøÉÊòØÊ≠£Á°ÆÁöÑÔºåËØ¶ÁªÜËØÅÊòéËøôÈáå‰∏çÂÜô‰∫Ü„ÄÇÔºàÊèêÁ§∫ÔºöËÄÉËôëÊúÄ‰ºòËß£‰∏≠ \(1\rightarrow0\) ÁöÑÊúÄÂ∞è‰ΩçÁΩÆÔºâ Âà§Êñ≠ÊòØÂê¶Â≠òÂú®ÂâçÁºÄ / ÂêéÁºÄ \(0\) ÁöÑ‰∏™Êï∞Â§ö‰∫é / Â∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºåÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÊØè‰∏™ÂâçÁºÄ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞Âáè \(1\) ÁöÑ‰∏™Êï∞ÂæàÂÆπÊòìÂú∞Â§ÑÁêÜ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[ËøòÊ≤°ÂÜôËøá„ÄÇÂ¶ÇÊûúÊúâÈîôËØØÂèØ‰ª• QQ / ËØÑËÆ∫ÂëäËØâÊàë„ÄÇ È¢òËß£ ËøôÊ†∑ÁêÜËß£Ëøô‰∏™ÈóÆÈ¢òÔºöÂàùÂßãÊó∂Êó∂Èó¥‰∏∫Á¨¨ \(0\) Áßí„ÄÇÊØèÁßí‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™ \(i\)ÔºåÁÑ∂ÂêéÊää \(a_i\) Âä†‰∏ä \(k\)ÔºåÊé•‰∏ãÊù•ÂÜçÊääÊâÄÊúâ \(a_i\) ÂáèÂéª \(1\)„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÂÅúÊ≠¢Ëøô‰∏™ËøáÁ®ãÔºåÂπ∂ÊääÂΩìÂâçÁöÑ \(a\) Êï∞ÁªÑ‰Ωú‰∏∫ÁªìÊûú„ÄÇÈóÆÂú®‰∏çÁªèËøá‰ªª‰ΩïÂ≠òÂú® \(a_i &lt; 0\) ÁöÑÁä∂ÊÄÅÁöÑÂâçÊèê‰∏ãÔºåËÉΩÂ§üÂæóÂà∞Â§öÂ∞ëÁßç‰∏çÂêåÁöÑÁªìÊûú„ÄÇ ‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÔºåÂ¶ÇÊûú‰∏çËÄÉËôë \(+k\) Êìç‰ΩúÔºåÊØèÁßíÊØè‰∏™ \(a_i\)ÈÉΩ‰ºöÂáèÂ∞ë \(1\)„ÄÇ ËÆæ \(c_{t,i}\) Ë°®Á§∫Ââç \(t\) Áßí \(a_i\) Ë¢´ÊâßË°å \(+k\) Êìç‰ΩúÁöÑÊ¨°Êï∞„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúËøô‰∏™ËøáÁ®ãÂú®ËøõË°å‰∫Ü \(T\) Áßí‰πãÂêéÁªìÊùüÔºå\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)Ôºå‰πüÂ∞±ÊòØËØ¥ \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)„ÄÇ ‰∏çÈöæËØÅÊòéÂ≠òÂú®ÁªèËøá \(T\) ÁßíÊ≤°ÊúâÂá∫Áé∞ËøáË¥üÊï∞ÁöÑÊñπÊ°àÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºö \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] ÂØπ‰∫é \(t \in \mathbb{N}\)Ôºå\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) ÊòØÂê¶ÊàêÁ´ãÊòØ‰∏é \(T\) Êó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåË¶Å‰πàÂØπÊâÄÊúâÁöÑ \(T\) ÈÉΩÂ≠òÂú®‰∏çÁªèËøáË¥üÊï∞ÁöÑÊñπÊ°àÔºåË¶Å‰πàÂ≠òÂú®‰∏Ä‰∏™ÈùûË¥üÊï¥Êï∞ \(T_0\)ÔºåÂΩì \(T \le T_0\) Êó∂Â≠òÂú®ÊñπÊ°àÔºå\(T &gt; T_0\) Êó∂‰∏çÂ≠òÂú®ÊñπÊ°à„ÄÇ Â§™Êôö‰∫ÜÂÖàÁù°‰∫Ü„ÄÇÂùëÂæÖÂ°´„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[Âè£ËÉ°ÁöÑÊ≤°ÂÆûÁé∞ËøáÔºåÂ¶ÇÊúâÈîôËØØËØ∑ QQ ÊàñËØÑËÆ∫ÂëäËØâÊàëÔºÅ È¢òËß£ ËÄÉËôëÂè™Êúâ‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÁöÑÊÉÖÂÜµ„ÄÇ Á¨¨‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_1, a_1b_1, a_1b_1^2, \ldots\) Á¨¨‰∫å‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_2,a_2b_2,a_2b_2^2,\ldots\) ÂÅáËÆæ \(v\) ÂêåÊó∂Âá∫Áé∞Âú®‰∏§‰∏™Á≠âÊØîÊï∞Âàó‰∏≠ÔºåÈÇ£‰πà \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)„ÄÇ ËÆæ \(p_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™Á¥†Êï∞„ÄÇ \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) ËÄÉËôë‰ªªÊÑè‰∏§‰∏™‰∏çÂêåÁ¥†Êï∞ \(p_i\) Âíå \(p_j\)ÔºåÂÅáËÆæ \(p_i\) Âú® \(a_1,a_2\) ‰∏≠Âá∫Áé∞Ê¨°Êï∞ÂàÜÂà´ÊòØ \(w_{1i},w_{2i}\)„ÄÇ ÈÇ£‰πàÊúâ \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] ËøôÊòØ‰∏Ä‰∏™‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑ„ÄÇÂÅáËÆæ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåËøô‰∏™ÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ ÂÅáËÆæÂ≠òÂú® \(i &lt; j\)Ôºå \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåÈÇ£‰πàËß£Âá∫Ëøô‰∏™ÊñπÁ®ã„ÄÇËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÂîØ‰∏Ä‰∏Ä‰∏™ÂèØËÉΩÊòØÊâÄÊúâÁ≠âÊØîÊï∞ÂàóÂÖ±ÊúâÂÖÉÁ¥†ÁöÑÊï∞ÔºàÁöÑÁ¥†Âõ†Êï∞ÂàÜËß£ÔºâÔºåÁÑ∂ÂêéÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; j\) ÈÉΩÊúâ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÁõ∏ÂÖ≥„ÄÇ ÈÇ£‰πàÂ≠òÂú®Ê≠£Êï¥Êï∞ \(w\)Ôºå\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)„ÄÇ \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] ‰∏çÂ¶®ËÆæ \(a_1 \le a_2\)„ÄÇÈÇ£‰πà‰∏ÄÂÆöÊúâ \(a_1 \mid a_2\)„ÄÇ ËÆæ \(\frac {a_2} {a_1} = x\)ÔºåÂ¶ÇÊûúÊúâËß£ÔºåÂøÖÊúâ \(x = w^n, n \in \mathbb{N}\)„ÄÇ ÊñπÁ®ãÂèò‰∏∫ \(k_1i_1-k_2i_2 = n\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰∏çÂÆöÊñπÁ®ã„ÄÇ‰∏çÈöæÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑ‰∏ÄÁªÑËß£ \(k_1= x, k_2 = y\)„ÄÇÔºàÂÖ∑‰ΩìÊù•ËØ¥ÂÖàÊâæÂà∞ \(k_1i_1-k_2i_2=1\) ÁöÑËß£ÔºåÁÑ∂ÂêéÂú®‰∏§Ëæπ‰πò‰ª• \(n\)Ôºâ ÈÇ£‰πàËøô‰∏™ÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)„ÄÇ ‰∏çÈöæÊâæÂà∞ \(k_1\) ÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞Ëß£ÔºåÂÅáËÆæËøôÊó∂ \(a_1w^{k_1c_1}=t\)„ÄÇËøôÊ†∑‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÂ∞±Ë¢´ÂêàÂπ∂‰∏∫‰∫Ü‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)„ÄÇ ÁªßÁª≠ÊääÂêàÂπ∂ÂæóÂà∞ÁöÑÁ≠âÊØîÊï∞ÂàóÂíåÂÖ∂‰ªñÁ≠âÊØîÊï∞ÂàóËøõË°åÁõ∏ÂêåÁöÑÊìç‰ΩúÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÊîØÈÖçÊ†ë]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÊîØÈÖçÊ†ëÁöÑÁÆóÊ≥ïÂæàÂ¶ô„ÄÇÂÆÉÁöÑËØÅÊòéÂÆûÂú®Â§™Èïø‰∫Ü‚Ä¶.ÂÆåÊï¥ÂÜô‰∏ÄÈÅçÊØîËæÉË¥πÊó∂Èó¥ÔºåËøôÈáåÂ∞±Âè™ÂÜôÁªìËÆ∫‰∫Ü„ÄÇ ÊòæÁÑ∂ÊîØÈÖçÂÖ≥Á≥ªÊûÑÊàê‰∏ÄÊ£µÊ†ë„ÄÇ ÂÆö‰πâ \(sdom(u)\) ÊòØËÉΩÂ§ü‰ªé \(v\) Âá∫ÂèëÂè™ÁªèËøá \(dfn\) ÊØî \(u\) Â§ßÁöÑÂà∞Ëææ \(u\)Ôºà\(u\) Âíå \(v\) ‰∏çÁÆóÂú®ÈáåÈù¢ÔºâÁöÑ \(dfn\) ÊúÄÂ∞èÁöÑ \(v\)„ÄÇ \(sdom(u)\) Ë¶Å‰πàÊòØËÉΩÂ§üÈÄöËøá‰∏ÄÊù°ÂâçÂêëËæπ / Ê†ëËæπÁõ¥Êé•Âà∞Ëææ \(u\) ÁöÑÁÇπÔºåË¶Å‰πàÊòØÊª°Ë∂≥Â≠êÊ†ë‰∏≠Â≠òÂú®Ëá≥Â∞ë‰∏Ä‰∏™ÁÇπËÉΩÂ§üÁõ¥Êé•Ëµ∞Âà∞ \(u\) ‰∏î \(dfn\) ÊØî \(u\) Â§ßÁöÑÁÇπÁöÑ \(sdom\)„ÄÇÊ†πÊçÆËøô‰∏ÄÁÇπÂèØ‰ª•Âπ∂Êü•ÈõÜËÆ°ÁÆó \(sdom\)„ÄÇÂπ∂Êü•ÈõÜÁª¥Êä§ÁöÑÊòØÈìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇ ËÆæ \(v\) ÊòØ \(u\) Âà∞ \(sdom(u)\) ÁöÑÈìæ‰∏äÔºà‰∏çÂê´ \(sdom(u)\)Ôºâ\(sdom\) ÊúÄÂ∞èÁöÑÁÇπ ÔºåÈÇ£‰πàÂ¶ÇÊûú \(sdom(v) = sdom(u)\)Ôºå\(idom(u) = sdom(u)\)ÔºåÂê¶Âàô \(idom(u) = idom(v)\)„ÄÇËøô‰∏™‰∏úË•ø‰πüÊòØË¶ÅÊ±Ç‰∏Ä‰∏™Èìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇÂèØ‰ª•Ê±Ç \(sdom\) ÁöÑÊó∂ÂÄôÈ°∫‰æøÁª¥Êä§‰∏Ä‰∏ã„ÄÇ Âú®Ëøô‰ªΩ‰ª£Á†Å‰∏≠ \(sdom\) Â≠òÁöÑÊòØ \(dfn\) ÊúÄÂ∞èÁöÑÁÇπÁöÑ \(dfn\) ËÄå‰∏çÊòØÁºñÂè∑ÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè„ÄÇ ÔºàÂê¨ËØ¥ËøôÈ¢òÊï∞ÊçÆÂæàÊ∞¥‚Ä¶ËØ¥‰∏çÂÆöÊúâÈîôÊ≤°Ë¢´Êü•Âá∫Êù•Ôºâ Ëøô‰ªΩ‰ª£Á†ÅË¢´Êèê‰∫§Âà∞ „ÄêÊ®°Êùø„ÄëÊîØÈÖçÊ†ë„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT ÈóÆÈ¢òÊÄªÁªì]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥‰ª•Êù•ÂØπ 2-SAT ÁöÑÁêÜËß£ÊØîËæÉÊ®°Á≥äÔºåÊâÄ‰ª•ÂÜôËøôÊ†∑‰∏Ä‰∏™Â∞ΩÂèØËÉΩÊ∏ÖÊô∞ÁöÑÊÄªÁªìÊù•ÁêÜÊ∏ÖÊÄùË∑Ø„ÄÇ 2-SAT ÈóÆÈ¢òÁöÑÂÆö‰πâÔºöÊúâ \(n\) ‰∏™ÈÄªËæëÂèòÈáèÔºåÁî® \(b_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™ÈÄªËæëÂèòÈáè„ÄÇ\(m\) ‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏Ä‰∏™ÈôêÂà∂Êù°‰ª∂ÂΩ¢Â¶ÇÔºö\((\neg)b_i \to (\neg) b_j\)„ÄÇÈóÆÊòØÂê¶Â≠òÂú®Êª°Ë∂≥ÈôêÂà∂ÁöÑ \(b\)„ÄÇ Áî®ÂõæÊù•ÊèèËø∞ÈôêÂà∂Êù°‰ª∂„ÄÇÂØπÊØè‰∏™ÈÄªËæëÂèòÈáèÂª∫‰∏§‰∏™ÁÇπÔºåÂàÜÂà´‰ª£Ë°®ÂèñÂÄº‰∏∫ \(0\) ÂíåÂèñÂÄº‰∏∫ \(1\)„ÄÇ‰ª£Ë°® \(b_i=0\) ÁöÑÁÇπ‰∏∫ \(p_i\)Ôºå‰ª£Ë°® \(b_i = 1\) ÁöÑÁÇπ‰∏∫ \(q_i\)„ÄÇÂØπÊØè‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÂú®Âõæ‰∏äËøû‰∏ÄÊù°ÊúâÂêëËæπÔºåË°®Á§∫‰∏Ä‰∏™ÂëΩÈ¢òÊé®Âá∫Âè¶‰∏Ä‰∏™ÂëΩÈ¢òÔºåÁÑ∂ÂêéÂÜçÂä†‰∏ÄÊù°ËæπË°®Á§∫ËØ•ÈôêÂà∂Êù°‰ª∂ÁöÑÈÄÜÂê¶ÂëΩÈ¢ò„ÄÇ‰∏æ‰æãÊù•ËØ¥ÔºåÂ¶ÇÊûúÊúâÈôêÂà∂Êù°‰ª∂ \(\neg b_i \rightarrow b_j\)ÔºåÂ∞±Âä†ÂÖ• \((p_i, q_j)\) Âíå \((p_j, q_i)\) Ëøô‰∏§Êù°ÊúâÂêëËæπ„ÄÇÈóÆÈ¢òÂ∞±Âèò‰∏∫Âà§ÂÆöÊòØÂê¶Â≠òÂú®ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)ÔºåÊÅ∞Â•ΩÂåÖÂê´ \(p_i\) Âíå \(q_i\) ‰∏≠ÁöÑ‰∏Ä‰∏™ÁÇπÁöÑÈó≠ÂêàÂ≠êÂõæ„ÄÇ ÂÆöÁêÜÔºö2-SAT ÊúâËß£ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂú®Âêå‰∏ÄÂº∫ËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ ÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑ„ÄÇ ‰∏ãÈù¢Áî®ÊûÑÈÄ†ËØÅÊòéÂÖÖÂàÜÊÄßÔºö ÂÖà tarjan Ê±ÇÂá∫Âº∫ËøûÈÄöÂàÜÈáèÔºåÊääÊØè‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÁº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÁî±‰∫é‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÁöÑÁÇπÂØπÂ∫îÁõ∏ÂèçÂèñÂÄºÁöÑÁÇπ‰πüÊûÑÊàê‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÔºåÊâÄ‰ª•Áº©ÁÇπÂêéÔºåËøô‰∏™ÈóÆÈ¢òÂèò‰∏∫‰∫Ü‰∏Ä‰∏™Êõ¥Â∞èÁöÑ 2-SAT ÈóÆÈ¢ò„ÄÇÂè™ÈúÄË¶ÅËß£ÂÜ≥ÂõæÊòØ DAG Êó∂ÁöÑÈóÆÈ¢òÂç≥ÂèØ„ÄÇ ÊääÊâÄÊúâÁöÑËæπÊñπÂêëÂèçËøáÊù•„ÄÇ‰∏ãÈù¢ÊâÄÊúâÁöÑËÆ®ËÆ∫ÈÉΩÊòØÂú®ÂèçÂõæ‰∏äÁöÑ„ÄÇ Áî®Á¨¶Âè∑ \(v^r\) Ë°®Á§∫‰∏éÁÇπ \(v\) ÂØπÂ∫îÁöÑÁÇπÔºö\(p_i^r = q_i, q_i^r = p_i\)„ÄÇ Ê±ÇÂá∫ÊãìÊâëÂ∫èÔºåÊåâÊãìÊâëÂ∫è‰æùÊ¨°Â§ÑÁêÜÊØè‰∏™ÁÇπÔºöÂ¶ÇÊûúÂΩìÂâçÁÇπ \(u\) Ë¢´Êâì‰∫ÜÊ†áËÆ∞ÔºåÈÇ£‰πà‰∏çÈÄâÔºõÂê¶ÂàôÈÄâÊã© \(u\)ÔºåÂπ∂Êää \(u^r\) ‰ª•Âèä \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÊâÄÊúâÁÇπÊâì‰∏äÊ†áËÆ∞ÔºàÈÄíÂΩíËøõË°åÔºåÂ¶ÇÊûúÂ∑≤ÁªèË¢´ÊâìËøáÊ†áËÆ∞Â∞±Ë∑≥ËøáÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºöË¢´Ê†áËÆ∞‰∏ÄÊ¨°Ôºâ„ÄÇ ËøôÊ†∑ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂèØËÉΩÂêåÊó∂Ë¢´ÈÄâÔºåÂ∑≤ÈÄâÁöÑÁÇπ‰πü‰∏ç‰∏éÈôêÂà∂ÁüõÁõæÔºåÂè™ÈúÄË¶ÅËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(u\)Ôºå\(u\) Âíå \(u^r\) ‰∏≠Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÈÄâÂç≥ÂèØ„ÄÇ Â¶ÇÊûú \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´Ê†áËÆ∞ÁöÑÂéüÂõ†ÊòØ \(v\) Ë¢´ÈÄâÊã©Ôºå ÈÇ£‰πà \(u\) ÊòØ \(v^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºåÁî± 2-SAT ÁöÑÊÄßË¥®ÂèØÂæó \(v\) ÊòØ \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºå‰ªéËÄå \(v\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†Âêé„ÄÇ ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ \(u\)Ôºå\(u\) Âíå \(u^r\) ÈÉΩË¢´Ê†áËÆ∞‰∫ÜÔºåÊ†áËÆ∞ \(u\) ÁöÑÂéüÂõ†ÊòØ \(v_1\) ÊòØË¢´ÈÄâÊã©ÔºåÊ†áËÆ∞ \(u^r\) ÁöÑÂéüÂõ†ÊòØ \(v_2\) Ë¢´ÈÄâÊã©„ÄÇÈÇ£‰πà \(v_1\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºå\(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u\) Èù†Âêé„ÄÇ‰∏çÂ¶®ËÆæ \(u\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÈÇ£‰πà \(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÂú®Â§ÑÁêÜ \(v_2\) ‰πãÂâçÂ∞±‰ºöÂÖàÂ§ÑÁêÜ \(u^r\)ÔºåÁüõÁõæ„ÄÇ ÊâÄ‰ª•ËØ•ÁÆóÊ≥ï‰ºöÂæóÂà∞‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊñπÊ°à„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢ò]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Áî®Êù•ËÆ∞ÂΩïÂè£ËÉ°ÁöÑÈ¢òÁõÆ„ÄÇ Â¶ÇÊúâÈîôËØØËØ∑Âä°ÂøÖ qq ÊàñËÄÖËØÑËÆ∫ÂëäËØâÊàëÔºåË∞¢Ë∞¢ÔºÅ JOISC 2018 Day4 T1 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Â¶ÇÊûúËÆ§‰∏∫Áõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥Êúâ‰∏ÄÊù°ËæπÔºåÊú¨È¢òÂ∞±ÂèØ‰ª•ÁúãÊàêÊ±ÇÊúÄÂ§ßÊùÉÁÇπÁã¨Á´ãÈõÜ„ÄÇ ÊòæÁÑ∂‰∏ÄÊù°ÈìæÊòØ‰∫åÂàÜÂõæÔºåÈÇ£‰πàÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫Áî®Ë¥πÁî®ÊµÅÊ±ÇÊúÄÂ∞èÊùÉÁÇπË¶ÜÁõñÈõÜ„ÄÇ ËÆ∞ÂΩïÁõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥ËæπÁöÑÊñπÂêëÔºåÊääËøûÁª≠‰∏ÄÊÆµÊñπÂêëÁõ∏ÂêåÁöÑËßÜ‰Ωú‰∏Ä‰∏™ÊÆµ„ÄÇÁî®Á∫øÊÆµÊ†ëÁª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÊØèÊ¨°ÊúâÊÆµÂèëÁîüÂèòÊõ¥Êó∂Â∞±ËØ¢ÈóÆËøô‰∏™ÊÆµÔºåÁÑ∂Âêé‰øÆÊîπÁ∫øÊÆµÊ†ë‰∏äÁöÑ‰ø°ÊÅØ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Áª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÂ∞±Âú® \(\mathcal O(n \log n)\) ÁöÑÊó∂Èó¥Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ JOISC 2018 Day4 T2 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Áúã‰ΩúÊòØËØ¢ÈóÆ‰∏ÄÊù°Èìæ‰∏ä‰∏ÄÈÉ®ÂàÜÁÇπÁöÑÂØºÂá∫Â≠êÂõæÁöÑËøûÈÄöÂùóÊï∞„ÄÇ‰æùÊ¨°Âä†ÁÇπÔºåÈÄöËøá‰∫åÂàÜÊ±ÇÂá∫Êñ∞Âä†ÁöÑÁÇπÂíåÂ∑≤ÊúâÁÇπÊûÑÊàêÁöÑËøûÈÄöÂùó‰πãÈó¥ÁöÑËøûËæπ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™Êúâ \(n-1\) Êù°ËæπÔºåËØ¢ÈóÆÊ¨°Êï∞‰∏ç‰ºöË∂ÖËøá \(\lceil \log n\rceil (n-1)\)„ÄÇ LOJ 6191 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÈÖçÂØπÊ∏∏Êàè ÁÇπÂáªÊü•ÁúãÈ¢òËß£ ÊúÄÂêé‰∏ÄÂÆö‰ºöÂèòÊàê &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;„ÄÇ \(f_{i,j}\) Ë°®Á§∫Ââç \(i\) ‰∏™Ê∂àÂÆåÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶ÊúÄÂêéÊúâËøûÁª≠ \(j\) ‰∏™ &gt;ÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶‰∏≠ &lt; ÁöÑÊï∞ÈáèÁöÑÊúüÊúõ„ÄÇ ÊúÄÂêéÂæàÂÆπÊòìÁªüËÆ°Á≠îÊ°à„ÄÇ LOJ 6192 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÂüéÂ∏ÇÁΩëÁªú Ê≤°Âï•Â•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÂÄçÂ¢û‰∏Ä‰∏ã„ÄÇ LOJ 6194 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÊéíÂàó ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Êåâ \(a_i\) ‰∏∫Á¨¨‰∏ÄÂÖ≥ÈîÆÂ≠óÔºå\(b_i\) ‰∏∫Á¨¨‰∫åÂÖ≥ÈîÆÂ≠óÊéíÂ∫è„ÄÇÈáçÊñ∞ÁªôÁÇπÁºñÂè∑„ÄÇ ÂÅáËÆæ‰Ωø saved ÂèòÂä®ÁöÑÁÇπÁöÑÁºñÂè∑ÂàÜÂà´ÊòØ \(c_1, \ldots, c_k\)ÔºåÊúâ \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)„ÄÇ ËÄÉËôëÂØπ‰∫éÁªôÂÆöÁöÑ \(c_i\) Âíå \(k\)ÔºåÂ¶Ç‰ΩïËÆ°ÁÆó \(p\) ÁöÑÊï∞Èáè„ÄÇ ËÆæ \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)ÔºåÂÆö‰πâ \(d_0 = n\)„ÄÇ Â¶ÇÊûú \(d_k &gt; 1\)Ôºå\(p\) ÁöÑÊï∞Èáè‰∏∫ \(0\)„ÄÇ Âê¶Âàô \(p\) ÁöÑÊï∞Èáè‰∏∫ \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÆπÊòì \(dp\) Â§ÑÁêÜÁöÑÂºèÂ≠ê„ÄÇÂàÜÊ≤ª‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ÂÅöÂÆå‰∫Ü„ÄÇ LOJ 6212 „ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçmelon ÁÇπÂáªÊü•ÁúãÈ¢òËß£ \(n \le L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(n\)Ôºå\(L &lt; n \le 2L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(L\)Ôºå‰∏ãÈù¢ËÆ®ËÆ∫ \(n &gt; 2L\) ÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûú Alice ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæÁìúÁöÑÊï∞ÈáèÂ§ß‰∫é \(2L\)ÔºåÂèñËµ∞‰∏Ä‰∏™ÁìúÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÁìúÔºåÂ∞±ËÉΩ‰øùËØÅËá≥Â∞ëÊãøÂà∞ \(\lceil \frac {n} 2\rceil\) ‰∏™Áìú„ÄÇÔºàÂõ†‰∏∫ËøôÊ†∑ Alice ÊãøÂà∞ÁöÑÁìú‰∏ÄÂÆö‰∏ç‰ºöÊØî Bob Â∞ëÔºâ Â¶ÇÊûú Bob ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæ Alice ÂàöÂàöÊãøËµ∞‰∫Ü \(x\) ‰∏™ÁìúÔºåÁé∞Âú®ËøòÂâ©‰∏ã \(c\) ‰∏™ÁìúÔºåÂ¶ÇÊûú \(c-x \ge 2L\)ÔºåÈÇ£‰πàÂèñËµ∞ \(x\) ‰∏™ÁìúÔºõÂê¶ÂàôÂÖàÂèñËµ∞ \(x-1\) ‰∏™ÁìúÔºåÂêÉÂÆåÂêéÔºåÂâ©‰ΩôÁìúÊï∞‰∏∫ \(c-(x-1)\)ÔºåÂõ†‰∏∫ \(c-x &lt; 2L\)ÔºåÊâÄ‰ª• \(c-x+1 \le 2L\)ÔºåÂ¶ÇÊûú \(c-x+1 \le L\)ÔºåÁõ¥Êé•ÂèñËµ∞Ââ©‰ΩôÂÖ®ÈÉ®ÁìúÔºåËøôÁßçÊÉÖÂÜµ‰∏ã Bob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÔºåÂõ†‰∏∫ \(c-x+1 \le 2L\)ÔºåÂú®Ââ©‰ΩôÁöÑ \(c-x+1\) ‰∏™Áìú‰∏≠ÔºåBob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÊúÄÂùè‰πüÂè™ÊòØÁî±‰∫é‰∏ä‰∏ÄÊ¨° Alice Êìç‰ΩúÁöÑÊó∂ÂàªÔºåAlice ÂèñËµ∞‰∫Ü \(x\) ‰∏™ËÄå Bob ÂèñËµ∞‰∫Ü \(x-1\) ‰∏™ÔºåBob ÊØî Alice ÊãøÁöÑÁìúÂ∞ë‰∫Ü‰∏Ä‰∏™„ÄÇÊâÄ‰ª• Bob ÊãøÁöÑÁìúÁöÑÊï∞ÈáèÊúÄÂùèÊØî Alice Â∞ë \(1\)„ÄÇ Âõ†Ê≠§ÔºåÂú®ÂèåÊñπÈÉΩÈááÂèñÊúÄ‰ºòÁ≠ñÁï•Êó∂ÔºåAlice ËÉΩËé∑ÂæóÊÅ∞Â•Ω \(\lceil \frac{n} 2\rceil\) ‰∏™Áìú„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂΩì \(n \le L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(n\)ÔºõÂΩì \(L &lt; n \le 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(L\)ÔºõÂΩì \(n &gt; 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(\lceil \frac {n} 2\rceil\)„ÄÇ CF 1215F Radio Stations ÈùûÂ∏∏Â¶ôÁöÑ 2SAT È¢òÔºåÊ≤°ÊÉ≥Âá∫Êù•„ÄÇÁúã‰∫ÜÈ¢òËß£ËßâÂæóÂæà nb„ÄÇÂÖ∑‰ΩìÂÅöÊ≥ïÂ∞±‰∏çÂÜô‰∫Ü„ÄÇÂèØ‰ª•ÁúãÂÆòÊñπÈ¢òËß£„ÄÇ CF 1188E Problem from Red Panda ÂæÖÂ°´Âùë„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á±ªÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥Áî®‰∏ÄÁõ¥Êã∑Êùø...ÈúÄË¶ÅË°•‰∏ÄË°•‰∫Ü„ÄÇ ÈóÆÈ¢ò Ê±Ç \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] Âç≥Âú®‰∏ÄÊù°Áõ¥Á∫ø‰∏ãÁöÑÊï¥ÁÇπÊï∞. ÂÅöÊ≥ï Â¶ÇÊûú \(a \ge c\) Êàñ \(b \ge c\)ÔºåÂàô \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) Âê¶Âàô \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] ÔºàÂõ†‰∏∫ \(i\) ‰ªé \(0\) ÂºÄÂßãÔºåÊâÄ‰ª•Ë¶ÅÁî®Â∞è‰∫éÂè∑Ôºâ ËøôÊ†∑ÊØèÈÄíÂΩí‰∏§Ê¨°Ôºå\((a,c)\) Â∞±ÂèòÊàê \((c, a\bmod c)\)ÔºåÂõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(O(\log (a+c))\). Áî±‰∫é \(a &lt; c, b &lt; c\)ÔºåÊâÄ‰ª• \(n\) ÁöÑÂÄº‰∏ç‰ºöÂ¢ûÂ§ßÔºåÊó†ÈúÄÊãÖÂøÉÁàÜ long long.]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] ÂÆåÁæéÁöÑÈòüÂàó]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òËß£ Â§çÊùÇÂ∫¶ËÆ®ËÆ∫‰∏≠ÈªòËÆ§ \(n,m\) ÂêåÈò∂„ÄÇ ÂÆö‰πâÁ¨¨ \(i\) ‰∏™Êìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥‰∏∫ \(i\)„ÄÇ Ê±ÇÂá∫ÊØèÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÊñ∞ÁöÑ \(x\) ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥ÔºåÂ∞±ÂæàÂ•ΩÊ±ÇÁ≠îÊ°à‰∫Ü„ÄÇ ‰ªéÂêéÂæÄÂâçËÄÉËôëÊØè‰∏™Êìç‰ΩúÔºåËÆ°ÁÆóËøôÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥„ÄÇ ÂÆö‰πâ‰∏Ä‰∏™ÈòüÂàó \(i\) ÁöÑÂºπÂá∫Êó∂Èó¥‰∏∫‰ªéÂΩìÂâçÊìç‰ΩúÂºÄÂßãÔºåÂæÄÂêéÁ¨¨ \(a_i\) ‰∏™ÂΩ±ÂìçÈòüÂàó \(i\) ÁöÑÊìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥„ÄÇ ÂàÜÂùóÔºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØè‰∏™Êìç‰ΩúÔºåÂàÜÂà´Áª¥Êä§ÊØè‰∏ÄÂùó‰∏≠ÁöÑÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄº„ÄÇÊàë‰ª¨Êää‰∏ÄÂùó‰∏≠ÊâÄÊúâÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄºÁß∞‰∏∫Ëøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Âú®Âä†ÂÖ•Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂêéÔºåÁ¨¨ \(i\) ‰∏™Âùó \([a_i,b_i]\) Áª¥Êä§ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t_i\)ÔºåËÆæ \(c_p\) ‰∏∫Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂà∞Á¨¨ \(t_i-1\) ‰∏™Êìç‰Ωú‰∏≠Á¨¨ \(p\) ‰∏™ÈòüÂàóË¢´ push ÁöÑÊ¨°Êï∞ÔºåÁª¥Êä§ \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)„ÄÇÂêåÊó∂Áª¥Êä§ \(c_p\) ÁöÑÂÄº„ÄÇÔºàÈÄöËøáÊâìÊ†áËÆ∞Ôºâ ËÄÉËôëÂú®Âä†ÂÖ•Êìç‰Ωú \(i\) ÂêéÔºåÂ¶Ç‰ΩïÊõ¥Êñ∞ÊØèÂùóÁª¥Êä§ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÅáËÆæËøô‰∏™ÂùóÊòØÁ¨¨ \(k\) ‰∏™Âùó„ÄÇ ÂØπ‰∫éËøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â§ß‰∫éÁ≠â‰∫é \(m\) ÁöÑÊÉÖÂÜµÈ¢ÑÂÖàÂ§ÑÁêÜÂ•Ω„ÄÇ‰∏ãÈù¢Âè™ËÆ®ËÆ∫ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â∞è‰∫é \(m\) ÁöÑÊÉÖÂÜµ„ÄÇ Êõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ Â¶ÇÊûúËøô‰∏™ÂùóË¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êõ¥Êñ∞ \(mn_k \leftarrow mn_k+1\)„ÄÇÊõ¥Êñ∞ \(c_p\) ÁöÑÂÄºÔºåÂç≥Êâì‰∏Ä‰∏™Êï¥ÂùóÂä† \(1\) Ê†áËÆ∞„ÄÇ Â¶ÇÊûúËøô‰∏™ÂùóÊú™Ë¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êö¥ÂäõÈáçÊûÑÔºåÊõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ„ÄÇ Êõ¥Êñ∞ \(t_k\) Êåâ‰ª•‰∏ãÊ≠•È™§ËøõË°åÔºö Â¶ÇÊûú \(mn_k \ge 0\)ÔºåËØ¥Êòé \(t_k\) ÂèØ‰ª•ÂáèÂ∞èÔºåÈÇ£‰πà \(t_k \leftarrow t_k-1\)„ÄÇÂê¶Âàô‰∏çÁî®Êõ¥Êñ∞ÔºåÁªìÊùüÊìç‰Ωú„ÄÇ Â¶ÇÊûúÁ¨¨ \(t_k\) Ê¨°Êìç‰ΩúÂåÖÂê´Êï¥‰∏™ÂùóÔºåÈÇ£‰πà \(mn_k \leftarrow mn_k-1\)ÔºåÊâì \(-1\) Ê†áËÆ∞Êõ¥Êñ∞ \(c_p\) ÁöÑÂÄº„ÄÇÂê¶ÂàôÊö¥ÂäõÈáçÊûÑÊõ¥Êñ∞ \(mn_k\) Âíå \(c_p\) ÁöÑÂÄº„ÄÇ ËΩ¨Âà∞Êìç‰Ωú 1„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂú® \(O(n \sqrt n)\) Êó∂Èó¥ÂÜÖÁª¥Êä§ÊØè‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Ââ©‰ΩôÁöÑÈóÆÈ¢òÊòØ: Â¶Ç‰ΩïÂú®‰ªéÂè≥ÂæÄÂ∑¶Âä†ÂÖ•Êìç‰ΩúÁöÑËøáÁ®ã‰∏≠ÔºåÊîØÊåÅÊü•ËØ¢‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇÊääÂå∫Èó¥ÊãÜÊàêËã•Âπ≤‰∏™ÂùóÂíå‰∏çË∂ÖËøá \(2 \sqrt n\) ‰∏™Â§öÂá∫Êù•ÁöÑÁÇπ„ÄÇÂØπ‰∫éËøô‰∫õÂùóÔºåÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ÔºåÂèñ \(\max\) Âç≥ÂèØ„ÄÇÂØπ‰∫éËøô‰∫õÂ§öÂá∫Êù•ÁöÑÁÇπÔºåÈúÄË¶ÅÂä®ÊÄÅËØ¢ÈóÆ‰ªñ‰ª¨ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Â§ÑÁêÜÂçïÁÇπ‰ø°ÊÅØ Ë¶ÅÊîØÊåÅ‰ªéÂêéÂæÄÂâçÊ∑ªÂä†Êìç‰ΩúÔºåËØ¢ÈóÆÂçï‰∏™ÈòüÂàóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ ÂêåÊ†∑ÂàÜÂùóÁª¥Êä§„ÄÇÂØπÊØè‰∏™ÂùóÂºÄ‰∏Ä‰∏™ vectorÔºåÂØπÊØè‰∏™ÈòüÂàóÂºÄ‰∏Ä‰∏™ vector„ÄÇÂú®ËøõË°å‰øÆÊîπÊó∂ÔºåÂØπÂÆåÊï¥ÂåÖÂê´ÁöÑÊØè‰∏™ÂùóÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑ÔºåÂÜçÂØπ‰∏§ËæπÂ§öÂá∫ÁöÑ \(O (\sqrt n)\) ‰∏™ÈòüÂàóÂØπÂ∫îÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑„ÄÇ ÈÇ£‰πà‰∏Ä‰∏™ÈòüÂàóÁöÑÊìç‰ΩúÂ∫èÂàóÂ∞±ÊòØÂÆÉÁöÑ vector ÂíåÂÆÉÊâÄÂú®ÁöÑÂùóÁöÑ vector ÂΩíÂπ∂ÂêéÁöÑÁªìÊûú„ÄÇÂØπÊØè‰∏™ÁÇπËÆ∞ÂΩïÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t\) (ÊØèÊ¨°ËØ¢ÈóÆÊó∂Êõ¥Êñ∞Ôºå‰øÆÊîπÊó∂‰∏ç‰∏ÄÂÆöÊòØÊúÄÊñ∞ÁöÑ)ÔºåÂÆÉÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâçÁöÑ‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_1\)ÔºåÂÆÉÊâÄÂú®ÂùóÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâç‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_2\)„ÄÇÂØπÊØè‰∏™ÂùóËÆ∞ÂΩïËøô‰∏™Âùó‰∏≠ÁöÑÈòüÂàóÂú®‰∏ä‰∏ÄÊ¨°Êõ¥Êñ∞‰ø°ÊÅØ‰πãÂêé‰øÆÊîπÁöÑÊ¨°Êï∞ \(c\)„ÄÇÈÇ£‰πà‰øÆÊîπÁöÑÊó∂ÂÄôÂØπÊï¥ÂùóÂè™ÈúÄË¶Å \(c \leftarrow c+1\)ÔºåÂØπ‰∏§Á´ØÁöÑÂùóÊõ¥Êñ∞ÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™ÈòüÂàóÁöÑ \(t, p_1, p_2\)ÔºåÂπ∂Êää \(c\) ËÆæ‰∏∫ \(0\)„ÄÇÊõ¥Êñ∞ÊñπÊ≥ïÂ§ßËá¥‰∏∫ÔºöÂØπ‰∫é‰∏Ä‰∏™ÈòüÂàóÔºåÂÖàÂà§Êñ≠ \(t\) ÊòØÂú®ÂÆÉ vector ‰∏≠ËøòÊòØÂú®ÂùóÁöÑ vector ‰∏≠ÔºàÈÄöËøá \(p_1, p_2\) ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ÔºâÔºåËøô‰∏§ÁßçÊÉÖÂÜµÂå∫Âà´‰∏çÂ§ßÔºåÊâÄ‰ª•ËøôÈáåÂè™ÂÜôÂú®Âùó vector ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÂÆö‰πâ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáè \(t = c\)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂùóÁöÑ vector ‰∏≠ÁöÑÁ¨¨ \(p_2+t\) È°πÁöÑÂ∞è‰∫éËøô‰∏™ÈòüÂàóÁöÑ vector ‰∏≠ÁöÑ \(p_1\) È°πÔºåÈÇ£‰πà \(p_1 \leftarrow p_1+1\)ÔºåÁÑ∂Âêé \(t \leftarrow t-1\)ÔºåÁÑ∂ÂêéÂÜçÊ¨°Ê£ÄÊü•ÔºåËøôÊ†∑Âæ™ÁéØÁõ¥Âà∞ÂèØ‰ª•Áõ¥Êé•Êää \(p_2\) Êîπ‰∏∫ \(p_2+t\) ÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ \(p_2\) Â∞±ÂÆåÊàê‰∫ÜÊõ¥Êñ∞„ÄÇ ‰∏Ä‰∏™ÈòüÂàóË¢´Êõ¥Êñ∞Êó∂ËøõË°åÁöÑÂà§Êñ≠ÁöÑÊÄªÊ¨°Êï∞‰∏éÂÆÉÁöÑ vector ‰∏≠ÂÖÉÁ¥†‰∏™Êï∞ÂêåÁ∫ßÔºåÊâÄ‰ª•Êõ¥Êñ∞ÁöÑÊÄªÂ§çÊùÇÂ∫¶ÊòØ \(O(n)\) ÁöÑ„ÄÇÔºà‰ΩÜÊòØÁª¥Êä§ vector ÂíåËøõË°åÊìç‰ΩúÊòØ \(O(\sqrt n)\) ÁöÑÔºâ„ÄÇ ËøôÊ†∑Â∞±‰ª• \(O(n \sqrt n)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ÂÆûÁé∞ 1ÂæÖÂ°´]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊìç‰ΩúÊ®°Êùø]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI ÂâçÂ§ç‰π†„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //ÊúÄÂ§ßÂ§öÈ°πÂºèÈïøÂ∫¶ÔºåÂÄçÊï∞ÈóÆÈ¢òÂ∑≤ÁªèËÄÉËôëconst int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé®]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[Â§öÈ°πÂºèÂèñÊ®°‰ºòÂåñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // ÁâπÂæÅÂ§öÈ°πÂºèint wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //‰πò‰ª• A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÈîôËØØËÆ∞ÂΩï]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ÊØîËæÉÂáΩÊï∞ÂÆö‰πâ‰∏ç‰∏•Ê†ºÔºåÂ≠òÂú®ËøîÂõûÁõ∏Á≠â‰ΩÜÊòØÂÆûÈôÖ‰∏äÊúâÂå∫Âà´ÁöÑÊÉÖÂÜµ„ÄÇËøôÂèØËÉΩÂØºËá¥ÂèåÂ†ÜÁª¥Êä§Âà†Èô§Êìç‰ΩúÊó∂Âá∫Áé∞ÈóÆÈ¢ò„ÄÇÔºàÂ∫îÂΩìÂêåÊó∂ÂºπÊ†à‰ΩÜÊòØÊ†àÈ°∂ÂÖÉÁ¥†‰∏çÁõ∏Á≠âÔºâ for (int i = 1; i &lt;= n; i++) a[n] = inf„ÄÇ Âú®‰∏Ä‰∫õÂõûÊ∫ØÊó∂ÈúÄË¶ÅÊí§ÈîÄÊìç‰ΩúÁöÑ dfs ‰∏≠ÔºåÂõ†‰∏∫ÂÖ∂‰ªñÂéüÂõ† return ÁöÑÊó∂ÂÄôÊ≤°ÊúâÊí§ÈîÄÊìç‰Ωú„ÄÇ Âæ™ÁéØ/if ÈáåÂ±ÇÂ§ñÂ±ÇÂèòÈáèÂêçÊ∑∑Ê∑Ü„ÄÇ ËøõË°å dfs / ÈÄíÂΩíÊó∂ÔºåÂõ†‰∏∫‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè‰∏ãÂ±Ç dfs Êó∂Á†¥Âùè‰∫Ü‰∏äÂ±Ç‰πãÂêéË¶ÅÁî®Âà∞ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÆπÊñ•Êó∂ÔºåÂè™Êûö‰∏æ‰∫ÜÈõÜÂêàÂ§ßÂ∞èÂøòËÆ∞‰∫Ü‰πòÁªÑÂêàÊï∞„ÄÇ ÊèíÂ§¥ dp ‰∏çË¶ÅÂøòËÆ∞ËøûÊé•‰∏§‰∏™Â∑¶Êã¨Âè∑ÊàñËÄÖËøûÊé•‰∏§‰∏™Âè≥Êã¨Âè∑ÁöÑÊÉÖÂÜµ„ÄÇ Ê†ëÈìæÂâñÂàÜÊó∂ÔºåËØ¢ÈóÆÈìæÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèÊòØÊØîËæÉÈáçÈìæÈ°∂Á´ØÊ∑±Â∫¶Â§ßÂ∞èÔºå‰∏çËÉΩÁõ¥Êé•ÊØîËæÉ‰∏§‰∏™ÁÇπÊ∑±Â∫¶Â§ßÂ∞è„ÄÇ sort Êó∂ÂøòËÆ∞Âä†ÊØîËæÉÂáΩÊï∞„ÄÇ Áª¥Êä§Áü©Èòµ‰πòÊ≥ïÊó∂Â∑¶‰πòÂè≥‰πòÊêûÈîô„ÄÇ Á∫øÊÆµÊ†ëÂêàÂπ∂Êó∂ÔºåÂ¶ÇÊûúË¶ÅÂèØÊåÅ‰πÖÂåñÔºåÁ©∫Èó¥Ë¶ÅÂºÄ‰∏§ÂÄç„ÄÇ Âú®Â§ÑÁêÜÊ∂âÂèä‰∏çÂêåÈïøÂ∫¶Â≠óÁ¨¶‰∏≤ÁöÑÂ≠óÁ¨¶‰∏≤ÂìàÂ∏åÊó∂Ôºå‰∏ÄÂÆöË¶ÅÁî® str[i] - 'a' + 1 ËÄå‰∏çÊòØ str[i] - 'a' Âú®Â§ÑÁêÜÂ≠êÊ†ëÊúÄÈïø‰ªéÊ†πÂºÄÂßãË∑ØÂæÑ‰πãÁ±ªÁöÑÈóÆÈ¢òÊó∂ÔºåÂ¶ÇÊûúËøô‰∏™Â≠êÊ†ë‰∏çËÉΩÈÄâÔºådp ÂÄºËÆæ‰∏∫ \(0\) ‰ªç‰ºö +1 Âêë‰∏äË¥°ÁåÆ Âú®Áî® new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Âá∫Áé∞Ë∂äÁïå„ÄÇËøôÊó∂‰∏ç‰ºöÊä•ÈîôÔºåÂá∫Áé∞ new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Ôºå‰∏ÄÂÆöË¶ÅË∞®ÊÖéËÆ°ÁÆóÊØèÊ¨°Ë∞ÉÁî®ÁöÑÂ§ßÂ∞è„ÄÇÔºàÂ∞§ÂÖ∂ÊòØÂÜôÂ§öÈ°πÂºèÊó∂Ôºâ Áª¥Êä§Á∫øÊÆµÊ†ëÂå∫Èó¥Âä†Êó∂ÔºåÁªìÊûúÂèØËÉΩÂæàÂ§ßÁöÑÊó∂ÂÄô modify ÂáΩÊï∞ÂèÇÊï∞‰∏çÂºÄ long long]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[ÂèëËøôÁØáÂçöÂÆ¢‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆ∞ÂΩï‰∏Ä‰∏™ÊûÅ‰∏∫ÈöêËîΩÁöÑÈîôËØØ„ÄÇ ÂÜôÊØîËæÉÂáΩÊï∞‰∏ÄÂÆöË¶Å‰øùËØÅÊòØ‰∏•Ê†ºÁöÑÂ∞è‰∫éÂè∑„ÄÇË¶ÅÁâπÂà´Â§ÑÁêÜÁ≠â‰∫é„ÄÇÂê¶ÂàôÂú®ÈÅáÂà∞Â†ÜÊâìÊ†áËÆ∞Âà†Èô§ËøôÁßçÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÂÖÉÁ¥†Âú®Â†Ü‰∏≠ÁöÑÈ°∫Â∫è‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] „ÄåZJOI2017„ÄçÂ≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÂÅöÊ≥ï ‰∏çÈöæËØÅÊòéÂ¶ÇÊûú‰∏Ä‰∏™Â≠ê‰∏≤ \(s\) Êúâ‰∏§‰∏™ÂêéÁºÄ \(s_1, s_2\)Ôºå\(s_2\) ÊòØ \(s_1\) ÁöÑ border ‰∏î \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)ÔºåÈÇ£‰πàÂØπ‰∫é‰ªªÊÑèÁöÑÂ≠óÁ¨¶‰∏≤ \(t\)Ôºå\(s_2\) ‰∏çÂèØËÉΩÊòØ \(st\) ÁöÑÊúÄÂ∞èÂêéÁºÄ„ÄÇ Áî®‰∏Ä‰∏™Á∫øÊÆµÊ†ëÁª¥Êä§ÊØè‰∏™Âå∫Èó¥ÂÜÖÂèØËÉΩÊàê‰∏∫ÊúÄÂ∞èÂêéÁºÄÁöÑÁÇπÔºåËøôÊ†∑ÁöÑÁÇπÂè™Êúâ \(\mathcal O (\log n)\) ‰∏™„ÄÇpush up ÁöÑÊó∂ÂÄôÊö¥ÂäõÂêàÂπ∂Âç≥ÂèØ„ÄÇ ÊØîËæÉÂ§ßÂ∞èÁöÑÊó∂ÂÄôÈúÄË¶ÅÊü• lcpÔºåÂàÜÂùóÁª¥Êä§ÂâçÁºÄÂìàÂ∏åÂç≥ÂèØÂÅöÂà∞ \(\mathcal O(\sqrt n)\) ‰øÆÊîπÔºå\(\mathcal O(\log n)\) ËØ¢ÈóÆÔºàË∞ÉÊï¥ÂùóÂ§ßÂ∞èÂ∫îËØ•ÂèØ‰ª•ÂÅöÂà∞Êõ¥‰ºòÁöÑÂ§çÊùÇÂ∫¶Ôºâ„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)„ÄÇ ÔºàÁúüÁöÑÊØíÁò§Ôºâ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø]-Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ ÁÆÄÂçïÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] Âå∫Èó¥Á¥†Êï∞‰∏™Êï∞]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ËØïÁùÄÂÆûÁé∞‰∏ã min_25 Á≠õÁöÑÁ¨¨‰∏ÄÊ≠•„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/problemset/problem/715/E È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏§‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàó \(p_1\) Âíå \(p_2\)ÔºåÂÖ∂‰∏≠Êúâ‰∏Ä‰∫õ‰ΩçÁΩÆË¢´ÊåñÁ©∫ÔºåËÆ©‰Ω†Ëá™Â∑±Â°´Êï∞Â≠ó„ÄÇ ËØ∑‰Ω†ÂØπÊØè‰∏™ \(k\) ËæìÂá∫ÔºåÊúâÂ§öÂ∞ëÁßçÂ°´Êï∞Â≠óÊñπÊ°àÔºå‰ΩøÂæó \(p_1\) ÊúÄÂ∞ë‰∫§Êç¢ \(k\) Ê¨°ÂèØ‰ª•ÂèòÊàê \(p_2\)„ÄÇ \(n \le 250\)„ÄÇ Ëß£Ê≥ï È¶ñÂÖàÈ¢òÁõÆ‰øùËØÅËá≥Â∞ëÂ≠òÂú®‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°à‰ΩøÂæó \(p_1\) Âíå \(p_2\) ÊòØÊéíÂàóÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊï∞‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµ„ÄÇ ÂÆπÊòìÁúãÂá∫‰∫§Êç¢Ê¨°Êï∞ \(n-(p_1p_2^{-1}\) ÁöÑËΩÆÊç¢Êï∞\()\)„ÄÇ ÈóÆÈ¢òÂèòÊàê‰∫ÜÊ±ÇÊª°Ë∂≥ \(p_1p_2^{-1}\) ÊÅ∞Â•ΩÂèØ‰ª•ÂàÜËß£‰∏∫ \(k\) ‰∏™‰∏çÁõ∏‰∫§ËΩÆÊç¢ÁöÑÊñπÊ°àÊï∞„ÄÇ ËÆæ \(p_1p_2^{-1}=w\)ÔºåÂàô \(p_1=wp_2\)ÔºåÂç≥ \(p_1[i]=w[p_2[i]]\)„ÄÇ ËÆæÊâÄÊúâ \(p_1\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_1\)ÔºåÊâÄÊúâ \(p_2\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_2\)„ÄÇ ÂÅáËÆæ \(w\) ÊòØÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊéíÂàó„ÄÇÈÇ£‰πàÂØπ‰∫é \(i \in S_1\)ÔºåÊúâ \(p_2[i]=w^{-1}[p_1[i]]\)ÔºõÂØπ‰∫é \(i \in S_2\)ÔºåÊúâ \(p_1[i]=w[p_2[i]]\)„ÄÇÊâÄ‰ª• \(\forall i \in S_1 \cap S_2\)Ôºå\(p_1[i]\) Âíå \(p_2[i]\) ÈÉΩÊòØÁ°ÆÂÆöÁöÑ„ÄÇÂØπ‰∫é \(p_1\) Êù•ËØ¥ÔºåËøòÊúâ \(n-\lvert S_1\cup S_2 \rvert\) ‰∏™‰ΩçÁΩÆË¶ÅÂ°´ÁöÑÊï∞Ê≤°ÊúâÁ°ÆÂÆö„ÄÇÈÇ£‰πàÂ¶ÇÊûúÂ≠òÂú®Ëá≥Â∞ë‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°àÔºåÂ∞±ÊÅ∞Â•ΩÊúâ \((n-\lvert S_1\cup S_2 \rvert)!\) Áßç‰ΩøÂæó \(p_1p_2^{-1}=w\) ÁöÑÂ°´Êï∞ÊñπÊ°à„ÄÇ ÂÜçËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÂêàÊ≥ïÁöÑ \(w\)„ÄÇÂØπ‰∫é \(i \in S_1\cap S_2\)Ôºå\(w[p_2[i]]=p_1[i]\)„ÄÇÊâÄ‰ª• \(w\) ÁöÑ‰∏Ä‰∫õ‰ΩçÁΩÆÂ∑≤ÁªèÁ°ÆÂÆö‰∫Ü„ÄÇÂêåÊó∂ \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)„ÄÇ\(w\) ‰∏≠Á°ÆÂÆöÁöÑ‰ΩçÁΩÆÂ∑≤ÁªèÊûÑÊàê‰∫Ü‰∏Ä‰∫õÈìæÂíå‰∏Ä‰∫õÁéØ„ÄÇÊûÑÊàêÁéØÂêé‰∏çÂèØËÉΩ‰∏éÂÖ∂‰ªñÁÇπËøûËæπÔºåÂèØ‰ª•Áõ¥Êé•ÂøΩÁï•„ÄÇÈìæÂèØ‰ª•Áº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÈÇ£‰πàÈóÆÈ¢òËΩ¨Âåñ‰∏∫ÔºåÁªôÂÆö‰∏§‰∏™ÈõÜÂêà \(A\) Âíå \(B\)ÔºåÊ±ÇÊúâÂ§öÂ∞ë‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàóÔºåÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÊéíÂàóÔºåÊª°Ë∂≥ \(\forall i \in A, w[i] \notin B\)„ÄÇÊòæÁÑ∂Ëøô‰∏™ÈóÆÈ¢òÂè™‰∏é \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) ÊúâÂÖ≥„ÄÇ ÂÖàËÄÉËôë \(A\cap B =\emptyset\)„ÄÇÂÆπÊñ•‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] ÂÜçËÄÉËôë \(A\cap B \neq \emptyset\)„ÄÇÊääÈôêÂà∂Êù°‰ª∂Áúã‰Ωú \(\forall i \in A\setminus B,w[i]\notin B\) Âíå \(\forall i \in A \cap B, w[i] \notin B\)„ÄÇÂØπÁ¨¨‰∫å‰∏™Êù°‰ª∂ÂÆπÊñ•„ÄÇËÆæ \(G(n, c, i)\) ‰∏∫ \(n\) ‰∏™Êï∞ÁöÑÊéíÂàóÔºåÂÜ≥ÂÆö \(c\) ‰∏™‰ΩçÁΩÆÂ°´‰ªÄ‰πàÔºå‰ΩøÂ∑≤ÁªèÂÜ≥ÂÆöÁöÑËæπÊûÑÊàê \(i\) ‰∏™ÁéØÊñπÊ°àÊï∞ÔºàÊòæÁÑ∂Ê≠§Êó∂Êúâ \(n-c\) Êù°ÈìæÔºâ„ÄÇ \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) ÂÆûÈôÖÂè™Êúâ \(n^2\) ÁßçÔºåÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(F\) Âç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n^3)\)„ÄÇ ÂÜçËÄÉËôë \(G\) ÊÄé‰πàËÆ°ÁÆó„ÄÇ\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) ËÆ°ÁÆóÈùûÂ∏∏Êñπ‰æø„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï È¶ñÂÖàÔºå‰∏Ä‰∏™‰ª• \(A\) ‰∏∫ÂºÄÂ§¥‰ª• \(B\) ‰∏∫ÁªìÂ∞æÁöÑÂ∫èÂàóÊòØÂê¶Â≠òÂú®Ôºå‰ªÖ‰∏é \(A\oplus B\) ÊúâÂÖ≥„ÄÇ Â¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÈÇ£‰πà \(A\oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏ÄÂÆöÊòØÂ•áÊï∞„ÄÇ ‰∏Ä‰∏™ÁªìËÆ∫ÊòØÔºåÂ¶ÇÊûú \(A \oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÈÇ£‰πàÊª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàó‰∏ÄÂÆöÂ≠òÂú®„ÄÇ ‰∏ãÈù¢ÈÄíÂΩíÂú∞ÁªôÂá∫ÊûÑÈÄ†„ÄÇ ÂÆö‰πâ \(build(n,A,B)\) ËøîÂõû‰∏Ä‰∏™ \(0 \ldots 2^n-1\) ÁöÑ‰ª• \(A\) ‰∏∫ÂºÄÂ§¥Ôºå\(B\) ‰∏∫ÁªìÂ∞æÁöÑÊéíÂàó„ÄÇÔºà\(A\oplus B\) ‰∏≠ÊúâÂ•áÊï∞‰∏™ \(1\)Ôºâ Ëã• \(n=1\)ÔºåÂ¶ÇÊûú \(A = 0\)ÔºåËøîÂõû \(A, B\)„ÄÇ Ëã• \(A \oplus B\) ‰∏≠ÊÅ∞Êúâ‰∏Ä‰∏™ \(1\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^{n-1}\)ÔºàÂÖ∂‰ªñÊÉÖÂÜµÂè™ÈúÄË¶ÅÊääÊâÄÊúâÊï∞ÂºÇÊàñ‰∏ä \(A\) Âπ∂Êää \(1\) ÊâÄÂú®Âú®‰ΩçÂíåÊúÄÈ´ò‰Ωç‰∫§Êç¢Âç≥ÂèØÔºâ„ÄÇ ËÆæ \(a=build(n-1, 0, 1)\)ÔºåÈÇ£‰πà \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠Â≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæÂÖ∂‰∏≠ \(0\) Âú®ÊúÄ‰Ωé‰Ωç‰∏ä‰∏î \(A\) ÁöÑÊúÄ‰Ωé‰Ωç‰∏∫ \(0\)„ÄÇ ËÆæ \(a = build(n-1, \frac A 2, \frac B 2)\)Ôºå\(b = build(n-1, a_1, a_2)\)„ÄÇ ÈÇ£‰πà \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠‰∏çÂ≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^n-1\)„ÄÇ ËÆæ \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)„ÄÇ Âàô \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊéíÂàó„ÄÇ Áî®‰∏ªÂÆöÁêÜÂèØ‰ª•ÂàÜÊûêÂá∫Áõ¥Êé•ÈÄíÂΩíÁöÑÂ§çÊùÇÂ∫¶Âπ∂‰∏çÈ´ò„ÄÇÊâÄ‰ª•Áõ¥Êé•ÈÄíÂΩí‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï ËÆæ \(f_{i,j}\) Ë°®Á§∫Êää \(p_i \ldots p_n\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÊéíÂ∫èÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇ ËÆæ \(k\) ÊòØ \(p_i \ldots p_n\) ‰∏≠Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÁöÑ‰ΩçÁΩÆÔºå\(p_i\ldots p_k\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÂÖ±Êúâ \(c\) ‰∏™„ÄÇ \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] È¢ÑÂ§ÑÁêÜÂá∫ \(p\) Âíå \(c\)Ôºå\(n^2\) dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ È¢òÁõÆÂ§ßÊÑè Áªô‰Ω†‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÔºåËæπ‰∏äÊúâÂ≠óÁ¨¶„ÄÇÂÆö‰πâË∑ØÂæÑ \(u\) Âà∞ \(v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Â∞±ÊòØÊääË∑ØÂæÑ‰∏äÁöÑÂ≠óÁ¨¶‰æùÊ¨°Êé•Ëµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁªôÂÆö \(m\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s_1,s_2\ldots s_m\)„ÄÇ\(q\) Ê¨°ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏â‰∏™Êï∞ \(i, j, k\)ÔºåËØ¢ÈóÆÂú®Ë∑ØÂæÑ \(i\) Âà∞ \(j\) ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠Ôºå\(s_k\) Âá∫Áé∞‰∫ÜÂá†Ê¨°„ÄÇ Ëß£Ê≥ï Á¨¶Âè∑ËØ¥ÊòéÔºö\(s^R\) Ë°®Á§∫ \(s\) ÁöÑÂèç‰∏≤„ÄÇ\(pre(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂâçÁºÄÔºå\(suf(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂêéÁºÄ„ÄÇ\(s+t\) Ë°®Á§∫ÊääÂ≠óÁ¨¶‰∏≤ \(s\) ÂíåÂ≠óÁ¨¶‰∏≤ \(t\) ÊãºËµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇ ÂÖàÂÅö‰∏ÄÊ¨°ÁÇπÂàÜÊ≤ªÂ∞±ÂèØ‰ª•ÊääÈóÆÈ¢òËΩ¨Âåñ‰∏∫ \(u \rightarrow v\) ÁªèËøáÊ†πÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•Âè™ËÆ®ËÆ∫ÁªèËøáÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ËÆæÊ†π‰∏∫ \(r\)ÔºåËØ¢ÈóÆÁöÑË∑ØÂæÑ‰∏∫ \(u \rightarrow v\)ÔºåËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(s_k\)„ÄÇ ÂèØ‰ª•Êää \(s_k\) Âú®Ë∑ØÂæÑ \(u \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÂàÜÊàê‰∏âÈÉ®ÂàÜËÆ°ÁÆóÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØÂú® \(u\rightarrow r\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∫åÈÉ®ÂàÜÊòØÂú® \(r \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∏âÈÉ®ÂàÜÊòØÂú®Ë∑®Ëøá \(r\) ÁöÑÂåπÈÖç„ÄÇ Ââç‰∏§ÈÉ®ÂàÜÊòØÊØîËæÉÂ•ΩËÆ°ÁÆóÁöÑ„ÄÇÁ¶ªÁ∫ø‰∏Ä‰∏ãÔºåÂØπÊâÄÊúâÁöÑ \(s_i\) Âª∫ACËá™Âä®Êú∫ÔºåÂú®Ê†ë‰∏ädfsÔºåÊØèÊ¨°Âú®ACËá™Âä®Êú∫‰∏äËµ∞‰∏ÄÊù°ËΩ¨ÁßªËæπÔºåÁî® BIT Áª¥Êä§‰∏Ä‰∏ãÊØè‰∏™ÁÇπË¢´Ëµ∞‰∫ÜÂá†Ê¨°ÔºåÂú® dfs Âà∞ÁÇπ \(x\) Êó∂ÔºåÂè™ÈúÄ‰Ωú‰∏ÄÊ¨°Â≠êÊ†ëËØ¢ÈóÆÂç≥ÂèØÂø´ÈÄüÂæóÂà∞ \(s_k\) Âú® \(r\rightarrow x\) ‰∏äÂá∫Áé∞‰∫ÜÂá†Ê¨°ÔºàÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØ¢ÈóÆ \(s_k\) ÁöÑÂèç‰∏≤Âá∫Áé∞‰∫ÜÂá†Ê¨°Ôºâ„ÄÇ ÊØîËæÉÁÆÄÂçïÂ∞±‰∏çËØ¶ÁªÜÊèèËø∞‰∫Ü„ÄÇ Á¨¨‰∏âÈÉ®ÂàÜÊØîËæÉÂ§çÊùÇ„ÄÇËÆæË∑ØÂæÑ \(u\rightarrow r\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(x\)ÔºåË∑ØÂæÑ \(r \rightarrow v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(y\)„ÄÇËÆæ \(p\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(pre(s_k,p)=suf(x,p)\) ÁöÑÊï¥Êï∞Ôºå\(q\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(suf(s_k,q)=pre(y,q)\) ÁöÑÊï¥Êï∞„ÄÇÈÇ£‰πàËÆ°ÁÆóÁ¨¨‰∏âÈÉ®ÂàÜÂèØ‰ª•ËΩ¨Âåñ‰∏∫ËÆ°ÁÆó \(s_k\) Âú® \(suf(x,p)+pre(y,q)\) ‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞„ÄÇ ËÆæ \(t_i\) Ë∑ØÂæÑË°®Á§∫ \(r\rightarrow i\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂàô \(suf(x,p)+pre(y,q)\) ÂèØ‰ª•Ë°®Á§∫‰∏∫ \(pre(s_k,p)+suf(s_k,q)\)ÔºåËøôÊ†∑Â∞±ËΩ¨Âåñ‰∏∫‰∫ÜÂè™‰∏é \(s_k\) Áõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ\(p\)„ÄÅ\(q\) ÁöÑÂÖ∑‰ΩìÊ±ÇÊ≥ïÂêéÈù¢‰ºöËØ¶ÁªÜÊèèËø∞„ÄÇÂÅáËÆæÂ∑≤ÁªèÊ±ÇÂæó‰∫Ü \(p\)„ÄÅ\(q\)ÔºåËÄÉËôëÊÄé‰πàÂø´ÈÄüÂæóÂà∞Á¨¨‰∏âÈÉ®ÂàÜÁöÑÂåπÈÖçÊ¨°Êï∞„ÄÇ ÊääËØ¢ÈóÆÁ¶ªÁ∫ø„ÄÇÂØπÊØè‰∏™ \(i\)ÔºåÂª∫‰∏ÄÊ£µ \(s_i\) ÁöÑÂêéÁºÄÊ†ëÂíå \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë„ÄÇÂú® \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë‰∏ä \(dfs\)Ôºå\(dfs\) ÁöÑËøáÁ®ã‰∏≠ÔºåÁª¥Êä§‰∏ÄÊ£µÁ∫øÊÆµÊ†ë„ÄÇÂ¶ÇÊûú \(dfs\) Âà∞‰∏Ä‰∏™‰ª£Ë°® \(s_i^R\) ÂêéÁºÄÁöÑÁÇπÔºåËÆæËøô‰∏™ÁÇπÂØπÂ∫îÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ \(l\)ÔºåÈÇ£‰πàÂ∞±Âú®Á∫øÊÆµÊ†ë‰∏äÊää \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÂØπÂ∫î \(s_i[l+1\ldots \lvert s_i \rvert]\) ÁöÑÁÇπÁöÑÂ≠êÊ†ë \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂä†‰∏Ä„ÄÇÔºàÂèØËÉΩÊèèËø∞ÁöÑ‰∏çÊòØÂæàÊ∏ÖÊ•ö...Êàë‰πü‰∏çÁü•ÈÅìÊÄé‰πàÊèèËø∞‰∫ÜÔºâÂõûÊ∫ØÊó∂Êí§ÈîÄÊìç‰Ωú„ÄÇÁÑ∂ÂêéÂØπÊØè‰∏™ËØ¢ÈóÆ \(p, q\)ÔºåÂè™Ë¶ÅÂú® \(dfs\) Âà∞ \(s_i^R\) ÈïøÂ∫¶‰∏∫ \(p\) ÁöÑÂêéÁºÄÊó∂ÔºåËØ¢ÈóÆ‰∏Ä‰∏ã \(s_i\) ÈïøÂ∫¶‰∏∫ \(q\) ÁöÑÂêéÁºÄÂú® \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÁöÑ \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÁöÑÂÄºÂç≥ÂèØ„ÄÇ ËÄÉËôëÂ¶Ç‰ΩïÊ±Ç \(p\)„ÄÅ\(q\)„ÄÇÁî±‰∫éÊ±Ç \(q\) ÁöÑËøáÁ®ãÂíåÊ±Ç \(p\) Á±ª‰ººÔºåËøôÈáåÂè™ËØ¶ÁªÜÊèèËø∞Ê±Ç \(p\) ÁöÑËøáÁ®ã„ÄÇÂØπÊâÄÊúâ \(s_i\) ‰ª•Âèä \(s_i^R\) Âª∫Âá∫‰∏Ä‰∏™Âπø‰πâSAM„ÄÇÁÑ∂ÂêéÁ±ª‰ººACËá™Âä®Êú∫+BITÁöÑËøáÁ®ãÂú∞ÔºåÁª¥Êä§‰∏Ä‰∏™‰ª•parentÊ†ë \(dfs\) Â∫è‰∏∫‰∏ãÊ†áÁöÑÁ∫øÊÆµÊ†ë„ÄÇÁÑ∂ÂêéÂú®ÁÇπÂàÜÊ≤ªÂêéÂæóÂà∞ÁöÑËøûÈÄöÂùó‰∏ä \(dfs\)Ôºå\(dfs\) Âà∞ \(u\) Êó∂Áª¥Êä§ \(r\rightarrow u\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Âú®SAM‰∏äÁöÑ‰ΩçÁΩÆÔºåÂπ∂ÊääÂÆÉÁöÑÂ≠êÊ†ëÂú® \(dfs\) Â∫è‰∏äÁöÑ‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÂ≠êÊ†ëÂØπÈïøÂ∫¶Âèñ \(max\)„ÄÇÁÑ∂ÂêéÊ±Ç \(p\) Êó∂Âè™ÈúÄË¶ÅËØ¢ÈóÆ‰∏Ä‰∏ã \(s_k^R\) Âú® \(SAM\) ‰∏äÁöÑ‰ΩçÁΩÆÂú®parent tree‰∏≠ÁöÑ \(dfs\) Âú®Á∫øÊÆµÊ†ë‰∏äÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• „ÄåPKUWC2018„ÄçMinimax„ÄÇ Â§ßËá¥ÊÄùË∑Ø&amp;&amp;ÂêêÊßΩ Á∫øÊÆµÊ†ëÂêàÂπ∂ÔºåÁª¥Êä§Êüê‰∏™ÁÇπÊúÄÂêéÁöÑÂÄºÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™Âå∫Èó¥ÁöÑÊ¶ÇÁéá„ÄÇ merge ÁöÑÊó∂ÂÄôËÆ∞‰∏Ä‰∏ãÂâçÂêéÁºÄÊ¶ÇÁéáÂ∞±ËÉΩËΩ¨Áßª‰∫Ü„ÄÇ ‰ª£Á†ÅËÉΩÂäõÁúüÊòØË∂äÊù•Ë∂äÂ∑Æ‰∫Ü..Á∫øÊÆµÊ†ëÂêàÂπ∂ÈÉΩÂÜô‰∏çÁÜü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 Êï¥Êï∞]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) ‰∏™ \(bit\) Âéã‰∏ÄËµ∑ÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥Â∑¶ËæπËøûÁª≠ \(0\) Âíå \(2^{30}-1\) ÁöÑ‰∏™Êï∞„ÄÇ ‰ª£Á†ÅËÉΩÂäõÂ§™Ëèú‰∫ÜË°•Ë°•Ê∞¥È¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ Ë¥®Êï∞Âà§ÂÆö„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] ÂèçÂõûÊñá‰∏≤]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄåSDOI2018„ÄçÂèçÂõûÊñá‰∏≤„ÄÇ È¢òËß£ ËÄÉËôë‰ªÄ‰πàÊ†∑ÁöÑÂõûÊñá‰∏≤Âú®Âæ™ÁéØÁßª‰Ωç \(k\) ‰ΩçÂêéËøòÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤„ÄÇ ËÆæ \(s\) ÊòØ‰∏Ä‰∏™Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶‰∏∫ \(n\) ÂõûÊñá‰∏≤„ÄÇ ËÆ∞Â≠óÁ¨¶‰∏≤ \(a\) ÁöÑÂèç‰∏≤‰∏∫ \(a^R\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØÂõûÊñá‰∏≤ÔºåÂØπ‰∫é \(1\le i \le n\)Ôºå\(s[i]=s[n-i+1]\)„ÄÇ ÂèàÂõ†‰∏∫ \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤Ôºö ÂØπ‰∫é \(1 \le i \le n-2k\)Ôºö \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) ÂØπ‰∫é \(n-2k &lt; i \le n-k\)Ôºö \(s[i] = s[2n-2k-i+1] = s[i+2k]\) ÂØπ‰∫é \(n-k&lt;i \le n\)Ôºö \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) ÂèØ‰ª•ÁúãÂá∫ \(2k\) ÊòØ \(s\) ÁöÑÂë®ÊúüÔºå‰∏î \(s\) Âæ™ÁéØÂè≥Áßª \(2k\) ‰ΩçÂêéÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤‰∏é \(s\) Áõ∏Á≠â„ÄÇÂõ†Ê≠§ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÊòØ \(n\) ÁöÑÁ∫¶Êï∞„ÄÇËÆæ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÈïøÂ∫¶‰∏∫ \(t\)Ôºå\(t \mid n\)„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûú \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰Ωç‰ªçÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÈÇ£‰πà \(t \mid 2k\)„ÄÇÊúâ \(t\) Áßç‰∏çÂêåÁöÑ‰∏é \(s\) Âæ™ÁéØÂêåÊûÑÁöÑ‰∏≤„ÄÇËã• \(t\) ‰∏∫ÂÅ∂Êï∞ÔºåÈÇ£‰πà \(s\) Âæ™ÁéØÂè≥Áßª \(\frac t 2\) ‰ΩçÊàñÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇÂê¶ÂàôÂè™ÊúâÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇ ‰∏∫‰∫ÜËÆ°ÁÆó‰∏éÊüê‰∏™ÂõûÊñá‰∏≤Âæ™ÁéØÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÔºåËÄÉËôëÊûö‰∏æÂõûÊñá‰∏≤Âπ∂ËÆ°ÁÆó‰∏éËøô‰∏™ÂõûÊñá‰∏≤ÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤ÊúâÂ§öÂ∞ëÁßçÔºåËøôÊ†∑ÊúÄÂ∞èÂë®ÊúüÊòØÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤‰ºöË¢´ÁÆóÊÅ∞Â•Ω‰∏§Ê¨°ÔºåÂÖ∂‰ªñÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤Âè™‰ºöË¢´ÁÆó‰∏ÄÊ¨°„ÄÇÁâπÂà§ÊúÄÂ∞èÂë®Êúü‰∏∫ÂÅ∂Êï∞ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå‰∏çÂèØËÉΩÊûö‰∏æÊâÄÊúâÁöÑÂõûÊñá‰∏≤„ÄÇËÄÉËôëÊääÊúÄÂ∞èÂë®ÊúüÁõ∏ÂêåÁöÑÂõûÊñá‰∏≤ÊîæÂú®‰∏ÄËµ∑Êûö‰∏æ„ÄÇËÆæÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è‰∏∫ \(K\)ÔºåÊúÄÂ∞èÂë®Êúü‰∏∫ \(i\) ÁöÑÁ∫¶Êï∞ÁöÑÂõûÊñá‰∏≤Êúâ \(K^{\lceil \frac i 2 \rceil}\) ‰∏™„ÄÇËé´ÊØî‰πåÊñØÂèçÊºî‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå \(n\) ÈùûÂ∏∏ÁöÑÂ§ßÔºåÊ≤°ÊúâÂäûÊ≥ïÁõ¥Êé•ÂèçÊºîÂá∫‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ ÊääÁ≠îÊ°àÂÜôÂá∫Êù•ÂåñÁÆÄÔºö \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] Êûö‰∏æ \(d\)„ÄÇ \(d\) ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)„ÄÇ \(d\) ‰∏∫Â•áÊï∞Êó∂ÔºåËã• \(n\) ‰∏∫Â•áÊï∞Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)ÔºåÂê¶Âàô \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)„ÄÇ \(Pollard-Rho\) ÂàÜËß£Á¥†Âõ†Êï∞ÂêéÁÆÄÂçïÁªüËÆ°‰∏Ä‰∏ãÁ≠îÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [Ynoi2016]Èïú‰∏≠ÁöÑÊòÜËô´„ÄÇ ËÆ∞ÂΩïÊØè‰∏™ÁÇπ \(i\) ÂâçÈù¢Á¨¨‰∏Ä‰∏™‰∏é‰ªñÂêåËâ≤ÁöÑ‰ΩçÁΩÆ \(pre_i\)„ÄÇËØ¢ÈóÆÂå∫Èó¥È¢úËâ≤Êï∞ÂèòÊàêËØ¢ÈóÆÂå∫Èó¥ÂÜÖÊúâÂ§öÂ∞ë‰∏™ \(pre_i &lt;l\)ÔºåËøôÊòØ‰∏Ä‰∏™‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò„ÄÇÊ≥®ÊÑèÂà∞‰øÆÊîπ \(pre\) Êï∞ÁªÑÊ¨°Êï∞ÂùáÊëä \(\mathcal O (n)\)ÔºåÁî® \(set\) Áª¥Êä§ÊØè‰∏ÄÊÆµÔºåcdqÂàÜÊ≤ªÊàñËÄÖÊ†ëÂ•óÊ†ëÂÅö‰∏Ä‰∏ã‰∫åÁª¥ÂÅèÂ∫èÂç≥ÂèØ„ÄÇ ËøôÈ¢òÊúâ‰∏ÄÁÇπÂç°Â∏∏..cdqÂàÜÊ≤ªÂÜôÂΩíÂπ∂ÈÄüÂ∫¶‰ºöÂø´ÂæàÂ§ö„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //Á¶ªÊï£Âåñint pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //ÂØπ l+1-r ÁöÑpreÊõ¥Êñ∞ set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[È¢òËß£] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[ËôΩÁÑ∂ÂâçÈù¢ËøòÊúâÂæàÂ§öÂùëÊ≤°Ë°•ÂÆå...‰ΩÜÊòØÊàëÂèëÁé∞Ëá™Â∑±‰ª£Á†ÅËÉΩÂäõÈóÆÈ¢òÊØîËæÉ‰∏•Èáç„ÄÇÊâÄ‰ª•Êù•ÂÅöÂÅöynoi„ÄÇ ÂùëÂÖàÊîæÂú®Ëøô...Ê∏ÖÈÜíÁöÑÊó∂ÂÄôÊÖ¢ÊÖ¢Â°´„ÄÇ [YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢„ÄÇ ÂÖàÂíïÁùÄ„ÄÇ„ÄÇ„ÄÇ‰∏á‰∏ÄÈÅá‰∏äÁé∞Êé®Âêß„ÄÇ]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÊâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ„ÄÇ ËøôÈ¢òÁõÆÊúâÈóÆÈ¢òÂêß....Ê®°Êï∞ÂèØ‰ª•ÁàÜ long long ÁöÑ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÂêéÁºÄËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂêéÁºÄËá™Âä®Êú∫„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Splay(Áª¥Êä§Â∫èÂàó)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [NOI2005]Áª¥Êä§Êï∞Âàó„ÄÇ Â∏∏Êï∞ÈùûÂ∏∏ÈùûÂ∏∏Â§ß.....ÂÖàÂΩìÊùøÂ≠êËÉå‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèexp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÂØπÊï∞ÂáΩÊï∞„ÄÇ ‰ª£Á†ÅÁâπÂà´‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊ±ÇÈÄÜ]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÊ±ÇÈÄÜ„ÄÇ \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) ‰ª£Á†Å‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ‰ªªÊÑèÈïøÂ∫¶DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm Ê±Ç \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) ËÆæ \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)„ÄÇ Âàô \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)„ÄÇ \(i-k\) ÂèØËÉΩ‰ºöÂá∫Áé∞Ë¥üÊï∞„ÄÇÂπ≥Áßª‰∏ãÂÅö‰∏™Âç∑ÁßØÂç≥ÂèØ„ÄÇ ÊáíÂæóÂÜôQAQ„ÄÇÔºàÂ•ΩÂÉè‰πüÊ≤°Âï•Â•ΩÂÜôÁöÑÔºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] NTTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∏™ÊôÆÈÄöÁöÑ NTT Ê®°Êùø„ÄÇ‰ª£Á†ÅÈùûÂ∏∏‰∏ë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FFTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÁúÅÈÄâÂâçÂ§ç‰π†„ÄÇËøôÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ fft Ê®°Êùø„ÄÇ ÔºàÂèëÁé∞Ëá™Â∑±Â∑ÆÁÇπfftÊ®°Êùø‰∏ç‰ºöÊâì‰∫ÜÔºâ Âõ†‰∏∫Ê≤°ÊúâÈ¢ÑÂ§ÑÁêÜ&amp;&amp;Áî®‰∫ÜcomplexÁ±ªÂèØËÉΩÂ∏∏Êï∞ÊØîËæÉÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÊàëÂèëÁé∞Ëá™Â∑±ÁöÑ‰ª£Á†ÅËÉΩÂäõÂ§™Âº±‰∫Ü...... Êúâ‰∫õÊ®°ÊùøÈúÄË¶ÅÂπ≥Êó∂ÂÜô‰∏Ä‰∏ãÔºå‰∏çËÉΩÁé∞Âú∫ÂÜôÔºåÂê¶Âàô‰∏ç‰∏ÄÂÆöË∞ÉÁöÑÂá∫Êù•„ÄÇËøôÈáåÂàóÂá∫‰∏Ä‰∫õÂ∏∏Áî®Ê®°Êùø„ÄÇÔºà‰ºòÂåñÂ∏∏Êï∞&amp;&amp;‰ºòÂåñ‰ª£Á†ÅÂ§çÊùÇÂ∫¶&amp;&amp;ËÉå‰∏ãÊù•Ôºâ„ÄÇ Â§öÈ°πÂºèÔºö FFT NTT Â§öÈ°πÂºèÊ±ÇÈÄÜ Â§öÈ°πÂºèln Â§öÈ°πÂºèexp Â§öÈ°πÂºèÂèñÊ®° Â§öÈ°πÂºèÂ§öÁÇπÊ±ÇÂÄº Â§öÈ°πÂºèÂø´ÈÄüÊèíÂÄº Â§öÈ°πÂºèÂ§çÂêàÈÄÜ Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé® Êï∞ËÆ∫Ôºö LucasÂÆöÁêÜ exCRT ÊùúÊïôÁ≠õ Pollard-Rho Miller-Rabin min_25Á≠õ Á±ªÊ¨ßÂá†ÈáåÂæó ‰∫åÊ¨°Ââ©‰Ωô Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºö Á∫øÊÆµÊ†ëÂêàÂπ∂ Ê†ëÁä∂Êï∞ÁªÑ Splay LCT ETT ÁÇπÂàÜÊ†ë Ê†ëÈìæÂâñÂàÜ Âä®ÊÄÅdp Â≠óÁ¨¶‰∏≤Ôºö ÂêéÁºÄËá™Âä®Êú∫ Âª∫ÂêéÁºÄÊ†ë ÂêéÁºÄÊï∞ÁªÑ trieÊ†ëSAM ACËá™Âä®Êú∫ ÂõûÊñáÊ†ë ÂÖ∂‰ªñÔºö FWT ÂçäÂπ≥Èù¢‰∫§ Áü©Èòµ-Ê†ëÂÆöÁêÜ ÂõæËÆ∫Ôºö ÊîØÈÖçÊ†ë ÂúÜÊñπÊ†ë ËæπÂèå]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢òÁõÆ]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑËøô‰πàËèú‰∫ÜËøòÂè£ËÉ°È¢òÁõÆ...Â§ßÊ¶Ç‰ºöË∂äÊù•Ë∂äËèúÂêß.. 2019.3.29 CF 1097G \(k\) Ê¨°ÊñπÁúã‰ΩúÊòØÈÄâ \(k\) Êù°Ëæπ„ÄÇËÄÉËôëÊâÄÊúâ \(k\) Êù°ËæπÁöÑÊúâÂ∫èÂØπÔºåËÆ°ÁÆóÂåÖÂê´ÂÆÉ‰ª¨ÁöÑÈõÜÂêàÊï∞„ÄÇËÉåÂåÖ \(dp\) ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇÊ†πÊçÆÊüêËÄÉËøáÂæàÂ§öÊ¨°ÁöÑÂ§çÊùÇÂ∫¶ÂàÜÊûêÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ \(\mathcal O (nk)\)„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Ôºö https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf È¢òÁõÆÂ§ßÊÑè ËæìÂÖ•‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ≠óÁ¨¶‰∏≤ \(s\)„ÄÇ‰Ω†Êúâ‰∏Ä‰∏™Á©∫‰∏≤ \(t\)Ôºå‰Ω†Ë¶ÅÊääÂÆÉÂèòÊàêËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂèØ‰ª•ËøõË°å‰ª•‰∏ãÂá†ÁßçÊìç‰ΩúÔºö Âú® \(t\) ÁöÑÂºÄÂ§¥ÊàñËÄÖÊú´Â∞æÊ∑ªÂä†‰∏Ä‰∏™Â≠óÁ¨¶„ÄÇ Êää \(t\) ÁøªËΩ¨ËøáÊù•ÔºåÁÑ∂ÂêéÊé•Âú®ÂéüÊù•ÁöÑ \(t\) ÁöÑÂºÄÂ§¥ÊàñÊú´Â∞æ„ÄÇ Ê±ÇÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ \(n \le 10^5\) Ëß£Ê≥ï Âú®ÊúÄÂêéËøûÁª≠ÁöÑËã•Âπ≤Ê¨°Âä†Â≠óÁ¨¶Êìç‰Ωú‰πãÂâçÔºå\(t\) ‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÂÄíËøáÊù•ËÄÉËôëÔºåÁî®ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞Êää \(s\) ÂèòÊàêÁ©∫‰∏≤„ÄÇÂè™ÈúÄË¶ÅÂàÜÂà´ËÄÉËôëÊØè‰∏™ÂõûÊñá‰∏≤ÁöÑÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Âª∫Á´ãÂõûÊñáÊ†ë„ÄÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏âÁßçËΩ¨ÁßªÔºö ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤Âèò‰∏∫‰ªñÁöÑ‰∏ÄÂçä„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂéªÊéâ‰ªñ‰∏§Á´ØÁöÑÂ≠óÁ¨¶„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåËΩ¨ÁßªÂà∞‰ªñÁöÑÊúÄÈïøÂõûÊñáÂâçÁºÄ„ÄÇ ÊåâÈïøÂ∫¶‰ªéÂ∞èÂà∞Â§ßÈ°∫Â∫è \(dp\)„ÄÇÂêé‰∏§ÁßçËΩ¨ÁßªÂèØ‰ª•Áõ¥Êé•ËÆ°ÁÆó„ÄÇÂØπÁ¨¨‰∏ÄÁßçËΩ¨ÁßªÔºåÂÄçÂ¢û‰∏Ä‰∏ãÂà§Êñ≠ \(fail\) Ê†ë‰∏äÊúâÊ≤°ÊúâÈïøÂ∫¶ÊÅ∞Â•Ω‰∏∫‰∏ÄÂçäÁöÑÁ•ñÂÖàÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØÂÅáÁöÑ„ÄÇË¶ÅÁúÅÈÄâ‰∫Ü..ÂÖàË°•ÁÇπÂà´ÁöÑÂÜçÊù•ÊâìËøôÈ¢òQAQ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â≠óÁ¨¶‰∏≤ÊäÄÂ∑ß„ÄÅÊÄùÊÉ≥„ÄÅÁü•ËØÜÁÇπÊï¥ÁêÜ]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! U2FsdGVkX1+Xgqa0R7Bm9Cq2rtjYVaHmfqPUcr2vYNESKZaUUTRMGMFpzbTumz6Qr+V/DRovv3dBuH8bKHsiDKMyMaphcxvvebAsUioWKE7u9cFIotkmui1ajH4QRiCInhwhYXcJk3DSjwzLHRbTyWC739p5w+/78j087QJofbBh/m5tBYPFlEzkeAsPu7eUNviqcuhMwiGKNbpcq1n7MAtVjDfTGNLAcuG3JHpW8VcQ0a101KAFvbNDPs/8TBqqz/adPhRaTOjDg0fXeLiZR7IqG/xl38DLkVDHJoeXEU5QVLlx6H27Dpi//OXg9f2q1llLJsxEtoHdYj63wqYuzZZg/KTygUxoL4KpwSRXnaIFNJen1XsXwHJh9HmCu+CO1xmSTADBmBd8s8idDOQTQ5kgHQ6pZjdlAsYlUHp3VYraIfGeNEtuz5/weKyaeCcKTQqpovL/1qPM4Qr3YfIY21ROv4QO2Ff7naG50xAL2amv7T+T+TMJ0mIO/MAE3tANxQLcZ+haoOJKPEZyqSdcOgpRrPhu9ALc2qNntYriQVbvX6IFbSwwImMFmQQR5faaaQRHRVUGvthdZ2IygRqptnNrVatxIeHOdlWt+NtomfFHXxE70chS/E3IcPhuc1Ln1yiCQQq954Vpuz0xXiKryBKRh9ko2T7ZUWaDPCgpq+gHgDctRC9m/5bm7HkRPF4dz4jJa9CIlk0CNqsN7ng6Ddb6w7//R/ZqpHLDLx8HMKrcUdWb41y49hE7n2fJ52Gc7yprykkzx9+wNSfLz4dePiL+H9PdoTZACOYlaP0q6MDjx3UvMkYfEGW/0q73bA85Y0HUHfPjUWthw4176zBtoW1QYhataVu8eycHP732JH6DrBhlm00v+RSAKEO+RhE3HicxX2xxPV44CgvIIk+gtdjTCPcgFbjjLJUSuXkuZnbLoJGKyadvlIIOUQytW7NcGHDYRsUyPa3tW+sYTHLheeaZLByOTJTAr9DLw/ZhcG20zJQ+Z71pYqrxCO9HjBKByfXq/Uh6/Icin33jrxdknD2RqPZaf9ChmPNKO3FgtHdFI0mcvrF8QXPOczfgflT4PR0Xg352LcYTPTbgNJg7xQNJ1mE8sA625dGtJkW6HGlFs4uGhvvD9aNr6+ruX33V31r+D3BLDE63Oi211zCGP3E9wb7MG4nW5KrD+IS5N8S4c//HUZJoIlpn5D4FeKsPkz0pIzYJ2XwMoNWb8pI4Ea0a7Ccj3T25XiuKyoyJuCN5Vo5xTVsWxp/ezRG/iLM2mUurGGi/XlLlupgve0IErUY09oLNnpJxl2f5pntnf/7iXd+vQ/KKXIKuYGFdf+MA+WRzdIw2/QDvng2E20LW0whT19agFD22dPh4T3FTtyQWvgeGlBYQrH5zRSxikIhusB5vdJiNh0AkAzkoJCLAFyXh6j2FOxlWYnbZZgrN/Zl5UJ94vmYrU+dIkjNLVDFoJdUYD8BSreU03UrG2z8ikcmDr4bHBXKzEF4gxSALvg6MDcDSvoaLyAiAzP++/FM2QxvB/ULR4TDBKQ48xV3jXOc4PrcYkvQx5kaia/8jeC5sqzVWzei+BWIAM6SKMRN/aYiYI0FOob0LZjsC+Nn+V3GOKkvQwyCb6EMww+qDiQM11ksrQVsv9FJZPug61pyoHqtQ781rGlgCoVvSgpnGuYL9QGCcnaXUtXSh4jBeXX9OzFDP1PotxfiuaCpwTlBnfa2kemya7jsLM7wMlHTq2t1sC+mKNI8oQ7Ans5yYiA2thJbuGCD9/bsywWjybg/dvBJPG4leoXQAjYgnv+ocgWy6CZlEFuTyFmCvk+zq1AuVe5zEPF1gJxV9y7sj76QWV8nk95uuTI0RLHK+wAfCxsuxNlxLphYqxw9fixbn3LnYIvBA88suU1PeEK1F2mtELxLFTKNTsDdAGLt/f6KLYntG8O5NofkDb0x0zFwIMzbDe+6X0TTHXVyf5LfQKzDZvrriSW9bWxMBjYQNbqJ4937LSkOwcoz4xSbdvS7LuHs22rPfJ/oQpyWtkMCoLEGGjFXhvucTbbC0bEMNdsbXw8PTHtJMbJsSupZU72ao/gIsDwFKq5cC9Id/Ma6xGbhaY+0QIo4g9uuN/gyVaBkt08JKdjL06zb9R+H0SrRcbS0RxWuDv9AHeH5Dfk8RaAwCsu4byRRWGuIg+ivGpphY31dM8cpkFVBg/fe9+BikDetGJY5hocII3Ws4vtILtKtqRn6C7lj54lQtxW3tDws0J981mfYdmlmwaus4JGpdf1qI4Z7GtxXv7p1pag/DxtwOZIM16qh/rb6GApQWjOOGVF/MENEhRheN8Tn8Mm6urdVz3m6YjGqgzzFhe6T72bi6b/T6NAbZsctz3olmwb3eNFV/OEtMvJIPHtx75XB96RWJ9fqaNd/a8mAb80naGC7DnU8E/QH5Fgj5sX2fsbVIUGcOoeCnsbS7PYU63cMNR3HekPZXfrqBdqrRGzrzrwIiSx5UIje/wb081JML8Gsd8w==]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon wordÁöÑ‰∏Ä‰∫õÊÄßË¥®]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Lyndon_word ÂÆö‰πâ Â¶ÇÊûú‰∏Ä‰∏™‰∏≤ÊúÄÂ∞èÂêéÁºÄÊòØÂÆÉÊú¨Ë∫´ÔºåÈÇ£‰πàÁß∞‰ªñ‰∏∫ Lyndon word„ÄÇÔºà‰∏é‰∏•Ê†ºÊúÄÂ∞èÂæ™ÁéØÁßª‰ΩçÁöÑÂÆö‰πâÊòØÁ≠â‰ª∑ÁöÑÔºâ Áõ∏ÂÖ≥ÊÄßË¥®ÂíåÁÆóÊ≥ï ÊÄßË¥®1 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºåÈÇ£‰πà \(s\) ‰∏çÂ≠òÂú® border„ÄÇ ÊÄßË¥®2 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºå\(s=uv\) ‰∏î \(u\) Âíå \(v\) ÈùûÁ©∫ÔºåÈÇ£‰πà \(u&lt;v\)„ÄÇ ÊÄßË¥®3 Â¶ÇÊûú \(s,t\) ÊòØ Lyndon word ‰∏î \(s &lt; t\)ÔºåÈÇ£‰πà \(st\) ‰πüÊòØ Lyndon word„ÄÇ ÊÄßË¥®4 ‰∏Ä‰∏™ÈïøÂ∫¶Â§ß‰∫éÁ≠â‰∫é \(2\) Â≠óÁ¨¶‰∏≤ÁöÑ \(s\) ÊòØ Lyndon word ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå\(s\) ÂèØ‰ª•ÊãÜÊàê‰∏§‰∏™ÈùûÁ©∫‰∏≤ \(u,v\)ÔºåÊª°Ë∂≥ \(u &lt; v\) ‰∏î \(u\) Âíå \(v\) ÈÉΩÊòØ Lyndon word„ÄÇ ËØÅÊòé ÂÖÖÂàÜÊÄßÂç≥‰∏ä‰∏ÄÊù°ÊÄßË¥®ÔºåÂè™ËØÅÂøÖË¶ÅÊÄß„ÄÇ ËÆæ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(n\)ÔºåÂêéÁºÄ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄ„ÄÇ ÂÅáËÆæ \(s[1..i-1]\) ÊúâÈïøÂ∫¶‰∏∫ \(k\) ÁöÑ borderÔºåÂç≥ \(s[1..k]=s[i-k..i-1]\)„ÄÇ Âõ†‰∏∫ \(k &lt; i-1\)ÔºåÊâÄ‰ª• \(k+1 \neq i\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØ Lyndon wordÔºå\(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊâÄ‰ª• \(s[i..n]&lt;s[k+1..n]\)„ÄÇÂèàÂõ†‰∏∫ \(s[i-k..i-1]=s[1..k]\)ÔºåÊâÄ‰ª• \(s[i-k..n]&lt;s[1..n]\)ÔºåËøô‰∏é \(s\) ÊòØ Lyndon word ÁüõÁõæ„ÄÇÊâÄ‰ª• \(s[1..i-1]\) Ê≤°Êúâ border„ÄÇ Ê†πÊçÆ Lyndon word ÁöÑÂÆö‰πâÂèä \(s[1..i-1]\) Ê≤°Êúâ borderÔºåÊúâ \(\forall 1 &lt; j \le i-1\)Ôºå\(\exists j \le k \le i-1\)ÔºåÊª°Ë∂≥ \(s[k] &gt; s[k-j+1]\)ÔºåÂç≥ \(s[j..i-1] &gt; s[1..i-1]\)„ÄÇÊâÄ‰ª• \(s[1..i-1]\) ÊòØ Lyndon word„ÄÇ Âõ†‰∏∫ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊòæÁÑ∂‰∏çÂ≠òÂú® \(j&gt;i\) Êª°Ë∂≥ \(s[j..n]&lt;s[i..n]\)ÔºåÊâÄ‰ª• \(s[i..n]\) ÊòØ Lyndon word„ÄÇ ÊâÄ‰ª• \(u=s[1..i-1],v=s[i..n]\) ÊòØ‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊãÜÂàÜÔºåÂøÖË¶ÅÊÄßÂæóËØÅ„ÄÇ ÊÄßË¥®5 ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\) ÈÉΩÂèØ‰ª•ÂîØ‰∏ÄÂú∞ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÂÖ∏Â∫è‰∏çÂ¢ûÁöÑ Lyndon Word„ÄÇ ÊàëÊäΩ‰ª£Â§™Ëèú‰∫Ü...ÂÖ∂‰ªñÁöÑÊÄßË¥®‰ª•ÂêéÂÜçË°•Âêß„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon ÂàÜËß£]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ëß£Ê≥ï ÂÖ≥‰∫é Lyndon word ÁöÑ‰∏Ä‰∫õÁªìËÆ∫ÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/D È¢òÁõÆÂ§ßÊÑè ÁªôÂÆö‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÔºå‰ª• \(1\) ‰∏∫Ê†πÁöÑÊ†ëÔºåÁ¨¨ \(i\) ‰∏™ÁÇπÊúâ‰∏Ä‰∏™‰ª∑Ê†º \(c_i\)„ÄÇ ‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™‰∫∫‰ºöÁªôÊØè‰∏™Âè∂ËäÇÁÇπËÆæÁΩÆ‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ‰Ω†Âè™ËÉΩÂØπÂ∑≤ÁªèÈÄâÊã©ÁöÑÁÇπÂÅöÂ≠êÊ†ëÂä†‰ªªÊÑèÊï∞Â≠óÁöÑÊìç‰Ωú„ÄÇ ‰Ω†Ë¶ÅÈÄöËøáËã•Âπ≤Ê¨°Êìç‰ΩúÊääÊâÄÊúâÂè∂Â≠êËäÇÁÇπ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\)„ÄÇ ÈóÆÔºöË¶ÅÁ°Æ‰øùÂè¶‰∏Ä‰∏™‰∫∫Êó†ËÆ∫ÊÄé‰πàÊìç‰Ωú‰Ω†ÈÉΩËÉΩÊääÂè∂Â≠ê‰∏äÁöÑÊï∞ÂèòÊàê \(0\)Ôºå‰Ω†ÈÄâÊã©ÁöÑÁÇπ‰ª∑Ê†ºÊÄªÂíåÊúÄÂ∞èÊòØ‰ªÄ‰πàÔºüÊúâÂì™‰∫õÁÇπË¢´Ëá≥Â∞ë‰∏ÄÁßçÊúÄÂ∞è‰ª∑Ê†ºÁöÑÊñπÊ°àÂåÖÂê´Ôºü \(n \le 200000\)Ôºå\(0\le c_i \le 10^9\)„ÄÇ Ëß£Ê≥ï Ëøô‰∏™ÈóÆÈ¢òÂèØ‰ª•ÁúãÊàêÔºå‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπ‰Ωú‰∏∫Êú™Áü•Êï∞ÔºåÊØè‰∏™Âè∂Â≠êÁöÑÈôêÂà∂ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÊñπÁ®ãÔºå‰Ω†Ë¶ÅËÆ©Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÊª°Ë∂≥ÔºåÊó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåËøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Âõ†‰∏∫‰ª∑Ê†ºÊòØÈùûË¥üÊï¥Êï∞ÔºåÂ¶ÇÊûúÁ≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÁõ∏ÂÖ≥ÔºåÂøÖÂèØ‰ª•Âà†Èô§Êüê‰∏ÄÂàóÔºåÂç≥ÂèØ‰ª•Â∞ëÈÄâ‰∏Ä‰∏™ÁÇπÔºåËøôÊ†∑‰∏ÄÂÆö‰∏ç‰ºöÂèòÁöÑÊõ¥Â∑ÆÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥„ÄÇÂõ†‰∏∫Êó†ËÆ∫Â∏∏Êï∞È°πÁöÑÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩË¶ÅÊúâËß£ÔºåÊâÄ‰ª•Ë°åÊï∞Á≠â‰∫éÂàóÊï∞„ÄÇ ÁªìËÆ∫ ËÆæÂè∂ËäÇÁÇπ‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∏Ä‰∏™ÂåÖÂê´ÊÅ∞Â•Ω \(x\) ‰∏™ÁÇπÁöÑÈÄâÂèñÊñπÊ°àËÉΩ‰øùËØÅÂèØ‰ª•Â∞ÜÊâÄÊúâÂè∂Â≠ê‰∏äÁöÑÊï∞Â≠óÂèòÊàê \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÔºåÂ≠òÂú®Ë¢´ÈÄâÂèñÁöÑÁÇπÔºå‰∏îÊ∑±Â∫¶ÊúÄÂ§ßÁöÑË¢´ÈÄâÂèñÁÇπ‰∏çÂêå„ÄÇ ËØÅÊòé ÂøÖË¶ÅÊÄßÊòæÁÑ∂„ÄÇ ÂÖÖÂàÜÊÄßÔºöÊääÊñπÁ®ãÁªÑÁöÑÊú™Áü•Êï∞Êåâ‰ªªÊÑè‰∏ÄÁßç \(dfs\) Â∫èÊéíÂàóÔºåÁ≥ªÊï∞Áü©Èòµ‰∏≠ÔºåÊØè‰∏ÄË°åÁöÑÁ¨¨‰∏Ä‰∏™Èùû \(0\) ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂàóÈÉΩ‰∏çÂêåÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥ÔºåÂèàÂõ†‰∏∫Ë°åÊï∞Á≠â‰∫éÂàóÊï∞ÔºåÊâÄ‰ª•Êó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Áä∂ÊÄÅ \(dp[i][j][k]\) Ôºö \(i\) Ë°®Á§∫Âè™ËÄÉËôë‰ª• \(i\) ‰∏∫Ê†πÁöÑÂ≠êÊ†ë„ÄÇ \(j\) Ë°®Á§∫ \(i\) ÊòØÂê¶Ë¢´ÈÄâÊã©„ÄÇ \(k\) Ë°®Á§∫ÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Âè∂Â≠êÔºå‰ªñÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏≠Ê≤°ÊúâÁÇπË¢´ÈÄâÊã©„ÄÇ \(dp\) Êï∞ÁªÑ‰∏≠Â≠òÁöÑÊòØÔºåÊª°Ë∂≥‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏äÊ∑±Â∫¶ÊúÄÂ§ßÁöÑÁ•ñÂÖà‰∏çÂêåÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÁúã‰Ωú \(0\)ÔºâÁöÑÊúÄÂ∞è‰ª∑Ê†ºÂíå„ÄÇ \(dp\) ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéËÆ∞ÂΩïÂì™‰∫õËΩ¨ÁßªÂèØ‰ª•ÂèñÂà∞ÊúÄ‰ºòÂÄºÔºåÊúÄÂêé‰ªéÊ†πÂºÄÂßã \(dfs\) ‰∏ÄÈÅçÊ±ÇÊñπÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ÔºàÂ∑®‰∏ëÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/C È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s\)„ÄÇ ËØ∑‰Ω†Êää \(s\) ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÁ¨¶‰∏≤ \(s=t_1t_2\cdots t_k\)„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∏≤ÔºåËã• \(t_i\) ÊòØ \(t_1t_2\cdots t_{i-1}\) ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(b\) ÁöÑ‰ª£‰ª∑ÔºåÂê¶Âàô \(t_i\) ÈïøÂ∫¶ÂøÖÈ°ª‰∏∫ \(1\)Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(a\) ÁöÑ‰ª£‰ª∑„ÄÇÊ±ÇÊúÄÂ∞è‰ª£‰ª∑„ÄÇ \(n \le 5000\)ÔºåÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è \(26\)„ÄÇ Ëß£Ê≥ï ËÆæ \(dp_i\) Ë°®Á§∫Ââç \(i\) ‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂ∞èÂàíÂàÜÔºåÂú®Ê±ÇÂá∫ \(dp_i\) ÂêéÁî® \(kmp\) ÊâæÊúÄÈïøÂú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑ‰ªé \(i+1\) ÂºÄÂßãÁöÑ‰∏≤ÔºåÊõ¥Êñ∞ÊâÄÊúâ \(dp_j\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÊï¥ÁêÜÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Impartial_game impartial game ÊòØÊåáÊª°Ë∂≥Â¶Ç‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÔºö - ‰∏§‰∏™Áé©ÂÆ∂ËΩÆÊµÅÊìç‰ΩúÔºåÁõ¥Âà∞ËææÂà∞‰∏çËÉΩÊìç‰ΩúÁöÑÁä∂ÊÄÅÔºàterminal positionÔºâ„ÄÇ - ÂΩì‰∏Ä‰∏™Áé©ÂÆ∂‰∏çËÉΩÊìç‰ΩúÊó∂Ôºåwinner Â∞±Ë¢´Á°ÆÂÆö‰∫Ü„ÄÇ - ÊØè‰∏™Áä∂ÊÄÅÁöÑÊìç‰ΩúÊï∞ÂíåÁä∂ÊÄÅÊÄªÊï∞ÊòØÊúâÈôêÁöÑ„ÄÇ - ÊâÄÊúâÁöÑÊìç‰ΩúÂøÖÈ°ªÂêåÊó∂ËÉΩË¢´‰∏§‰∏™Áé©ÂÆ∂ËøõË°å„ÄÇ - ÊâÄÊúâÊìç‰ΩúÁöÑÁªìÊûúÈÉΩÊòØÁ°ÆÂÆöÊÄßÁöÑ„ÄÇ Normal play convention wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Normal_play_convention Impartial game ÁöÑ Normal play convention ÔºöÊúÄÂêé‰∏Ä‰∏™ÂèØ‰ª•Êìç‰ΩúÁöÑÁé©ÂÆ∂Ëé∑ËÉú„ÄÇ NimÊ∏∏Êàè wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Nim ÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅÂèñÁü≥Â≠ê„ÄÇÊØèÊ¨°ËΩÆÂà∞ÁöÑ‰∫∫ÂèØ‰ª•ÈÄâÊã©‰ªéÊüê‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Ëã•Âπ≤È¢óÁü≥Â≠êÔºà‰∏çËÉΩ‰∏çÊãøÔºâÔºå‰∏çËÉΩÊåâËßÑÂàôÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ Nim Ê∏∏ÊàèÂ±û‰∫é Impartial game„ÄÇ NimÊ∏∏ÊàèÁöÑËÉúÂà©Êù°‰ª∂ ÂÆöÁêÜÔºöÂΩì‰∏î‰ªÖÂΩìÊØèÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) Êó∂ÔºåÂÖàÊâãÂøÖËÉú„ÄÇ ËØÅÊòéÔºö ÂØπ‰∫é terminal positionÔºåÂç≥Ê≤°ÊúâÁü≥ÁöÑÊÉÖÂÜµÔºåÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåËΩÆÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑ‰∫∫Ëæì„ÄÇÂÆöÁêÜÂØπ terminal position ÊàêÁ´ã„ÄÇ ÂºïÁêÜ1 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\)ÔºåÂàôÂÆÉÂøÖÂÆöÂèØ‰ª•ËΩ¨ÁßªÂà∞‰∏Ä‰∏™Áü≥Â≠ê‰∏™Êï∞‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\)„ÄÇ ËÆæ \(s\) ÊúÄÈ´òÁöÑ‰∫åËøõÂà∂‰ΩçÊòØÁ¨¨ \(k\) ‰ΩçÔºà‰ªé‰ΩéÂà∞È´òÔºåÊúÄ‰Ωé‰Ωç‰∏∫Á¨¨ \(0\) ‰ΩçÔºâ„ÄÇ ‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÂ†ÜÁü≥Â≠ê‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∫åËøõÂà∂‰∏ã \(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)„ÄÇ Èô§‰∫ÜËøôÂ†ÜÁü≥Â≠êÂ§ñÔºåÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\oplus x\)„ÄÇ \(s\oplus x\) Âíå \(x\) Âú®ÊâÄÊúâÊØîÁ¨¨ \(k\) ‰ΩçÈ´òÁöÑ‰∫åËøõÂà∂‰Ωç‰∏äÁõ∏Á≠âÔºå\(s\oplus x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(0\)Ôºå\(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)ÔºåÊâÄ‰ª• \(s \oplus x &lt; x\)„ÄÇ ÂèØ‰ª•‰ªéËøôÂ†ÜÁü≥Â≠ê‰∏≠ÂèñËµ∞ \(x-s\oplus x\) ‰∏™Áü≥Â≠êÔºå‰ΩøÂºÇÊàñÂíåÂèò‰∏∫ \(0\)„ÄÇ ÂºïÁêÜ2 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÈÉΩ‰ºöËΩ¨ÁßªÂà∞‰∏Ä‰∏™ÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊìç‰ΩúÁöÑÂ†ÜÂú®Êìç‰ΩúÂâçÊúâ \(x\) È¢óÁü≥Â≠ê„ÄÇ ÈÇ£‰πàÈô§‰∫ÜËøôÂ†Ü‰ª•Â§ñÁöÑÂÖ∂‰ªñÂ†ÜÁü≥Â≠êÊï∞ÂºÇÊàñÂíå‰πü‰∏∫ \(x\)„ÄÇ Âú®ÂèñÁü≥Â≠êÂêéÔºåËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏ÄÂÆö‰∏ç‰∏∫ \(x\)„ÄÇ Âè™ÊúâËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏∫ \(x\) Êó∂Ôºå‰∏éÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíåÊâç‰ºö‰∏∫ \(0\)„ÄÇ ÊâÄ‰ª•Êìç‰ΩúÂêéÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏ÄÂÆöÈùû \(0\)„ÄÇ Ê†πÊçÆÁªìÊûÑÂΩíÁ∫≥Ê≥ïÂèØÁü•ÂÆöÁêÜÊàêÁ´ã„ÄÇ Sprague‚ÄìGrundy ÂÆöÁêÜ wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Sprague‚ÄìGrundy_theorem ÂÆö‰πâ \(mex\) ËøêÁÆóÔºå‰∏Ä‰∏™ÈõÜÂêàÁöÑ \(mex\) ÂÄºÊòØÊúÄÂ∞èÁöÑÊ≤°ÊúâÂá∫Áé∞Âú®Ëøô‰∏™ÈõÜÂêà‰∏≠ÁöÑËá™ÁÑ∂Êï∞„ÄÇ ÂÆö‰πâ Sprague-Grundy ÂáΩÊï∞ÔºöÂØπ‰∫é‰∏Ä‰∏™Áä∂ÊÄÅ \(x\)ÔºåÂΩì \(x\) ÊòØ terminal position Êó∂Ôºå\(SG(x)=mex\{SG(y)|x\) ÂèØ‰ª•ËΩ¨ÁßªÂà∞ \(y\}\)„ÄÇ ÂèØ‰ª•Áî® Sprague-Grundy ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏™Áä∂ÊÄÅÊòØÂøÖËÉúÁä∂ÊÄÅËøòÊòØÂøÖË¥•Áä∂ÊÄÅÔºåÂõ†‰∏∫ÂøÖËÉúÁä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏ç‰∏∫ \(0\)ÔºåÂøÖË¥•Áä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏∫ \(0\)„ÄÇ ÂÆö‰πâ‰∏§‰∏™Ê∏∏ÊàèÁöÑ disjunctive sum ‰∏∫‰∏Ä‰∏™Ê∏∏ÊàèÔºöËΩÆÂà∞ÊØè‰∏™Áé©ÂÆ∂ÁöÑÊó∂ÂÄôÔºå‰ªñÂèØ‰ª•ÈÄâÊã©‰∏§‰∏™Ê∏∏Êàè‰∏≠ÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Ê∏∏Êàè‰∏äÊìç‰Ωú‰∏ÄÊ≠•ÔºåÊó†Ê≥ïÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÊòæÁÑ∂ disjunctive sum Êª°Ë∂≥‰∫§Êç¢ÂæãÂíåÁªìÂêàÂæã„ÄÇ ÂÆöÁêÜ Êúâ \(n\) ‰∏™Ê∏∏Êàè \(G_1,G_2,\cdots,G_n\)ÔºåËÆæ‰ªñ‰ª¨ÁöÑ disjunctive sum ‰∏∫ \(G\)„ÄÇÈÇ£‰πà \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)„ÄÇ ËØÅÊòéÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ Ëøô‰πüËØ¥Êòé‰∫ÜÊØè‰∏Ä‰∏™ normal play convention ‰∏ãÁöÑ impartial game ÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰∏™NimÊ∏∏Êàè„ÄÇ]]></content>
      <tags>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
