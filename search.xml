<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[做法 设 \(C(x) = \sum x^{c_i}\)，\(a_i\) 是权值和为 \(i\) 的二叉树数量 (特别地，空二叉树算作一种权值和为 \(0\) 的二叉树)，\(A(x) = \sum_{i \ge 0} a_ix^i\)。 则 \(A(x) = A^2(x)C(x)+ 1\)，\(C(x)A^2(x)-A(x)+1=0\)。由一元二次方程求根公式得 \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)，由于 \(A(x)\) 在形式幂级数环中，这里应该取负号。 于是多项式开根一下就好了。(因为 \([x^0] (1-4C(x)) = 1\)，只存在两个的多项式 \(F(x)\) 满足 \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)，一正一负) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[神仙题，之前听人提过。但是凸性完全不会证，会了之后补上 QwQ。 做法 显然使 \(\sum s_i^2\) 取到最小值的划分一定满足条件。 所以二分斜率求出 \(\sum s_i^2\) 最小的序列就行了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点双连通分量的求法]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由于我水平太低普及组知识点都没掌握，今天终于搞懂了一点所以打算记录一下。 下面讨论的都是无向图，由于连通块间独立，我们只考虑连通图的情况。 如果点数为 \(1\)，在某些问题下需要特殊处理。下面我们只考虑点数不为 \(1\) 的情况。 定义 1 对于一个连通图 \(G\)，如果从 \(G\) 删去点 \(u\) 和所有与它相邻的边得到的图不连通，就称 \(u\) 是 \(G\) 的一个割点。 定义 2 若连通图 \(G\) 中不存在割点，则称 \(G\) 是一个点双连通图。 定义 3 称连通图 \(G\) 的极大点双连通图子图为 \(G\) 的点双连通分量。 性质 1 两个不同点双连通分量的交至多包含一个点。 证明 假设两个不同的点双连通分量 \(A\) 和 \(B\) 有交，设这两个点双连通分量的并为 \(H\)，根据点双连通分量的定义，\(H\) 一定不是点双连通图，所以存在一个点 \(u\)，从 \(H\) 中删去点 \(u\) 后得到的图不连通。\(H\) 中删去点 \(u\) 得到的图即为 \(A\) 删去点 \(u\) (如果存在) 和 \(B\) 删去点 \(u\) (如果存在) 得到的图的并。如果 \(A\) 和 \(B\) 的交大于 \(1\)，由于两个有交的连通图的并仍为连通图，\(H\) 中删去点 \(u\) 得到的图也是连通图，这就导出了矛盾。 性质 2 在一个连通图 \(G\) 中，对于任意一条边 \(e\)，恰有一个 \(G\) 的点双连通分量包含边 \(e\)。 证明 边 \(e\) 的两个顶点的导出子图就是一个 \(G\) 的大小为 \(2\) 的点双连通子图，所以也一定存在包含边 \(e\) 的点双连通分量。由性质 1 可知两个不同的点双连通分量不可能包含同一条边。 由于点双连通分量是连通的，只要确定了一个点双连通分量中所有边，点也就确定了。图 \(G\) 的所有点双连通分量构成边集的一个划分。 在图上作 DFS，取一棵以 \(r\) 为根的 DFS 树，设点 \(u\) 第一次被访问时间为 \(dfn_u\)，\(u\) 子树中所有点通过一条返祖边能够到达的 dfn 最小的点的 dfn 与 \(dfn_u\) 的最小值为 \(low_u\) (注意返祖边指的是非树边，不包含 \(u\) 到父亲的边，实现时要特判)。 设点 \(u\) 在这棵 DFS 树上的父亲为 \(fa(u)\)。 对于点 \(u \neq r, fa(u) \neq r\)，如果 \(low_u &lt; dfn_{fa(u)}\)，那么存在一个包含点 \(u, fa(u), fa(fa(u))\) 的点双连通子图，从而 \(u\) 到父亲的边和 \(fa(u)\) 到父亲的边在同一个点双连通分量中。 在 DFS 的过程中，每经过一条树边就把这条树边放入一个栈中。在点 \(u\) 回溯时，检查一下是否有 \(low_u \ge dfn_{fa(u)}\) (如果是根的话不用检查了)。 考虑第一次满足这个条件的回溯，此时点 \(u\) 子树中所有树边都在同一个点双连通分量中，因此存在一个包含 \(u\) 子树中所有点的点双连通子图。因为不存在跨过 \(u\) 到父亲的边的非树边，这个点双连通子图是一个极大点双连通子图，所以 \(u\) 的子树中所有点的导出子图是一个点双连通分量。我们把这个点双连通分量中的点保存起来，然后从栈中弹出 \(u\) 子树中所有树边。 在之后的回溯中，如果满足 \(low_u \ge dfn_{fa(u)}\)，那么此时栈中所有树边在同一个点双连通分量中，且这些边的所有端点的导出子图是一个点双连通分量。把这个点双连通分量保存下来然后把栈中所有 \(u\) 子树中的边弹出即可。 这样就在 \(\mathcal O(n+m)\) 的复杂度内求出了每个点双连通分量的点集。一个点双连通分量中的边就是这个点双连通分量内部的树边加上这个点双连通分量中所有点的返祖边，这很容易处理。（注意这里返祖边的定义是从某个点出发到它祖先的非树边，这也就意味着每条非树边是恰好一个点的返祖边）]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[做法 一个图的染色方案数等于各个点双的染色方案数乘积除以颜色数的(点双数 - 连通块数)次方（考虑对每个连通块在圆方树上从上往下对每个点双染色）。 根据题目中的条件，一个点双的大小不会超过 \(7\)，暴力枚举集合划分可以求出一个点双的色多项式，分治 fft 一下即可得到给定的图的色多项式，然后多点求值一下即可。 (为啥一定要给各种染色方案数题套个多点求值...好无聊) 完全不会写点双..调了一天。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// 第一类斯特林数int S[10][10];// 下降幂系数int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[做法 设 \(f_i\) 是第 \(i\) 步时恰好到达点 \(n\) 的概率，显然数列 \(\{f_i\}\) 满足一个不超过 \(n\) 阶的线性递推。 因为给定的图是平面图，所以 \(m = \mathcal O(n)\)，我们可以暴力求出 \(f\) 的前 \(2n\) 项，然后 BM 出递推式。得到递推式之后也就得到了生成函数，求个导把 \(x=1\) 代入就是答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[吐槽：这题目名取的。。。。 做法 要是不是预先知道是一般图最大匹配估计一星期都想不到。。 考虑构造一个无向图，然后用一般图最大匹配去处理它。 对每个 . 建一个点。如果一个格子是 +，那么建两个新的点，两个新的点都向它四周的 . 对应的点连边，然后两个新点之间连一条边。如果一个格子是 *，建两个新点，一个向上下的 . 对应的点各连一条边，一个向左右的 . 对应的点各连一条边。这样这个图的最大匹配减去 * 和 + 的个数就是答案。 时间复杂度理论可以做到 \(\mathcal O(n^2m^2)\)，可过。 然而我写的这个带花树似乎是三方的，但它也过了。。。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]「美团 CodeM 决赛」tree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[做法 对于一条链，假设它从某一端开始第一个大于 \(1\) 的点的点权为 \(x\)，这个点(开始的那一端到它)之前有 \(k\) 个点，之后有 \(l\) 个点，之后 \(l\) 个点点权乘积为 \(s\)。 假设这条链的答案比这个点左边的点构成的链和右边的点构成的链的答案都要严格优。 那么 \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] 所以 \(k = l\)。因此，如果一条链比它的所有子链都严格优，且这条链上存在点权大于 \(1\) 的点，那么从它两端开始的第一个点权大于 \(1\) 的点都是中点。 所以只需考虑全 \(1\) 链和以某个点为中点，其他点都是 \(1\) 的链。 换根 dp 一下即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea 整理]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[太神仙了，看 sol 了。 做法 先规定当两个石子距离为 \(1\) 时，不能移动坐标小的石子。这样就只需要对操作序列计数了。 考虑对有 \(K\) 个把某个石子的坐标增加 \(1\) 的操作的方案计数。\(K = N\) 的情况很容易单独考虑。 对于 \(K &lt; N\) 的情况，假设我们已经确定了把某个石子的坐标增加 \(1\) 的操作，考虑一个序列 \(s\)，若第 \(i\) 个把某石子坐标 \(+1\) 操作移动的是坐标小的石子，\(s_i = -1\)，否则 \(s_i = 1\)。这样的一个序列 \(s\) 显然满足 \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)。对于一个这样的序列 \(s\)，我们来考虑有多少种把“坐标小的石子移动到坐标大的石子的位置”的操作插入到这个（只包含把某石子坐标增加 \(1\) 的操作的）操作序列之中的方案。显然 \(s\) 中有 \(B\) 个 \(1\)，\(K-B\) 个 \(-1\)。如果最后一个插入的操作插在 \(s_i\) 对应的操作和 \(s_{i+1}\) 对应的操作之间，那么 \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)。设 \(t_i = \sum_{k \le i} s_k\)。如果有一个操作被插入在 \(s_i\) 和 \(s_{i+1}\) 对应的操作之间，且存在 \(j &gt; i\)，\(t_j \le t_i\)，那么这个操作序列一定不合法。所以最后一个插入的操作一定在 \(t_i = B-(K-B)-(B-A)=B+A-K\) 的最后一个 \(s_i\) 与 \(s_{i+1}\) 之间，其他操作必须插入最后一个 \(t_i = x, x \le B+A-K\) 的最后一个 \(s_i\) 与 \(s_{i+1}\) 之间，且只要满足这个条件得到的就是一个合法的操作序列。于是问题就变成了求把 \(N-K-1\) 拆成 \(B+A-K+1\) 个非负整数之和的方案数，这很容易用一个组合数计算。注意到对于不同的 \(s\)，插入操作的方案之和 \(K\) 有关，所以我们枚举 \(K\) 统计答案即可。 对于一个对应的 \(K\)，计算对应的 \(s\) 的个数是一个类似卡特兰数的问题，不会的话可以去看看 AGC021E。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[做法 考虑一个无向图 \(G\)，如果存在一个 balancer \((x_i,y_i)\)，就在点 \(x_i\) 和点 \(y_i\) 之间连一条标号为 \(i\) 的无向边。 第一部分：\(T=1\) 假设存在一个方案，考虑所有被用过 balancer，可以发现它们对应的边构成的子图一定是 \(G\) 的一棵生成树，且如果把最后终止的 wire 作为根，每个点到它父亲的边的标号都小于它父亲到它父亲的父亲的边的标号（如果存在的话）。反过来，容易验证如果存在一棵这样的生成树，那么也存在一种合法方案。 把 balancer 作为点建一个有向图，如果 balancer \(i,j\) 都连接了某个 wire，且 \(i &lt; j\)，就从 \(j\) 到 \(i\) 连一条边。如果存在合法方案，一定可以从这个图上某个点出发，到达与每个 wire 相连的至少一个 balancer。反过来，如果存在这样一个点，我们从这个点对应的 balancer 开始，按编号从大到小考虑每个 balancer。维护一个 balancer 的集合，初始时只有这个点对应的 balancer，考虑到一个 balancer 时，如果它连接的一个 wire 是当前维护的集合中某个 balancer 的端点，另一个不是，就把这个 balancer 加入集合。最后得到的集合显然是一个满足条件的生成树。 所以我们只要找到一个满足条件的 balancer，然后用以上算法构造即可。优化一下建边，我们可以对每个 wire，把与它相邻的 balancer 排序，只考虑相邻的 balancer 之间的有向边。然后就是一个简单的 DAG 上 DP 问题，直接做复杂度为 \(\mathcal O(nm)\)，用 bitset 优化一下就能过了。 第二部分：\(T=2\) 当 \(n \ge 3\) 时，从后往前依次加入每条边，可以发现总存在一种方案使所有 wire 最终不汇聚在同一个点。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[做法 特判掉两棵树一模一样的情况。 枚举第一个操作的点及其操作方式，设这个点为 \(r\)。我们考虑进行完第一次操作后的两棵树。 设第一棵树为 \(T_A\)，第二棵树为 \(T_B\)，把 \(r\) 作为两棵树的根。接下来我们在有根树上考虑问题。 假设在一个合法方案中，你在某个时刻把点 \(u\) 染黑并接到点 \(v\)，那么在这之后 \(v\) 以及其祖先一定都不可能是叶子，所以此时 \(T_A\) 上 \(u\) 到根的路径等于 \(T_B\) 上 \(u\) 到根的路径。因此 \(v\) 必须是 \(u\) 在 \(T_B\) 上的父亲。 如果一个点初始时到根的路径（经过的点的序列）在两棵树上不同，我们称它为不好的，否则我们称它为好的。显然我们不会染黑好的点，而不好的点必须要被染黑。所以我们只需要解决可行性问题。 事实上，存在一个合法方案等价于存在一个不好的点的排列，使得： - 任意一个不好的点在 \(T_A\) 上的所有儿子都排在它之前。 - 任意一个不好的点在 \(T_B\) 上的所有儿子都排在它之后。 这是一个有向图是否存在拓扑序的问题，判一下 DAG 即可。 时间复杂度 \(\mathcal O(Tn^3)\)。由于我懒写了 \(\mathcal O(Tn^4)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[做法 对于给定的序列 \(a\)，我们把它拆成两个非负序列 \(x\) 和 \(y\) 的和。然后仅用不减序列取得到 \(x\)，仅用不增序列得到 \(y\)。 容易证明，对于长为 \(k\) 序列 \(a\) (定义 \(a_0 = a_{k+1} = 0\))，把它拆成若干前缀不减序列的和，最小个数为 \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)；把它拆成若干后缀不增序列的和，最小个数为 \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)。 于是我们可以想到一个贪心，考虑 \(i\) 从小到大地决定 \(x\) 和 \(y\) 的第 \(i\) 项，然后使得前 \(i\) 项 \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) 尽可能小。然而直接贪心是不对的。注意到，对于两种 \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) 相等的方案，\(x_i\) 较小的一定比较优，而且如果前 \(i\) 项一个方案的代价比前 \(i\) 项最小代价方案的代价还要大超过 \(2\)，它一定不优。所以实际上我们可以只保留三个方案，使得其中一定有一个在之后可以变成最优方案。 时间复杂度 \(\mathcal O(n)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // 先判断是否可能不增加 // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // 再判断只增加一项，x 的最小值（显然可以只增加一项） ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[做法 不妨假设 \(n \ge m\)。 只会 \(\mathcal O(n \log^2 n)\) 自闭了，去看题解了。 由于你的决策不会影响之后的问题的答案，所以显然每次选概率大的就比较好。 设第 \(k+1\) 个问题能够答对的概率为 \(p_k\)，假设前 \(k\) 个问题中答对了 \(a\) 个，那么 \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] 分为 \(n - a &lt; m - (k - a)\) 和 \(n-a \ge m - (k - a)\) 计算贡献。 设 \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)。 第一部分： \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) 这一部分对 \(p_k\) 贡献为 \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] 第二部分 \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) 这一部分对 \(p_k\) 贡献为 \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] 快速计算 \(H,G\) 的意义是有多少条从 \((0,0)\) 到 \((n,m)\) 的非降路径与直线 \(x+y = s\) 的交点的横坐标在某个范围内。 由这个组合意义很容易得出 \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] 所以我们从小到大枚举 \(k\) 线性维护 \(H\) 和 \(G\) 需要用到的值，就在 \(\mathcal O(n)\) 的复杂度内解决了问题。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[做法 考虑一个无向图 \(G\)，对于第 \(i\) 个交换，如果交换的是 \(a_i\) 和 \(a_j\)，在点 \(i\) 和点 \(j\) 之间连一条边，标号为 \(i\)。 设 \(S_1\) 是所有第一个序列中是 \(0\) 第二个序列中是 \(1\) 的位置的集合，\(S_2\) 是所有两个序列中都是 \(1\) 的位置的集合，\(S_3\) 是所有第一个序列中是 \(1\) 第二个序列中是 \(0\) 的位置的集合。 \(S_1\) 和 \(S_3\) 中点度数都是 \(1\)，\(S_2\) 中点度数都是 \(2\)。不难证明，如果最终两个序列变得一样 \(G\) 的一个连通块要么是一条 \(S_1\) 中点到 \(S_3\) 中点的路径，要么是一个 \(S_2\) 内部的环。 考虑对能使两个序列变得一样的图的形态和边的标号计数，那么，对于一个固定的图 \(G\)，一个环上的标号顺序是无所谓的，一条链标号一定是从 \(S_1\) 一侧到 \(S_3\) 一侧递增。所以如果决定了 \(G\)，可以先决定每个连通块的边用哪些标号，然后对于环可以任意排列，链只有一种标号方式。 考虑决定 \(S_2\) 中的图的结构，我们可以写出环和链的 EGF，\(C(x)\) 和 \(P(x)\)。 \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) 题目中要求的即是 \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)。 NTT 一下即可，时间复杂度 \(\mathcal O(n \log^2 n)\)。（其实直接写上系数就是了，前面推的完全用不到...） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[做法 吐槽：为啥这种没啥意思的题会是 agc 的 F 题。 这个游戏是从 \(1\) 开始的游戏和从 \(2\) 开始的游戏的和，所以只要从 \(1\) 开始的游戏和从 \(2\) 开始的游戏 SG 值不一样就行。 考虑按 \(SG\) 值 \(dp\)，\(dp_{S}\) 表示集合 \(S\) 中任何的点 SG 值都比 \(S\) 外任何点消，至少一端在 \(S\) 中的边的方案数。 转移就是枚举 SG 为 \(S\) 中最大 SG 值加一的点的集合，然后这个集合内部所有边都不选，所有不在这个集合内也不在 \(S\) 内的点到这个集合至少有一条边，乘以一个系数；这个集合到不在这个集合中也不在 \(S\) 中的点的边可选可不选，乘以一个系数。注意 \(1,2\) 不能同时在这个集合。 时间复杂度 \(\mathcal O(n3^n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[做法 把问题放到一个无向图上考虑，如果第 \(i\) 个人选了火鸡 \(x_i,y_i\)，就在 \(x_i,y_i\) 之间连一条无向边，我们称这条边的时间为 \(i\)。 考虑一个火鸡 \(s\) 幸存的条件：如果 \(s\) 在时刻 \(t\) 没被吃掉，对于每一条边 \(\{s,v\}\)，如果这条边的时间小于等于 \(t\)，被吃掉的都是火鸡 \(v\)，于是火鸡 \(v\) 要在这条边的时间幸存，如此传递下去，最终会得到若干条被吃掉的火鸡确定边，这些边会构成一棵树（如果不构成一棵树的话火鸡 \(s\) 不可能幸存）。显然只要这个树上的边被吃掉的火鸡满足了条件，\(s\) 也一定会幸存。因此火鸡 \(s\) 和 \(t\) 同时幸存的条件就是它们对应的确定的边没有冲突。 由于一个火鸡幸存的条件中最多 \(n-1\) 条边被吃掉的火鸡被确定，所以可以暴力检查两个火鸡是否可以同时幸存，时间复杂度为 \(\mathcal O(n^3)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[做法 如果红树上有一条边 \((u,v)\)，\(u\) 和 \(v\) 在蓝树上距离大于 \(2\)，那么 Sigma 走到 \(u\) 或 \(v\) 就可以一直跑下去了。 我们把存在一条相邻红边在蓝树上距离大于 \(2\) 的点标记一下，只要到达这种点就可以一直往下跑。 假设 Sigma 在点 \(X\)，Sugim 在点 \(Y\)，考虑蓝树去掉点 \(Y\) 后形成的若干个连通块，Sigma 无法从一个连通块的未标记点到另一个连通块。所以显然 Sugim 的最优策略是，每次在蓝树上向 \(X\) 所在的方向走一步。Sigma 的最优策略是不会重复经过走过的点的。 于是我们可以很容易地求出 Sigma 可能走到哪些点，如果他能走到一个标记点，那么就可以一直跑下去。否则答案就是能走到的点在蓝树上与 \(Y\) 的最远距离。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // 此时 Y 的深度为 T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于最长反链方案的构造]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[有一些求最长反链的题目会让你构造方案，比如 [CTSC2008] 祭祀 和 CF590E Birthday。 找到了一个写的比较清晰的做法，r-64 的 uoj blog。 大概是说建出二分图求最大独立集，所有两部中对应的点都在独立集中的点构成最长反链。 构成反链是显然的，构成最长反链的理由似乎不太完整（也有可能是作者觉得这过于显然了），坑了我很久，这里记录一下。 设原图点数为 \(n\)，二分图的最大匹配为 \(m\)，那么最小链覆盖大小为 \(n-m\)，最大独立集大小为 \(2n - m\)。我们要证明，对于一个最大独立集，左右部中对应点都在其中的点有 \(n-m\) 个。首先我们要证明，对于任意一个点，它在左右部对应的点至少有一个在最大独立集中（那篇 blog 中似乎缺少了这一步）：如果一个点在左右部对应的点都不在最大独立集中，一定有一个与它在左部对应的(二分图上的)点有边的(二分图上的)点 \(a\) 在最大独立集，也有一个与它在右部对应的点有边的点 \(b\) 在最大独立集中。由偏序关系的传递性可知 \(a\) 和 \(b\) 在二分图上有一条边，与最大独立集的定义矛盾。因此，最大独立集大小等于 \(n + 左右部对应点都在最大独立集中的点的数量\)，也就证明了我们构造出的反链是最长反链。]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] 「JOISC 2017 Day 1」开荒者]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[做法 设东西南北方向吹的次数分别为 \(c_E, c_W, c_S, c_N\)。 题意相当于是要求 \(c_E+c_W+c_S+c_N\) 最小的 \(c_E,c_W,c_S,c_N\)，使得在平面上放 \(n\) 个矩形，第 \(i\) 个矩形的横坐标范围为 \([S_i - c_N, S_i + c_S]\)，纵坐标范围为 \([E_i - c_W, E_i + c_E]\)，能够覆盖以 \((1,1)\) 为左上角的 \(R \times C\) 矩形。 假设有一个方案，考虑调整。 代码]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[知识点] 万能欧几里得]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[例题 LOJ6440 做法 考虑这样一个问题：作一条射线 \(y = \frac{Px+R}Q\)，只考虑 \(x &gt; 0\)，碰到一条直线 \(y = i\) 就执行操作 \(A\)，碰到一条直线 \(x = i\) 就执行操作 \(B\)，\(i\) 是正整数。 “操作序列”对应的信息要可合并。 考虑递归地处理问题，设 \(A\) 和 \(B\) 是两个操作序列对应的信息。定义 \(solve(P, Q, R, L, A, B)\) 表示一个含有 \(L\) 个 \(B\)，第 \(k\) 个 \(B\) 和第 \(k-1\) 个 \(B\) 之间有 \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) 个 \(A\) 的操作序列的信息（\(k = 1\) 时是开头 \(A\) 的数量）。把 \(R\) 对 \(Q\) 取模不会改变答案，把 \(P\) 对 \(Q\) 取模只要把 \(B\) 变成 \(A^{\lfloor \frac P Q \rfloor}B\) 就可以得到同样的结果。 先取模，保证 \(P, R &lt; Q\)。 考虑交换 \(A\) 和 \(B\) 的地位，原来我们是考虑每个 \(B\) 前面有几个 \(A\)，现在我们考虑每个 \(A\) 前面有几个 \(B\)，第 \(i\) 个 \(A\) 在第 \(j\) 个 \(B\) 前面的条件是 \(i \le \frac{Pj+R}{Q}\)，即 \(j \ge \frac{Qi-R}P\)。那么第 \(i\) 个 \(A\) 在第 \(j\) 个 \(B\) 后面的条件是 \(j &lt; \frac{Qi-R}P\)，从第 \(i\) 个 \(A\) 前面有 \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) 个 \(B\)。我们只需要特别去处理一下最后一个 \(B\) 和 \(Qi-R-1\) 小于 \(0\) 的情况即可得到一个形式一样的问题。由于 \(R &lt; Q\)，\(i &gt; 0\) 时 \(Qi-R-1 \ge 0\)。但是 \(i = 0\) 时出现负数按之前的定义会出问题，所以第一个 \(A\) 以及前面的部分单独处理，调用 \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)，处理下开头结尾即可。要判一下没有 \(A\) 的情况。 涉及到求矩阵幂可以直接快速幂，可以证明复杂度仍是一个 \(\log\)。 关于值域 本题的值域特别大，要小心爆 long long。 下面我们来分析各个变量再递归过程中的最大值。 代码]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[做法 这个题比较水。 假设没有初始值和上限，那么其实要算一只 pony 能收取的 mana，只需要知道这次收取和上次收取的时间间隔，乘上 \(r_i\) 即可。 我们要在操作时维护所有 pony 的最后操作时间，这是一个简单的区间覆盖问题，很容易写一个均摊 \(\mathcal O(n \log n)\) 的实现：建一个线段树，修改时先把询问区间在线段树上拆成 \(\mathcal O(\log n)\) 个区间，对每个区间，做一个这样的过程：先考虑当前区间所有点是不是最终修改时间相同，如果是，就处理这个区间对答案的贡献，然后在这个区间上打标记，否则就两边递归下去。每次往下递归都会使得一个线段树上区间中不同的最终修改时间数减少一，从而这个算法的复杂度是均摊 \(\mathcal O(n \log n)\)。 有初始值和上限也可以类似的处理，不同的是，因为有了上限，需要对每个区间维护一个以 \(\lceil \frac {m_i}{r_i}\rceil\) 为关键字排好序的东西。这样你可以二分一下前多少个都是在这段时间里面 mana 满了的，直接加进答案，然后后面的只需要统计一下 \(r_i\) 的和乘上时间差加进答案即可。这个东西很容易暴力预处理。 初始值要特别处理，在每个点第一次修改时暴力算一下即可。 感觉实际上可以用线段树分裂和合并做到一个 \(\log\)。 总复杂度 \(\mathcal O(n \log^2 n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[做法 毒瘤分类讨论.... 就放个代码..结论太麻烦就不写了 TAT。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[做法 神仙题，看题解了。 取任意一个生成树，取这个树的重心和所有跨过这个重心的非树边的端点（实际上两个端点中只要任取一个就行，只要保证子树不连通），考虑跨过这些点的路径，然后再对每个子树点分。 注意不要把这些点删掉再对每个连通块做点分治，因为这样可能一个连通块不是一个树上连通块，就不是很好处理（应该也能处理）。 然后就像动态点分治一样维护就行，预处理一下要删去的点与当前连通块中每个点的最短距离。 时间复杂度 \(\mathcal O(nk\log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // 点分树上父亲，一个点被删掉时对应点分树上哪个点vector&lt;int&gt; vimp[maxn], mn[maxn]; // 点分树上一次删去的点，以及到连通块内最近被 mark 点的距离unordered_map&lt;ll, int&gt; mdis; // 被删去的点到内部一个点的距离int vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // 点分治用变量void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // 原本这里是把所有处理的点删掉的，写得可能有点奇怪，懒得改了 vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[做法 容易证明，对于一个长度为 \(n\) 的度数序列 \(d\)，存在一棵对应的 \(n\) 个点的树的充要条件是 \(1 \le d_i &lt; n\) 且 \(\sum {d_i} = 2(n-1)\)（从叶子归纳）。 考虑去钦定这个树的 \(k\) 个匹配，如果能钦定出来就说明答案 \(\ge k\)。钦定两个点匹配可以看作这两个点被缩到了一起，变成了一个度数和为两个点的度数之和减去 \(2\) 的点。只要保证所有匹配缩起来之后得到的度数序列依然满足之前所说的条件即可。这是一个众所周知的贪心问题，排序后贪心用小的匹配大的即可。需要特别注意 \(1\) 和 \(1\) 在点数大于 \(2\) 时不能匹配（因为 \(1+1-2=0\)），但是点数等于 \(2\) 时可以匹配。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[做法 奇怪的题目... 先把点按 \(a_i\) 从小到大重新标个号。接下来我们假设 \(a_i &lt; a_{i+1}\)。 把 \(1\) 看作根，显然可以通过调整使每个点的父亲编号都比他小。 把两种贡献一起考虑，定义边 \(\{u, fa(u)\}\) 的贡献为 \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)，对每个 \(u\) 去找能使代价最小的 \(fa(u)\)。由于这个树的特殊性质，点 \(u\) 最优的父亲一定是原树上 \(u\) 的祖先，所以倍增一下即可。 时间复杂度 \(\mathcal O(n \log n)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // 距离不超过 2^k 的点int cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[知识点] 最小树形图]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[问题 给定一个 \(n\) 个点 \(m\) 条边的带权简单有向图，求一个最小边权和的是以 \(r\) 为根的内向生成树。 外向树的情况没有本质区别，边反一反就好。 无根的情况可以加一个点转化为有根的情况。 算法 如果给定的有向图是 DAG，一个显然的贪心是，取除了 \(r\) 以外的每个点的最小出边。显然这样会构成一棵内向树，且不可能有权值和更小的内向树。 如果给定的有向图不是 DAG，直接取除了 \(r\) 以外的每个点的最小出边不一定会得到一棵树，此时可能会有多个弱连通块，每个连通块是一条链（包含 \(r\) 的）或者一棵基环内向树。如果你得到了一个内向生成树就求出了答案，下面我们考虑至少有一个环的情况。 可以发现，对于一个（某个基环树连通块中的）环，一定存在一个最小内向生成树，恰好只有一条环上边不在这个最小内向生成树中。原因很简单，我们先假设边权互不相同（你可以加入一个充分小的偏移量，在不影响答案的前提下使边权互不相同），设点 \(u\) 的最大出边连向点 \(f(u)\)，考虑一个最小内向生成树，如果存在一个点 \(u \neq r\)，\(f(u)\) 不在 \(u\) 的子树中，且 \(f(u)\) 不是 \(u\) 的父亲，我们可以把 \(u\) 的父亲改为 \(f(u)\)，得到一个更小的内向生成树，这与这个树是最小内向生成树矛盾。这说明，对于任意一个环上的点 \(u\)，使得 \(f(u)\) 不是 \(u\) 的父亲 (环上点肯定不是 \(r\))，\(f(u)\) 要么是 \(u\) 的父亲要么在 \(u\) 的子树中。考虑从 \(u\) 出发，每次从 \(u\) 走向 \(f(u)\)，在走回 \(u\) 之前，一定不会经过一个点两次，从而路径上只有第一次走的时候 \(f(u)\) 不是 \(u\) 的父亲，因此环上只有一条边没有在这个最小内向生成树中出现。 因此我们只需要考虑一个环上哪一条边没有出现。考虑把环缩成一个点，得到一个与原图等价的图。 例图 其中 \(e\) 是不在最小树形图中的边，从图中可以很明显地看到，把环缩成一个点，然后把缩完后的的点的出边边权减去原来这条出边对应的 \(e\) 的权值即可得到一个等价的图。 暴力缩点可以用 \(\mathcal O(nm)\) 的时间复杂度求出最小树形图。 复杂度优化 用并查集维护弱连通块，再用并查集维护当前哪些点被缩成了一个点。用可并堆维护当前每个点的出边，缩点时带 tag 合并一下，然后找最小出边，如果在同一弱连通块又可以缩点了，否则的话就和其他弱连通块合并在了一起。 缩一次至少减少一个点，所以这个算法的复杂度为 \(\mathcal O((n+m) \log n)\)。 实现 咕咕咕。 由于实现咕了所以也不能保证上面说的是对的。]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[做法 猜了个结论，不会证但是又想不到其他做法..看了眼题解发现是对的。 对于第 \(i\) 个抽奖，假设你买了 \(x\) 次，你从这个抽奖中获得的钱数的期望是 \(p_i\frac {x} {x + l_i}\)。假设你已经买了第 \(i\) 个抽奖 \(x\) 次，再买一次，期望的增加量是 \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)。容易发现这个增加量关于 \(x\) 单调递减，所以我们只要对于所有的 \(i\) 和 \(x \le i\)，把 \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) 丢进一个数组，从大到小排个序，前 \(t\) 个数之和即是答案。但是这样做复杂度不能接受。 我们先算出初始清空的最优方案，给第 \(k\) 个抽奖原有的票数加一减一之后，考虑两种操作：一，少买一个抽奖 \(k\)，多买一个另一个抽奖；二，多买一个抽奖 \(k\)，少买一个另一个抽奖。我们找到能使期望增加量最大的操作，这很容易用堆来维护。只需要经过一次这样的操作即可得到最优方案，证明就不具体写出了。（比如说如果是进行操作二，从进行一次操作二后，再进行一次操作二的减小量要比在修改票数之前进行一次操作二的减小量要大来考虑即可） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[做法 为了方便描述，先把题目中给定串翻转一下，变成要找一个每个串是后一个串子串的序列。 下面我们认为，这个序列中的元素是一个(包含位置的)子串。同一字符串出现在不同位置被认为是不同的。 假设你有一个序列，你一定可以在不改变长度的情况下把它调整成第 \(i\) 个子串长为 \(i\)。所以我们只考虑这类序列。 称一个子串 \(s[l..r]\) 是可达的，当且仅当存在一个这类序列以 \(s[l..r]\) 结尾。题目就是要求最长可达的子串。 注意到如果 \(l &lt; r\)，\(s[l..r]\) 可达，那么 \(s[l..r-1]\) 和 \(s[l+1..r]\) 一定可达。因此我们只需要对每个 \(l\) 求出最大的 \(r\) 使得 \(s[l..r]\) 可达，设对于 \(l=i\) 最大的 \(r\) 是 \(f_i\)。对 \(f\) 作 dp，显然 \(f_i \ge f_{i-1}\)，所以每次先令 \(f_i = f_{i-1}\)，然后检查一下 \(f_i\) 能不能增大，如果能增大就一直增大到不能增大就行了。检验只需要在 SAM 上找到要检验的串在某个位置之前的最后出现位置就好，这很容易用 SAM + 线段树实现（也可以用其他方式）。由于总共只会增大 \(\mathcal O(n)\) 次，这个算法的时间复杂度为 \(\mathcal O(n \log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// 有没有右端点在 x 或之前的int check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[做法 我们先不要考虑边权。 考虑直接 dp，\(dp[u][i][j]\) 表示 \(u\) 的子树中修改后有 \(i\) 个黑点，距离根最远的与子树中所有黑点距离都大于 \(x\) 的红点与根的距离为 \(j\)，最小要修改几次。转移的时候需要决定距离根最近的红点，所以需要知道距离根最近的黑点的距离，但是如果我们再记一个最近黑点的话复杂度就炸了。注意到一个性质：如果根是红点，距离根最近的黑点所在的(根的儿子的)子树中一定所有红点都可以在这个子树中找到距离不超过 \(x\) 的黑点。所以只要对 \(j = 0\) 的情况额外记录下最近的黑点。这样就可以 dp 了。 现在来考虑一下边权，注意到我们只需要记一个点到根的距离，所以我们可以把每个点到根的距离先离散化一下，这样就能做带权的情况了。 内存需要卡一下。 题解竟然是对 \(500\) 级别的东西跑单纯形，不太能理解出题人的想法。 时间复杂度为 \(\mathcal O(n^3)\)。经过艰难的调试和卡常终于 A 了。（时限 1000 ms，开 Ofast 982 ms，不开 Ofast 998 ms，TAT） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : 有 i 个黑点，所有红点深度不超过 j // g : 有 i 个黑点，没有未匹配红点，至少存在一个黑点深度不超过 j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[做法 先求重心：随便找个点，把多边形划分成若干个三角形，求出每个三角形重心，按有向面积加权平均。 对于一个点 \((x_p,y_p)\)，设 \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)。把它绕 \((x_0,y_0)\) 逆时针旋转 \(c\) 弧度，相当于把 \(p\) 左乘一个矩阵 \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)。只需要记一个 \(3 \times 3\) 矩阵就能快速获得每个点的位置。旋转时考虑一下固定的点和重心的位置即可。 听（题解上）说需要把一个点移到 \((0,0)\) 避免精度误差。不知道不这样能不能过。 （样例 2 真的会转吗？） 时间复杂度 \(\mathcal O(n+m)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // 现在用 p2 旋转 Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[做法 看成每次删除一个点时会给它所在的连通块每个点一个贡献。 对每个点对 \((u,v)\) 计算 \(v\) 会给 \(u\) 一个贡献的概率， 加起来就是答案。 题目中给定的图是一棵基环树。 对于 \(u = v\)，这个概率是 \(1\)。对 \(u \neq v\)，分两种情况讨论： 一， \(u,v\) 在同一个子树中。把 \(u\) 看作根，那么这个概率就是，每次从还未被删除的点中选择一个点，将其子树删除，当 \(v\) 被删除时，\(u\) 到 \(v\) 路径上除了 \(v\) 以外的点都还未被删除的概率。设总共有 \(n\) 个点，\(u\) 到 \(v\) 路径上有 \(k\) 个点，类似猎人杀一题中的技巧，我们可以知道这个概率等于不断从 \([1,n]\) 中等概率随机取一个整数，一旦出现 \(v\) 或 \(v\) 的祖先就停止，停止时除 \(v\) 以外 \(v\) 的所有祖先都未被删除的概率，即 \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)。 二，\(u,v\) 不在同一子树中，与情况一类似，但是不同的是此时 \(u\) 到 \(v\) 有两条路径，只要其中一条存在就有贡献。可以容斥成第一条存在的概率加上第二条存在的概率减去两条都存在的概率。这三个问题都可以类似情况一地解决。 这样就在 \(\mathcal O(n^2)\) 的时间复杂度内解决了本题。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数学</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[做法 想了挺久只会胡个 \(\mathcal O(n \sqrt n \log n)\) 的莫队 + 维护 huffman 树，去看了眼别人的题解发现也有是这个复杂度的.....不过比我胡的妙多了，下面写的是看到的别人的做法。 用莫队处理询问，维护下每个数出现几次，并记录下当前出现次数大于 \(x\) 的数。对次数不超过 \(x\) 的数，记一下每个数出现几次然后 \(\mathcal O(x)\) 算出合并代价。转化为只有出现次数超过 \(x\) 的数的情况，这时最多只有 \(\frac n x\) 个数，贪心合并即可。询问时间复杂度为 \(\mathcal O(x + \frac n x \log n)\)，取 \(x = \sqrt {n \log n}\)，则一次询问的复杂度为 \(\sqrt {n \log n}\)。 莫队维护出现次数大于 \(x\) 的数时可以使用链表，这样的话莫队的复杂度为 \(\mathcal O(n \sqrt n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
        <tag>贪心</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[做法 题目中的连边方式可以概括为，如果(开)区间 \((l_1,r_1)\) 与 \((l_2,r_2)\) 交不为空，且 \((l_1,r_1)\) 与 \((l_2,r_2)\) 不是一对存在包含关系的区间，那么这两个区间之间有一条双向边。否则，如果 \((l_1,r_1)\) 被 \((l_2,r_2)\) 包含，\((l_1,r_1)\) 到 \((l_2,r_2)\) 有一条有向边。 对于一个仅由双向边构成的连通块，设这个连通块中所有区间的并为 \((L,R)\)，我们可以认为现在就存在这样一个区间 \((L,R)\)。因为长度是递增的，如果之后加入一个区间 \((a,b)\)，\(a\) 被 \((L,R)\) 包含或者 \(b\) 被 \((L,R)\) 包含，那么 \((a,b)\) 与这个连通块中的某个点有一条双向边。不难发现，一个区间 \(a\) 能到达区间 \(b\) 的充要条件是 \(a\) 所在连通块所有区间的并被 \(b\) 所在连通块所有区间的并包含。这样我们只要用并查集维护连通块，并记录一下连通块的并的左右端点，就可以直接判断能否到达了。 update : 仔细证了一下之后似乎这一结论再两个连通块所有区间的并相同时不成立，需要特别判一下会不会其中一个连通块只有一个点。 我们用线段树维护，对于每个点有哪些连通块的并包含这个点。这可以通过在线段树上每个点开一个 vector 来实现，查询哪些连通块的并包含一个点时，只需取这个点到根的路径上所有 vector 的并即可。每加入一个区间，就对左右端点查一下，把得到的连通块合并，然后再把新的连通块加入线段树。由于所有被你查过的点 vector 中所有点都会被你合并，所以你每查询一个点的 vector 就可以把它的 vector 清空，而每加入一个区间最多增加一个连通块，你只会给 \(\mathcal O(\log n)\) 个点的 vector 添加元素。所以这个算法的总复杂度为 \(\mathcal O(n \log n \alpha (n))\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x 是根，把 y 加入 xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[做法 作重链剖分，然后求出重链剖分后的 dfs 序。 一条链可以拆成 dfs 序上 \(\mathcal O(\log n)\) 个区间。 按 dfs 序把每个点的字符排成一个字符串 \(s\)，预先建一个能 \(\mathcal O(1)\) 询问 \(s\) 的任意两个后缀 lcp，询问 \(s^R\) 任意两个后缀 lcp 和询问一个 \(s\) 的后缀和 \(s^R\) 的一个后缀的 lcp 的数据结构。可以对 \(ss^R\) 建树状数组，因为我不擅长写树状数组，所以我对它们用 SAM 求出了后缀树，然后写了一个 \(\mathcal O(n\log n) - \mathcal O(1)\) lca。 对于一个询问，一条链，可以看成 \(\mathcal O(\log n)\) 个区间拼起来，所以就变成了两组若干个区间拼起来的串要求 lcp，利用预处理的信息从前往后依次求就行了。 时间复杂度 \(\mathcal O(n \log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // 写一个给一个字符串支持询问 LCP 的东西 int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind 是正串后缀对应点 // rind 是反串后缀对应点 for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[做法 考虑按串长根号分类。 对于串长大于 \(\sqrt n\) 的串，这样的串不会很多，枚举每个这样的串，用 AC 自动机统计其他每个串作为这个串子串出现的次数，算一下前缀和，然后回答一下关于这个串的所有询问。 对于串长小于等于 \(\sqrt n\) 的串，把询问 \([l,r]\) 拆成 \([1,r]\) 和 \([1,l-1]\) 相减，然后从前往后扫每个前缀，回答与每个前缀相关的所有回答。在扫前缀的过程中，用一个 AC 自动机 \(\mathcal O(串长)\) 询问这个前缀中有多少个某个串的子串即可。那么只需要在 AC 自动机上实现一个 fail 树上的子树加（加入一个新的串），在 dfs 序上转为区间加，用分块做到 \(\mathcal O(\sqrt n)\) 区间加， \(\mathcal O(1)\) 单点询问就行了。 总复杂度为 \(\mathcal O(n\sqrt n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[做法 显然可以二分答案，转化为这样一个问题：每个边的边权是正负一，判断是否有长度在 \(l\) 到 \(r\) 之间的路径，权值之和非负。 从下往上合并，每次考虑当前点作为 lca 的情况，然后把子树合并，由于你合并时只需要考虑一个点子树中每个深度到根权值和最大的点，可以用长链剖分来维护深度信息。合并的时候顺便询问一下答案，长链剖分 + 线段树即可。 时间复杂度 \(\mathcal O(n \log^2n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
        <tag>二分</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[做法 点分治一下，转化为以下问题： 有两个长为 \(n\) 的数组 \(a_1\) 和 \(d_1\)，两个长为 \(m\) 的数组 \(a_2\) 和 \(d_2\)，求： \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] 枚举一下 \(i\)，关键就是如何求形如 \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) 的东西。 注意到 \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) 设 \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) 是很容易处理的，只需要对每个 \(1\ldots m\) 中的数 \(i\) 考虑 \(d_2[i]\phi(a_2[i])\) 对每个 \(s\) 中 \(i\) 的约数下标位置的贡献即可。 如果暴力计算上式，复杂度为 \(1 \ldots n\) 中每个数的约数个数的约数个数之和乘以点分治的一个 \(\log\)。前面的部分复杂度是 \(\log^2\) 的（考虑 \((\sum \frac 1 i )^2\)），从而总复杂度为 \(\mathcal O(n\log^3 n)\)。 继续对上式变形： 设 \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)，\(t_k\) 是一个常数。 \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] 考虑对 \(t\) 进行预处理。\(t\) 是一个积性函数（因为它是两个积性函数的狄利克雷卷积），我们可以直接把它筛出来。 但是因为我懒，我选择直接暴力预处理 \(t\)，时间复杂度为 \(\mathcal O(n \log n)\)。 这个算法的复杂度为 \(\mathcal O(n \log^2n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;。， &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>数据结构</tag>
        <tag>数论</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[做法 随便取一个点作根，用线段树按 dfs 序维护存在的点，维护一下所有存在的点的 lca 和到根的路径的并的长度即可。 误以为要减去点数 * lca 的深度，调了好久... 一直调不出来可能需要检查一下是不是哪里想错了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要经常复习的东西]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[一些感觉自己考试的时候很难独立想出来但是又经常会忘的东西。 详细内容见 这篇 blog，考前复习用。 楼房重建的做法 (2020.03.09) 支配树 伯努利数与自然数幂和 自然数的（可重 / 不可重）无序拆分：根号做法与 \(\log\) 做法 jls线段树 万能欧几里得与类欧几里得 处理分母等差生成函数的方法 你的名字 那个题的做法 最小字典序拓扑序(指按编号从小到大把每个点在拓扑序上的位置写下来的序列)，见 agc001_f 利用时间戳线性基 (按每个元素被删除的时间) 实现离线进行不带 log 的线性基插入删除 判线性无关时把实数改成取模并不会有太大损失，类似哈希（逐步考虑矩阵的变化~，其实只要不出现模数倍数就行 链上询问 / 区间询问小于等于 \(k\) (k 每次给定) 的元素的信息 (不可减)，有办法一个 \(\log\) 点双联通分量的求法 (写了篇公开 blog) 一类二分凸优化输出方案的方法 拉格朗日反演 记得卷积形式的 dp 可以分治 fft 优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现技巧整理]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于回滚操作的技巧在需要回滚的数组比较多的时候一个一个开栈回滚会比较麻烦，可以试着下面这样写： 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; 这样还原的时候也只需要根据指针搞一搞就好，只需要开一个栈就行了，注意 \(k\) 不要开小。 有时候你需要记录一个支持随时清空的 \(01\) 数组，这时可以不额外开标记数组。记一个变量 \(tim\)，赋 \(1\) 的时候就设为 \(tim\)，判断是 \(0\) 还是 \(1\) 就看是否等于 \(tim\)，清空就 \(tim \leftarrow tim + 1\)。 上下界费用流，对每条必须边不要直接添加，而是对每一个点记一个度数，全部添加之后再根据度数决定每个点到超级源还是超级汇，连多大流量的边，这样可以大大减少边数。 在做 dinic 时以下两份代码有巨大常数差距，下面的有时甚至可以比上面的快十倍，不知道为什么。 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[题解 把操作离线，然后分治，把问题变成只需要支持加边，回滚，维护两点间最小 \(xor\) 路径。 在询问 \(u,v\) 中，你可以从 \(u\) 走到 \(t\) 然后走回 \(u\)，路径上每条边都被经过两次，所以路径上的边贡献为 \(0\)。因此如果有一条 \(xor\) 为 \(x\) 的 \(u,v\) 路径，有一个 \(xor\) 为 \(c\) 的环，就存在一条 \(xor\) 为 \(x\oplus c\) 的路径。 任意考虑一棵生成树，对于一个非树边 \(u,v,w\)，设 \(u\) 到 \(v\) 的树上路径 \(xor\) 为 \(x\)，那么存在一个 \(xor\) 为 \(x \oplus w\) 的环，因此如果经过了这条非树边，我们不妨把它看成是沿着树上路径从 \(u\) 走到 \(v\)。之后再异或上这个换的权值。 所以我们只需要考虑把 \(u\) 到 \(v\) 之间的树上路径异或上一些由一条非树边一条树链构成的环的 \(xor\)，答案最小是什么。 维护所有非树边加上一条树链构成的环的 \(xor\) 的线性基即可。 然后考虑怎么加边维护这个东西。因为需要回滚，均摊算法（如 LCT，路径压缩的并查集）无法使用。我们只需要支持询问两点是否连通，询问两点之间的 \(xor\)，加边和回滚即可。我们可以给点 \(i\) 维护一个值 \(v_i\)，初始时所有点的值 \(=0\)，用按秩合并的并查集来维护连通性。我们始终要保证对于任意的 \(u,v\)，如果 \(u,v\) 连通，那么 \(u,v\) 之间树上路径的 \(xor\) 等于 \(v_u \oplus v_v\)。每次加边的时候，如果两个连通块并成了一个连通块，你可以通过把其中一个连通块内的所有点的 \(v_i\) 异或上一个数来保持这一性质。按秩合并时打个 tag 即可。 时间复杂度为 \(\mathcal O(n \log^2 n)\)。 代码 这次尝试了一种新的码风。看上去字符量少了不少。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // 准备左区间 for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // 准备右区间 for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[题解 感觉比 E 题难但是过的人远比 E 题多... 不知道 piece 怎么翻译，后面用石子代指 piece。 先枚举一个点 \(r\)，然后考虑把所有石子都移动到点 \(r\) 上的情况。把 \(r\) 作为根，考虑每个石子到 \(r\) 的距离之和 \(s\)，显然操作不会改变 \(s\) 的奇偶性，所以如果 \(s\) 是偶数，不存在把所有石子移动到 \(r\) 的方案。如果存在把所有石子移动到 \(r\) 的方案，那么最少步数必然是 \(\frac s 2\)，因为如果一个方案中有一次使一个石子到根的距离变小，另一个石子到根的距离变大，一定可以调整为一个步数更少的的方案。接下来我们只需考虑如何检验方案是否存在，如果我们只考虑一个子树内的操作，不难发现最优方案一定可以调整为一种先进行完全在某个儿子的子树内部的操作，再进行两个石子在不同儿子子树内部的操作的方案。所以我们可以做树形 dp，设 \(f_{ij}\) 表示是否可以对 \(i\) 的子树内部的石子进行操作，使得 \(i\) 子树内部石子到根的距离之和为 \(j\)。考虑怎么转移，假设我们已经决定了点 \(u\) 每个儿子子树内的操作，经过这些操作时候第 \(i\) 个儿子子树内的石子到 \(u\) 距离之和为 \(s_i\)，共有 \(c\) 个儿子，设 \(\max s_i = t\)，可以证明，\(f_{uj} = 1\)，当且仅当 \(j\) 与 \(\sum s_i\) 奇偶性相同，且 \(j \ge 2t - \sum s_i\)。这样的复杂度太大了，不难归纳证明对于任意的 \(i\)，\(f_{ij} = 1\) 的 \(j\) 必然是某个区间内的所有奇数 / 偶数。利用这个性质，我们 dp 使只需要记一个区间即可。在计算这个区间的右边界时，只需把所有儿子的子树中的石子到这个儿子的距离之和都取到最大即可。在计算左边界时，枚举取到左边界的方案中哪个儿子的 \(s_i\) 最大，让其他儿子的 \(s_i\) 都尽量小，这个儿子的 \(s_i\) 在大于等于其他儿子的前提下尽量小，更新一下左边界即可。具体实现可以看代码。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[题解 很有启发性的问题...做了一遍把对 FWT 理解的不彻底的地方都搞清楚了。 倒过来看，计算每个数变成 \(0\) 的期望步数，显然答案是一样的。 首先这个问题可以列 \(2^n\) 元线性方程组去解，但是暴力高斯消元的复杂度太高了。 我们设 \(f_i\) 表示 \(i\) 变成 \(0\) 的期望步数，\(p_i\) 表示随机数生成器生成 \(i\) 的概率。那么可以发现 \(f\) 数组满足方程 \(f = f\cdot p + w x^0 + \sum x^S\)。其中乘法表示集合异或卷积。 移项得到 \((x^0-p)f = w x^0 + \sum x^S\)，对两边同时 FWT，得 \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)。显然 \(\hat{p}_{0} = \sum p_S= 1\)，从而 \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)，这就推出了 \(w = -2^n\)。显然 \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)，从而可以推出 \(\hat{f}_S\) 的值。接下来，只要知道 \(\hat f_0\) 就可以 IFWT 出 \(f\) 了。注意到，\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)，只需随便给 \(\hat f_0\) 设一个值，然后 IFWT 出一个数组 \(f\)，对每个 \(i\) 把 \(f_i\) 减去 \(f_0\) 即可。（这里用到了 \(f_0 = 0\) 的条件） 模数写成 \(10^9+7\) 还调了好久...我真的是 zz。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc 题号很神奇...以链接中的为准。 题解 给点 \(i\) 一个权重 \(w_i\)，重新定义 \(D_i = \sum_k w_k dis(i,k)\)。初始时对于所有的 \(i\)，\(w_i = 1\)。任意时刻，\(\sum_i w_i = n\)。 可以发现，如果点 \(v\) 与点 \(u\) 相邻，以点 \(u\) 为根时点 \(v\) 的子树中的点权重之和为 \(s\)，则 \(D_v - D_u = n - 2s\)。 找到 \(D_u\) 最大的点 \(u\)，由于任何与 \(v\) 相邻的点都满足 \(D_v - D_u \le 0\)，所以以 \(u\) 为根 \(v\) 子树中的点权重和至少为 \(\frac n 2\)，所以 \(u\) 至多有一个相邻点。我们不考虑 \(n = 1\) 的情况。\(u\) 是一个叶子。 假设与 \(u\) 相邻的点是 \(f\)，那么 \(D_f-D_u = 2w_u - n\)，由于 \(D_i\) 互不相同，这就唯一确定了 \(u\) 的父亲 \(f\)。我们记录一下点 \(u\) 和点 \(f\) 连一条边，把点 \(f\) 的权重加上点 \(u\) 的权重，然后把点 \(u\) 删去。这样对还在树上的任何一个点 \(i\)，经过这次操作 \(D_i\) 恰好减少了 \(w_u\)。更新一下即可。 一直这样操作下去就唯一确定了一棵树，检验一下即可。（懒得判特殊情况，就直接暴力验证了） 实际上不需要更新 \(D_i\)，因为所有的操作都是整体加，而我们始终只会用到 \(D_i\) 的相对大小关系和 \(D_f-D_u\) 的值。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[题解 设 \(f_{ij}\) 表示 \(A_i &lt; A_j\) 的概率。 每次修改 \(\mathcal O(n)\) 更新一下就行。 最后求出逆序对个数的期望，乘以 \(2^q\) 就是答案。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[题解 为了方便描述结论，把输入的数组看作 \(n\) 个格子，每个格子里填了一个数字。对格子黑白染色，第一个格子是黑色，相邻两个格子颜色不同。 不难发现结论：如果 \(n\) 为偶数，先手最优策略得到的收益是黑格子上数字的和与白格子上数字的和的最大值。如果 \(n\) 为奇数，设白格子上数字的和为 \(s\)，先手能够获得至少 \(x\) 的收益，当且仅当存在一种选出若干个白格子的方案，用这些白格子把 \(n\) 个格子分成若干个连续段，每个连续段内黑格子的和减去白格子的和都大于等于 \(x-s\)。 证明比较显然，具体过程不写出了。大概思路就是要证明先手最优策略的收益是 \(x\)，只需先手存在一种策略，无论后手怎么操作至少能够 \(x\) 的收益，后手存在一种策略无论先手怎么操作一定能使先手获得至多 \(x\) 的收益。\(n\) 为奇数直接做，\(n\) 为偶数二分 dp 一下即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[题解 可以发现，假设最终能变成 0，如果有 000，第一步操作把它变成 0 一定最终仍然能变成 0。这是因为，假设存在一个第一步不是对这三个数操作，考虑第一次影响到这三个数中某个数的操作，如果这个操作就是把这三个 0 变成一个 0，那么可以直接把这次操作移动到第一次操作。否则的话，那么把这次操作改为把这三个 0 变成一个 0 肯定不会更劣。（因为把序列上的一个 0 改为 1 得到的序列一定不会更劣）用类似的思路可以证明，如果有 010，第一步把它变成 0 也不会更劣，如果有 101 第一步把它变成 1 也不会更劣。 考虑一个序列，反复进行以上三种操作直到不能操作，把得到的序列划分为若干个 0 / 1 的连续段，除了开头和结尾的连续段，每个连续段长度至少为 \(2\)，且 0 的连续段长度不会超过 \(2\)。显然把 111 变成 1 是不优的。不难用归纳法证明满足这个条件的序列无论怎么操作，都不会出现 000。（考虑在进行一步操作之后，利用 010 变为 0 的结论再进行一次操作，这样就会得到一个更短的满足这个条件的序列）而其他操作都会使 0 的个数和 1 的个数同时减少 1。这就说明满足这个条件的序列，最终能变成 1，当且仅当 1 的个数大于 0 的个数。（长度必为奇数） 对这个东西 dp 一下即可。如果存在一个前缀 1 的个数减去 0 的个数大于等于 \(2\)，这个序列必然可以变成 0。所以实际需要记的状态数很少。 代码]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[题解 对于 \(i, j\)，考虑 \(P_i &gt; P_j\) 的方案数。只需考虑 \(A_i \le A_j\) 的情况即可。这相当于是把 \(A_j\) 改为 \(A_i\) 之后满足 \(\forall i, P_i \le A_i\) 的限制的排列数除以 \(2\)。 把 \(1 \ldots n\) 按 \(A_i\) 从小到大排序，设排序后第 \(i\) 个数是 \(p_i\)。显然满足 \(\forall i, P_i \le A_i\) 的排列总数为 \(\prod_i A_{p_i}-i+1\)。设总数为 \(C\)。 设 \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) 对所有满足 \(p_i &lt; p_j\) 的 \((i,j)\) 计算 \(P_{p_i} &gt; P_{p_j}\) 的排列数。对于每一对 \(i &lt; j\)，如果 \(p_i &lt; p_j\)，那么它的贡献是 \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)。\(p_i &gt; p_j\) 的情况没有很大区别，具体式子就不写出来了。枚举 \(j\)，用线段树对每个 \(p_i\) 维护下这个式子，每次移动 \(j\) 的时候区间乘更新，统计答案时区间求和即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Atcoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[题解 update: 感觉我做麻烦了，题解做法好简单。这篇 blog 就丢这吧…..感觉没什么错误。 如果只把 \(0\) 变成 \(1\) 而不把 \(1\) 变成 \(0\)，会导致 \(0\) 的个数减少，还不如不改变原序列。 如果既出现把 \(0\) 变成 \(1\) 也出现把 \(1\) 变成 \(0\)，设某一个把 \(0\) 变成 \(1\) 的位置为 \(p_1\)，某一个把 \(1\) 变成 \(0\) 的位置为 \(p_2\)。 不妨设 \(p_1 &lt; p_2\)。（如果 \(p_1 &gt; p_2\)，交换原序列和新序列就和一种 \(p_1 &lt; p_2\) 的情况等价了） 设 \(f[l,r]\) 表示原序列上 \([l,r]\) 中最长不降子序列长度，\(g[l,r]\) 表示新序列上 \([l,r]\) 中最长不降子序列长度。 定义 \(f[l,r] = g[l,r] = 0(l &gt; r)\)。 那么 \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)。 因此新序列上 \([p_1,p_2]\) 中的最长不降子序列必然要包含 \(p_1\) 和 \(p_2\)，但是新序列上 \(p_1\) 位置为 \(1\)，\(p_2\) 位置为 \(0\)，这是不可能的。 因此，只会出现把 \(1\) 变成 \(0\) 的位置，不会出现把 \(0\) 变成 \(1\) 的位置。 考虑把一个位置在原序列左端或左边不为 \(1\) 的 \(1\) 变成 \(0\)，不对任意区间内的最长不降子序列产生影响的条件。 假设这个位置是 \(p\)。分两种情况讨论： \(p &lt; n\) 且位置 \(p+1\) 上的是 \(1\). \(p = n\) 或位置 \(p+1\) 上的是 \(0\). 先看第一种情况。把位置 \(p\) 上的 \(1\) 变成 \(0\) 看作新序列（用 \(g[l,r]\) 描述新序列上的最长不降子序列）。对于任意的 \(i &lt; p\)，\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)，而新序列上位置 \(p\) 上的是 \(0\)，这说明 \([i,p-1]\) 存在结尾为 \(0\) 的最长不降子序列，即 \([i,p-1]\) 的最长不降子序列等于 \([i, p-1]\) 中 \(0\) 的个数。可以证明这个条件对任意的 \(i &lt; p\) 都成立的充要条件为对于任意的 \(i &lt; p\)，\([i,p-1]\) 中 \(0\) 的个数不少于 \(1\) 的个数：必要性是显然的，只需证充分性，假设 \([i, p-1]\) 的最长不降子序列大于 \(0\) 的个数，任取一个 \([i,p-1]\) 的最长不降子序列，它必然包含一个 \(1\)，设第一个 \(1\) 位置为 \(k\)，那么这个子序列 \(k\) 之前的元素再拼上 \([k,p-1]\) 中所有的 \(0\) 必然是一个全 \(0\) 的不会更短的子序列（因为 \([k,p-1]\) 中 \(0\) 的个数不少于 \(1\) 的个数），这与不存在全为 \(0\) 的不降子序列矛盾。不难验证这也是第一种情况中能把 \(p\) 上的数变为 \(0\) 的充要条件。 第二种情况显然也必须要满足第一种情况的条件。除此之外，由于位置 \(p+1\) 上的是 \(0\)，还需满足对于任意的 \(i &gt; p\)，\([p+1,i]\) 中 \(1\) 的个数不少于 \(0\) 的个数（与第一种情况的证明类似，详细过程就不写了）。 从左往右贪心，对于一个位置，如果它是 \(1\)，且能够保持任意区间最长不降子序列长度不变地变为 \(0\)，就把它变成 \(0\)。不难证明这种贪心是正确的，详细证明这里不写了。（提示：考虑最优解中 \(1\rightarrow0\) 的最小位置） 判断是否存在前缀 / 后缀 \(0\) 的个数多于 / 少于 \(1\) 的个数，可以通过计算每个前缀中 \(0\) 的个数减 \(1\) 的个数很容易地处理。]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[还没写过。如果有错误可以 QQ / 评论告诉我。 题解 这样理解这个问题：初始时时间为第 \(0\) 秒。每秒你可以选择一个 \(i\)，然后把 \(a_i\) 加上 \(k\)，接下来再把所有 \(a_i\) 减去 \(1\)。你可以随时停止这个过程，并把当前的 \(a\) 数组作为结果。问在不经过任何存在 \(a_i &lt; 0\) 的状态的前提下，能够得到多少种不同的结果。 从这个角度来看，如果不考虑 \(+k\) 操作，每秒每个 \(a_i\)都会减少 \(1\)。 设 \(c_{t,i}\) 表示前 \(t\) 秒 \(a_i\) 被执行 \(+k\) 操作的次数。那么，如果这个过程在进行了 \(T\) 秒之后结束，\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)，也就是说 \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)。 不难证明存在经过 \(T\) 秒没有出现过负数的方案的充要条件是： \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] 对于 \(t \in \mathbb{N}\)，\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) 是否成立是与 \(T\) 无关的。所以，要么对所有的 \(T\) 都存在不经过负数的方案，要么存在一个非负整数 \(T_0\)，当 \(T \le T_0\) 时存在方案，\(T &gt; T_0\) 时不存在方案。 太晚了先睡了。坑待填。]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[口胡的没实现过，如有错误请 QQ 或评论告诉我！ 题解 考虑只有两个等比数列的情况。 第一个等比数列：\(a_1, a_1b_1, a_1b_1^2, \ldots\) 第二个等比数列：\(a_2,a_2b_2,a_2b_2^2,\ldots\) 假设 \(v\) 同时出现在两个等比数列中，那么 \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)。 设 \(p_i\) 表示第 \(i\) 个素数。 \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) 考虑任意两个不同素数 \(p_i\) 和 \(p_j\)，假设 \(p_i\) 在 \(a_1,a_2\) 中出现次数分别是 \(w_{1i},w_{2i}\)。 那么有 \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] 这是一个二元一次方程组。假设 \((c_{1i},-c_{2i})\) 和 \((c_{1j}, -c_{2j})\) 线性无关，这个方程组有唯一解。 假设存在 \(i &lt; j\)， \((c_{1i},-c_{2i})\) 和 \((c_{1j}, -c_{2j})\) 线性无关，那么解出这个方程。这样就得到了唯一一个可能是所有等比数列共有元素的数（的素因数分解），然后检验一下即可。 否则，对于任意的 \(i &lt; j\) 都有 \((c_{1i},-c_{2i})\) 和 \((c_{1j}, -c_{2j})\) 线性相关。 那么存在正整数 \(w\)，\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)。 \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] 不妨设 \(a_1 \le a_2\)。那么一定有 \(a_1 \mid a_2\)。 设 \(\frac {a_2} {a_1} = x\)，如果有解，必有 \(x = w^n, n \in \mathbb{N}\)。 方程变为 \(k_1i_1-k_2i_2 = n\)。 这是一个简单的不定方程。不难找到这个方程的一组解 \(k_1= x, k_2 = y\)。（具体来说先找到 \(k_1i_1-k_2i_2=1\) 的解，然后在两边乘以 \(n\)） 那么这个方程的通解为 \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)。 不难找到 \(k_1\) 最小的非负整数解，假设这时 \(a_1w^{k_1c_1}=t\)。这样两个等比数列就被合并为了一个等比数列：\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)。 继续把合并得到的等比数列和其他等比数列进行相同的操作即可。]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 支配树]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[支配树的算法很妙。它的证明实在太长了….完整写一遍比较费时间，这里就只写结论了。 显然支配关系构成一棵树。 定义 \(sdom(u)\) 是能够从 \(v\) 出发只经过 \(dfn\) 比 \(u\) 大的到达 \(u\)（\(u\) 和 \(v\) 不算在里面）的 \(dfn\) 最小的 \(v\)。 \(sdom(u)\) 要么是能够通过一条前向边 / 树边直接到达 \(u\) 的点，要么是满足子树中存在至少一个点能够直接走到 \(u\) 且 \(dfn\) 比 \(u\) 大的点的 \(sdom\)。根据这一点可以并查集计算 \(sdom\)。并查集维护的是链 sdom 的最小值。 设 \(v\) 是 \(u\) 到 \(sdom(u)\) 的链上（不含 \(sdom(u)\)）\(sdom\) 最小的点 ，那么如果 \(sdom(v) = sdom(u)\)，\(idom(u) = sdom(u)\)，否则 \(idom(u) = idom(v)\)。这个东西也是要求一个链 sdom 的最小值。可以求 \(sdom\) 的时候顺便维护一下。 在这份代码中 \(sdom\) 存的是 \(dfn\) 最小的点的 \(dfn\) 而不是编号，需要特别注意。 （听说这题数据很水…说不定有错没被查出来） 这份代码被提交到 【模板】支配树。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT 问题总结]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[一直以来对 2-SAT 的理解比较模糊，所以写这样一个尽可能清晰的总结来理清思路。 2-SAT 问题的定义：有 \(n\) 个逻辑变量，用 \(b_i\) 表示第 \(i\) 个逻辑变量。\(m\) 个限制条件，每一个限制条件形如：\((\neg)b_i \to (\neg) b_j\)。问是否存在满足限制的 \(b\)。 用图来描述限制条件。对每个逻辑变量建两个点，分别代表取值为 \(0\) 和取值为 \(1\)。代表 \(b_i=0\) 的点为 \(p_i\)，代表 \(b_i = 1\) 的点为 \(q_i\)。对每个限制条件，在图上连一条有向边，表示一个命题推出另一个命题，然后再加一条边表示该限制条件的逆否命题。举例来说，如果有限制条件 \(\neg b_i \rightarrow b_j\)，就加入 \((p_i, q_j)\) 和 \((p_j, q_i)\) 这两条有向边。问题就变为判定是否存在对于任意的 \(i\)，恰好包含 \(p_i\) 和 \(q_i\) 中的一个点的闭合子图。 定理：2-SAT 有解的充要条件是，对于任意的 \(i\)，\(p_i\) 和 \(q_i\) 不在同一强连通分量中。 必要性是显然的。 下面用构造证明充分性： 先 tarjan 求出强连通分量，把每个强联通分量缩成一个点。由于一个强连通分量内的点对应相反取值的点也构成一个强连通分量，所以缩点后，这个问题变为了一个更小的 2-SAT 问题。只需要解决图是 DAG 时的问题即可。 把所有的边方向反过来。下面所有的讨论都是在反图上的。 用符号 \(v^r\) 表示与点 \(v\) 对应的点：\(p_i^r = q_i, q_i^r = p_i\)。 求出拓扑序，按拓扑序依次处理每个点：如果当前点 \(u\) 被打了标记，那么不选；否则选择 \(u\)，并把 \(u^r\) 以及 \(u^r\) 出发能到达的所有点打上标记（递归进行，如果已经被打过标记就跳过，这样每个点只会被标记一次）。 这样对于任意的 \(i\)，\(p_i\) 和 \(q_i\) 不可能同时被选，已选的点也不与限制矛盾，只需要证明对于任意的 \(u\)，\(u\) 和 \(u^r\) 中至少有一个被选即可。 如果 \(u\) 第一次被标记的原因是 \(v\) 被选择， 那么 \(u\) 是 \(v^r\) 出发能到达的点，由 2-SAT 的性质可得 \(v\) 是 \(u^r\) 出发能到达的点，从而 \(v\) 在拓扑序上比 \(u^r\) 靠后。 假设存在一个 \(u\)，\(u\) 和 \(u^r\) 都被标记了，标记 \(u\) 的原因是 \(v_1\) 是被选择，标记 \(u^r\) 的原因是 \(v_2\) 被选择。那么 \(v_1\) 在拓扑序上比 \(u^r\) 靠后，\(v_2\) 在拓扑序上比 \(u\) 靠后。不妨设 \(u\) 在拓扑序上比 \(u^r\) 靠后，那么 \(v_2\) 在拓扑序上比 \(u^r\) 靠后，在处理 \(v_2\) 之前就会先处理 \(u^r\)，矛盾。 所以该算法会得到一组合法的方案。]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[口胡的题]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[用来记录口胡的题目。 如有错误请务必 qq 或者评论告诉我，谢谢！ JOISC 2018 Day4 T1 点击查看题解 如果认为相邻两点之间有一条边，本题就可以看成求最大权点独立集。 显然一条链是二分图，那么问题可以转化为用费用流求最小权点覆盖集。 记录相邻两点之间边的方向，把连续一段方向相同的视作一个段。用线段树维护最短增广路，每次有段发生变更时就询问这个段，然后修改线段树上的信息。这样就可以维护最短增广路，就在 \(\mathcal O(n \log n)\) 的时间解决了问题。 JOISC 2018 Day4 T2 点击查看题解 看作是询问一条链上一部分点的导出子图的连通块数。依次加点，通过二分求出新加的点和已有点构成的连通块之间的连边。由于总共只有 \(n-1\) 条边，询问次数不会超过 \(\lceil \log n\rceil (n-1)\)。 LOJ 6191 「美团 CodeM 复赛」配对游戏 点击查看题解 最后一定会变成 &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;。 \(f_{i,j}\) 表示前 \(i\) 个消完，留下的字符最后有连续 \(j\) 个 &gt;，留下的字符中 &lt; 的数量的期望。 最后很容易统计答案。 LOJ 6192 「美团 CodeM 复赛」城市网络 没啥好说的，就是倍增一下。 LOJ 6194 「美团 CodeM 复赛」排列 点击查看题解 按 \(a_i\) 为第一关键字，\(b_i\) 为第二关键字排序。重新给点编号。 假设使 saved 变动的点的编号分别是 \(c_1, \ldots, c_k\)，有 \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)。 考虑对于给定的 \(c_i\) 和 \(k\)，如何计算 \(p\) 的数量。 设 \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)，定义 \(d_0 = n\)。 如果 \(d_k &gt; 1\)，\(p\) 的数量为 \(0\)。 否则 \(p\) 的数量为 \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)。 这是一个非常容易 \(dp\) 处理的式子。分治优化一下就做完了。 LOJ 6212 「美团 CodeM 决赛」melon 点击查看题解 \(n \le L\) 时答案显然是 \(n\)，\(L &lt; n \le 2L\) 时答案显然是 \(L\)，下面讨论 \(n &gt; 2L\) 的情况。 如果 Alice 采取如下策略：假设瓜的数量大于 \(2L\)，取走一个瓜，否则取走 \(L\) 个瓜，就能保证至少拿到 \(\lceil \frac {n} 2\rceil\) 个瓜。（因为这样 Alice 拿到的瓜一定不会比 Bob 少） 如果 Bob 采取如下策略：假设 Alice 刚刚拿走了 \(x\) 个瓜，现在还剩下 \(c\) 个瓜，如果 \(c-x \ge 2L\)，那么取走 \(x\) 个瓜；否则先取走 \(x-1\) 个瓜，吃完后，剩余瓜数为 \(c-(x-1)\)，因为 \(c-x &lt; 2L\)，所以 \(c-x+1 \le 2L\)，如果 \(c-x+1 \le L\)，直接取走剩余全部瓜，这种情况下 Bob 拿的瓜不会比 Alice 少，否则取走 \(L\) 个，因为 \(c-x+1 \le 2L\)，在剩余的 \(c-x+1\) 个瓜中，Bob 拿的瓜不会比 Alice 少，这种情况下最坏也只是由于上一次 Alice 操作的时刻，Alice 取走了 \(x\) 个而 Bob 取走了 \(x-1\) 个，Bob 比 Alice 拿的瓜少了一个。所以 Bob 拿的瓜的数量最坏比 Alice 少 \(1\)。 因此，在双方都采取最优策略时，Alice 能获得恰好 \(\lceil \frac{n} 2\rceil\) 个瓜。 综上所述，当 \(n \le L\) 时，答案为 \(n\)；当 \(L &lt; n \le 2L\) 时，答案为 \(L\)；当 \(n &gt; 2L\) 时，答案为 \(\lceil \frac {n} 2\rceil\)。 CF 1215F Radio Stations 非常妙的 2SAT 题，没想出来。看了题解觉得很 nb。具体做法就不写了。可以看官方题解。 CF 1188E Problem from Red Panda 待填坑。]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类欧几里得算法]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直用一直拷板...需要补一补了。 问题 求 \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] 即在一条直线下的整点数. 做法 如果 \(a \ge c\) 或 \(b \ge c\)，则 \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) 否则 \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] （因为 \(i\) 从 \(0\) 开始，所以要用小于号） 这样每递归两次，\((a,c)\) 就变成 \((c, a\bmod c)\)，因此时间复杂度为 \(O(\log (a+c))\). 由于 \(a &lt; c, b &lt; c\)，所以 \(n\) 的值不会增大，无需担心爆 long long.]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] 完美的队列]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[题目链接 题解 复杂度讨论中默认 \(n,m\) 同阶。 定义第 \(i\) 个操作的发生时间为 \(i\)。 求出每次操作加入的新的 \(x\) 全部被弹出的最早时间，就很好求答案了。 从后往前考虑每个操作，计算这次操作加入的元素全部被弹出的最早时间。 定义一个队列 \(i\) 的弹出时间为从当前操作开始，往后第 \(a_i\) 个影响队列 \(i\) 的操作的发生时间。 分块，从后往前依次加入每个操作，分别维护每一块中的队列弹出时间的最大值。我们把一块中所有队列弹出时间的最大值称为这个块的最早弹出时间。 在加入第 \(k\) 个操作后，第 \(i\) 个块 \([a_i,b_i]\) 维护最早弹出时间 \(t_i\)，设 \(c_p\) 为第 \(k\) 个操作到第 \(t_i-1\) 个操作中第 \(p\) 个队列被 push 的次数，维护 \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)。同时维护 \(c_p\) 的值。（通过打标记） 考虑在加入操作 \(i\) 后，如何更新每块维护的信息。 假设这个块是第 \(k\) 个块。 对于这个块的最早弹出时间大于等于 \(m\) 的情况预先处理好。下面只讨论最早弹出时间小于 \(m\) 的情况。 更新 \(mn_k\) 和 \(c\) 数组 如果这个块被第 \(i\) 次修改的区间完整包含： 更新 \(mn_k \leftarrow mn_k+1\)。更新 \(c_p\) 的值，即打一个整块加 \(1\) 标记。 如果这个块未被第 \(i\) 次修改的区间完整包含： 暴力重构，更新 \(mn_k\) 和 \(c\) 数组。 更新 \(t_k\) 按以下步骤进行： 如果 \(mn_k \ge 0\)，说明 \(t_k\) 可以减小，那么 \(t_k \leftarrow t_k-1\)。否则不用更新，结束操作。 如果第 \(t_k\) 次操作包含整个块，那么 \(mn_k \leftarrow mn_k-1\)，打 \(-1\) 标记更新 \(c_p\) 的值。否则暴力重构更新 \(mn_k\) 和 \(c_p\) 的值。 转到操作 1。 这样就做到了在 \(O(n \sqrt n)\) 时间内维护每个块的最早弹出时间。 剩余的问题是: 如何在从右往左加入操作的过程中，支持查询一个区间的最早弹出时间。把区间拆成若干个块和不超过 \(2 \sqrt n\) 个多出来的点。对于这些块，已经知道了它的最早弹出时间，取 \(\max\) 即可。对于这些多出来的点，需要动态询问他们的最早弹出时间。 处理单点信息 要支持从后往前添加操作，询问单个队列的最早弹出时间。 同样分块维护。对每个块开一个 vector，对每个队列开一个 vector。在进行修改时，对完整包含的每个块的 vector 加入当前修改的编号，再对两边多出的 \(O (\sqrt n)\) 个队列对应的 vector 加入当前修改的编号。 那么一个队列的操作序列就是它的 vector 和它所在的块的 vector 归并后的结果。对每个点记录它的最早弹出时间 \(t\) (每次询问时更新，修改时不一定是最新的)，它的 vector 中第一个在 \(t\) 之前的修改的位置 \(p_1\)，它所在块的 vector 中第一个在 \(t\) 之前修改的位置 \(p_2\)。对每个块记录这个块中的队列在上一次更新信息之后修改的次数 \(c\)。那么修改的时候对整块只需要 \(c \leftarrow c+1\)，对两端的块更新其中每一个队列的 \(t, p_1, p_2\)，并把 \(c\) 设为 \(0\)。更新方法大致为：对于一个队列，先判断 \(t\) 是在它 vector 中还是在块的 vector 中（通过 \(p_1, p_2\) 可以直接判断），这两种情况区别不大，所以这里只写在块 vector 上的情况。定义一个临时变量 \(t = c\)，如果它的块的 vector 中的第 \(p_2+t\) 项的小于这个队列的 vector 中的 \(p_1\) 项，那么 \(p_1 \leftarrow p_1+1\)，然后 \(t \leftarrow t-1\)，然后再次检查，这样循环直到可以直接把 \(p_2\) 改为 \(p_2+t\) 的时候，修改 \(p_2\) 就完成了更新。 一个队列被更新时进行的判断的总次数与它的 vector 中元素个数同级，所以更新的总复杂度是 \(O(n)\) 的。（但是维护 vector 和进行操作是 \(O(\sqrt n)\) 的）。 这样就以 \(O(n \sqrt n)\) 的时间复杂度解决了问题。 实现 1待填]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式操作模板]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI 前复习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //最大多项式长度，倍数问题已经考虑const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>模板</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 常系数齐次线性递推]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[多项式取模优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // 特征多项式int wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //乘以 A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>模板</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现错误记录]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[比较函数定义不严格，存在返回相等但是实际上有区别的情况。这可能导致双堆维护删除操作时出现问题。（应当同时弹栈但是栈顶元素不相等） for (int i = 1; i &lt;= n; i++) a[n] = inf。 在一些回溯时需要撤销操作的 dfs 中，因为其他原因 return 的时候没有撤销操作。 循环/if 里层外层变量名混淆。 进行 dfs / 递归时，因为使用全局变量下层 dfs 时破坏了上层之后要用到的信息。 容斥时，只枚举了集合大小忘记了乘组合数。 插头 dp 不要忘记连接两个左括号或者连接两个右括号的情况。 树链剖分时，询问链的时候一定要注意是比较重链顶端深度大小，不能直接比较两个点深度大小。 sort 时忘记加比较函数。 维护矩阵乘法时左乘右乘搞错。 线段树合并时，如果要可持久化，空间要开两倍。 在处理涉及不同长度字符串的字符串哈希时，一定要用 str[i] - 'a' + 1 而不是 str[i] - 'a' 在处理子树最长从根开始路径之类的问题时，如果这个子树不能选，dp 值设为 \(0\) 仍会 +1 向上贡献 在用 new 出来的数组时出现越界。这时不会报错，出现 new 出来的数组时，一定要谨慎计算每次调用的大小。（尤其是写多项式时）]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[发这篇博客主要是为了记录一个极为隐蔽的错误。 写比较函数一定要保证是严格的小于号。要特别处理等于。否则在遇到堆打标记删除这种问题的时候，相同元素在堆中的顺序会影响答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] 「ZJOI2017」字符串]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[题目链接 做法 不难证明如果一个子串 \(s\) 有两个后缀 \(s_1, s_2\)，\(s_2\) 是 \(s_1\) 的 border 且 \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)，那么对于任意的字符串 \(t\)，\(s_2\) 不可能是 \(st\) 的最小后缀。 用一个线段树维护每个区间内可能成为最小后缀的点，这样的点只有 \(\mathcal O (\log n)\) 个。push up 的时候暴力合并即可。 比较大小的时候需要查 lcp，分块维护前缀哈希即可做到 \(\mathcal O(\sqrt n)\) 修改，\(\mathcal O(\log n)\) 询问（调整块大小应该可以做到更优的复杂度）。 总复杂度 \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)。 （真的毒瘤）]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[题目链接。 做法]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板]-貌似是洲阁筛的筛法]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[提交至 简单的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] 区间素数个数]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接。 试着实现下 min_25 筛的第一步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/problemset/problem/715/E 题目大意 你有两个长度为 \(n\) 的排列 \(p_1\) 和 \(p_2\)，其中有一些位置被挖空，让你自己填数字。 请你对每个 \(k\) 输出，有多少种填数字方案，使得 \(p_1\) 最少交换 \(k\) 次可以变成 \(p_2\)。 \(n \le 250\)。 解法 首先题目保证至少存在一种填数方案使得 \(p_1\) 和 \(p_2\) 是排列，所以不需要考虑已经确定的数不合法的情况。 容易看出交换次数 \(n-(p_1p_2^{-1}\) 的轮换数\()\)。 问题变成了求满足 \(p_1p_2^{-1}\) 恰好可以分解为 \(k\) 个不相交轮换的方案数。 设 \(p_1p_2^{-1}=w\)，则 \(p_1=wp_2\)，即 \(p_1[i]=w[p_2[i]]\)。 设所有 \(p_1\) 中已经确定的位置的下标构成的集合为 \(S_1\)，所有 \(p_2\) 中已经确定的位置的下标构成的集合为 \(S_2\)。 假设 \(w\) 是已经确定的排列。那么对于 \(i \in S_1\)，有 \(p_2[i]=w^{-1}[p_1[i]]\)；对于 \(i \in S_2\)，有 \(p_1[i]=w[p_2[i]]\)。所以 \(\forall i \in S_1 \cap S_2\)，\(p_1[i]\) 和 \(p_2[i]\) 都是确定的。对于 \(p_1\) 来说，还有 \(n-\lvert S_1\cup S_2 \rvert\) 个位置要填的数没有确定。那么如果存在至少一种填数方案，就恰好有 \((n-\lvert S_1\cup S_2 \rvert)!\) 种使得 \(p_1p_2^{-1}=w\) 的填数方案。 再考虑有多少种恰有 \(k\) 个环的合法的 \(w\)。对于 \(i \in S_1\cap S_2\)，\(w[p_2[i]]=p_1[i]\)。所以 \(w\) 的一些位置已经确定了。同时 \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)。\(w\) 中确定的位置已经构成了一些链和一些环。构成环后不可能与其他点连边，可以直接忽略。链可以缩成一个点。那么问题转化为，给定两个集合 \(A\) 和 \(B\)，求有多少个长度为 \(n\) 的排列，恰有 \(k\) 个环的排列，满足 \(\forall i \in A, w[i] \notin B\)。显然这个问题只与 \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) 有关。 先考虑 \(A\cap B =\emptyset\)。容斥一下即可。 \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] 再考虑 \(A\cap B \neq \emptyset\)。把限制条件看作 \(\forall i \in A\setminus B,w[i]\notin B\) 和 \(\forall i \in A \cap B, w[i] \notin B\)。对第二个条件容斥。设 \(G(n, c, i)\) 为 \(n\) 个数的排列，决定 \(c\) 个位置填什么，使已经决定的边构成 \(i\) 个环方案数（显然此时有 \(n-c\) 条链）。 \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) 实际只有 \(n^2\) 种，暴力预处理 \(F\) 即可，时间复杂度 \(\mathcal O(n^3)\)。 再考虑 \(G\) 怎么计算。\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) 计算非常方便。 这样就做完了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 首先，一个以 \(A\) 为开头以 \(B\) 为结尾的序列是否存在，仅与 \(A\oplus B\) 有关。 如果存在一个满足条件的序列，那么 \(A\oplus B\) 中 \(1\) 的个数一定是奇数。 一个结论是，如果 \(A \oplus B\) 中 \(1\) 的个数是奇数，那么满足条件的序列一定存在。 下面递归地给出构造。 定义 \(build(n,A,B)\) 返回一个 \(0 \ldots 2^n-1\) 的以 \(A\) 为开头，\(B\) 为结尾的排列。（\(A\oplus B\) 中有奇数个 \(1\)） 若 \(n=1\)，如果 \(A = 0\)，返回 \(A, B\)。 若 \(A \oplus B\) 中恰有一个 \(1\)，不妨设 \(A = 0, B = 2^{n-1}\)（其他情况只需要把所有数异或上 \(A\) 并把 \(1\) 所在在位和最高位交换即可）。 设 \(a=build(n-1, 0, 1)\)，那么 \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) 是一个满足条件的排列。 若 \(A\oplus B\) 中存在 \(0\)，不妨设其中 \(0\) 在最低位上且 \(A\) 的最低位为 \(0\)。 设 \(a = build(n-1, \frac A 2, \frac B 2)\)，\(b = build(n-1, a_1, a_2)\)。 那么 \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) 是一个满足条件的排列。 若 \(A\oplus B\) 中不存在 \(0\)，不妨设 \(A = 0, B = 2^n-1\)。 设 \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)。 则 \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) 是一个合法的排列。 用主定理可以分析出直接递归的复杂度并不高。所以直接递归一下就好。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 设 \(f_{i,j}\) 表示把 \(p_i \ldots p_n\) 中大于等于 \(j\) 的数排序的最小代价。 设 \(k\) 是 \(p_i \ldots p_n\) 中第一个大于等于 \(j\) 的数的位置，\(p_i\ldots p_k\) 中大于等于 \(j\) 的数共有 \(c\) 个。 \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] 预处理出 \(p\) 和 \(c\)，\(n^2\) dp 一下即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[题目链接。 题目大意 给你一棵 \(n\) 个点的树，边上有字符。定义路径 \(u\) 到 \(v\) 上的字符串就是把路径上的字符依次接起来得到的字符串。给定 \(m\) 个字符串 \(s_1,s_2\ldots s_m\)。\(q\) 次询问，每次询问给出三个数 \(i, j, k\)，询问在路径 \(i\) 到 \(j\) 的字符串中，\(s_k\) 出现了几次。 解法 符号说明：\(s^R\) 表示 \(s\) 的反串。\(pre(s,i)\) 表示 \(s\) 的长度为 \(i\) 的前缀，\(suf(s,i)\) 表示 \(s\) 的长度为 \(i\) 的后缀。\(s+t\) 表示把字符串 \(s\) 和字符串 \(t\) 拼起来得到的字符串。 先做一次点分治就可以把问题转化为 \(u \rightarrow v\) 经过根的情况，所以只讨论经过根的情况。 设根为 \(r\)，询问的路径为 \(u \rightarrow v\)，询问的字符串为 \(s_k\)。 可以把 \(s_k\) 在路径 \(u \rightarrow v\) 上的匹配分成三部分计算，第一部分是在 \(u\rightarrow r\) 上的匹配，第二部分是在 \(r \rightarrow v\) 上的匹配，第三部分是在跨过 \(r\) 的匹配。 前两部分是比较好计算的。离线一下，对所有的 \(s_i\) 建AC自动机，在树上dfs，每次在AC自动机上走一条转移边，用 BIT 维护一下每个点被走了几次，在 dfs 到点 \(x\) 时，只需作一次子树询问即可快速得到 \(s_k\) 在 \(r\rightarrow x\) 上出现了几次（对于第一部分是询问 \(s_k\) 的反串出现了几次）。 比较简单就不详细描述了。 第三部分比较复杂。设路径 \(u\rightarrow r\) 上的字符串为 \(x\)，路径 \(r \rightarrow v\) 上的字符串为 \(y\)。设 \(p\) 是最大的满足 \(pre(s_k,p)=suf(x,p)\) 的整数，\(q\) 是最大的满足 \(suf(s_k,q)=pre(y,q)\) 的整数。那么计算第三部分可以转化为计算 \(s_k\) 在 \(suf(x,p)+pre(y,q)\) 中的出现次数。 设 \(t_i\) 路径表示 \(r\rightarrow i\) 上的字符串。则 \(suf(x,p)+pre(y,q)\) 可以表示为 \(pre(s_k,p)+suf(s_k,q)\)，这样就转化为了只与 \(s_k\) 相关的问题。\(p\)、\(q\) 的具体求法后面会详细描述。假设已经求得了 \(p\)、\(q\)，考虑怎么快速得到第三部分的匹配次数。 把询问离线。对每个 \(i\)，建一棵 \(s_i\) 的后缀树和 \(s_i^R\) 的后缀树。在 \(s_i^R\) 的后缀树上 \(dfs\)，\(dfs\) 的过程中，维护一棵线段树。如果 \(dfs\) 到一个代表 \(s_i^R\) 后缀的点，设这个点对应的字符串长度为 \(l\)，那么就在线段树上把 \(s_i\) 的后缀树上对应 \(s_i[l+1\ldots \lvert s_i \rvert]\) 的点的子树 \(dfs\) 序上位置加一。（可能描述的不是很清楚...我也不知道怎么描述了）回溯时撤销操作。然后对每个询问 \(p, q\)，只要在 \(dfs\) 到 \(s_i^R\) 长度为 \(p\) 的后缀时，询问一下 \(s_i\) 长度为 \(q\) 的后缀在 \(s_i\) 的后缀树上的 \(dfs\) 序上位置在线段树上的值即可。 考虑如何求 \(p\)、\(q\)。由于求 \(q\) 的过程和求 \(p\) 类似，这里只详细描述求 \(p\) 的过程。对所有 \(s_i\) 以及 \(s_i^R\) 建出一个广义SAM。然后类似AC自动机+BIT的过程地，维护一个以parent树 \(dfs\) 序为下标的线段树。然后在点分治后得到的连通块上 \(dfs\)，\(dfs\) 到 \(u\) 时维护 \(r\rightarrow u\) 上的字符串在SAM上的位置，并把它的子树在 \(dfs\) 序上的位置在线段树上子树对长度取 \(max\)。然后求 \(p\) 时只需要询问一下 \(s_k^R\) 在 \(SAM\) 上的位置在parent tree中的 \(dfs\) 在线段树上的位置即可。 代码]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[题目链接 「PKUWC2018」Minimax。 大致思路&amp;&amp;吐槽 线段树合并，维护某个点最后的值在线段树上每个区间的概率。 merge 的时候记一下前后缀概率就能转移了。 代码能力真是越来越差了..线段树合并都写不熟。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 整数]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) 个 \(bit\) 压一起，线段树维护区间左边连续 \(0\) 和 \(2^{30}-1\) 的个数。 代码能力太菜了补补水题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[提交至 质数判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] 反回文串]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[提交至 「SDOI2018」反回文串。 题解 考虑什么样的回文串在循环移位 \(k\) 位后还是一个回文串。 设 \(s\) 是一个循环右移 \(k\) 位后仍是回文串的长度为 \(n\) 回文串。 记字符串 \(a\) 的反串为 \(a^R\)。 因为 \(s\) 是回文串，对于 \(1\le i \le n\)，\(s[i]=s[n-i+1]\)。 又因为 \(s\) 循环右移 \(k\) 位后仍是回文串： 对于 \(1 \le i \le n-2k\)： \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) 对于 \(n-2k &lt; i \le n-k\)： \(s[i] = s[2n-2k-i+1] = s[i+2k]\) 对于 \(n-k&lt;i \le n\)： \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) 可以看出 \(2k\) 是 \(s\) 的周期，且 \(s\) 循环右移 \(2k\) 位后得到的字符串与 \(s\) 相等。因此 \(s\) 的最小周期是 \(n\) 的约数。设 \(s\) 的最小周期长度为 \(t\)，\(t \mid n\)。 显然，如果 \(s\) 循环右移 \(k\) 位仍是一个回文串，那么 \(t \mid 2k\)。有 \(t\) 种不同的与 \(s\) 循环同构的串。若 \(t\) 为偶数，那么 \(s\) 循环右移 \(\frac t 2\) 位或循环右移 \(0\) 位是回文串。否则只有循环右移 \(0\) 位是回文串。 为了计算与某个回文串循环同构的字符串数，考虑枚举回文串并计算与这个回文串同构的字符串有多少种，这样最小周期是偶数的回文串的循环同构串会被算恰好两次，其他回文串的循环同构串只会被算一次。特判最小周期为偶数的情况即可。 然而不可能枚举所有的回文串。考虑把最小周期相同的回文串放在一起枚举。设字符集大小为 \(K\)，最小周期为 \(i\) 的约数的回文串有 \(K^{\lceil \frac i 2 \rceil}\) 个。莫比乌斯反演一下即可。 然而 \(n\) 非常的大，没有办法直接反演出一个数组。 把答案写出来化简： \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] 枚举 \(d\)。 \(d\) 为偶数时，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)。 \(d\) 为奇数时，若 \(n\) 为奇数，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)，否则 \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)。 \(Pollard-Rho\) 分解素因数后简单统计一下答案即可。 代码]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] 镜中的昆虫]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[提交至 [Ynoi2016]镜中的昆虫。 记录每个点 \(i\) 前面第一个与他同色的位置 \(pre_i\)。询问区间颜色数变成询问区间内有多少个 \(pre_i &lt;l\)，这是一个二维偏序问题。注意到修改 \(pre\) 数组次数均摊 \(\mathcal O (n)\)，用 \(set\) 维护每一段，cdq分治或者树套树做一下二维偏序即可。 这题有一点卡常..cdq分治写归并速度会快很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //离散化int pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //对 l+1-r 的pre更新 set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[虽然前面还有很多坑没补完...但是我发现自己代码能力问题比较严重。所以来做做ynoi。 坑先放在这...清醒的时候慢慢填。 [YNOI2016] 镜中的昆虫]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[提交至 【模板】快速沃尔什变换。 先咕着。。。万一遇上现推吧。]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 扩展中国剩余定理]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】扩展中国剩余定理。 这题目有问题吧....模数可以爆 long long 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 后缀自动机]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[提交至 【模板】后缀自动机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Splay(维护序列)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[提交至 [NOI2005]维护数列。 常数非常非常大.....先当板子背了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式exp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式ln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式对数函数。 代码特别丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式求逆]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式求逆。 \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) 代码丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 任意长度DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm 求 \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) 设 \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)。 则 \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)。 \(i-k\) 可能会出现负数。平移下做个卷积即可。 懒得写QAQ。（好像也没啥好写的）]]></content>
  </entry>
  <entry>
    <title><![CDATA[[模板] NTT模板]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一个普通的 NTT 模板。代码非常丑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FFT模板]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[省选前复习。这是一个普通的 fft 模板。 （发现自己差点fft模板不会打了） 因为没有预处理&amp;&amp;用了complex类可能常数比较大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[我发现自己的代码能力太弱了...... 有些模板需要平时写一下，不能现场写，否则不一定调的出来。这里列出一些常用模板。（优化常数&amp;&amp;优化代码复杂度&amp;&amp;背下来）。 多项式： FFT NTT 多项式求逆 多项式ln 多项式exp 多项式取模 多项式多点求值 多项式快速插值 多项式复合逆 常系数齐次线性递推 数论： Lucas定理 exCRT 杜教筛 Pollard-Rho Miller-Rabin min_25筛 类欧几里得 二次剩余 貌似是洲阁筛的筛法 高级数据结构： 线段树合并 树状数组 Splay LCT ETT 点分树 树链剖分 动态dp 字符串： 后缀自动机 建后缀树 后缀数组 trie树SAM AC自动机 回文树 其他： FWT 半平面交 矩阵-树定理 图论： 支配树 圆方树 边双]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[口胡的题目]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[我的这么菜了还口胡题目...大概会越来越菜吧.. 2019.3.29 CF 1097G \(k\) 次方看作是选 \(k\) 条边。考虑所有 \(k\) 条边的有序对，计算包含它们的集合数。背包 \(dp\) 一下就好了。根据某考过很多次的复杂度分析，时间复杂度是 \(\mathcal O (nk)\)。]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[题面： https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf 题目大意 输入一个长度为 \(n\) 的字符串 \(s\)。你有一个空串 \(t\)，你要把它变成输入的字符串。可以进行以下几种操作： 在 \(t\) 的开头或者末尾添加一个字符。 把 \(t\) 翻转过来，然后接在原来的 \(t\) 的开头或末尾。 求最少操作次数。 \(n \le 10^5\) 解法 在最后连续的若干次加字符操作之前，\(t\) 一定是回文串。倒过来考虑，用最少操作次数把 \(s\) 变成空串。只需要分别考虑每个回文串的最少操作次数。 建立回文树。只需要考虑三种转移： 一个长度为偶数的回文串变为他的一半。 一个回文串，去掉他两端的字符。 一个回文串，转移到他的最长回文前缀。 按长度从小到大顺序 \(dp\)。后两种转移可以直接计算。对第一种转移，倍增一下判断 \(fail\) 树上有没有长度恰好为一半的祖先即可。 代码 下面的代码是假的。要省选了..先补点别的再来打这题QAQ。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串技巧、思想、知识点整理]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1/RAbvMXmgdpSktUoll9DJJvuWm70NQL3EC0QfZMltfhb+RQxQCYOiLj0U14+YABkhSeP7O1XsOJri8VtiWiuAv++xEbOEQZCnYkT90bclnnEKsUA4VXsZDOcMkHnNvyfRAHR8xGx8hWTBdZxiQ9UeVjwMNmfYpQuDqdXzhPWJ8Th+QjD5PX2kdVPA9o59w1rWY5/Q8WNwhbQxib+1+E//jk8k8Og5VwqWo3WVck2Jo76xEr+4rPIzNIgXBjlee0f5I8Vr5QskasE7hUB0Qniz+MUdlUyGIT68c6686T/UgfOMRnq+mymYWwKSIkRiC92XGVcDBiGTY/5vn5xsIS5Cv37tLVBj5FccrLbtCC4i+rfc9e4HaFSOOmnp0a4Qa6qqzLsYT5zkSgOoXiTSsJ2rGofKfnPxHhg9GqQ2XujK0PDh3q73BkJcIenQ0h7M1FuPIAKNcK2JLl8a5LaZIaPyzxV8vVW++ueR0SnOUwrrt9qqjmYgyixYJ/CkI6pJnGmF17RxPx15GC4Q9/GwuWOAqBmDhAMoWGwprFTtrlO+437DUmYsKoWPs08mDKoO3odM5l0g4lX7hneGfjxd43DAzrukm+iHOUCicix2eFDPDgGFU2iRZXEr7L6oZyLjnq3MeCGvxFJRroiBrK9vFk4RTx6fWh9GcBJDwiYpStCbkfIsCTgZU3F3MC4slg390n9XJLIUIezrBUg4kmML4HfEazd3C7Alm1hFNNeeaDrb3ruQvaqslWvOUTOYIK8dFd23qd0zcFMVkfTxQOVfCM0Y+3pZW6Akm/9OMzofsyxlWRqtdRW90mARjnMWl2gqM/H/gujw/Ml8sF/nW1PDlycQ+dW74BWf3kr/hHT/hRaS79ACtmycY4eHC6gTgLQqTT8HUk6CZNjQk3ajLhXT55YgZujomoBMmABhS12up6YwVgu9ktOqtD4PjfzEex0//doBYtB7won6bPvmwXFPzWEE+ItNCIIAYJEX74F/DzUbo5/dnJPs64atHUBESs/kJYyNKfrx7v6xg4avb0CplUOdsLS8u4WpQFhBFM/eN3idJe3GgjcBJSS20BpQaNRBmKY4gKYRT/5Xltl9LFZqmeAtFki3gcSN4Z1KsAJKkmbLrQQC5dmJ5eLHwaOoItGp7N8MM6HLtfwoVMdAgCtERpjsVD8fWcRCtBffjB3wBxvPH1tuBDrWinywNzJ2n9TzzOdlbgtVX21BoYsuluF2N+0ffXSzXuwQYZrcmuVTYQIlL7+eOor0BS88gfRzKryVrDL3qPm1Dkyeiz/Ieocw4ZrhgfVBmEfXwrn0o9tCb9upGrT7DzkmS6wpMF2U3w3IV0uYrcrKyYP8F83b1vyjo71Ow1uUm608x75e3pbSxFP2JIXouSRkbmaZ+GTuO+wJiweQw2I53TTVEo3hbuNm6rEHiQDo/ePOXd3S+noGZglrSVNwDh2Xe2sdOvDWHIgopwBvmq5u2YjXUSEcu6aA38/3zXMS4I35t4WQzmrAlMP4W2fzXHgKT6MrPljwH85kFISBp7MSWN/xc1q0Pp86hqaNuKX8UJqKTIojbAMFFETsnP08NAmOf66FHTL36FOO1TLoHkkoTtpk1Abwf4bpowN9e+jX0ealAFovA2mZ8zbDaF9Wnb2NHLaTmcHm+H3c7FXIaUF7ULcYkmbDhHMNkKZv7OcmRseBI6ib1ZZDi5TTrpOeEClsUs38Hs9mrG1eRuF6O6FEJKwR0ai5yuB7SEFenXSmXk9KDbYuawuw+hXP3z9dmOVgrTaPlYt0td9d/Ov+IGroEqnTvI5dHaIsnVGYc7h6dwDVdw5yYRD2B0hGCKs8vYs1mbCTWCVSmo65Y12a+pLJutM3hklxD132uXIbv3xIuVu3cgBy+pC20dkwkT0PHOUdvcqHEPHnRnwAC0WOkup0tCkQFC9IHCngLHdQZq+VjDOpZw7oOZubZqeKLRBw4OzIhfMElVD2dlz5gIW5d1XfmcwFlPcMW9xQ5XKsxbQeyMcswg7luGNqVsF2D/Tn6CmEVV63LkSrR/a0HjwEufBGwCTNg/JBBMWPmQhAE7bQmzrSlo06SKL1hhu3Kyuj+5ajm0ma6298aUB1XTTcu3QLNpObgtolGYMCzoe/U2+qDE4pmQyhoWkRTIPBTG8pj1a1HzXymtgeKXZdgbIgCNRIkN5Qd2WzLFYCqLYjqxPbGgJXnIoFCtexUHLa/gKcLiyq5Nrdo45xPbgcZZIwt8r+Qm34SYUh+f4R/63Da0duDnhkXCi6XeqMvNpL9Y14jNlL94oGHjhzWz8JATfZlh5i1vk8IKo0n9w/0qRtfeKrJGYDorl6TtWgqNNTYDebZDb3zqgdRfW8K1NB8AAopu+PzT5BM7QGAEKuVfUbaE+1Ya5m8jZNZcDQ25eekSpnBZHSGSlrwhxo41kJT9kKwzf5jvxBcf9bmP8umR0rQv7zBg7dbKof7Hx2WTyWsVJTtPvdnljD6UWY1mkeII7V+6Woo1ZNobA==]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>字符串</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon word的一些性质]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipedia链接：https://en.wikipedia.org/wiki/Lyndon_word 定义 如果一个串最小后缀是它本身，那么称他为 Lyndon word。（与严格最小循环移位的定义是等价的） 相关性质和算法 性质1 如果 \(s\) 是 Lyndon word，那么 \(s\) 不存在 border。 性质2 如果 \(s\) 是 Lyndon word，\(s=uv\) 且 \(u\) 和 \(v\) 非空，那么 \(u&lt;v\)。 性质3 如果 \(s,t\) 是 Lyndon word 且 \(s &lt; t\)，那么 \(st\) 也是 Lyndon word。 性质4 一个长度大于等于 \(2\) 字符串的 \(s\) 是 Lyndon word 的充要条件是，\(s\) 可以拆成两个非空串 \(u,v\)，满足 \(u &lt; v\) 且 \(u\) 和 \(v\) 都是 Lyndon word。 证明 充分性即上一条性质，只证必要性。 设 \(s\) 的长度为 \(n\)，后缀 \(s[i..n]\) 是 \(s\) 的次小后缀。 假设 \(s[1..i-1]\) 有长度为 \(k\) 的 border，即 \(s[1..k]=s[i-k..i-1]\)。 因为 \(k &lt; i-1\)，所以 \(k+1 \neq i\)。 因为 \(s\) 是 Lyndon word，\(s[i..n]\) 是 \(s\) 的次小后缀，所以 \(s[i..n]&lt;s[k+1..n]\)。又因为 \(s[i-k..i-1]=s[1..k]\)，所以 \(s[i-k..n]&lt;s[1..n]\)，这与 \(s\) 是 Lyndon word 矛盾。所以 \(s[1..i-1]\) 没有 border。 根据 Lyndon word 的定义及 \(s[1..i-1]\) 没有 border，有 \(\forall 1 &lt; j \le i-1\)，\(\exists j \le k \le i-1\)，满足 \(s[k] &gt; s[k-j+1]\)，即 \(s[j..i-1] &gt; s[1..i-1]\)。所以 \(s[1..i-1]\) 是 Lyndon word。 因为 \(s[i..n]\) 是 \(s\) 的次小后缀，显然不存在 \(j&gt;i\) 满足 \(s[j..n]&lt;s[i..n]\)，所以 \(s[i..n]\) 是 Lyndon word。 所以 \(u=s[1..i-1],v=s[i..n]\) 是一组合法的拆分，必要性得证。 性质5 任意一个字符串 \(s\) 都可以唯一地拆成若干个字典序不增的 Lyndon Word。 我抽代太菜了...其他的性质以后再补吧。]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon 分解]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[解法 关于 Lyndon word 的一些结论可以看这个。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/D 题目大意 给定一棵 \(n\) 个点，以 \(1\) 为根的树，第 \(i\) 个点有一个价格 \(c_i\)。 你要选一些点，然后另一个人会给每个叶节点设置一个数字。你只能对已经选择的点做子树加任意数字的操作。 你要通过若干次操作把所有叶子节点上的数变为 \(0\)。 问：要确保另一个人无论怎么操作你都能把叶子上的数变成 \(0\)，你选择的点价格总和最小是什么？有哪些点被至少一种最小价格的方案包含？ \(n \le 200000\)，\(0\le c_i \le 10^9\)。 解法 这个问题可以看成，你要选一些点作为未知数，每个叶子的限制构成了一个方程，你要让这个线性方程组满足，无论常数项取值是什么，这个线性方程组都有解。 因为价格是非负整数，如果系数矩阵的列向量组线性相关，必可以删除某一列，即可以少选一个点，这样一定不会变的更差，所以系数矩阵的列向量组线性无关。因为无论常数项的取值是什么，方程组都要有解，所以行数等于列数。 结论 设叶节点个数为 \(x\)，一个包含恰好 \(x\) 个点的选取方案能保证可以将所有叶子上的数字变成 \(0\) 的充要条件是，任意两个叶子到根的路径上，存在被选取的点，且深度最大的被选取点不同。 证明 必要性显然。 充分性：把方程组的未知数按任意一种 \(dfs\) 序排列，系数矩阵中，每一行的第一个非 \(0\) 元素所在的列都不同，所以系数矩阵的列向量组线性无关，又因为行数等于列数，所以无论常数项取值是什么，方程组都有解。 状态 \(dp[i][j][k]\) ： \(i\) 表示只考虑以 \(i\) 为根的子树。 \(j\) 表示 \(i\) 是否被选择。 \(k\) 表示是否存在一个叶子，他到 \(i\) 的路径中没有点被选择。 \(dp\) 数组中存的是，满足任意两个叶子到 \(i\) 的路径上深度最大的祖先不同（如果不存在则看作 \(0\)）的最小价格和。 \(dp\) 一下，然后记录哪些转移可以取到最优值，最后从根开始 \(dfs\) 一遍求方案即可。 代码 （巨丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/C 题目大意 你有一个长度为 \(n\) 个字符串 \(s\)。 请你把 \(s\) 拆成若干个字符串 \(s=t_1t_2\cdots t_k\)。 对于第 \(i\) 个串，若 \(t_i\) 是 \(t_1t_2\cdots t_{i-1}\) 的字符串，你需要付出 \(b\) 的代价，否则 \(t_i\) 长度必须为 \(1\)，你需要付出 \(a\) 的代价。求最小代价。 \(n \le 5000\)，字符集大小 \(26\)。 解法 设 \(dp_i\) 表示前 \(i\) 个字符的最小划分，在求出 \(dp_i\) 后用 \(kmp\) 找最长在前面出现过的从 \(i+1\) 开始的串，更新所有 \(dp_j\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈整理（一）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipedia链接：https://en.wikipedia.org/wiki/Impartial_game impartial game 是指满足如下条件的游戏： - 两个玩家轮流操作，直到达到不能操作的状态（terminal position）。 - 当一个玩家不能操作时，winner 就被确定了。 - 每个状态的操作数和状态总数是有限的。 - 所有的操作必须同时能被两个玩家进行。 - 所有操作的结果都是确定性的。 Normal play convention wikipedia链接：https://en.wikipedia.org/wiki/Normal_play_convention Impartial game 的 Normal play convention ：最后一个可以操作的玩家获胜。 Nim游戏 wikipedia链接：https://en.wikipedia.org/wiki/Nim 有若干堆石子，两个人轮流取石子。每次轮到的人可以选择从某一堆中拿走若干颗石子（不能不拿），不能按规则操作的人输。 Nim 游戏属于 Impartial game。 Nim游戏的胜利条件 定理：当且仅当每堆石子的个数异或和不为 \(0\) 时，先手必胜。 证明： 对于 terminal position，即没有石的情况，异或和为 \(0\)，轮到这个状态的人输。定理对 terminal position 成立。 引理1 若一个状态，每堆石子个数异或和不为 \(0\)，则它必定可以转移到一个石子个数为 \(0\) 的状态。 证明： 设每堆石子个数的异或和为 \(s\)。 设 \(s\) 最高的二进制位是第 \(k\) 位（从低到高，最低位为第 \(0\) 位）。 一定存在一堆石子个数为 \(x\)，二进制下 \(x\) 的第 \(k\) 位为 \(1\)。 除了这堆石子外，其他堆石子个数的异或和为 \(s\oplus x\)。 \(s\oplus x\) 和 \(x\) 在所有比第 \(k\) 位高的二进制位上相等，\(s\oplus x\) 的第 \(k\) 位为 \(0\)，\(x\) 的第 \(k\) 位为 \(1\)，所以 \(s \oplus x &lt; x\)。 可以从这堆石子中取走 \(x-s\oplus x\) 个石子，使异或和变为 \(0\)。 引理2 若一个状态，每堆石子个数异或和为 \(0\)，无论怎么操作都会转移到一个每堆石子个数异或和不为 \(0\) 的状态。 证明： 设操作的堆在操作前有 \(x\) 颗石子。 那么除了这堆以外的其他堆石子数异或和也为 \(x\)。 在取石子后，这堆石子的个数一定不为 \(x\)。 只有这堆石子的个数为 \(x\) 时，与其他堆石子个数的异或和才会为 \(0\)。 所以操作后，每堆石子个数的异或和一定非 \(0\)。 根据结构归纳法可知定理成立。 Sprague–Grundy 定理 wikipedia链接：https://en.wikipedia.org/wiki/Sprague–Grundy_theorem 定义 \(mex\) 运算，一个集合的 \(mex\) 值是最小的没有出现在这个集合中的自然数。 定义 Sprague-Grundy 函数：对于一个状态 \(x\)，当 \(x\) 是 terminal position 时，\(SG(x)=mex\{SG(y)|x\) 可以转移到 \(y\}\)。 可以用 Sprague-Grundy 函数判断一个状态是必胜状态还是必败状态，因为必胜状态函数值必不为 \(0\)，必败状态函数值必为 \(0\)。 定义两个游戏的 disjunctive sum 为一个游戏：轮到每个玩家的时候，他可以选择两个游戏中的一个游戏，然后在这个游戏上操作一步，无法操作的人输。 显然 disjunctive sum 满足交换律和结合律。 定理 有 \(n\) 个游戏 \(G_1,G_2,\cdots,G_n\)，设他们的 disjunctive sum 为 \(G\)。那么 \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)。 证明可以看这个。 这也说明了每一个 normal play convention 下的 impartial game 都等价于一个Nim游戏。]]></content>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
