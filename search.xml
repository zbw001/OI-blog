<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/problemset/problem/715/E 题目大意 你有两个长度为 \(n\) 的排列 \(p_1\) 和 \(p_2\)，其中有一些位置被挖空，让你自己填数字。请你对每个 \(k\) 输出，有多少种填数字方案，使得 \(p_1\) 最少交换 \(k\) 次可以变成 \(p_2\)。 \(n \le 250\)。 解法 代码]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 首先，一个以 \(A\) 为开头以 \(B\) 为结尾的序列是否存在，仅与 \(A\oplus B\) 有关。 如果存在一个满足条件的序列，那么 \(A\oplus B\) 中 \(1\) 的个数一定是奇数。 一个结论是，如果 \(A \oplus B\) 中 \(1\) 的个数是奇数，那么满足条件的序列一定存在。 下面递归地给出构造。 定义 \(build(n,A,B)\) 返回一个 \(0 \ldots 2^n-1\) 的以 \(A\) 为开头，\(B\) 为结尾的排列。（\(A\oplus B\) 中有奇数个 \(1\)） 若 \(n=1\)，如果 \(A = 0\)，返回 \(A, B\)。 若 \(A \oplus B\) 中恰有一个 \(1\)，不妨设 \(A = 0, B = 2^{n-1}\)（其他情况只需要把所有数异或上 \(A\) 并把 \(1\) 所在在位和最高位交换即可）。 设 \(a=build(n-1, 0, 1)\)，那么 \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) 是一个满足条件的排列。 若 \(A\oplus B\) 中存在 \(0\)，不妨设其中 \(0\) 在最低位上且 \(A\) 的最低位为 \(0\)。 设 \(a = build(n-1, \frac A 2, \frac B 2)\)，\(b = build(n-1, a_1, a_2)\)。 那么 \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) 是一个满足条件的排列。 若 \(A\oplus B\) 中不存在 \(0\)，不妨设 \(A = 0, B = 2^n-1\)。 设 \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)。 则 \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) 是一个合法的排列。 用主定理可以分析出直接递归的复杂度并不高。所以直接递归一下就好。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[题目链接。 做法 设 \(f_{i,j}\) 表示把 \(p_i \ldots p_n\) 中大于等于 \(j\) 的数排序的最小代价。 设 \(k\) 是 \(p_i \ldots p_n\) 中第一个大于等于 \(j\) 的数的位置，\(p_i\ldots p_k\) 中大于等于 \(j\) 的数共有 \(c\) 个。 \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] 预处理出 \(p\) 和 \(c\)，\(n^2\) dp 一下即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF%2F</url>
    <content type="text"><![CDATA[题目链接。 题目大意 给你一棵 \(n\) 个点的树，边上有字符。定义路径 \(u\) 到 \(v\) 上的字符串就是把路径上的字符依次接起来得到的字符串。给定 \(m\) 个字符串 \(s_1,s_2\ldots s_m\)。\(q\) 次询问，每次询问给出三个数 \(i, j, k\)，询问在路径 \(i\) 到 \(j\) 的字符串中，\(s_k\) 出现了几次。 解法 符号说明：\(s^R\) 表示 \(s\) 的反串。\(pre(s,i)\) 表示 \(s\) 的长度为 \(i\) 的前缀，\(suf(s,i)\) 表示 \(s\) 的长度为 \(i\) 的后缀。\(s+t\) 表示把字符串 \(s\) 和字符串 \(t\) 拼起来得到的字符串。 先做一次点分治就可以把问题转化为 \(u \rightarrow v\) 经过根的情况，所以只讨论经过根的情况。 设根为 \(r\)，询问的路径为 \(u \rightarrow v\)，询问的字符串为 \(s_k\)。 可以把 \(s_k\) 在路径 \(u \rightarrow v\) 上的匹配分成三部分计算，第一部分是在 \(u\rightarrow r\) 上的匹配，第二部分是在 \(r \rightarrow v\) 上的匹配，第三部分是在跨过 \(r\) 的匹配。 前两部分是比较好计算的。离线一下，对所有的 \(s_i\) 建AC自动机，在树上dfs，每次在AC自动机上走一条转移边，用 BIT 维护一下每个点被走了几次，在 dfs 到点 \(x\) 时，只需作一次子树询问即可快速得到 \(s_k\) 在 \(r\rightarrow x\) 上出现了几次（对于第一部分是询问 \(s_k\) 的反串出现了几次）。 比较简单就不详细描述了。 第三部分比较复杂。设路径 \(u\rightarrow r\) 上的字符串为 \(x\)，路径 \(r \rightarrow v\) 上的字符串为 \(y\)。设 \(p\) 是最大的满足 \(pre(s_k,p)=suf(x,p)\) 的整数，\(q\) 是最大的满足 \(suf(s_k,q)=pre(y,q)\) 的整数。那么计算第三部分可以转化为计算 \(s_k\) 在 \(suf(x,p)+pre(y,q)\) 中的出现次数。 设 \(t_i\) 路径表示 \(r\rightarrow i\) 上的字符串。则 \(suf(x,p)+pre(y,q)\) 可以表示为 \(pre(s_k,p)+suf(s_k,q)\)，这样就转化为了只与 \(s_k\) 相关的问题。\(p\)、\(q\) 的具体求法后面会详细描述。假设已经求得了 \(p\)、\(q\)，考虑怎么快速得到第三部分的匹配次数。 把询问离线。对每个 \(i\)，建一棵 \(s_i\) 的后缀树和 \(s_i^R\) 的后缀树。在 \(s_i^R\) 的后缀树上 \(dfs\)，\(dfs\) 的过程中，维护一棵线段树。如果 \(dfs\) 到一个代表 \(s_i^R\) 后缀的点，设这个点对应的字符串长度为 \(l\)，那么就在线段树上把 \(s_i\) 的后缀树上对应 \(s_i[l+1\ldots \lvert s_i \rvert]\) 的点的子树 \(dfs\) 序上位置加一。（可能描述的不是很清楚...我也不知道怎么描述了）回溯时撤销操作。然后对每个询问 \(p, q\)，只要在 \(dfs\) 到 \(s_i^R\) 长度为 \(p\) 的后缀时，询问一下 \(s_i\) 长度为 \(q\) 的后缀在 \(s_i\) 的后缀树上的 \(dfs\) 序上位置在线段树上的值即可。 考虑如何求 \(p\)、\(q\)。由于求 \(q\) 的过程和求 \(p\) 类似，这里只详细描述求 \(p\) 的过程。对所有 \(s_i\) 以及 \(s_i^R\) 建出一个广义SAM。然后类似AC自动机+BIT的过程地，维护一个以parent树 \(dfs\) 序为下标的线段树。然后在点分治后得到的连通块上 \(dfs\)，\(dfs\) 到 \(u\) 时维护 \(r\rightarrow u\) 上的字符串在SAM上的位置，并把它的子树在 \(dfs\) 序上的位置在线段树上子树对长度取 \(max\)。然后求 \(p\) 时只需要询问一下 \(s_k^R\) 在 \(SAM\) 上的位置在parent tree中的 \(dfs\) 在线段树上的位置即可。 代码]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[题目链接 「PKUWC2018」Minimax。 大致思路&amp;&amp;吐槽 线段树合并，维护某个点最后的值在线段树上每个区间的概率。 merge 的时候记一下前后缀概率就能转移了。 代码能力真是越来越差了..线段树合并都写不熟。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 整数]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) 个 \(bit\) 压一起，线段树维护区间左边连续 \(0\) 和 \(2^{30}-1\) 的个数。 代码能力太菜了补补水题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[提交至 质数判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] 反回文串]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[提交至 「SDOI2018」反回文串。 题解 考虑什么样的回文串在循环移位 \(k\) 位后还是一个回文串。 设 \(s\) 是一个循环右移 \(k\) 位后仍是回文串的长度为 \(n\) 回文串。 记字符串 \(a\) 的反串为 \(a^R\)。 因为 \(s\) 是回文串，对于 \(1\le i \le n\)，\(s[i]=s[n-i+1]\)。 又因为 \(s\) 循环右移 \(k\) 位后仍是回文串： 对于 \(1 \le i \le n-2k\)： \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) 对于 \(n-2k &lt; i \le n-k\)： \(s[i] = s[2n-2k-i+1] = s[i+2k]\) 对于 \(n-k&lt;i \le n\)： \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) 可以看出 \(2k\) 是 \(s\) 的周期，且 \(s\) 循环右移 \(2k\) 位后得到的字符串与 \(s\) 相等。因此 \(s\) 的最小周期是 \(n\) 的约数。设 \(s\) 的最小周期长度为 \(t\)，\(t \mid n\)。 显然，如果 \(s\) 循环右移 \(k\) 位仍是一个回文串，那么 \(t \mid 2k\)。有 \(t\) 种不同的与 \(s\) 循环同构的串。若 \(t\) 为偶数，那么 \(s\) 循环右移 \(\frac t 2\) 位或循环右移 \(0\) 位是回文串。否则只有循环右移 \(0\) 位是回文串。 为了计算与某个回文串循环同构的字符串数，考虑枚举回文串并计算与这个回文串同构的字符串有多少种，这样最小周期是偶数的回文串的循环同构串会被算恰好两次，其他回文串的循环同构串只会被算一次。特判最小周期为偶数的情况即可。 然而不可能枚举所有的回文串。考虑把最小周期相同的回文串放在一起枚举。设字符集大小为 \(K\)，最小周期为 \(i\) 的约数的回文串有 \(K^{\lceil \frac i 2 \rceil}\) 个。莫比乌斯反演一下即可。 然而 \(n\) 非常的大，没有办法直接反演出一个数组。 把答案写出来化简： \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] 枚举 \(d\)。 \(d\) 为偶数时，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)。 \(d\) 为奇数时，若 \(n\) 为奇数，\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)，否则 \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)。 \(Pollard-Rho\) 分解素因数后简单统计一下答案即可。 代码]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] 镜中的昆虫]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[提交至 [Ynoi2016]镜中的昆虫。 记录每个点 \(i\) 前面第一个与他同色的位置 \(pre_i\)。询问区间颜色数变成询问区间内有多少个 \(pre_i &lt;l\)，这是一个二维偏序问题。注意到修改 \(pre\) 数组次数均摊 \(\mathcal O (n)\)，用 \(set\) 维护每一段，cdq分治或者树套树做一下二维偏序即可。 这题有一点卡常..cdq分治写归并速度会快很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //离散化int pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //对 l+1-r 的pre更新 set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[虽然前面还有很多坑没补完...但是我发现自己代码能力问题比较严重。所以来做做ynoi。 坑先放在这...清醒的时候慢慢填。 [YNOI2016] 镜中的昆虫]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[提交至 【模板】快速沃尔什变换。 先咕着。。。万一遇上现推吧。]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 扩展中国剩余定理]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】扩展中国剩余定理。 这题目有问题吧....模数可以爆 long long 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 后缀自动机]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[提交至 【模板】后缀自动机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] Splay(维护序列)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[提交至 [NOI2005]维护数列。 常数非常非常大.....先当板子背了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式exp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式ln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式对数函数。 代码特别丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 多项式求逆]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[提交至 【模板】多项式求逆。 \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) 代码丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] 任意长度DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm 求 \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) 设 \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)。 则 \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)。 \(i-k\) 可能会出现负数。平移下做个卷积即可。 懒得写QAQ。（好像也没啥好写的）]]></content>
  </entry>
  <entry>
    <title><![CDATA[[模板] NTT模板]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一个普通的 NTT 模板。代码非常丑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模板] FFT模板]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[省选前复习。这是一个普通的 fft 模板。 （发现自己差点fft模板不会打了） 因为没有预处理&amp;&amp;用了complex类可能常数比较大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[我发现自己的代码能力太弱了...... 有些模板需要平时写一下，不能现场写，否则不一定调的出来。这里列出一些常用模板。（优化常数&amp;&amp;优化代码复杂度&amp;&amp;背下来）。 多项式： FFT NTT 多项式求逆 多项式ln 多项式exp 多项式取模 多项式多点求值 多项式快速插值 多项式复合逆 常系数齐次线性递推 数论： Lucas定理 exCRT 杜教筛 Pollard-Rho Miller-Rabin min_25筛 类欧几里得 二次剩余 高级数据结构： 线段树合并 树状数组 Splay LCT ETT 点分树 树链剖分 动态dp 字符串： 后缀自动机 建后缀树 后缀数组 trie树SAM AC自动机 回文树 其他： FWT 半平面交 矩阵-树定理]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[口胡的题目]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[我的这么菜了还口胡题目...大概会越来越菜吧.. 2019.3.29 CF 1097G \(k\) 次方看作是选 \(k\) 条边。考虑所有 \(k\) 条边的有序对，计算包含它们的集合数。背包 \(dp\) 一下就好了。根据某考过很多次的复杂度分析，时间复杂度是 \(\mathcal O (nk)\)。]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[题面： https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf 题目大意 输入一个长度为 \(n\) 的字符串 \(s\)。你有一个空串 \(t\)，你要把它变成输入的字符串。可以进行以下几种操作： 在 \(t\) 的开头或者末尾添加一个字符。 把 \(t\) 翻转过来，然后接在原来的 \(t\) 的开头或末尾。 求最少操作次数。 \(n \le 10^5\) 解法 在最后连续的若干次加字符操作之前，\(t\) 一定是回文串。倒过来考虑，用最少操作次数把 \(s\) 变成空串。只需要分别考虑每个回文串的最少操作次数。 建立回文树。只需要考虑三种转移： 一个长度为偶数的回文串变为他的一半。 一个回文串，去掉他两端的字符。 一个回文串，转移到他的最长回文前缀。 按长度从小到大顺序 \(dp\)。后两种转移可以直接计算。对第一种转移，倍增一下判断 \(fail\) 树上有没有长度恰好为一半的祖先即可。 代码 下面的代码是假的。要省选了..先补点别的再来打这题QAQ。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串技巧、思想、知识点整理]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+r+IodZGhGXFG5HA/Pv6zg+z/ZKbOFFucWrD7qmgvKxezd/iTDMqCoNP6C72izezZxGe0PszWhBH7zGqhuKspLK63ZAEmw5rwBDl8ZL/Bu9L+yPcl5hVZn10t1oLQYqyQi7GwHhk6XtBMJmyxK6TdqZvJEEnbAYZ8Zdv/TGkPUSp2EL1HI4dUtsU152u9T4GaelLN6L3A18azo8Whq8BcvKHYGjFBzgQNSHYV90g6jbZPKU6evDdwpmQRcOAh1rFfjqckOTAFpHBpIuOVAjvHpXopotf62MAQgpdclRWsR/KYt/At2wP/LmLQ9BNCx9mO26bpwrJSCOx0Y20t9TRy1rFqJS0Rp+j3BzVSIWPzX37bfF6jCYxf/1RDz8gvf+JzRQ/hTwX2su2ZCfKn4kuHG+QmLybur5N7cZL/xheI2XvzAaEXX0z5UtEqUroQUPNYV25leLK4/z30PqbYxdbGSDLICI4Su3YU0tQiWC22iIka5L2NmWTJ3bhE9RB/RhqKZw48/bE/ws5oRiduUOObvycaYJE2aKWTnCwUOOKQTmdoL7oKGLR7OdjBBbZVAngzzkrhJiumSyGBWhwjNaz7bfDWEUjtXtX9GBEwhJ46O11LqXGKjg/qvbD/Kx9We48hJSKJJIH9um3tjNRo1GRGXdG+Bt5wcS9TpGZ1nE+F1AYb0t6SGyD8nr6PRISwv7FTbp0dTdER3rw86uGNKIFxmoWC2XDKQq9rMa2/Y9TG7GJ89qrgVGgwwMk8gd9JtoyzuPryomq1cn846ZifylHT1O5+RJ90eG6hPlH0n+V3HxDR8/P1/vQitnV4X+wgiP7uVLPQLZI7+cEIa8DpsonwERfYP65F8bL4c5MIzlUQjdWJWbApB0THLJlnfvvhifxUXZrug03MIHYw5ztfWyP2AbgQ9rGZzSnuFNnGg+JK5QTgpBkqXAUc8dAnbuWJ41t8pLD4SjCzNU/l3y43YdsCubtPqjSiSxcAV8Qn214dQsASpdeIESL2hEptXgtAHDKo/OMah4FX5k+R96cQQXOUvp7w2eRPC6DUdxoW1QHm8Ojybc+BdQTsH2ZiUL2Bd47hcJWjt1vvMisAKIhkvHtO9WybZt7uUtP7AUQAYQfIs7PdidXiM5M33cFrGUPvEafkJi156bJ+Lv0XFrhUcVuEWLmNAg4ZnRg0bEX61F9vI83wkKwuyOKeErza6z1vcfjZ0LIz6koQ9pK7n3EsKxRQ9v0zHpUDlPoz6QeCFHLxXNEZUZy5JWGNyKE3W+l+IkdoIZkTmlHuIbDUMHicjPkwFCmrjq3m/sIq43R276omjfQMWaGQgkEKH6MhYCKpPVRq5h6NTjFNSh1JFrK8M2MmhkI/GYySZS4QSgTSc5IrXrc1wDOxBUOBV3FtMgX7cXaRpUXdsa0dDD2gbBZza+TyvJ/yMjClb1tVnQ45FTH+F8E8dz7Q3Ob8ncdARFla8IGZD9sVmRwz5ffJkGz6RvEkW3ij/4ZSriPY46k/GNuswz8/sp/F7R/sG5Q5IcFgi3wypTdHI7FsVPJ/46/ov5svudJ0cFunoyotQpRarzoPWmr84u/BnLKHKOBMwEsTSwLY3hCRFvuRETjvdHD9hVhFZNEpAJ16jfByfYOSt4CgdiIAwkZZP5d9F//LFmE0oJ/K17CTAQhVOjYTcW32RznhLSTJHrAHHCJg0VcMOs0LAEs0tqxVGFfUhuOpVzGSZ/meZF6YFGvVGW6fTbgDB5aobxvVBsKr/4dVOOkj4FNKnLRmswVPNzrfQ2wX2QlxR01gZteQGUHFitd6cwotGYlfE/amiwhppO3OaAQa9ROavmafgVVfKDipm6VwKR4SnKBBmJfWS7u4UWJdsLsbmZJsnxvMM0vVx2Keg9EzwXm2L61snvQ0MKVnziSYJ37swfE8ESlAQSE9q0lPAECGooIndpUs90U/Mh12aszWiaNK5LAgX/QX36yg1w6r18IkmFuh4NcNh4BNpFmD44HulLZ0moMoxqrQ9Q6y3Km9tRl+bp0hzEAAzz8famHuNU0/jxjn5r/saqvZVCgmAr/jf8n6fQN0sGr71wfhVH/xzzBZ20bbWBwKNHqxYJubGSbopAJSbTtws7PEfQqHRjrn5elSGQRq8DUSFqykGWmQbRnSaQ6NNRhPvID7qHf3icNqRt6yW+d+Q+cq5t8zCE6Ez8CTSMpeyF+5zS1fk1L39+87nsIRZdcHYGPoAbryKVBYjGBT8I7ePSjXUNvHVSLyB6h1zwap+pExsjw00HECZJ/eWsikHr8342+bgN5eNyjv/ekNAMPBR3SXfTZDqo+sO/dTvCtUSHQjUd6r8Xpx2ZDX5Ei5KLt2KmVk1CLxmjexBcOJeFjd0Qd9PagGR05veq+J67e7W3hzpqhHZt5+CCAQJJYaMCF0m81xq7wFqN9gsYNi3DY3Lp2ZkNiCzG6Fqg2cveO24YbJy80BFToY0HGCH+AcWdNLxdv5P/qfrHoXLURXzx90KU48Blg==]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>知识点</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon word的一些性质]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipedia链接：https://en.wikipedia.org/wiki/Lyndon_word 定义 如果一个串最小后缀是它本身，那么称他为 Lyndon word。（与严格最小循环移位的定义是等价的） 相关性质和算法 性质1 如果 \(s\) 是 Lyndon word，那么 \(s\) 不存在 border。 性质2 如果 \(s\) 是 Lyndon word，\(s=uv\) 且 \(u\) 和 \(v\) 非空，那么 \(u&lt;v\)。 性质3 如果 \(s,t\) 是 Lyndon word 且 \(s &lt; t\)，那么 \(st\) 也是 Lyndon word。 性质4 一个长度大于等于 \(2\) 字符串的 \(s\) 是 Lyndon word 的充要条件是，\(s\) 可以拆成两个非空串 \(u,v\)，满足 \(u &lt; v\) 且 \(u\) 和 \(v\) 都是 Lyndon word。 证明 充分性即上一条性质，只证必要性。 设 \(s\) 的长度为 \(n\)，后缀 \(s[i..n]\) 是 \(s\) 的次小后缀。 假设 \(s[1..i-1]\) 有长度为 \(k\) 的 border，即 \(s[1..k]=s[i-k..i-1]\)。 因为 \(k &lt; i-1\)，所以 \(k+1 \neq i\)。 因为 \(s\) 是 Lyndon word，\(s[i..n]\) 是 \(s\) 的次小后缀，所以 \(s[i..n]&lt;s[k+1..n]\)。又因为 \(s[i-k..i-1]=s[1..k]\)，所以 \(s[i-k..n]&lt;s[1..n]\)，这与 \(s\) 是 Lyndon word 矛盾。所以 \(s[1..i-1]\) 没有 border。 根据 Lyndon word 的定义及 \(s[1..i-1]\) 没有 border，有 \(\forall 1 &lt; j \le i-1\)，\(\exists j \le k \le i-1\)，满足 \(s[k] &gt; s[k-j+1]\)，即 \(s[j..i-1] &gt; s[1..i-1]\)。所以 \(s[1..i-1]\) 是 Lyndon word。 因为 \(s[i..n]\) 是 \(s\) 的次小后缀，显然不存在 \(j&gt;i\) 满足 \(s[j..n]&lt;s[i..n]\)，所以 \(s[i..n]\) 是 Lyndon word。 所以 \(u=s[1..i-1],v=s[i..n]\) 是一组合法的拆分，必要性得证。 性质5 任意一个字符串 \(s\) 都可以唯一地拆成若干个字典序不增的 Lyndon Word。 我抽代太菜了...其他的性质以后再补吧。]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon 分解]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[解法 关于 Lyndon word 的一些结论可以看这个。 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/D 题目大意 给定一棵 \(n\) 个点，以 \(1\) 为根的树，第 \(i\) 个点有一个价格 \(c_i\)。 你要选一些点，然后另一个人会给每个叶节点设置一个数字。你只能对已经选择的点做子树加任意数字的操作。 你要通过若干次操作把所有叶子节点上的数变为 \(0\)。 问：要确保另一个人无论怎么操作你都能把叶子上的数变成 \(0\)，你选择的点价格总和最小是什么？有哪些点被至少一种最小价格的方案包含？ \(n \le 200000\)，\(0\le c_i \le 10^9\)。 解法 这个问题可以看成，你要选一些点作为未知数，每个叶子的限制构成了一个方程，你要让这个线性方程组满足，无论常数项取值是什么，这个线性方程组都有解。 因为价格是非负整数，如果系数矩阵的列向量组线性相关，必可以删除某一列，即可以少选一个点，这样一定不会变的更差，所以系数矩阵的列向量组线性无关。因为无论常数项的取值是什么，方程组都要有解，所以行数等于列数。 结论 设叶节点个数为 \(x\)，一个包含恰好 \(x\) 个点的选取方案能保证可以将所有叶子上的数字变成 \(0\) 的充要条件是，任意两个叶子到根的路径上，存在被选取的点，且深度最大的被选取点不同。 证明 必要性显然。 充分性：把方程组的未知数按任意一种 \(dfs\) 序排列，系数矩阵中，每一行的第一个非 \(0\) 元素所在的列都不同，所以系数矩阵的列向量组线性无关，又因为行数等于列数，所以无论常数项取值是什么，方程组都有解。 状态 \(dp[i][j][k]\) ： \(i\) 表示只考虑以 \(i\) 为根的子树。 \(j\) 表示 \(i\) 是否被选择。 \(k\) 表示是否存在一个叶子，他到 \(i\) 的路径中没有点被选择。 \(dp\) 数组中存的是，满足任意两个叶子到 \(i\) 的路径上深度最大的祖先不同（如果不存在则看作 \(0\)）的最小价格和。 \(dp\) 一下，然后记录哪些转移可以取到最优值，最后从根开始 \(dfs\) 一遍求方案即可。 代码 （巨丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[题目链接： https://codeforces.com/contest/1120/problem/C 题目大意 你有一个长度为 \(n\) 个字符串 \(s\)。 请你把 \(s\) 拆成若干个字符串 \(s=t_1t_2\cdots t_k\)。 对于第 \(i\) 个串，若 \(t_i\) 是 \(t_1t_2\cdots t_{i-1}\) 的字符串，你需要付出 \(b\) 的代价，否则 \(t_i\) 长度必须为 \(1\)，你需要付出 \(a\) 的代价。求最小代价。 \(n \le 5000\)，字符集大小 \(26\)。 解法 设 \(dp_i\) 表示前 \(i\) 个字符的最小划分，在求出 \(dp_i\) 后用 \(kmp\) 找最长在前面出现过的从 \(i+1\) 开始的串，更新所有 \(dp_j\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈整理（一）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipedia链接：https://en.wikipedia.org/wiki/Impartial_game impartial game 是指满足如下条件的游戏： - 两个玩家轮流操作，直到达到不能操作的状态（terminal position）。 - 当一个玩家不能操作时，winner 就被确定了。 - 每个状态的操作数和状态总数是有限的。 - 所有的操作必须同时能被两个玩家进行。 - 所有操作的结果都是确定性的。 Normal play convention wikipedia链接：https://en.wikipedia.org/wiki/Normal_play_convention Impartial game 的 Normal play convention ：最后一个可以操作的玩家获胜。 Nim游戏 wikipedia链接：https://en.wikipedia.org/wiki/Nim 有若干堆石子，两个人轮流取石子。每次轮到的人可以选择从某一堆中拿走若干颗石子（不能不拿），不能按规则操作的人输。 Nim 游戏属于 Impartial game。 Nim游戏的胜利条件 定理：当且仅当每堆石子的个数异或和不为 \(0\) 时，先手必胜。 证明： 对于 terminal position，即没有石的情况，异或和为 \(0\)，轮到这个状态的人输。定理对 terminal position 成立。 引理1 若一个状态，每堆石子个数异或和不为 \(0\)，则它必定可以转移到一个石子个数为 \(0\) 的状态。 证明： 设每堆石子个数的异或和为 \(s\)。 设 \(s\) 最高的二进制位是第 \(k\) 位（从低到高，最低位为第 \(0\) 位）。 一定存在一堆石子个数为 \(x\)，二进制下 \(x\) 的第 \(k\) 位为 \(1\)。 除了这堆石子外，其他堆石子个数的异或和为 \(s\oplus x\)。 \(s\oplus x\) 和 \(x\) 在所有比第 \(k\) 位高的二进制位上相等，\(s\oplus x\) 的第 \(k\) 位为 \(0\)，\(x\) 的第 \(k\) 位为 \(1\)，所以 \(s \oplus x &lt; x\)。 可以从这堆石子中取走 \(x-s\oplus x\) 个石子，使异或和变为 \(0\)。 引理2 若一个状态，每堆石子个数异或和为 \(0\)，无论怎么操作都会转移到一个每堆石子个数异或和不为 \(0\) 的状态。 证明： 设操作的堆在操作前有 \(x\) 颗石子。 那么除了这堆以外的其他堆石子数异或和也为 \(x\)。 在取石子后，这堆石子的个数一定不为 \(x\)。 只有这堆石子的个数为 \(x\) 时，与其他堆石子个数的异或和才会为 \(0\)。 所以操作后，每堆石子个数的异或和一定非 \(0\)。 根据结构归纳法可知定理成立。 Sprague–Grundy 定理 wikipedia链接：https://en.wikipedia.org/wiki/Sprague–Grundy_theorem 定义 \(mex\) 运算，一个集合的 \(mex\) 值是最小的没有出现在这个集合中的自然数。 定义 Sprague-Grundy 函数：对于一个状态 \(x\)，当 \(x\) 是 terminal position 时，\(SG(x)=mex\{SG(y)|x\) 可以转移到 \(y\}\)。 可以用 Sprague-Grundy 函数判断一个状态是必胜状态还是必败状态，因为必胜状态函数值必不为 \(0\)，必败状态函数值必为 \(0\)。 定义两个游戏的 disjunctive sum 为一个游戏：轮到每个玩家的时候，他可以选择两个游戏中的一个游戏，然后在这个游戏上操作一步，无法操作的人输。 显然 disjunctive sum 满足交换律和结合律。 定理 有 \(n\) 个游戏 \(G_1,G_2,\cdots,G_n\)，设他们的 disjunctive sum 为 \(G\)。那么 \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)。 证明可以看这个。 这也说明了每一个 normal play convention 下的 impartial game 都等价于一个Nim游戏。]]></content>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
