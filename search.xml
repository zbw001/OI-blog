<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[BZOJ4977] Ë∑≥‰ºûÊ±ÇÁîü]]></title>
    <url>%2F2020%2F05%2F14%2Fbzoj4977%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éËøôÁØá blog ÂÜô‰∏ãÊó∂ÔºåÁõÆÂâçÁàÜÁÇ∏ OJ Ê≠£Â§Ñ‰∫éÁàÜÁÇ∏Áä∂ÊÄÅÔºåËøôÈáåÈôÑ‰∏Ä‰∏™È¢òÁõÆÊèèËø∞„ÄÇ È¢òÁõÆÊèèËø∞ Â∞è Q ÊúÄËøëÊ≤âËø∑‰∫é„ÄäË∑≥‰ºûÊ±ÇÁîü„ÄãÊ∏∏Êàè„ÄÇ‰ªñÁªÑÂª∫‰∫Ü‰∏ÄÊîØÁî± \(n\) ÂêçÁé©ÂÆ∂ÔºàÂåÖÊã¨‰ªñËá™Â∑±ÔºâÁªÑÊàêÁöÑÊàòÈòüÔºåÁºñÂè∑‰æùÊ¨°‰∏∫ \(1\) Âà∞ \(n\)„ÄÇËøô‰∏™Ê∏∏Êàè‰∏≠ÔºåÊØèÂ±ÄÊ∏∏ÊàèÂºÄÂßãÊó∂ÔºåÊâÄÊúâÁé©ÂÆ∂ÈÉΩ‰ºö‰ªéÈ£ûÊú∫‰∏äË∑≥‰ºûÔºåÈÄâÊã©‰∏Ä‰∏™ÁõÆÁöÑÂú∞ÈôçËêΩÔºåË∑≥‰ºûÂíåÈôçËêΩÁöÑÊó∂Èó¥ÊúâÊó©ÊúâÊôö„ÄÇÂú®ÊüêÂ±ÄÊ∏∏ÊàèÈôçËêΩÂâçÔºå‰ªñ‰ª¨Âú®Á©∫‰∏≠ËßÇÂØüÂèëÁé∞Âú∞Èù¢‰∏ä‰∏ÄÂÖ±Êúâ \(m\) Èó¥ÊàøÂ≠êÔºåÁºñÂè∑‰æùÊ¨°‰∏∫ \(1\) Âà∞ \(m\)„ÄÇÂÖ∂‰∏≠ÊØèÈó¥ÊàøÂ≠êÊÅ∞Â•ΩÊúâ‰∏ÄÂêçÊïå‰∫∫Êó©‰∫é‰ªñ‰ª¨Âà∞Ëææ„ÄÇÂ∞è Q ÊàòÈòüÁöÑÁ¨¨ \(i\) ÂêçÁé©ÂÆ∂Êã•Êúâ \(a_i\) ÂèëÂ≠êÂºπÔºåÂú∞Èù¢‰∏äÁ¨¨ \(i\) Èó¥ÊàøÂ≠êÈáåÁöÑÊïå‰∫∫Êã•Êúâ \(b_i\) ÂèëÂ≠êÂºπÔºåÊ∂àÁÅ≠‰ªñÂèØ‰ª•Ëé∑Âæó \(c_i\) ÁÇπÁßØÂàÜ„ÄÇÊØèÂêçÁé©ÂÆ∂ÂøÖÈ°ª‰∏îÂè™ËÉΩÈÄâÊã©‰∏ÄÈó¥ÊàøÂ≠êÈôçËêΩÔºåÁÑ∂ÂêéÂéªÊ∂àÁÅ≠ÈáåÈù¢ÁöÑÊïå‰∫∫„ÄÇËã•Á¨¨ \(i\) ÂêçÁé©ÂÆ∂ÈÄâÊã©‰∫ÜÁ¨¨ \(j\) Èó¥ÊàøÂ≠êÔºåÂ¶ÇÊûú \(a_i&gt;b_ j\)ÔºåÈÇ£‰πà‰ªñÂ∞±ÂèØ‰ª•Ê∂àÁÅ≠ËØ•Êïå‰∫∫ÔºåËé∑Âæó \(a_i-b_j+c_j\) ÁöÑÂõ¢ÈòüÂ•ñÂä±ÁßØÂàÜÔºåÂê¶Âàô‰ªñ‰ºöË¢´Êïå‰∫∫Ê∂àÁÅ≠„ÄÇ‰∏∫‰∫ÜÈò≤Ê≠¢Âõ¢ÁÅ≠ÔºåÂ∞è Q ‰∏çÂÖÅËÆ∏Â§öÂêçÁé©ÂÆ∂ÈÄâÊã©Âêå‰∏ÄÈó¥ÊàøÂ≠êÔºåÂõ†Ê≠§Â¶ÇÊûúÊüê‰ΩçÁé©ÂÆ∂ÊØ´Êó†Âà©Áî®‰ª∑ÂÄºÔºå‰Ω†ÂèØ‰ª•ÈÄâÊã©ËÆ©‰ªñÈÄÄÂá∫Ê∏∏Êàè„ÄÇÂõ†‰∏∫ÊàøÂ≠ê‰πãÈó¥ÁöÑË∑ùÁ¶ªËøáÈïøÔºå‰Ω†ÂèØ‰ª•ËÆ§‰∏∫ÊØèÂêçÁé©ÂÆ∂Âú®ÈôçËêΩ‰πãÂêé‰∏çËÉΩÂÜçÂéªÊ∂àÁÅ≠ÂÖ∂ÂÆÉÊàøÈó¥ÈáåÁöÑÊïå‰∫∫„ÄÇ‰Ωú‰∏∫Â∞è Q ÊàòÈòüÁöÑÊåáÊå•ÔºåËØ∑Âà∂ÂÆö‰∏ÄÂ•óÊúÄ‰ºòÁöÑÈôçËêΩÊñπÊ°àÔºå‰ΩøÂæóÊúÄÂêéËé∑ÂæóÁöÑÂõ¢ÈòüÂ•ñÂä±ÊÄªÁßØÂàÜÊúÄÂ§ß„ÄÇ \(n, m \le 10^5\) ÂÅöÊ≥ï Âª∫Â¶Ç‰∏ãË¥πÁî®ÊµÅÂõæÔºåÊ±ÇÊúÄÂ§ßË¥πÁî®ÊµÅ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠Êï∞Â≠óÊ†áÊ≥®ÁöÑÊòØË¥πÁî®„ÄÇ ÂÅáËÆæÂàöÂºÄÂßãÊ∫êÁÇπÂá∫ÂèëÁöÑÈÇ£‰∫õËæπ‰∏çÂ≠òÂú®Ôºå‰æùÊ¨°Âä†ÂÖ•ÈÇ£‰∫õËæπÔºåÊØèÊ¨°Âä†ÂÖ•‰∏ÄÊù°ËæπÂêéÊõ¥Êñ∞ÊúÄÂ∞èË¥πÁî®ÊµÅ„ÄÇ ÂèØ‰ª•Ê≥®ÊÑèÂà∞Â¢ûÂπøËøáÁ®ã‰∏≠Âä†ÂÖ•ÁöÑÂèçÂêëËæπÈÉΩÊòØ‰ªéÂ∑¶Âà∞Âè≥ÁöÑÔºåËøôÊ†∑ÁöÑËæπ‰∏ç‰ºöË¢´Áî®Âà∞„ÄÇ ÊâÄ‰ª•Êàë‰ª¨‰∏çÈúÄË¶ÅÂÖ≥ÂøÉÂàùÂßãÊó∂‰∏çÂú®Ë¥πÁî®ÊµÅÂõæ‰∏äÁöÑËæπ„ÄÇÊØèÊ¨°Âä†ÂÖ•‰∏ÄÊù°ËæπÂêéÊúâ‰∏âÁßçÊÉÖÂÜµÔºö Â¢ûÂπø‰∏ÄÊù°Ê∫êÂà∞Ê±áÁöÑÁÆÄÂçïË∑ØÂæÑ Ê∂àÊéâ‰∏Ä‰∏™ÂåÖÂê´Âä†ÂÖ•ÁöÑËæπÁöÑÁÆÄÂçïË¥üÁéØ (Âõ†‰∏∫ÊòØË¥üÁéØ‰∏ÄÂÆöÁªèËøáÊ±áÔºåÊâÄ‰ª•‰πüÂ∞±‰∏ÄÂÆöÊÅ∞Â•ΩÁªèËøá‰∏§Êù°‰∏éÊ±áÁõ∏ÈÇªÁöÑËæπ) ‰∏ç‰ΩúÊõ¥Êñ∞ Á¨¨‰∏ÄÁßçÁõ∏ÂΩì‰∫éÊòØÊääÊñ∞Âä†ÂÖ•ÁöÑËæπÂØπÂ∫îÁöÑÁé©ÂÆ∂Âíå‰∏Ä‰∏™Ê≤°ÊúâË¢´ÂåπÈÖçÁöÑÊàøÂ≠êÂåπÈÖçÔºåÁ¨¨‰∫åÁßçÁõ∏ÂΩì‰∫éÊòØÊää‰∏Ä‰∏™Â∑≤ÂåπÈÖçÁöÑÊàøÂ≠êÂåπÈÖçÁöÑÁé©ÂÆ∂Êîπ‰∏∫Êñ∞Âä†ÂÖ•ÁöÑËæπÂØπÂ∫îÁöÑÁé©ÂÆ∂„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Âä†ÂÖ•ÊØè‰∏™‰∫∫ÔºåÁî®Â†ÜÁª¥Êä§‰∏Ä‰∏ãÂì™‰∏™Êî∂ÁõäÊØîËæÉÂ§ßÔºåÂ¶ÇÊûúÈÉΩÊòØË¥üÁöÑÂ∞±‰∏ç‰ΩúÊõ¥Êñ∞ÔºåÂê¶ÂàôÂ∞±ÈÄâÊî∂ÁõäËæÉÂ§ßÁöÑÊõ¥Êñ∞Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Ê®°ÊãüË¥πÁî®ÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] Ê®°ÊãüË¥πÁî®ÊµÅÈóÆÈ¢ò]]></title>
    <url>%2F2020%2F05%2F14%2F%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ËøôÁØá blog ÊòØÂÜôÁªôËá™Â∑±ÁúãÁöÑÔºåÊâÄ‰ª•ÂèØËÉΩÊèèËø∞ÊØîËæÉÁÆÄÁï•„ÄÇ ‰ªÄ‰πàÊòØÊ®°ÊãüË¥πÁî®ÊµÅ Êúâ‰∏Ä‰∫õÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫‰∏Ä‰∏™Ë¥πÁî®ÊµÅÈóÆÈ¢òËß£ÂÜ≥Ôºå‰ΩÜÊòØÂª∫ÂõæÂ§çÊùÇÂ∫¶Â§™È´òÊàñÊòØÊ±ÇË¥πÁî®ÊµÅ‰ª£‰ª∑Â§™Â§ß„ÄÇ Ê®°ÊãüË¥πÁî®ÊµÅÂ∞±ÊòØÊåáÁªìÂêàÊµÅÁΩëÁªú‰∏≠ÁöÑÊÄßË¥®ÔºåÂØπË¥πÁî®ÊµÅÁÆóÊ≥ïÁöÑÂÖ∑‰ΩìËøáÁ®ãËøõË°å‰ºòÂåñ„ÄÇÊØîÂ¶ÇÂØπ Successive Shortest Path ÁÆóÊ≥ïÊâæÊúÄÁü≠Ë∑ØÁöÑËøáÁ®ã‰ºòÂåñÔºõÊàñÊòØÂàùÂßãÊó∂‰ªÖ‰øùÁïô‰∏Ä‰∫õËæπÔºåÁÑ∂ÂêéÈÄêÊù°Âä†ÂÖ•Ââ©‰∏ãÁöÑËæπÔºåÊØèÊ¨°Âä†ÂÖ•ÂêéÊ∂àÂúàÔºåÈÄöËøáÂàÜÊûêË¥üÂúàÁöÑÊÄßË¥®‰ºòÂåñÂ§çÊùÇÂ∫¶„ÄÇ Ë¥πÁî®ÊµÅÈóÆÈ¢òÁöÑ‰∏Ä‰∫õÊÄßË¥® Â¶ÇÊûú‰Ω†Â∑≤ÁªèÁü•ÈÅì‰∏Ä‰∏™ÂõæÁöÑ‰∏Ä‰∏™ÊúÄÂ∞èË¥πÁî®ÊµÅ/ÊúÄÂ∞èË¥πÁî®ÊúÄÂ§ßÊµÅÔºåËÄÉËôëÂä†‰∏ÄÊù°ÂÆπÈáè‰∏∫ \(1\) ÁöÑËæπÂ¶Ç‰ΩïÊ±ÇÂá∫Êñ∞ÁöÑÂõæÁöÑÊúÄÂ∞èË¥πÁî®ÊµÅ / ÊúÄÂ∞èË¥πÁî®ÊúÄÂ§ßÊµÅ„ÄÇ ÊúÄÂ∞èË¥πÁî®ÊµÅ ËÄÉËôëÂä†ËæπÂêéÁöÑ‰∏Ä‰∏™ÊúÄÂ∞èË¥πÁî®ÊµÅÂíåÂä†ËæπÂâçÁöÑ‰∏Ä‰∏™ÊúÄÂ∞èË¥πÁî®ÊµÅÁöÑÂ∑Æ„ÄÇ Ëøô‰∏™Â∑ÆÂèØ‰ª• (Ëæπ‰∏ç‰∫§Âú∞) ÂàÜËß£‰∏∫Ëã•Âπ≤‰∏™Ê∫êÂà∞Ê±áÁöÑÁÆÄÂçïË∑ØÂæÑÂíåÁÆÄÂçïÁéØ„ÄÇ ÂÖ∂‰∏≠Èô§‰∫ÜÂåÖÂê´Êñ∞Âä†ÂÖ•ÁöÑËæπÁöÑË∑ØÂæÑ / ÁéØÔºåÂÖ∂‰ªñÊùÉÂÄº‰πãÂíåÈÉΩ‰∏ÄÂÆö‰∏∫ \(0\)ÔºåÂèØ‰ª•Âà†Âéª„ÄÇ ‰ªéËÄåÊñ∞ÁöÑÂõæ‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÂèØ‰ª•Áî±‰∫éÂä†ËæπÂâçÁöÑÂõæÂ¢ûÂπø‰∏Ä‰∏™ÂåÖÂê´Êñ∞Âä†ÂÖ•ÁöÑËæπÁöÑÁÆÄÂçïË∑ØÂæÑÊàñÂ¢ûÂπø‰∏Ä‰∏™ÂåÖÂê´Êñ∞Âä†ÂÖ•ÁöÑËæπÁöÑÁÆÄÂçïÁéØÂæóÂà∞ÁöÑÊúÄÂ∞èË¥πÁî®ÊµÅ„ÄÇÔºà‰πüÂ∞±ÊòØÂ¢ûÂπøÊúÄÂ∞èÁöÑÁÆÄÂçïË∑ØÂæÑ/ÊúÄÂ∞èÁöÑÁÆÄÂçïÁéØÔºåÂ¶ÇÊûúÈÉΩ‰∏∫Ê≠£Âàô‰∏çÂ¢ûÂπøÔºâ ÊúÄÂ∞èË¥πÁî®ÊúÄÂ§ßÊµÅ ‰∏éÊúÄÂ∞èË¥πÁî®ÊµÅÂæàÁ±ª‰ººÔºå‰∏çËøáË¶ÅÂàÜÂ¢ûÂπø‰∏ÄÊù°Ë∑ØÂæÑÂíåÂ¢ûÂπø‰∏Ä‰∏™ÁéØËÆ®ËÆ∫„ÄÇ ÂêåÊ†∑ÊääÂ∑ÆÂàÜËß£‰∏∫Ëá≥Â§ö‰∏ÄÊù°ÁÆÄÂçïË∑ØÂæÑÂíåËã•Âπ≤ÁÆÄÂçïÁéØÔºå‰ªÖÊúâÂåÖÂê´Êñ∞Âä†ÂÖ•ÁöÑËæπÁöÑÊâçÊòØÊúâÁî®ÁöÑÔºåÂÖ∂‰ªñÈÉ®ÂàÜÂèØ‰ª•Âà†Âéª„ÄÇ ÊâÄ‰ª•Êñ∞ÂõæÁöÑÊúÄÂ∞èË¥πÁî®ÊúÄÂ§ßÊµÅ‰∏ÄÂÆöÂèØ‰ª•Áî±Âä†ËæπÂâçÁöÑÂõæÁöÑÊúÄÂ∞èË¥πÁî®ÊúÄÂ§ßÊµÅÂ¢ûÂπø‰∏ÄÊù°ÁÆÄÂçïË∑ØÂæÑÊàñËÄÖ‰∏Ä‰∏™ÁÆÄÂçïÁéØÂæóÂà∞„ÄÇ Â∏∏ËßÅÊ®°Âûã ‰ºº‰πéÂ∏∏ËßÅÁöÑÊ®°ÊãüË¥πÁî®ÊµÅÊ®°ÂûãÈÉΩÊòØÁâπÊÆäÁöÑ‰∫åÂàÜÂõæ‰∏äË∑ëË¥πÁî®ÊµÅÁöÑÈóÆÈ¢ò„ÄÇ‰πüÂ∞±ÊòØËØ¥Âõæ‰∏äÈô§‰∫ÜÊ∫êÊ±á‰ª•Â§ñÁöÑÁÇπÂèØÂàÜ‰∏∫‰∏§ÈÉ®ÂàÜÔºåËæπÂèØÂàÜ‰∏∫‰∏âÁ±ªÔºöÊ∫êÂíåÁ¨¨‰∏ÄÈÉ®ÂàÜ‰πãÈó¥ÁöÑËæπÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÂíåÁ¨¨‰∫åÈÉ®ÂàÜ‰πãÈó¥ÁöÑËæπÔºåÁ¨¨‰∫åÈÉ®ÂíåÊ±á‰πãÈó¥ÁöÑËæπ„ÄÇËøôÊ†∑ÂæóÂà∞‰∏Ä‰∏™Á±ª‰ºº‰∫é‰∫åÂàÜÂõæÂ∏¶ÊùÉÂåπÈÖçÁöÑÈóÆÈ¢ò„ÄÇÔºà‰ΩÜÊòØÁÇπÂèØ‰ª•Â∏¶ÁÇπÊùÉÔºâ Ê®°Âûã 1 ‰∏§ÈÉ®ÂàÜ‰πãÈó¥ÁöÑËøûËæπÂèØ‰ª•ÈÄöËøáÂª∫‰∏ÄÊù°ÈìæÊù•‰ºòÂåñ„ÄÇ ‰æã 1 BZOJ 4977 Ë∑≥‰ºûÊ±ÇÁîü ‰æã 2 Ê®°Âûã 2 Âè≥ÈÉ®ÁÇπÊï∞ÁâπÂà´Â∞ë„ÄÇ Ê®°Âûã 3 Ê®°Âûã 1 ‰∏äÊ†ë„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1349D] Slime and Biscuits]]></title>
    <url>%2F2020%2F05%2F13%2FCF1349D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(\sum a_i = s\)„ÄÇ ÊòæÁÑ∂Âú®‰ªª‰Ωï‰∏Ä‰∏™Êó∂ÂàªÂè™ÊúâËá≥Â§ö‰∏Ä‰∏™‰∫∫Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤„ÄÇ ËÆæ‰ªé‰∏Ä‰∏™Â≠òÂú®‰∏Ä‰∏™‰∫∫Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÁä∂ÊÄÅÂºÄÂßãÔºåÂÅáËÆæÊ∏∏Êàè‰∏ç‰ºöÁªìÊùüÔºå\(k\) Ê≠•‰πãÂêéÂ≠òÂú®‰∏Ä‰∏™Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑ‰∫∫Ôºå‰∏îËøôÊòØËøô‰∏™‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéá‰∏∫ \(q_k\) (\(q_0=1\))ÔºåËÆæ \(Q(x) = \sum_{k \ge 0} q_k x^k\)„ÄÇ ËÆæÁ¨¨ \(k\) Ê≠•Êó∂Á¨¨‰∏ÄÊ¨°Âá∫Áé∞‰∏Ä‰∏™Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑ‰∫∫ÁöÑÊ¶ÇÁéá‰∏∫ \(f_k\) (Âç≥Ê∏∏Êàè \(k\) Ê≠•ÁªìÊùüÁöÑÊ¶ÇÁéá)ÔºåËÆæ \(F(x) = \sum_{k\ge 0} f_kx^k\)„ÄÇ ËÆæ \(p_{i,k}\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™‰∫∫ \(k\) Ê≠•ÂêéÁ¨¨‰∏ÄÊ¨°Êã•ÊúâÊâÄÊúâÈ•ºÂπ≤ÁöÑÊ¶ÇÁéáÔºåËÆæ \(P_i(x) = \sum_{k \ge 0} p_{i,k}x^k\)„ÄÇ ÈÇ£‰πà \(F(x) Q(x) = \sum P_i(x)\)ÔºåÊâÄ‰ª• \(F(x) = \frac{\sum P_i(x)}{Q(x)}\)„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \(F&#39;(1)\)„ÄÇÁî±ÂàÜÂºèÊ±ÇÂØºÂÖ¨ÂºèÈóÆÈ¢òË¢´ËΩ¨Âåñ‰∏∫Ê±Ç \(P_i(1), P&#39;_i(1), Q(1), Q&#39;(1)\)„ÄÇ ÊòæÁÑ∂ \(P_i(1) = 1, Q(1) = n\)ÔºåËÄÉËôë \(P&#39;_i(x), Q&#39;(x)\) ÁöÑÂÆûÈôÖÊÑè‰πâÔºåÈóÆÈ¢òÂèòÊàêÊ±Ç‰∏Ä‰∏™ÂàùÂßãÊúâ \(x\) ‰∏™È•ºÂπ≤ÁöÑ‰∫∫Á¨¨‰∏ÄÊ¨°Êã•ÊúâÂÖ®ÈÉ®È•ºÂπ≤ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåËøôËøô‰∏™ÂÄº‰∏∫ \(x_i\)ÔºåÈÇ£‰πàÊúâ \[ x_s = 0\\ x_i = 1 + \frac 1 {n(n-1)}[(n-i)(n-2)x_i + i(n-1)x_{i-1}+(n-i)x_{i+1}]\\ P&#39;_i(1) = x_{a_i}, Q&#39;(1) = (n-1) x_0 \] Ëß£ÊñπÁ®ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n + \sum a_i)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;const int maxn = 300010;int n, a[maxn], x[maxn], k[maxn], b[maxn], s;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; y &gt;&gt;= 1; x = 1LL * x * x % mod; &#125; return ret;&#125;int inv(ll x) &#123; return qpow(x % mod, mod - 2);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; &#125; k[0] = 1; for (int i = 0; i &lt; s; i++) &#123; int k1 = 1LL * (mod + 1 - 1LL * (s-i) * inv(s) % mod * (n-2) % mod * inv(n-1) % mod) % mod * inv(1LL * (s-i) * inv(s) % mod * inv(n-1) % mod) % mod; int k2 = 1LL * (mod-i) * (n-1) % mod * inv(s - i) % mod; int _b = 1LL * (n-1) * (mod - s) % mod * inv(s - i) % mod; k[i+1] = (k[i+1] + 1LL * k1 * k[i] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k1 * b[i] % mod) % mod; if (i &gt; 0) &#123; k[i+1] = (k[i+1] + 1LL * k2 * k[i-1] % mod) % mod; b[i+1] = (b[i+1] + 1LL * k2 * b[i-1] % mod) % mod; &#125; b[i+1] = (b[i+1] + _b) % mod; &#125; int t = 0; x[0] = 1LL * (mod - b[s]) * qpow(k[s], mod - 2) % mod; for (int i = 1; i &lt;= s; i++) &#123; x[i] = (1LL * k[i] * x[0] + b[i]) % mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; t = (t + x[a[i]]) % mod; &#125; int ans = 1LL * (t - 1LL * (n-1) * x[0] % mod + mod) % mod * inv(n) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏ÄÁ±ªÂå∫Èó¥Âä†Âå∫Èó¥ËØ¢ÈóÆÈóÆÈ¢òÁöÑÈÄöÁî®Â§ÑÁêÜÊñπÊ≥ï]]></title>
    <url>%2F2020%2F05%2F13%2F%E4%B8%80%E7%B1%BB%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4%E8%AF%A2%E9%97%AE%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êï¥ÁêÜ‰∏Ä‰∏ãËøô‰∏ÄÁ±ªÈóÆÈ¢òÁöÑÁêÜËß£ÊñπÂºè..‰ª•‰æø‰ª•ÂêéÊõ¥ÂÆπÊòìÊÉ≥Ê∏ÖÊ•öËøôÁ±ªÈóÆÈ¢ò„ÄÇ ‰Ω†Ë¶ÅÁª¥Êä§‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a\)ÔºåËøô‰∏™Êï∞ÁªÑÊúâ‰∏Ä‰∏™ÂàùÂßãÂÄº„ÄÇÊúâ‰∏§‰∏™‰∫åÁª¥Êï∞ÁªÑ \(p[c][n]\) Âíå \(q[d][n]\)„ÄÇ ‰Ω†Ë¶ÅÊîØÊåÅ‰∏§ÁßçÊìç‰Ωú 1. ÁªôÂÆö \(l, r, k, x\)Ôºå\(1 \le k \le c\)ÔºåÂØπÊØè‰∏™ \(l \le i \le r\)ÔºåÊää \(a[i]\) ÊîπÊàê \(a[i] + x\cdot p[k][i]\) 2. ÁªôÂÆö \(l, r, k\)Ôºå\(1 \le k \le d\)ÔºåÊ±Ç \(\sum_{i=l}^r q[k][i]\cdot a[i]\) Ëøô‰∏™ÂΩ¢ÂºèÁöÑÈóÆÈ¢òÂú®‰∏Ä‰∏ãÊØîËæÉÂ§çÊùÇÁöÑÊ†ë‰∏äÈóÆÈ¢òÁöÑÁª¥Êä§‰∏≠ÂæàÂ∏∏ËßÅ„ÄÇÂ§ßÈÉ®ÂàÜËøôÊ†∑ÁöÑÈóÆÈ¢ò‰∏≠ÈÉΩÊúâ \(c = 1\) Êàñ \(d = 1\)„ÄÇ Êàë‰ª¨ÂÖàÊù•ÂÆö‰πâ‰∏ÄÊ£µÁª¥Êä§‰∏Ä‰∏™ \(a\) Êï∞ÁªÑÔºåÊîØÊåÅÂΩ¢Â¶Ç \(l,r,x\)ÔºåÊääÊâÄÊúâ \(l \le i\le r\) ÁöÑ \(a[i]\) ÊîπÊàê \(a[i] + x \cdot k[i]\) (\(k\) ÊòØ‰∏Ä‰∏™È¢ÑÂÖàÁ°ÆÂÆöÁöÑÊï∞ÁªÑ) ÁöÑÊìç‰ΩúÁöÑÁ∫øÊÆµÊ†ë„ÄÇÂè™Ë¶ÅËÆ∞ÂΩï‰∏Ä‰∏ãÊØè‰∏™Á∫øÊÆµÊ†ë‰∏äÁÇπÂØπÂ∫îÂå∫Èó¥ÂÜÖ \(k\) ÁöÑÂíåÂ∞±ÂæàÂÆπÊòìÊâìÊâì tag ÂÆûÁé∞ÔºåË∑ëËµ∑Êù•ÊïàÁéáÂíåÊôÆÈÄöÁ∫øÊÆµÊ†ëÊ≤°Êúâ‰ªÄ‰πàÂå∫Âà´„ÄÇÊàë‰∏ÄËà¨ÊòØËøôÊ†∑ÂÆûÁé∞ÁöÑÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct segTree &#123; ll k[maxn], iv[maxn], sk[maxn &lt;&lt; 2], sum[maxn &lt;&lt; 2], add[maxn &lt;&lt; 2]; void build(int l, int r, int rt) &#123; if (l == r) &#123; sk[rt] = k[l]; sum[rt] = iv[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); sk[rt] = sk[rt&lt;&lt;1] + sk[rt&lt;&lt;1|1]; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void modify(int rt, ll v) &#123; add[rt] += v; sum[rt] += sk[rt] * v; &#125; void pushDown(int rt) &#123; if (add[rt]) &#123; modify(rt&lt;&lt;1, add[rt]); modify(rt&lt;&lt;1|1, add[rt]); add[rt] = 0; &#125; &#125; void upd(int p, ll v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] += sk[rt] * v; return; &#125; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) &#123; upd(p, v, l, m, rt&lt;&lt;1); &#125; else &#123; upd(p, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; void upd(int L, int R, ll v, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify(rt, v); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) &#123; upd(L, R, v, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; upd(L, R, v, m+1, r, rt&lt;&lt;1|1); &#125; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; &#125; ll qry(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; ll ret = 0; if (L &lt;= m) &#123; ret += qry(L, R, l, m, rt&lt;&lt;1); &#125; if (R &gt; m) &#123; ret += qry(L, R, m+1, r, rt&lt;&lt;1|1); &#125; return ret; &#125;&#125;; ÂÖ∂‰∏≠ \(iv\) Êï∞ÁªÑÊòØ \(a\) ÁöÑÂàùÂßãÂÄº„ÄÇ ‰∏ãÈù¢ÁªôÂá∫‰∏Ä‰∏™ÈúÄË¶ÅÂºÄ \(c\cdot d\) Ê£µÁ∫øÊÆµÊ†ëÁöÑÂÆûÁé∞ÔºöÂØπÊØè‰∏™ \(1 \le x \le c, 1\le y \le d\)ÔºåÂºÄ‰∏ÄÊ£µÁ∫øÊÆµÊ†ë \((x,y)\)ÔºåÁª¥Êä§ÁöÑÊï∞ÁªÑÂç≥‰πãÂâçÂÆö‰πâÁöÑ \(a\) Êï∞ÁªÑÔºå\(k[i] = p[x][i]\cdot q[y][i]\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™ËØ¢ÈóÆ \(l,r,y\)ÔºåÊàë‰ª¨Â∞±ÂØπÊØè‰∏™ \(x\)ÔºåÂú®Á∫øÊÆµÊ†ë \((x,y)\) ‰∏äËØ¢ÈóÆÂå∫Èó¥ \(l,r\)ÔºåÊääÂæóÂà∞ÁöÑÁªìÊûúÂä†Ëµ∑Êù•„ÄÇËøôÊ†∑Âú®Â§ÑÁêÜ‰∏Ä‰∏™‰øÆÊîπ \(l,r,x,a\) ÁöÑÊó∂ÂÄôÔºåÂè™Ë¶ÅÂØπÊØè‰∏™ \(1 \le y \le d\) ÈÉΩÂú®Á∫øÊÆµÊ†ë \((x,y)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>ËÉ°Ë®Ä‰π±ËØ≠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2504] „Äå2018 ÈõÜËÆ≠Èòü‰∫íÊµã Day 5„ÄçÂ∞è H Áà±ÊüìËâ≤]]></title>
    <url>%2F2020%2F05%2F12%2Floj2504%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÁºñÂè∑ÁúãÊàê \(1 \ldots n\) Ë∞É‰∫ÜÂ∑®‰πÖÔºåÊàëÂ§ßÊ¶ÇÊ≤°Êïë‰∫Ü„ÄÇ ÊòæÁÑ∂ÁºñÂè∑ÊúÄÂ∞èÈªëÁêÉÁºñÂè∑‰∏∫ \(k\) ÁöÑÊñπÊ°àÊúâ \(\binom{n-k+1}m^2 - \binom {n-k}m^2\) Áßç„ÄÇ Á≠îÊ°à‰∏∫ \[ \sum_{k = 0}^{n-1} (\binom{n-k}m^2 - \binom {n-k-1}m^2) F(k) \] Ê≥®ÊÑèÂà∞ \((\binom{n-k}m^2 - \binom {n-k-1}m^2) F(k)\) ÊòØ‰∏Ä‰∏™ÂÖ≥‰∫é \(k\) ÁöÑ \(3m\) Ê¨°Â§öÈ°πÂºèÔºåÊàë‰ª¨Ë¶ÅÊ±ÇËøô‰∏™Â§öÈ°πÂºèÁöÑ‰∏Ä‰∏™ÂâçÁºÄÂíåÔºåËøô‰∏™Â§öÈ°πÂºèÁöÑÂâçÁºÄÂíåÊòØ‰∏Ä‰∏™ \(3m+1\) Ê¨°Â§öÈ°πÂºèÔºåËÆæÂÆÉ‰∏∫ \(G(k)\)„ÄÇÂ¶ÇÊûúÊàë‰ª¨Áü•ÈÅì \(F(0) \ldots F(3m+1)\) Â∞±ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞ÂæóÂà∞ \(G(0) \ldots G(3m+1)\)ÔºåÁÑ∂ÂêéÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂæóÂà∞ \(G(n-1)\)„ÄÇ ‰ΩÜÊòØÊàë‰ª¨Âè™Áü•ÈÅì \(F(0) \ldots F(m)\)„ÄÇËÄÉËôëÂ¶Ç‰ΩïËÆ°ÁÆó \(F(m+1) \ldots F(3m+1)\)„ÄÇ \[ F(x) = \sum_{i=0}^m F(i) \prod_{j \neq i, 0 \le j\le m} \frac{x-j}{i-j} \\\\ \text{ÂØπ‰∫é $m &lt; x \le 3m+1$} \\\\ F(x) = \sum_{i=0}^m F(i) \frac {(-1)^{m-i}x^{\underline{m+1}}} {(x-i)i!(m-i)!}=x^{\underline{m+1}} \sum_{i=0}^m F(i)\frac{(-1)^{m-i}}{i!(m-i)!} \frac 1 {x-i} \] ËøôÂèØ‰ª•Áî® NTT ‰ºòÂåñÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(m \log m)\)„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6363] „ÄåÂú∞Â∫ïËî∑Ëñá„Äç]]></title>
    <url>%2F2020%2F05%2F11%2Floj6363%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(A(x) = \sum_k a_k\frac{x^k}{k!}\)ÔºåÁÇπÂèåËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(B(x) = \sum_{k} b_k \frac{x^k}{k!}\) (Âùá‰∏çÂê´Á©∫ÂõæÔºå‰∏Ä‰∏™ÁÇπ‰∏çÁÆóÁÇπÂèåËøûÈÄöÂõæ) Âàô \[ A(x) = x\sum_{k \ge 0} \frac{(\sum_{s \ge 2} A(x)^{s-1}\frac {b_s} {(s-1)!})^k}{k!} = x \exp(B&#39;(A(x))) \\\\ B&#39;(A(x)) = \ln(\frac {A(x)} x) \] Áî®ÊãâÊ†ºÊúóÊó•ÂèçÊºîÊ±Ç \([x^n]B(x)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)Ôºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ \(i \in S\) ‰ª• \(\mathcal O(i \log i)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ËÆ°ÁÆó \([x^i]B(i)\)ÔºåÁÑ∂Âêé‰ªÖ‰øùÁïôËøô‰∫õÈ°πÂæóÂà∞‰∏Ä‰∏™È¢òÁõÆÂÖÅËÆ∏ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁîüÊàêÂáΩÊï∞ \(C(x)\)„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÂ§ßÂ∞èÈÉΩÂú® \(S\) ÂÜÖÁöÑÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ \(D(x)\) (‰∏ãÈù¢Áî® \(D(x)^{-1}\) Ë°®Á§∫ \(D(x)\) ÁöÑÂ§çÂêàÈÄÜ) : \[ C&#39;(D(x)) = \ln(\frac {D(x)} x) \\\\ C&#39;(x) = \ln (\frac {x}{D(x)^{-1}}) \\\\ D(x)^{-1} = \frac x {\exp C&#39;(x)} \] ÊâÄ‰ª• \(D(x)\) ÊòØ \(\frac x {\exp C&#39;(x)}\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O((n + \sum_{x \in S} x) \log n)\) ‰∏•ÈáçÂç°Â∏∏„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wn[100];int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpow(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;int w[maxn * 8];unsigned long long _a[maxn * 8];void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) _a[rev[i]] = a[i]; int _ = 0; for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int _wn = wn[++ _]; w[0] = 1; for (int i = 1; i &lt; len; i++) &#123; w[i] = 1LL * w[i-1] * _wn % mod; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; unsigned long long v1 = _a[i+j], v2 = _a[i+j+(len&gt;&gt;1)]*w[j]%mod; _a[i+j] = v1 + v2; _a[i+j+(len &gt;&gt; 1)] = v1 + mod - v2; &#125; &#125; if (len == (1 &lt;&lt; 15)) &#123; for (int j = 0; j &lt; (1&lt;&lt;l); j++) &#123; _a[j] = _a[j] % mod; &#125; &#125; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i++) &#123; a[i] = _a[i] % mod; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;poly A, lnA, dlnA;int ok[maxn], fac[maxn], ifac[maxn];void init(int n) &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly tmp(n + 2); for (int i = 0; i &lt;= n + 1; i++) &#123; tmp.a[i] = 1LL * ifac[i] * qpow(2, 1LL * i * (i - 1) / 2) % mod; &#125; poly lnt = polyLn(tmp); A = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; A.a[i] = 1LL * (i + 1) * lnt.a[i + 1] % mod; &#125; lnA = polyLn(A); dlnA = poly(n); for (int i = 0; i &lt; n; i++) &#123; dlnA.a[i] = 1LL * (i + 1) * lnA.a[i + 1] % mod; &#125;&#125;int cal(int n) &#123; poly nA(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nA.a[i] = 1LL * lnA.a[i] * (mod - n) % mod; &#125; poly T = polyExp(nA) * dlnA; return 1LL * qpow(n, mod-2) % mod * T.a[n - 1] % mod;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); ok[x] = 1; &#125; for (int i = 0; i &lt;= 20; i++) wn[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); init(n); poly dC(n + 1); for (int i = 0; i &lt;= n; i++) &#123; if (ok[i + 1]) &#123; dC.a[i] = cal(i); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; dC.a[i] = 1LL * dC.a[i] * n % mod; &#125; poly t = polyExp(dC); int ans = 1LL * t.a[n - 1] * fac[n - 1] % mod * qpow(n, mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÁõ∏ÂÖ≥ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F11%2FLagrange%2F</url>
    <content type="text"><![CDATA[ÊäÄÂ∑ß ÊèèËø∞ÊñπÂºè Â∞ΩÈáè‰ΩøÁî®Â§çÂêàÈÄÜÁöÑÊ¶ÇÂøµÊù•ÊèèËø∞ÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºåËøôÊ†∑ÂèØ‰ª•ÁúÅÂéªÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ ÂÆö‰πâËÆ∞Âè∑ \(F(x)^{-1}\) Ë°®Á§∫ \(F(x)\) ÁöÑÂ§çÂêàÈÄÜ (Ê≥®ÊÑè‰∏çË¶Å‰∏éÂÄíÊï∞Ê∑∑Ê∑Ü)Ôºå‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÊãâÊ†ºÊúóÊó•ÂèçÊºîÂÖ¨ÂºèÂèØ‰ª•Ë°®Á§∫‰∏∫ \[ [x^n]F(x)^{-1} = \frac 1 n[x^{-1}] \frac 1 {F^n(x)} \\\\ [x^n]G(F(x)^{-1}) = \frac 1 n [x^{-1}] \frac{G&#39;(x)}{F^n(x)} \] ÈÄöËøá‰∏éÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÂá†‰πéÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑËØÅÊòéÊñπÊ≥ïÂèØ‰ª•ËØÅÊòéÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÁöÑ‰∏Ä‰∏™Êâ©Â±ïÔºöËã• \(F(G(x)) = H(x)\)ÔºåÂàô \([x^n]F(x) = \frac 1 n [x^{-1}] \frac{H&#39;(x)}{G^n(x)}\)„ÄÇÁ¨¨‰∫å‰∏™ÂºèÂ≠ê‰∏éËøô‰∏ÄÁªìËÆ∫ÊòØÁ≠â‰ª∑ÁöÑÔºå‰ΩÜÊòØÂª∫ËÆÆÂ∞ΩÂèØËÉΩ‰ΩøÁî®Á¨¨‰∫å‰∏™ÂºèÂ≠êËÄå‰∏çË¶Å‰ΩøÁî®Ëøô‰∏™ÁªìËÆ∫„ÄÇ Êé®ÂØºÊäÄÂ∑ß Èô§‰∫ÜÁßªÈ°πÁ≠âÂèòÂΩ¢‰πãÂ§ñÔºåËøòÂèØ‰ª•Âà©Áî®Â§çÂêàËøõË°åÂåñÁÆÄ„ÄÇÁî®Â§çÂêàÂåñÁÆÄÊó∂Ê≥®ÊÑèË¶ÅÁÅµÊ¥ª‰ΩøÁî®Â∑¶Âè≥ÈÄÜÔºåÂç≥ÁÅµÊ¥ª‰ΩøÁî® \(A(x) = B(x) \Rightarrow F(A(x))= F(B(x))\) Âíå \(A(x) = B(x) \Rightarrow A(F(x)) = B(F(x))\)ÔºåÈÅøÂÖç‰∏ÄÁõ¥Âè™ÊÉ≥Âà∞ÂÖ∂‰∏≠‰∏ÄÁßçÁöÑÊÉÖÂÜµ„ÄÇ ÂØπ‰∫é \(F(G(x)) = H(x)\)ÔºåÁü• \(H(x), F(x)\) Ê±Ç \([x^n] G(x)\) ÁöÑÊÉÖÂÜµÔºåÁõÆÂâçÊöÇ‰∏çÁü•Êúâ‰ªÄ‰πàÂ•ΩÁöÑÂÅöÊ≥ïÔºå‰ΩÜÊòØÂØπ‰∫é‰∏Ä‰∫õ \(H(x)\) ‰∏é \(G(x)\) ÊúâËæÉ‰∏∫ÁÆÄÂçïÁöÑÂÖ≥Á≥ªÁöÑÈóÆÈ¢òÊòØÂèØÂÅöÁöÑ„ÄÇ ‰æãÂ¶Ç \(F(G(x)) = xG(x) \Rightarrow F(G(G(x)^{-1})) = G^{-1}(x)G(G(x)^{-1}) \Rightarrow F(x) = x G(x)^{-1}\)ÔºåÂç≥ \(G\) ÊòØ \(\frac {F(x)} x\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5827] ÁÇπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F11%2FLuogu5827%2F</url>
    <content type="text"><![CDATA[ÂàöÂºÄÂßã‰ª•‰∏∫ÂíåËæπÂèåÊ≤°Âï•Â∑ÆÂà´..ÁªìÊûúÂêéÊù•Êêû‰∫ÜÂ•Ω‰πÖ„ÄÇ UPDÔºöÂ•ΩÂÉèÂ≠òÂú®Êõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ï„ÄÇ ÂÅöÊ≥ï ËÆæ \(n\) ‰∏™ÁÇπÁöÑÁÇπÂèåËøûÈÄöÂõæÊúâ \(f_n\) ‰∏™ÔºåËøûÈÄöÂõæÊúâ \(g_n\) ‰∏™ÔºåÂÆÉ‰ª¨ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÈí¶ÂÆöÊ†π) Êàë‰ª¨ËÆ§‰∏∫‰∏Ä‰∏™ÁÇπÁöÑÂõæ‰∏çÁÇπÂèåËøûÈÄöÔºå‰∏îËøô‰∏Ä‰∏™ÁÇπ‰∏∫Ââ≤ÁÇπ„ÄÇÁî±‰∫éÈ¢òÁõÆÈáå‰∏Ä‰∏™ÁÇπÊòØÁÆóÁÇπÂèåËøûÈÄöÂõæÁöÑÔºåË¶ÅÁâπÂà§‰∏ã„ÄÇ ËÆæ \(n\) ‰∏™ÁÇπÁöÑÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæ‰∏™Êï∞‰∏∫ \(b_n\)ÔºåÂÖ∂ EGF ‰∏∫ \(B(x)\)„ÄÇÊ†πÊçÆÂâ≤ÁÇπÁöÑÂÆö‰πâÔºåÂéªÊéâÊ†π‰πãÂêéÁöÑÁÇπÊûÑÊàê‰∏Ä‰∏™ËøûÈÄöÂõæÔºåÊâÄ‰ª• \(b_n = \frac n {n!}(2^{n-1}-1)(n-1)!g_{n-1}=(2^{n-1}-1)g_{n-1}\ (n \ge 2)\)„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåÂåÖÂê´‰∏çÊòØÂâ≤ÁÇπÁöÑÁÇπÁöÑÁÇπÂèåÊòØÂîØ‰∏ÄÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Êûö‰∏æÂåÖÂê´Ê†πÁöÑÁÇπÂèåÁöÑÂ§ßÂ∞èÊù•ËÆ°ÁÆó \(B(x)\)„ÄÇËÆæ \(H(x) = G&#39;(x)\) (ÂØπ EGF Ê±ÇÂØºÁõ∏ÂΩì‰∫éÂπ≥Áßª‰∫Ü)ÔºåÂåÖÂê´Ê†πÁöÑÁÇπÂèåÂ§ßÂ∞è‰∏∫ \(n\) ‰∏îÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(n\frac{f_n}{n!}x^n H^{n-1}(x)\) (ËÄÉËôëÂÜ≥ÂÆöÊ†πÔºåÁÑ∂ÂêéÂÜ≥ÂÆöËøô‰∏™ÁÇπÂèå‰∏≠Èô§‰∫ÜÊ†π‰ª•Â§ñÊØè‰∏™ÁÇπÊåÇÁöÑËøûÈÄöÂõæ)„ÄÇ ËÆæ \(C(x) = \frac{B(x)}x\)ÔºåÂàô \[ B(x) = \sum_{n \ge 1} n\frac{f_n}{n!} x^n H^{n-1}(x) = xF&#39;(xH(x)) \\\\ xC(x) = xF&#39;(xH(x)) \\\\ C(x) = F&#39;(xH(x)) \] ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \[ [x^n] F(x) = \frac 1 n[x^{n-1}] F&#39;(x)=\frac 1 {n(n-1)}[x^{-1}]\frac{C&#39;(x)}{(xH(x))^{n-1}} \] ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; const int N = 100000; poly tmp(N + 1); for (int i = 0; i &lt;= N; i++) &#123; tmp.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnT = polyLn(tmp); poly G(N + 1); for (int i = 1; i &lt;= N; i++) &#123; // G.a[i] = 1LL * lnT.a[i] * i % mod; G.a[i] = lnT.a[i]; &#125; poly H(N); for (int i = 0; i &lt; N; i++) &#123; H.a[i] = 1LL * (i + 1) * G.a[i+1] % mod; &#125; poly B(N+1); int _ = 1; for (int i = 1; i &lt;= N; i++) &#123; B.a[i] = 1LL * (_ - 1) * G.a[i-1] % mod; _ = 1LL * _ * 2 % mod; &#125; poly C(N); for (int i = 0; i &lt; N; i++) &#123; C.a[i] = B.a[i+1]; &#125; poly lnH = polyLn(H); poly dC(N-1); for (int i = 0; i &lt; N-1; i++) &#123; dC.a[i] = 1LL * C.a[i+1] * (i+1) % mod; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); if (n == 1) &#123; puts("1"); continue; &#125; poly nH = poly(n); for (int i = 0; i &lt; n; i++) &#123; nH.a[i] = 1LL * lnH.a[i] * (mod - (n - 1)) % mod; &#125; poly res = polyExp(nH) * dC; int ans = 1LL * res.a[n - 2] * qpow(n - 1, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5828] ËæπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F10%2FLuogu5828%2F</url>
    <content type="text"><![CDATA[‰πãÂâçËØïÂõæÈÄöËøáÁî®Ê†ëÁöÑÁîüÊàêÂáΩÊï∞Â§çÂêàËæπÂèåÁöÑÁîüÊàêÂáΩÊï∞Êù•ÂæóÂà∞Á≠îÊ°à...‰ΩÜÊòØÈóÆÈ¢ò‰ºº‰πéÁ≠â‰ª∑‰∫éÂ∑≤Áü• \(F(x), H(x)\)Ôºå\(F(G(x)) = H(x)\)ÔºåÊ±Ç \([x^n] G(x)\)„ÄÇÊàë‰∏çÊòØÂæà‰ºöÔºåÂ¶ÇÊûúÊúâ‰∫∫‰ºöÁöÑËØùÊ±ÇÊïôÊàë‰∏Ä‰∏ã /kel„ÄÇ ‰∏ãÈù¢ÂÜôÁöÑÊòØÈ¢òËß£ÂÅöÊ≥ï„ÄÇ UPDÔºöÊ†ëÁöÑÁîüÊàêÂáΩÊï∞ÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁúãÂÅö‰∏Ä‰∏™ÊãâÊ†ºÊúóÊó•ÂèçÊºîÁöÑÁªìÊûú..ÊâÄ‰ª•ÊÑüÊÄßÁêÜËß£‰∏Ä‰∏ãÂèØ‰ª•ÁªïËøá‰∏äÈù¢ÈÇ£‰∏™ÂºèÂ≠êÊòØ‰∏Ä‰∏™ÂæàËá™ÁÑ∂ÁöÑ‰∏úË•ø„ÄÇ(Á∫ØÂ±ûËÉ°Ë®Ä‰π±ËØ≠) ÂÅöÊ≥ï ËÆæÊúâÊ†πËæπÂèåÂíåÊúâÊ†πËøûÈÄöÂõæ (ÊúâÊ†πÂ∞±ÊòØÈí¶ÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπ‰ΩúÊ†π) ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÂåÖÂê´Á©∫Âõæ) ‰ºóÊâÄÂë®Áü•ÔºåËÆæÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(H(x)\)ÔºåÂàôËøûÈÄöÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(\ln H(x)\)ÔºåÊâÄ‰ª• \(G(x) = \frac {xH&#39;(x)} {H(x)}\) (‰∏çÁî®ÁúüÁöÑÊåâÁÖßËøô‰∏™ÂºèÂ≠êÂéªÁÆóÔºåÂ∞±ÊòØÁ¨¨ \(i\) È°π‰πò‰ª• \(i\) ÁöÑÊÑèÊÄù)„ÄÇ ËÄÉËôëÊ†πÊâÄÂú®ÁöÑËæπÂèåÊÅ∞Â•Ω‰∏∫ \(n\) ÁöÑËøûÈÄöÂõæÊï∞ÔºåËøôÊ†∑ÁöÑËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ÊòØ \(x^n f_n \sum_k n^k \frac{G^k(x)}{k!}=x^nf_n\exp(nG(x))\)„ÄÇ ÊâÄ‰ª•Êúâ \(G(x) = \sum_{n \ge 1} f_n (x\exp G(x))^n=F(x\exp G(x))\)„ÄÇ ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \([x^n] F(x) = \frac 1 n[x^{-1}]\frac {G&#39;(x)}{(x\exp G(x))^n}\) ÊàëÈÄâÊã©Ë¥¥Êùø üíäüíäüíä ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; poly G, dG; &#123; int n = 100000; poly H(n + 1); for (int i = 0; i &lt;= n; i++) &#123; H.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnH = polyLn(H); G = poly(n + 1); for (int i = 1; i &lt;= n; i++) &#123; G.a[i] = 1LL * lnH.a[i] * i % mod; &#125; dG = poly(n); for (int i = 0; i &lt; n; i++) &#123; dG.a[i] = 1LL * G.a[i+1] * (i+1) % mod; &#125; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); poly nG = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nG.a[i] = 1LL * G.a[i] * (mod - n) % mod; &#125; poly res = polyExp(nG) * dG; int ans = 1LL * res.a[n-1] * qpow(n, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3684] Â§ßÊúãÂèãÂíåÂ§öÂèâÊ†ë]]></title>
    <url>%2F2020%2F05%2F10%2Fbzoj3684%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÁÇπÊùÉ‰∏∫ \(k\) ÁöÑÊ†ëÊúâ \(a_k\) Ê£µÔºåËÆæ \(A(x) = \sum_{i\ge 1} a_i x^i\) ËÆæ \(D(x) = \sum x^{d_i}\) Êúâ \(A(x) = D(A(x)) + x\)„ÄÇËÆæ \(C(x) = x - D(x)\)ÔºåÂàô \(C(A(x)) = x\) ÂÖ∂‰∏≠ \(C\) Âíå \(A\) ÈÉΩÊòØÊ≤°ÊúâÂ∏∏Êï∞È°π‰∏î‰∏ÄÊ¨°È°π‰∏∫ \(1\) ÁöÑÂ§öÈ°πÂºè„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \([x^s] A(x)\)Ôºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºö\([x^s] A(x) = \frac 1 s [x^{-1}] \frac 1 {C^s(x)}\) ËÆæ \(C(x) = xP(x)\)ÔºåÂàô \([x^s]A(x) = \frac 1 s [x^{s-1}] \frac 1 {P^s(x)}\) Ê±Ç‰∏™ÈÄÜÁÑ∂ÂêéÂ§öÈ°πÂºèÂø´ÈÄüÂπÇ‰∏Ä‰∏ãÂç≥ÂèØÔºå‰πüÂèØ‰ª•ÂÖà \(\ln\) ÂÜç \(\exp\)„ÄÇ BZOJ ‰∏äÂø´ÈÄüÂπÇ T ‰∫ÜÔºå‰ΩÜÊòØË¥¥‰∫Ü‰∏™ÊùøÂ≠êÊîπÊàê \(\ln\) + \(\exp\) Â∞±Ëøá‰∫ÜÔºåÁúã‰∫ÜÁ°ÆÂÆûÊòØÊØîÂø´ÈÄüÂπÇÂø´ÁöÑ„ÄÇ (BZOJ Á°ÆÂÆûÂ§™ÊÖ¢‰∫Ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 950009857;const int maxn = 100010;int g = 0;int s, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int wl[21];vector&lt;int&gt; vp;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int checkg(int g) &#123; int ok = 1; for (int i = 0; i &lt; vp.size(); i++) &#123; int p = vp[i]; if (qpow(g, (mod - 1) / p) == 1) &#123; ok = 0; &#125; &#125; return ok;&#125;struct poly &#123; int *a, len; poly (int len_=0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int _wl = wl[++ _]; for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = mo(v1 + v2); a[s + i + (len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL * w * _wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * inv * a[i] % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l - i]); &#125; &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int _l = 0; while ((1 &lt;&lt; _l) &lt; ret.len) &#123; ++ _l; &#125; int l = (1 &lt;&lt; _l); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, _l, 1), ntt(wb, _l, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, _l, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly qpow(poly p, int x) &#123; int l = p.len; poly ret(1); ret.a[0] = 1; while (x) &#123; if (x &amp; 1) &#123; ret = ret * p; ret.len = l; &#125; x &gt;&gt;= 1; p = p * p; p.len = l; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0 (tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; v0.a[0] = (v0.a[0] + mod - 2) % mod; for (int i = 0; i &lt; p.len; i++) &#123; v0.a[i] = (mod - v0.a[i]) % mod; &#125; v0.len = p.len; poly v1 = v0 * r0; v1.len = p.len; return v1;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;int main() &#123; &#123; int _ = mod - 1; for (int i = 2; i * i &lt;= _; i++) &#123; if (_ % i == 0) &#123; vp.push_back(i); while (_ % i == 0) &#123; _ /= i; &#125; &#125; &#125; if (_ &gt; 1) &#123; vp.push_back(_); &#125; for (int i = 2; i &lt;= mod; i++) &#123; if (checkg(i)) &#123; g = i; break; &#125; &#125; &#125; for (int i = 0; i &lt;= 20; i++) &#123; wl[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; scanf("%d%d", &amp;s, &amp;m); poly P(s); for (int i = 1; i &lt;= m; i++) &#123; int x = 0; scanf("%d", &amp;x); P.a[x - 1] = mod - 1; &#125; P.a[0] = 1; poly lnP = polyLn(P); int t = (mod - s) % mod; for (int i = 0; i &lt; lnP.len; i++) &#123; lnP.a[i] = 1LL * lnP.a[i] * t % mod; &#125; poly res = polyExp(lnP); int ans = 1LL * qpow(s, mod-2) * res.a[s-1] % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(C(x) = \sum x^{c_i}\)Ôºå\(a_i\) ÊòØÊùÉÂÄºÂíå‰∏∫ \(i\) ÁöÑ‰∫åÂèâÊ†ëÊï∞Èáè (ÁâπÂà´Âú∞ÔºåÁ©∫‰∫åÂèâÊ†ëÁÆó‰Ωú‰∏ÄÁßçÊùÉÂÄºÂíå‰∏∫ \(0\) ÁöÑ‰∫åÂèâÊ†ë)Ôºå\(A(x) = \sum_{i \ge 0} a_ix^i\)„ÄÇ Âàô \(A(x) = A^2(x)C(x)+ 1\)Ôºå\(C(x)A^2(x)-A(x)+1=0\)„ÄÇÁî±‰∏ÄÂÖÉ‰∫åÊ¨°ÊñπÁ®ãÊ±ÇÊ†πÂÖ¨ÂºèÂæó \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)ÔºåÁî±‰∫éÂàÜÊØçÊ≤°ÊúâÂ∏∏Êï∞È°πÔºåËøôÈáåÂ∫îËØ•ÂèñË¥üÂè∑„ÄÇ ‰∫éÊòØÂ§öÈ°πÂºèÂºÄÊ†π‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇ(Âõ†‰∏∫ \([x^0] (1-4C(x)) = 1\)ÔºåÂè™Â≠òÂú®‰∏§‰∏™ÁöÑÂ§öÈ°πÂºè \(F(x)\) Êª°Ë∂≥ \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)Ôºå‰∏ÄÊ≠£‰∏ÄË¥ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[Á•û‰ªôÈ¢òÔºå‰πãÂâçÂê¨‰∫∫ÊèêËøá„ÄÇ‰ΩÜÊòØÂá∏ÊÄßÂÆåÂÖ®‰∏ç‰ºöËØÅÔºå‰ºö‰∫Ü‰πãÂêéË°•‰∏ä QwQ„ÄÇ ÂÅöÊ≥ï ÊòæÁÑ∂‰Ωø \(\sum s_i^2\) ÂèñÂà∞ÊúÄÂ∞èÂÄºÁöÑÂàíÂàÜ‰∏ÄÂÆöÊª°Ë∂≥Êù°‰ª∂„ÄÇ ÊâÄ‰ª•‰∫åÂàÜÊñúÁéáÊ±ÇÂá∫ \(\sum s_i^2\) ÊúÄÂ∞èÁöÑÂ∫èÂàóÂ∞±Ë°å‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éÊàëÊ∞¥Âπ≥Â§™‰ΩéÊôÆÂèäÁªÑÁü•ËØÜÁÇπÈÉΩÊ≤°ÊéåÊè°Ôºå‰ªäÂ§©Áªà‰∫éÊêûÊáÇ‰∫Ü‰∏ÄÁÇπÊâÄ‰ª•ÊâìÁÆóËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢ËÆ®ËÆ∫ÁöÑÈÉΩÊòØÊó†ÂêëÂõæÔºåÁî±‰∫éËøûÈÄöÂùóÈó¥Áã¨Á´ãÔºåÊàë‰ª¨Âè™ËÄÉËôëËøûÈÄöÂõæÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûúÁÇπÊï∞‰∏∫ \(1\)ÔºåÂú®Êüê‰∫õÈóÆÈ¢ò‰∏ãÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Âè™ËÄÉËôëÁÇπÊï∞‰∏ç‰∏∫ \(1\) ÁöÑÊÉÖÂÜµ„ÄÇ ÂÆö‰πâ 1 ÂØπ‰∫é‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\)ÔºåÂ¶ÇÊûú‰ªé \(G\) Âà†ÂéªÁÇπ \(u\) ÂíåÊâÄÊúâ‰∏éÂÆÉÁõ∏ÈÇªÁöÑËæπÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄöÔºåÂ∞±Áß∞ \(u\) ÊòØ \(G\) ÁöÑ‰∏Ä‰∏™Ââ≤ÁÇπ„ÄÇ ÂÆö‰πâ 2 Ëã•ËøûÈÄöÂõæ \(G\) ‰∏≠‰∏çÂ≠òÂú®Ââ≤ÁÇπÔºåÂàôÁß∞ \(G\) ÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂõæ„ÄÇ ÂÆö‰πâ 3 Áß∞ËøûÈÄöÂõæ \(G\) ÁöÑÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂõæÂ≠êÂõæ‰∏∫ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇ ÊÄßË¥® 1 ‰∏§‰∏™‰∏çÂêåÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑ‰∫§Ëá≥Â§öÂåÖÂê´‰∏Ä‰∏™ÁÇπ„ÄÇ ËØÅÊòé ÂÅáËÆæ‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè \(A\) Âíå \(B\) Êúâ‰∫§ÔºåËÆæËøô‰∏§‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂπ∂‰∏∫ \(H\)ÔºåÊ†πÊçÆÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂÆö‰πâÔºå\(H\) ‰∏ÄÂÆö‰∏çÊòØÁÇπÂèåËøûÈÄöÂõæÔºåÊâÄ‰ª•Â≠òÂú®‰∏Ä‰∏™ÁÇπ \(u\)Ôºå‰ªé \(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂêéÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄö„ÄÇ\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæÂç≥‰∏∫ \(A\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) Âíå \(B\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) ÂæóÂà∞ÁöÑÂõæÁöÑÂπ∂„ÄÇÂ¶ÇÊûú \(A\) Âíå \(B\) ÁöÑ‰∫§Â§ß‰∫é \(1\)ÔºåÁî±‰∫é‰∏§‰∏™Êúâ‰∫§ÁöÑËøûÈÄöÂõæÁöÑÂπ∂‰ªç‰∏∫ËøûÈÄöÂõæÔºå\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæ‰πüÊòØËøûÈÄöÂõæÔºåËøôÂ∞±ÂØºÂá∫‰∫ÜÁüõÁõæ„ÄÇ ÊÄßË¥® 2 Âú®‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\) ‰∏≠ÔºåÂØπ‰∫é‰ªªÊÑè‰∏ÄÊù°Ëæπ \(e\)ÔºåÊÅ∞Êúâ‰∏Ä‰∏™ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÂåÖÂê´Ëæπ \(e\)„ÄÇ ËØÅÊòé Ëæπ \(e\) ÁöÑ‰∏§‰∏™È°∂ÁÇπÁöÑÂØºÂá∫Â≠êÂõæÂ∞±ÊòØ‰∏Ä‰∏™ \(G\) ÁöÑÂ§ßÂ∞è‰∏∫ \(2\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª•‰πü‰∏ÄÂÆöÂ≠òÂú®ÂåÖÂê´Ëæπ \(e\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÁî±ÊÄßË¥® 1 ÂèØÁü•‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏çÂèØËÉΩÂåÖÂê´Âêå‰∏ÄÊù°Ëæπ„ÄÇ Áî±‰∫éÁÇπÂèåËøûÈÄöÂàÜÈáèÊòØËøûÈÄöÁöÑÔºåÂè™Ë¶ÅÁ°ÆÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâËæπÔºåÁÇπ‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÂõæ \(G\) ÁöÑÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÊûÑÊàêËæπÈõÜÁöÑ‰∏Ä‰∏™ÂàíÂàÜ„ÄÇ Âú®Âõæ‰∏ä‰Ωú DFSÔºåÂèñ‰∏ÄÊ£µ‰ª• \(r\) ‰∏∫Ê†πÁöÑ DFS Ê†ëÔºåËÆæÁÇπ \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´ËÆøÈóÆÊó∂Èó¥‰∏∫ \(dfn_u\)Ôºå\(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÈÄöËøá‰∏ÄÊù°ËøîÁ•ñËæπËÉΩÂ§üÂà∞ËææÁöÑ dfn ÊúÄÂ∞èÁöÑÁÇπÁöÑ dfn ‰∏é \(dfn_u\) ÁöÑÊúÄÂ∞èÂÄº‰∏∫ \(low_u\) (Ê≥®ÊÑèËøîÁ•ñËæπÊåáÁöÑÊòØÈùûÊ†ëËæπÔºå‰∏çÂåÖÂê´ \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÔºåÂÆûÁé∞Êó∂Ë¶ÅÁâπÂà§)„ÄÇ ËÆæÁÇπ \(u\) Âú®ËøôÊ£µ DFS Ê†ë‰∏äÁöÑÁà∂‰∫≤‰∏∫ \(fa(u)\)„ÄÇ ÂØπ‰∫éÁÇπ \(u \neq r, fa(u) \neq r\)ÔºåÂ¶ÇÊûú \(low_u &lt; dfn_{fa(u)}\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ÁÇπ \(u, fa(u), fa(fa(u))\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºå‰ªéËÄå \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÂíå \(fa(u)\) Âà∞Áà∂‰∫≤ÁöÑËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ Âú® DFS ÁöÑËøáÁ®ã‰∏≠ÔºåÊØèÁªèËøá‰∏ÄÊù°Ê†ëËæπÂ∞±ÊääËøôÊù°Ê†ëËæπÊîæÂÖ•‰∏Ä‰∏™Ê†à‰∏≠„ÄÇÂú®ÁÇπ \(u\) ÂõûÊ∫ØÊó∂ÔºåÊ£ÄÊü•‰∏Ä‰∏ãÊòØÂê¶Êúâ \(low_u \ge dfn_{fa(u)}\) (Â¶ÇÊûúÊòØÊ†πÁöÑËØù‰∏çÁî®Ê£ÄÊü•‰∫Ü)„ÄÇ ËÄÉËôëÁ¨¨‰∏ÄÊ¨°Êª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂõûÊ∫ØÔºåÊ≠§Êó∂ÁÇπ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπÈÉΩÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÔºåÂõ†Ê≠§Â≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæ„ÄÇÂõ†‰∏∫‰∏çÂ≠òÂú®Ë∑®Ëøá \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÁöÑÈùûÊ†ëËæπÔºåËøô‰∏™ÁÇπÂèåËøûÈÄöÂ≠êÂõæÊòØ‰∏Ä‰∏™ÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª• \(u\) ÁöÑÂ≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊàë‰ª¨ÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÁÇπ‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂Âêé‰ªéÊ†à‰∏≠ÂºπÂá∫ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπ„ÄÇ Âú®‰πãÂêéÁöÑÂõûÊ∫Ø‰∏≠ÔºåÂ¶ÇÊûúÊª°Ë∂≥ \(low_u \ge dfn_{fa(u)}\)ÔºåÈÇ£‰πàÊ≠§Êó∂Ê†à‰∏≠ÊâÄÊúâÊ†ëËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠Ôºå‰∏îËøô‰∫õËæπÁöÑÊâÄÊúâÁ´ØÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰øùÂ≠ò‰∏ãÊù•ÁÑ∂ÂêéÊääÊ†à‰∏≠ÊâÄÊúâ \(u\) Â≠êÊ†ë‰∏≠ÁöÑËæπÂºπÂá∫Âç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n+m)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫‰∫ÜÊØè‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁÇπÈõÜ„ÄÇ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑËæπÂ∞±ÊòØËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÂÜÖÈÉ®ÁöÑÊ†ëËæπÂä†‰∏äËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâÁÇπÁöÑËøîÁ•ñËæπÔºåËøôÂæàÂÆπÊòìÂ§ÑÁêÜ„ÄÇÔºàÊ≥®ÊÑèËøôÈáåËøîÁ•ñËæπÁöÑÂÆö‰πâÊòØ‰ªéÊüê‰∏™ÁÇπÂá∫ÂèëÂà∞ÂÆÉÁ•ñÂÖàÁöÑÈùûÊ†ëËæπÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÊØèÊù°ÈùûÊ†ëËæπÊòØÊÅ∞Â•Ω‰∏Ä‰∏™ÁÇπÁöÑËøîÁ•ñËæπÔºâ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏Ä‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°àÊï∞Á≠â‰∫éÂêÑ‰∏™ÁÇπÂèåÁöÑÊüìËâ≤ÊñπÊ°àÊï∞‰πòÁßØÈô§‰ª•È¢úËâ≤Êï∞ÁöÑ(ÁÇπÂèåÊï∞ - ËøûÈÄöÂùóÊï∞)Ê¨°ÊñπÔºàËÄÉËôëÂØπÊØè‰∏™ËøûÈÄöÂùóÂú®ÂúÜÊñπÊ†ë‰∏ä‰ªé‰∏äÂæÄ‰∏ãÂØπÊØè‰∏™ÁÇπÂèåÊüìËâ≤Ôºâ„ÄÇ Ê†πÊçÆÈ¢òÁõÆ‰∏≠ÁöÑÊù°‰ª∂Ôºå‰∏Ä‰∏™ÁÇπÂèåÁöÑÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøá \(7\)ÔºåÊö¥ÂäõÊûö‰∏æÈõÜÂêàÂàíÂàÜÂèØ‰ª•Ê±ÇÂá∫‰∏Ä‰∏™ÁÇπÂèåÁöÑËâ≤Â§öÈ°πÂºèÔºåÂàÜÊ≤ª fft ‰∏Ä‰∏ãÂç≥ÂèØÂæóÂà∞ÁªôÂÆöÁöÑÂõæÁöÑËâ≤Â§öÈ°πÂºèÔºåÁÑ∂ÂêéÂ§öÁÇπÊ±ÇÂÄº‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ (‰∏∫Âï•‰∏ÄÂÆöË¶ÅÁªôÂêÑÁßçÊüìËâ≤ÊñπÊ°àÊï∞È¢òÂ•ó‰∏™Â§öÁÇπÊ±ÇÂÄº...Â•ΩÊó†ËÅä) ÂÆåÂÖ®‰∏ç‰ºöÂÜôÁÇπÂèå..Ë∞É‰∫Ü‰∏ÄÂ§©„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// Á¨¨‰∏ÄÁ±ªÊñØÁâπÊûóÊï∞int S[10][10];// ‰∏ãÈôçÂπÇÁ≥ªÊï∞int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268E] Expected Value]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(f_i\) ÊòØÁ¨¨ \(i\) Ê≠•Êó∂ÊÅ∞Â•ΩÂà∞ËææÁÇπ \(n\) ÁöÑÊ¶ÇÁéáÔºåÊòæÁÑ∂Êï∞Âàó \(\{f_i\}\) Êª°Ë∂≥‰∏Ä‰∏™‰∏çË∂ÖËøá \(n\) Èò∂ÁöÑÁ∫øÊÄßÈÄíÊé®„ÄÇ Âõ†‰∏∫ÁªôÂÆöÁöÑÂõæÊòØÂπ≥Èù¢ÂõæÔºåÊâÄ‰ª• \(m = \mathcal O(n)\)ÔºåÊàë‰ª¨ÂèØ‰ª•Êö¥ÂäõÊ±ÇÂá∫ \(f\) ÁöÑÂâç \(2n\) È°πÔºåÁÑ∂Âêé BM Âá∫ÈÄíÊé®Âºè„ÄÇÂæóÂà∞ÈÄíÊé®Âºè‰πãÂêé‰πüÂ∞±ÂæóÂà∞‰∫ÜÁîüÊàêÂáΩÊï∞ÔºåÊ±Ç‰∏™ÂØºÊää \(x=1\) ‰ª£ÂÖ•Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[ÂêêÊßΩÔºöËøôÈ¢òÁõÆÂêçÂèñÁöÑ„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÂÅöÊ≥ï Ë¶ÅÊòØ‰∏çÊòØÈ¢ÑÂÖàÁü•ÈÅìÊòØ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖç‰º∞ËÆ°‰∏ÄÊòüÊúüÈÉΩÊÉ≥‰∏çÂà∞„ÄÇ„ÄÇ ËÄÉËôëÊûÑÈÄ†‰∏Ä‰∏™Êó†ÂêëÂõæÔºåÁÑ∂ÂêéÁî®‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖçÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ ÂØπÊØè‰∏™ . Âª∫‰∏Ä‰∏™ÁÇπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ +ÔºåÈÇ£‰πàÂª∫‰∏§‰∏™Êñ∞ÁöÑÁÇπÔºå‰∏§‰∏™Êñ∞ÁöÑÁÇπÈÉΩÂêëÂÆÉÂõõÂë®ÁöÑ . ÂØπÂ∫îÁöÑÁÇπËøûËæπÔºåÁÑ∂Âêé‰∏§‰∏™Êñ∞ÁÇπ‰πãÈó¥Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ *ÔºåÂª∫‰∏§‰∏™Êñ∞ÁÇπÔºå‰∏Ä‰∏™Âêë‰∏ä‰∏ãÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°ËæπÔºå‰∏Ä‰∏™ÂêëÂ∑¶Âè≥ÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°Ëæπ„ÄÇËøôÊ†∑Ëøô‰∏™ÂõæÁöÑÊúÄÂ§ßÂåπÈÖçÂáèÂéª * Âíå + ÁöÑ‰∏™Êï∞Â∞±ÊòØÁ≠îÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÁêÜËÆ∫ÂèØ‰ª•ÂÅöÂà∞ \(\mathcal O(n^2m^2)\)ÔºåÂèØËøá„ÄÇ ÁÑ∂ËÄåÊàëÂÜôÁöÑËøô‰∏™Â∏¶Ëä±Ê†ë‰ºº‰πéÊòØ‰∏âÊñπÁöÑÔºå‰ΩÜÂÆÉ‰πüËøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]„ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçtree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫é‰∏ÄÊù°ÈìæÔºåÂÅáËÆæÂÆÉ‰ªéÊüê‰∏ÄÁ´ØÂºÄÂßãÁ¨¨‰∏Ä‰∏™Â§ß‰∫é \(1\) ÁöÑÁÇπÁöÑÁÇπÊùÉ‰∏∫ \(x\)ÔºåËøô‰∏™ÁÇπ(ÂºÄÂßãÁöÑÈÇ£‰∏ÄÁ´ØÂà∞ÂÆÉ)‰πãÂâçÊúâ \(k\) ‰∏™ÁÇπÔºå‰πãÂêéÊúâ \(l\) ‰∏™ÁÇπÔºå‰πãÂêé \(l\) ‰∏™ÁÇπÁÇπÊùÉ‰πòÁßØ‰∏∫ \(s\)„ÄÇ ÂÅáËÆæËøôÊù°ÈìæÁöÑÁ≠îÊ°àÊØîËøô‰∏™ÁÇπÂ∑¶ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÂíåÂè≥ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÁöÑÁ≠îÊ°àÈÉΩË¶Å‰∏•Ê†º‰ºò„ÄÇ ÈÇ£‰πà \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] ÊâÄ‰ª• \(k = l\)„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰∏ÄÊù°ÈìæÊØîÂÆÉÁöÑÊâÄÊúâÂ≠êÈìæÈÉΩ‰∏•Ê†º‰ºòÔºå‰∏îËøôÊù°Èìæ‰∏äÂ≠òÂú®ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÔºåÈÇ£‰πà‰ªéÂÆÉ‰∏§Á´ØÂºÄÂßãÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÈÉΩÊòØ‰∏≠ÁÇπ„ÄÇ ÊâÄ‰ª•Âè™ÈúÄËÄÉËôëÂÖ® \(1\) ÈìæÂíå‰ª•Êüê‰∏™ÁÇπ‰∏∫‰∏≠ÁÇπÔºåÂÖ∂‰ªñÁÇπÈÉΩÊòØ \(1\) ÁöÑÈìæ„ÄÇ Êç¢Ê†π dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea Êï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[Â§™Á•û‰ªô‰∫ÜÔºåÁúã sol ‰∫Ü„ÄÇ ÂÅöÊ≥ï ÂÖàËßÑÂÆöÂΩì‰∏§‰∏™Áü≥Â≠êË∑ùÁ¶ª‰∏∫ \(1\) Êó∂Ôºå‰∏çËÉΩÁßªÂä®ÂùêÊ†áÂ∞èÁöÑÁü≥Â≠ê„ÄÇËøôÊ†∑Â∞±Âè™ÈúÄË¶ÅÂØπÊìç‰ΩúÂ∫èÂàóËÆ°Êï∞‰∫Ü„ÄÇ ËÄÉËôëÂØπÊúâ \(K\) ‰∏™ÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÊñπÊ°àËÆ°Êï∞„ÄÇ\(K = N\) ÁöÑÊÉÖÂÜµÂæàÂÆπÊòìÂçïÁã¨ËÄÉËôë„ÄÇ ÂØπ‰∫é \(K &lt; N\) ÁöÑÊÉÖÂÜµÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÁ°ÆÂÆö‰∫ÜÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÔºåËÄÉËôë‰∏Ä‰∏™Â∫èÂàó \(s\)ÔºåËã•Á¨¨ \(i\) ‰∏™ÊääÊüêÁü≥Â≠êÂùêÊ†á \(+1\) Êìç‰ΩúÁßªÂä®ÁöÑÊòØÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÔºå\(s_i = -1\)ÔºåÂê¶Âàô \(s_i = 1\)„ÄÇËøôÊ†∑ÁöÑ‰∏Ä‰∏™Â∫èÂàó \(s\) ÊòæÁÑ∂Êª°Ë∂≥ \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)„ÄÇÂØπ‰∫é‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂ∫èÂàó \(s\)ÔºåÊàë‰ª¨Êù•ËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊää‚ÄúÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂùêÊ†áÂ§ßÁöÑÁü≥Â≠êÁöÑ‰ΩçÁΩÆ‚ÄùÁöÑÊìç‰ΩúÊèíÂÖ•Âà∞Ëøô‰∏™ÔºàÂè™ÂåÖÂê´ÊääÊüêÁü≥Â≠êÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÔºâÊìç‰ΩúÂ∫èÂàó‰πã‰∏≠ÁöÑÊñπÊ°à„ÄÇÊòæÁÑ∂ \(s\) ‰∏≠Êúâ \(B\) ‰∏™ \(1\)Ôºå\(K-B\) ‰∏™ \(-1\)„ÄÇÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÊèíÂú® \(s_i\) ÂØπÂ∫îÁöÑÊìç‰ΩúÂíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥ÔºåÈÇ£‰πà \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)„ÄÇËÆæ \(t_i = \sum_{k \le i} s_k\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êìç‰ΩúË¢´ÊèíÂÖ•Âú® \(s_i\) Âíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥Ôºå‰∏îÂ≠òÂú® \(j &gt; i\)Ôºå\(t_j \le t_i\)ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∫èÂàó‰∏ÄÂÆö‰∏çÂêàÊ≥ï„ÄÇÊâÄ‰ª•ÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰Ωú‰∏ÄÂÆöÂú® \(t_i = B-(K-B)-(B-A)=B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥ÔºåÂÖ∂‰ªñÊìç‰ΩúÂøÖÈ°ªÊèíÂÖ•ÊúÄÂêé‰∏Ä‰∏™ \(t_i = x, x \le B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥Ôºå‰∏îÂè™Ë¶ÅÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÂæóÂà∞ÁöÑÂ∞±ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ‰∫éÊòØÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÊ±ÇÊää \(N-K-1\) ÊãÜÊàê \(B+A-K+1\) ‰∏™ÈùûË¥üÊï¥Êï∞‰πãÂíåÁöÑÊñπÊ°àÊï∞ÔºåËøôÂæàÂÆπÊòìÁî®‰∏Ä‰∏™ÁªÑÂêàÊï∞ËÆ°ÁÆó„ÄÇÊ≥®ÊÑèÂà∞ÂØπ‰∫é‰∏çÂêåÁöÑ \(s\)ÔºåÊèíÂÖ•Êìç‰ΩúÁöÑÊñπÊ°à‰πãÂíå \(K\) ÊúâÂÖ≥ÔºåÊâÄ‰ª•Êàë‰ª¨Êûö‰∏æ \(K\) ÁªüËÆ°Á≠îÊ°àÂç≥ÂèØ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂØπÂ∫îÁöÑ \(K\)ÔºåËÆ°ÁÆóÂØπÂ∫îÁöÑ \(s\) ÁöÑ‰∏™Êï∞ÊòØ‰∏Ä‰∏™Á±ª‰ººÂç°ÁâπÂÖ∞Êï∞ÁöÑÈóÆÈ¢òÔºå‰∏ç‰ºöÁöÑËØùÂèØ‰ª•ÂéªÁúãÁúã AGC021E„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ balancer \((x_i,y_i)\)ÔºåÂ∞±Âú®ÁÇπ \(x_i\) ÂíåÁÇπ \(y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Ê†áÂè∑‰∏∫ \(i\) ÁöÑÊó†ÂêëËæπ„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö\(T=1\) ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëÊâÄÊúâË¢´Áî®Ëøá balancerÔºåÂèØ‰ª•ÂèëÁé∞ÂÆÉ‰ª¨ÂØπÂ∫îÁöÑËæπÊûÑÊàêÁöÑÂ≠êÂõæ‰∏ÄÂÆöÊòØ \(G\) ÁöÑ‰∏ÄÊ£µÁîüÊàêÊ†ëÔºå‰∏îÂ¶ÇÊûúÊääÊúÄÂêéÁªàÊ≠¢ÁöÑ wire ‰Ωú‰∏∫Ê†πÔºåÊØè‰∏™ÁÇπÂà∞ÂÆÉÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÈÉΩÂ∞è‰∫éÂÆÉÁà∂‰∫≤Âà∞ÂÆÉÁà∂‰∫≤ÁöÑÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ„ÄÇÂèçËøáÊù•ÔºåÂÆπÊòìÈ™åËØÅÂ¶ÇÊûúÂ≠òÂú®‰∏ÄÊ£µËøôÊ†∑ÁöÑÁîüÊàêÊ†ëÔºåÈÇ£‰πà‰πüÂ≠òÂú®‰∏ÄÁßçÂêàÊ≥ïÊñπÊ°à„ÄÇ Êää balancer ‰Ωú‰∏∫ÁÇπÂª∫‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂ¶ÇÊûú balancer \(i,j\) ÈÉΩËøûÊé•‰∫ÜÊüê‰∏™ wireÔºå‰∏î \(i &lt; j\)ÔºåÂ∞±‰ªé \(j\) Âà∞ \(i\) Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÂêàÊ≥ïÊñπÊ°àÔºå‰∏ÄÂÆöÂèØ‰ª•‰ªéËøô‰∏™Âõæ‰∏äÊüê‰∏™ÁÇπÂá∫ÂèëÔºåÂà∞Ëææ‰∏éÊØè‰∏™ wire Áõ∏ËøûÁöÑËá≥Â∞ë‰∏Ä‰∏™ balancer„ÄÇÂèçËøáÊù•ÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÊ†∑‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨‰ªéËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancer ÂºÄÂßãÔºåÊåâÁºñÂè∑‰ªéÂ§ßÂà∞Â∞èËÄÉËôëÊØè‰∏™ balancer„ÄÇÁª¥Êä§‰∏Ä‰∏™ balancer ÁöÑÈõÜÂêàÔºåÂàùÂßãÊó∂Âè™ÊúâËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancerÔºåËÄÉËôëÂà∞‰∏Ä‰∏™ balancer Êó∂ÔºåÂ¶ÇÊûúÂÆÉËøûÊé•ÁöÑ‰∏Ä‰∏™ wire ÊòØÂΩìÂâçÁª¥Êä§ÁöÑÈõÜÂêà‰∏≠Êüê‰∏™ balancer ÁöÑÁ´ØÁÇπÔºåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÂ∞±ÊääËøô‰∏™ balancer Âä†ÂÖ•ÈõÜÂêà„ÄÇÊúÄÂêéÂæóÂà∞ÁöÑÈõÜÂêàÊòæÁÑ∂ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÁîüÊàêÊ†ë„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑ balancerÔºåÁÑ∂ÂêéÁî®‰ª•‰∏äÁÆóÊ≥ïÊûÑÈÄ†Âç≥ÂèØ„ÄÇ‰ºòÂåñ‰∏Ä‰∏ãÂª∫ËæπÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ wireÔºåÊää‰∏éÂÆÉÁõ∏ÈÇªÁöÑ balancer ÊéíÂ∫èÔºåÂè™ËÄÉËôëÁõ∏ÈÇªÁöÑ balancer ‰πãÈó¥ÁöÑÊúâÂêëËæπ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ DAG ‰∏ä DP ÈóÆÈ¢òÔºåÁõ¥Êé•ÂÅöÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(nm)\)ÔºåÁî® bitset ‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ËÉΩËøá‰∫Ü„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÔºö\(T=2\) ÂΩì \(n \ge 3\) Êó∂Ôºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØèÊù°ËæπÔºåÂèØ‰ª•ÂèëÁé∞ÊÄªÂ≠òÂú®‰∏ÄÁßçÊñπÊ°à‰ΩøÊâÄÊúâ wire ÊúÄÁªà‰∏çÊ±áËÅöÂú®Âêå‰∏Ä‰∏™ÁÇπ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁâπÂà§Êéâ‰∏§Ê£µÊ†ë‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊÉÖÂÜµ„ÄÇ Êûö‰∏æÁ¨¨‰∏Ä‰∏™Êìç‰ΩúÁöÑÁÇπÂèäÂÖ∂Êìç‰ΩúÊñπÂºèÔºåËÆæËøô‰∏™ÁÇπ‰∏∫ \(r\)„ÄÇÊàë‰ª¨ËÄÉËôëËøõË°åÂÆåÁ¨¨‰∏ÄÊ¨°Êìç‰ΩúÂêéÁöÑ‰∏§Ê£µÊ†ë„ÄÇ ËÆæÁ¨¨‰∏ÄÊ£µÊ†ë‰∏∫ \(T_A\)ÔºåÁ¨¨‰∫åÊ£µÊ†ë‰∏∫ \(T_B\)ÔºåÊää \(r\) ‰Ωú‰∏∫‰∏§Ê£µÊ†ëÁöÑÊ†π„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âú®ÊúâÊ†πÊ†ë‰∏äËÄÉËôëÈóÆÈ¢ò„ÄÇ ÂÅáËÆæÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°à‰∏≠Ôºå‰Ω†Âú®Êüê‰∏™Êó∂ÂàªÊääÁÇπ \(u\) ÊüìÈªëÂπ∂Êé•Âà∞ÁÇπ \(v\)ÔºåÈÇ£‰πàÂú®Ëøô‰πãÂêé \(v\) ‰ª•ÂèäÂÖ∂Á•ñÂÖà‰∏ÄÂÆöÈÉΩ‰∏çÂèØËÉΩÊòØÂè∂Â≠êÔºåÊâÄ‰ª•Ê≠§Êó∂ \(T_A\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑÁ≠â‰∫é \(T_B\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑ„ÄÇÂõ†Ê≠§ \(v\) ÂøÖÈ°ªÊòØ \(u\) Âú® \(T_B\) ‰∏äÁöÑÁà∂‰∫≤„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™ÁÇπÂàùÂßãÊó∂Âà∞Ê†πÁöÑË∑ØÂæÑÔºàÁªèËøáÁöÑÁÇπÁöÑÂ∫èÂàóÔºâÂú®‰∏§Ê£µÊ†ë‰∏ä‰∏çÂêåÔºåÊàë‰ª¨Áß∞ÂÆÉ‰∏∫‰∏çÂ•ΩÁöÑÔºåÂê¶ÂàôÊàë‰ª¨Áß∞ÂÆÉ‰∏∫Â•ΩÁöÑ„ÄÇÊòæÁÑ∂Êàë‰ª¨‰∏ç‰ºöÊüìÈªëÂ•ΩÁöÑÁÇπÔºåËÄå‰∏çÂ•ΩÁöÑÁÇπÂøÖÈ°ªË¶ÅË¢´ÊüìÈªë„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËß£ÂÜ≥ÂèØË°åÊÄßÈóÆÈ¢ò„ÄÇ ‰∫ãÂÆû‰∏äÔºåÂ≠òÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°àÁ≠â‰ª∑‰∫éÂ≠òÂú®‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÁöÑÊéíÂàóÔºå‰ΩøÂæóÔºö - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_A\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂâç„ÄÇ - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_B\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂêé„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÊòØÂê¶Â≠òÂú®ÊãìÊâëÂ∫èÁöÑÈóÆÈ¢òÔºåÂà§‰∏Ä‰∏ã DAG Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(Tn^3)\)„ÄÇÁî±‰∫éÊàëÊáíÂÜô‰∫Ü \(\mathcal O(Tn^4)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫éÁªôÂÆöÁöÑÂ∫èÂàó \(a\)ÔºåÊàë‰ª¨ÊääÂÆÉÊãÜÊàê‰∏§‰∏™ÈùûË¥üÂ∫èÂàó \(x\) Âíå \(y\) ÁöÑÂíå„ÄÇÁÑ∂Âêé‰ªÖÁî®‰∏çÂáèÂ∫èÂàóÂéªÂæóÂà∞ \(x\)Ôºå‰ªÖÁî®‰∏çÂ¢ûÂ∫èÂàóÂæóÂà∞ \(y\)„ÄÇ ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫éÈïø‰∏∫ \(k\) Â∫èÂàó \(a\) (ÂÆö‰πâ \(a_0 = a_{k+1} = 0\))ÔºåÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂâçÁºÄ‰∏çÂáèÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)ÔºõÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂêéÁºÄ‰∏çÂ¢ûÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÔºåËÄÉËôë \(i\) ‰ªéÂ∞èÂà∞Â§ßÂú∞ÂÜ≥ÂÆö \(x\) Âíå \(y\) ÁöÑÁ¨¨ \(i\) È°πÔºåÁÑ∂Âêé‰ΩøÂæóÂâç \(i\) È°π \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Â∞ΩÂèØËÉΩÂ∞è„ÄÇÁÑ∂ËÄåÁõ¥Êé•Ë¥™ÂøÉÊòØ‰∏çÂØπÁöÑ„ÄÇÊ≥®ÊÑèÂà∞ÔºåÂØπ‰∫é‰∏§Áßç \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Áõ∏Á≠âÁöÑÊñπÊ°àÔºå\(x_i\) ËæÉÂ∞èÁöÑ‰∏ÄÂÆöÊØîËæÉ‰ºòÔºåËÄå‰∏îÂ¶ÇÊûúÂâç \(i\) È°π‰∏Ä‰∏™ÊñπÊ°àÁöÑ‰ª£‰ª∑ÊØîÂâç \(i\) È°πÊúÄÂ∞è‰ª£‰ª∑ÊñπÊ°àÁöÑ‰ª£‰ª∑ËøòË¶ÅÂ§ßË∂ÖËøá \(2\)ÔºåÂÆÉ‰∏ÄÂÆö‰∏ç‰ºò„ÄÇÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊàë‰ª¨ÂèØ‰ª•Âè™‰øùÁïô‰∏â‰∏™ÊñπÊ°àÔºå‰ΩøÂæóÂÖ∂‰∏≠‰∏ÄÂÆöÊúâ‰∏Ä‰∏™Âú®‰πãÂêéÂèØ‰ª•ÂèòÊàêÊúÄ‰ºòÊñπÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // ÂÖàÂà§Êñ≠ÊòØÂê¶ÂèØËÉΩ‰∏çÂ¢ûÂä† // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // ÂÜçÂà§Êñ≠Âè™Â¢ûÂä†‰∏ÄÈ°πÔºåx ÁöÑÊúÄÂ∞èÂÄºÔºàÊòæÁÑ∂ÂèØ‰ª•Âè™Â¢ûÂä†‰∏ÄÈ°πÔºâ ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏çÂ¶®ÂÅáËÆæ \(n \ge m\)„ÄÇ Âè™‰ºö \(\mathcal O(n \log^2 n)\) Ëá™Èó≠‰∫ÜÔºåÂéªÁúãÈ¢òËß£‰∫Ü„ÄÇ Áî±‰∫é‰Ω†ÁöÑÂÜ≥Á≠ñ‰∏ç‰ºöÂΩ±Âìç‰πãÂêéÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°àÔºåÊâÄ‰ª•ÊòæÁÑ∂ÊØèÊ¨°ÈÄâÊ¶ÇÁéáÂ§ßÁöÑÂ∞±ÊØîËæÉÂ•Ω„ÄÇ ËÆæÁ¨¨ \(k+1\) ‰∏™ÈóÆÈ¢òËÉΩÂ§üÁ≠îÂØπÁöÑÊ¶ÇÁéá‰∏∫ \(p_k\)ÔºåÂÅáËÆæÂâç \(k\) ‰∏™ÈóÆÈ¢ò‰∏≠Á≠îÂØπ‰∫Ü \(a\) ‰∏™ÔºåÈÇ£‰πà \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] ÂàÜ‰∏∫ \(n - a &lt; m - (k - a)\) Âíå \(n-a \ge m - (k - a)\) ËÆ°ÁÆóË¥°ÁåÆ„ÄÇ ËÆæ \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] Á¨¨‰∫åÈÉ®ÂàÜ \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] Âø´ÈÄüËÆ°ÁÆó \(H,G\) ÁöÑÊÑè‰πâÊòØÊúâÂ§öÂ∞ëÊù°‰ªé \((0,0)\) Âà∞ \((n,m)\) ÁöÑÈùûÈôçË∑ØÂæÑ‰∏éÁõ¥Á∫ø \(x+y = s\) ÁöÑ‰∫§ÁÇπÁöÑÊ®™ÂùêÊ†áÂú®Êüê‰∏™ËåÉÂõ¥ÂÜÖ„ÄÇ Áî±Ëøô‰∏™ÁªÑÂêàÊÑè‰πâÂæàÂÆπÊòìÂæóÂá∫ \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] ÊâÄ‰ª•Êàë‰ª¨‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æ \(k\) Á∫øÊÄßÁª¥Êä§ \(H\) Âíå \(G\) ÈúÄË¶ÅÁî®Âà∞ÁöÑÂÄºÔºåÂ∞±Âú® \(\mathcal O(n)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∫§Êç¢ÔºåÂ¶ÇÊûú‰∫§Êç¢ÁöÑÊòØ \(a_i\) Âíå \(a_j\)ÔºåÂú®ÁÇπ \(i\) ÂíåÁÇπ \(j\) ‰πãÈó¥Ëøû‰∏ÄÊù°ËæπÔºåÊ†áÂè∑‰∏∫ \(i\)„ÄÇ ËÆæ \(S_1\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_2\) ÊòØÊâÄÊúâ‰∏§‰∏™Â∫èÂàó‰∏≠ÈÉΩÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_3\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêà„ÄÇ \(S_1\) Âíå \(S_3\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(1\)Ôºå\(S_2\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(2\)„ÄÇ‰∏çÈöæËØÅÊòéÔºåÂ¶ÇÊûúÊúÄÁªà‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ \(G\) ÁöÑ‰∏Ä‰∏™ËøûÈÄöÂùóË¶Å‰πàÊòØ‰∏ÄÊù° \(S_1\) ‰∏≠ÁÇπÂà∞ \(S_3\) ‰∏≠ÁÇπÁöÑË∑ØÂæÑÔºåË¶Å‰πàÊòØ‰∏Ä‰∏™ \(S_2\) ÂÜÖÈÉ®ÁöÑÁéØ„ÄÇ ËÄÉËôëÂØπËÉΩ‰Ωø‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ÁöÑÂõæÁöÑÂΩ¢ÊÄÅÂíåËæπÁöÑÊ†áÂè∑ËÆ°Êï∞ÔºåÈÇ£‰πàÔºåÂØπ‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂõæ \(G\)Ôºå‰∏Ä‰∏™ÁéØ‰∏äÁöÑÊ†áÂè∑È°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºå‰∏ÄÊù°ÈìæÊ†áÂè∑‰∏ÄÂÆöÊòØ‰ªé \(S_1\) ‰∏Ä‰æßÂà∞ \(S_3\) ‰∏Ä‰æßÈÄíÂ¢û„ÄÇÊâÄ‰ª•Â¶ÇÊûúÂÜ≥ÂÆö‰∫Ü \(G\)ÔºåÂèØ‰ª•ÂÖàÂÜ≥ÂÆöÊØè‰∏™ËøûÈÄöÂùóÁöÑËæπÁî®Âì™‰∫õÊ†áÂè∑ÔºåÁÑ∂ÂêéÂØπ‰∫éÁéØÂèØ‰ª•‰ªªÊÑèÊéíÂàóÔºåÈìæÂè™Êúâ‰∏ÄÁßçÊ†áÂè∑ÊñπÂºè„ÄÇ ËÄÉËôëÂÜ≥ÂÆö \(S_2\) ‰∏≠ÁöÑÂõæÁöÑÁªìÊûÑÔºåÊàë‰ª¨ÂèØ‰ª•ÂÜôÂá∫ÁéØÂíåÈìæÁöÑ EGFÔºå\(C(x)\) Âíå \(P(x)\)„ÄÇ \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) È¢òÁõÆ‰∏≠Ë¶ÅÊ±ÇÁöÑÂç≥ÊòØ \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)„ÄÇ NTT ‰∏Ä‰∏ãÂç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇÔºàÂÖ∂ÂÆûÁõ¥Êé•ÂÜô‰∏äÁ≥ªÊï∞Â∞±ÊòØ‰∫ÜÔºåÂâçÈù¢Êé®ÁöÑÂÆåÂÖ®Áî®‰∏çÂà∞...Ôºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂêêÊßΩÔºö‰∏∫Âï•ËøôÁßçÊ≤°Âï•ÊÑèÊÄùÁöÑÈ¢ò‰ºöÊòØ agc ÁöÑ F È¢ò„ÄÇ Ëøô‰∏™Ê∏∏ÊàèÊòØ‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÁöÑÂíåÔºåÊâÄ‰ª•Âè™Ë¶Å‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏Êàè SG ÂÄº‰∏ç‰∏ÄÊ†∑Â∞±Ë°å„ÄÇ ËÄÉËôëÊåâ \(SG\) ÂÄº \(dp\)Ôºå\(dp_{S}\) Ë°®Á§∫ÈõÜÂêà \(S\) ‰∏≠‰ªª‰ΩïÁöÑÁÇπ SG ÂÄºÈÉΩÊØî \(S\) Â§ñ‰ªª‰ΩïÁÇπÊ∂àÔºåËá≥Â∞ë‰∏ÄÁ´ØÂú® \(S\) ‰∏≠ÁöÑËæπÁöÑÊñπÊ°àÊï∞„ÄÇ ËΩ¨ÁßªÂ∞±ÊòØÊûö‰∏æ SG ‰∏∫ \(S\) ‰∏≠ÊúÄÂ§ß SG ÂÄºÂä†‰∏ÄÁöÑÁÇπÁöÑÈõÜÂêàÔºåÁÑ∂ÂêéËøô‰∏™ÈõÜÂêàÂÜÖÈÉ®ÊâÄÊúâËæπÈÉΩ‰∏çÈÄâÔºåÊâÄÊúâ‰∏çÂú®Ëøô‰∏™ÈõÜÂêàÂÜÖ‰πü‰∏çÂú® \(S\) ÂÜÖÁöÑÁÇπÂà∞Ëøô‰∏™ÈõÜÂêàËá≥Â∞ëÊúâ‰∏ÄÊù°ËæπÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞ÔºõËøô‰∏™ÈõÜÂêàÂà∞‰∏çÂú®Ëøô‰∏™ÈõÜÂêà‰∏≠‰πü‰∏çÂú® \(S\) ‰∏≠ÁöÑÁÇπÁöÑËæπÂèØÈÄâÂèØ‰∏çÈÄâÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞„ÄÇÊ≥®ÊÑè \(1,2\) ‰∏çËÉΩÂêåÊó∂Âú®Ëøô‰∏™ÈõÜÂêà„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n3^n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÈóÆÈ¢òÊîæÂà∞‰∏Ä‰∏™Êó†ÂêëÂõæ‰∏äËÄÉËôëÔºåÂ¶ÇÊûúÁ¨¨ \(i\) ‰∏™‰∫∫ÈÄâ‰∫ÜÁÅ´È∏° \(x_i,y_i\)ÔºåÂ∞±Âú® \(x_i,y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Êó†ÂêëËæπÔºåÊàë‰ª¨Áß∞ËøôÊù°ËæπÁöÑÊó∂Èó¥‰∏∫ \(i\)„ÄÇ ËÄÉËôë‰∏Ä‰∏™ÁÅ´È∏° \(s\) Âπ∏Â≠òÁöÑÊù°‰ª∂ÔºöÂ¶ÇÊûú \(s\) Âú®Êó∂Âàª \(t\) Ê≤°Ë¢´ÂêÉÊéâÔºåÂØπ‰∫éÊØè‰∏ÄÊù°Ëæπ \(\{s,v\}\)ÔºåÂ¶ÇÊûúËøôÊù°ËæπÁöÑÊó∂Èó¥Â∞è‰∫éÁ≠â‰∫é \(t\)ÔºåË¢´ÂêÉÊéâÁöÑÈÉΩÊòØÁÅ´È∏° \(v\)Ôºå‰∫éÊòØÁÅ´È∏° \(v\) Ë¶ÅÂú®ËøôÊù°ËæπÁöÑÊó∂Èó¥Âπ∏Â≠òÔºåÂ¶ÇÊ≠§‰º†ÈÄí‰∏ãÂéªÔºåÊúÄÁªà‰ºöÂæóÂà∞Ëã•Âπ≤Êù°Ë¢´ÂêÉÊéâÁöÑÁÅ´È∏°Á°ÆÂÆöËæπÔºåËøô‰∫õËæπ‰ºöÊûÑÊàê‰∏ÄÊ£µÊ†ëÔºàÂ¶ÇÊûú‰∏çÊûÑÊàê‰∏ÄÊ£µÊ†ëÁöÑËØùÁÅ´È∏° \(s\) ‰∏çÂèØËÉΩÂπ∏Â≠òÔºâ„ÄÇÊòæÁÑ∂Âè™Ë¶ÅËøô‰∏™Ê†ë‰∏äÁöÑËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Êª°Ë∂≥‰∫ÜÊù°‰ª∂Ôºå\(s\) ‰πü‰∏ÄÂÆö‰ºöÂπ∏Â≠ò„ÄÇÂõ†Ê≠§ÁÅ´È∏° \(s\) Âíå \(t\) ÂêåÊó∂Âπ∏Â≠òÁöÑÊù°‰ª∂Â∞±ÊòØÂÆÉ‰ª¨ÂØπÂ∫îÁöÑÁ°ÆÂÆöÁöÑËæπÊ≤°ÊúâÂÜ≤Á™Å„ÄÇ Áî±‰∫é‰∏Ä‰∏™ÁÅ´È∏°Âπ∏Â≠òÁöÑÊù°‰ª∂‰∏≠ÊúÄÂ§ö \(n-1\) Êù°ËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Ë¢´Á°ÆÂÆöÔºåÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊ£ÄÊü•‰∏§‰∏™ÁÅ´È∏°ÊòØÂê¶ÂèØ‰ª•ÂêåÊó∂Âπ∏Â≠òÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â¶ÇÊûúÁ∫¢Ê†ë‰∏äÊúâ‰∏ÄÊù°Ëæπ \((u,v)\)Ôºå\(u\) Âíå \(v\) Âú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\)ÔºåÈÇ£‰πà Sigma Ëµ∞Âà∞ \(u\) Êàñ \(v\) Â∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª‰∫Ü„ÄÇ Êàë‰ª¨ÊääÂ≠òÂú®‰∏ÄÊù°Áõ∏ÈÇªÁ∫¢ËæπÂú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\) ÁöÑÁÇπÊ†áËÆ∞‰∏Ä‰∏ãÔºåÂè™Ë¶ÅÂà∞ËææËøôÁßçÁÇπÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥ÂæÄ‰∏ãË∑ë„ÄÇ ÂÅáËÆæ Sigma Âú®ÁÇπ \(X\)ÔºåSugim Âú®ÁÇπ \(Y\)ÔºåËÄÉËôëËìùÊ†ëÂéªÊéâÁÇπ \(Y\) ÂêéÂΩ¢ÊàêÁöÑËã•Âπ≤‰∏™ËøûÈÄöÂùóÔºåSigma Êó†Ê≥ï‰ªé‰∏Ä‰∏™ËøûÈÄöÂùóÁöÑÊú™Ê†áËÆ∞ÁÇπÂà∞Âè¶‰∏Ä‰∏™ËøûÈÄöÂùó„ÄÇÊâÄ‰ª•ÊòæÁÑ∂ Sugim ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØÔºåÊØèÊ¨°Âú®ËìùÊ†ë‰∏äÂêë \(X\) ÊâÄÂú®ÁöÑÊñπÂêëËµ∞‰∏ÄÊ≠•„ÄÇSigma ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØ‰∏ç‰ºöÈáçÂ§çÁªèËøáËµ∞ËøáÁöÑÁÇπÁöÑ„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞Ê±ÇÂá∫ Sigma ÂèØËÉΩËµ∞Âà∞Âì™‰∫õÁÇπÔºåÂ¶ÇÊûú‰ªñËÉΩËµ∞Âà∞‰∏Ä‰∏™Ê†áËÆ∞ÁÇπÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª„ÄÇÂê¶ÂàôÁ≠îÊ°àÂ∞±ÊòØËÉΩËµ∞Âà∞ÁöÑÁÇπÂú®ËìùÊ†ë‰∏ä‰∏é \(Y\) ÁöÑÊúÄËøúË∑ùÁ¶ª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // Ê≠§Êó∂ Y ÁöÑÊ∑±Â∫¶‰∏∫ T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÖ≥‰∫éÊúÄÈïøÂèçÈìæÊñπÊ°àÁöÑÊûÑÈÄ†]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏Ä‰∫õÊ±ÇÊúÄÈïøÂèçÈìæÁöÑÈ¢òÁõÆ‰ºöËÆ©‰Ω†ÊûÑÈÄ†ÊñπÊ°àÔºåÊØîÂ¶Ç [CTSC2008] Á•≠Á•Ä Âíå CF590E Birthday„ÄÇ ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÂÜôÁöÑÊØîËæÉÊ∏ÖÊô∞ÁöÑÂÅöÊ≥ïÔºår-64 ÁöÑ uoj blog„ÄÇ Â§ßÊ¶ÇÊòØËØ¥Âª∫Âá∫‰∫åÂàÜÂõæÊ±ÇÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÊâÄÊúâ‰∏§ÈÉ®‰∏≠ÂØπÂ∫îÁöÑÁÇπÈÉΩÂú®Áã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÊûÑÊàêÊúÄÈïøÂèçÈìæ„ÄÇ ÊûÑÊàêÂèçÈìæÊòØÊòæÁÑ∂ÁöÑÔºåÊûÑÊàêÊúÄÈïøÂèçÈìæÁöÑÁêÜÁî±‰ºº‰πé‰∏çÂ§™ÂÆåÊï¥Ôºà‰πüÊúâÂèØËÉΩÊòØ‰ΩúËÄÖËßâÂæóËøôËøá‰∫éÊòæÁÑ∂‰∫ÜÔºâÔºåÂùë‰∫ÜÊàëÂæà‰πÖÔºåËøôÈáåËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ËÆæÂéüÂõæÁÇπÊï∞‰∏∫ \(n\)Ôºå‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç‰∏∫ \(m\)ÔºåÈÇ£‰πàÊúÄÂ∞èÈìæË¶ÜÁõñÂ§ßÂ∞è‰∏∫ \(n-m\)ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞è‰∏∫ \(2n - m\)„ÄÇÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÂ∑¶Âè≥ÈÉ®‰∏≠ÂØπÂ∫îÁÇπÈÉΩÂú®ÂÖ∂‰∏≠ÁöÑÁÇπÊúâ \(n-m\) ‰∏™„ÄÇÈ¶ñÂÖàÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÂÆÉÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπËá≥Â∞ëÊúâ‰∏Ä‰∏™Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÔºàÈÇ£ÁØá blog ‰∏≠‰ºº‰πéÁº∫Â∞ë‰∫ÜËøô‰∏ÄÊ≠•ÔºâÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÁÇπÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÈÉΩ‰∏çÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠Ôºå‰∏ÄÂÆöÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Â∑¶ÈÉ®ÂØπÂ∫îÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπÊúâËæπÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπ \(a\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºå‰πüÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÊúâËæπÁöÑÁÇπ \(b\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠„ÄÇÁî±ÂÅèÂ∫èÂÖ≥Á≥ªÁöÑ‰º†ÈÄíÊÄßÂèØÁü• \(a\) Âíå \(b\) Âú®‰∫åÂàÜÂõæ‰∏äÊúâ‰∏ÄÊù°ËæπÔºå‰∏éÊúÄÂ§ßÁã¨Á´ãÈõÜÁöÑÂÆö‰πâÁüõÁõæ„ÄÇÂõ†Ê≠§ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞èÁ≠â‰∫é \(n + Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁÇπÈÉΩÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÁöÑÊï∞Èáè\)Ôºå‰πüÂ∞±ËØÅÊòé‰∫ÜÊàë‰ª¨ÊûÑÈÄ†Âá∫ÁöÑÂèçÈìæÊòØÊúÄÈïøÂèçÈìæ„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] „ÄåJOISC 2017 Day 1„ÄçÂºÄËçíËÄÖ]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ‰∏úË•øÂçóÂåóÊñπÂêëÂêπÁöÑÊ¨°Êï∞ÂàÜÂà´‰∏∫ \(c_E, c_W, c_S, c_N\)„ÄÇ È¢òÊÑèÁõ∏ÂΩì‰∫éÊòØË¶ÅÊ±Ç \(c_E+c_W+c_S+c_N\) ÊúÄÂ∞èÁöÑ \(c_E,c_W,c_S,c_N\)Ôºå‰ΩøÂæóÂú®Âπ≥Èù¢‰∏äÊîæ \(n\) ‰∏™Áü©ÂΩ¢ÔºåÁ¨¨ \(i\) ‰∏™Áü©ÂΩ¢ÁöÑÊ®™ÂùêÊ†áËåÉÂõ¥‰∏∫ \([S_i - c_N, S_i + c_S]\)ÔºåÁ∫µÂùêÊ†áËåÉÂõ¥‰∏∫ \([E_i - c_W, E_i + c_E]\)ÔºåËÉΩÂ§üË¶ÜÁõñ‰ª• \((1,1)\) ‰∏∫Â∑¶‰∏äËßíÁöÑ \(R \times C\) Áü©ÂΩ¢„ÄÇ ÂÅáËÆæÊúâ‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëË∞ÉÊï¥„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[‰æãÈ¢ò LOJ6440 ÂÅöÊ≥ï ËÄÉËôëËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰Ωú‰∏ÄÊù°Â∞ÑÁ∫ø \(y = \frac{Px+R}Q\)ÔºåÂè™ËÄÉËôë \(x &gt; 0\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(y = i\) Â∞±ÊâßË°åÊìç‰Ωú \(A\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(x = i\) Â∞±ÊâßË°åÊìç‰Ωú \(B\)Ôºå\(i\) ÊòØÊ≠£Êï¥Êï∞„ÄÇ ‚ÄúÊìç‰ΩúÂ∫èÂàó‚ÄùÂØπÂ∫îÁöÑ‰ø°ÊÅØË¶ÅÂèØÂêàÂπ∂„ÄÇ ËÄÉËôëÈÄíÂΩíÂú∞Â§ÑÁêÜÈóÆÈ¢òÔºåËÆæ \(A\) Âíå \(B\) ÊòØ‰∏§‰∏™Êìç‰ΩúÂ∫èÂàóÂØπÂ∫îÁöÑ‰ø°ÊÅØ„ÄÇÂÆö‰πâ \(solve(P, Q, R, L, A, B)\) Ë°®Á§∫‰∏Ä‰∏™Âê´Êúâ \(L\) ‰∏™ \(B\)ÔºåÁ¨¨ \(k\) ‰∏™ \(B\) ÂíåÁ¨¨ \(k-1\) ‰∏™ \(B\) ‰πãÈó¥Êúâ \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) ‰∏™ \(A\) ÁöÑÊìç‰ΩúÂ∫èÂàóÁöÑ‰ø°ÊÅØÔºà\(k = 1\) Êó∂ÊòØÂºÄÂ§¥ \(A\) ÁöÑÊï∞ÈáèÔºâ„ÄÇÊää \(R\) ÂØπ \(Q\) ÂèñÊ®°‰∏ç‰ºöÊîπÂèòÁ≠îÊ°àÔºåÊää \(P\) ÂØπ \(Q\) ÂèñÊ®°Âè™Ë¶ÅÊää \(B\) ÂèòÊàê \(A^{\lfloor \frac P Q \rfloor}B\) Â∞±ÂèØ‰ª•ÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú„ÄÇ ÂÖàÂèñÊ®°Ôºå‰øùËØÅ \(P, R &lt; Q\)„ÄÇ ËÄÉËôë‰∫§Êç¢ \(A\) Âíå \(B\) ÁöÑÂú∞‰ΩçÔºåÂéüÊù•Êàë‰ª¨ÊòØËÄÉËôëÊØè‰∏™ \(B\) ÂâçÈù¢ÊúâÂá†‰∏™ \(A\)ÔºåÁé∞Âú®Êàë‰ª¨ËÄÉËôëÊØè‰∏™ \(A\) ÂâçÈù¢ÊúâÂá†‰∏™ \(B\)ÔºåÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂâçÈù¢ÁöÑÊù°‰ª∂ÊòØ \(i \le \frac{Pj+R}{Q}\)ÔºåÂç≥ \(j \ge \frac{Qi-R}P\)„ÄÇÈÇ£‰πàÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂêéÈù¢ÁöÑÊù°‰ª∂ÊòØ \(j &lt; \frac{Qi-R}P\)Ôºå‰ªéÁ¨¨ \(i\) ‰∏™ \(A\) ÂâçÈù¢Êúâ \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) ‰∏™ \(B\)„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÁâπÂà´ÂéªÂ§ÑÁêÜ‰∏Ä‰∏ãÊúÄÂêé‰∏Ä‰∏™ \(B\) Âíå \(Qi-R-1\) Â∞è‰∫é \(0\) ÁöÑÊÉÖÂÜµÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™ÂΩ¢Âºè‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇÁî±‰∫é \(R &lt; Q\)Ôºå\(i &gt; 0\) Êó∂ \(Qi-R-1 \ge 0\)„ÄÇ‰ΩÜÊòØ \(i = 0\) Êó∂Âá∫Áé∞Ë¥üÊï∞Êåâ‰πãÂâçÁöÑÂÆö‰πâ‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•Á¨¨‰∏Ä‰∏™ \(A\) ‰ª•ÂèäÂâçÈù¢ÁöÑÈÉ®ÂàÜÂçïÁã¨Â§ÑÁêÜÔºåË∞ÉÁî® \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)ÔºåÂ§ÑÁêÜ‰∏ãÂºÄÂ§¥ÁªìÂ∞æÂç≥ÂèØ„ÄÇË¶ÅÂà§‰∏Ä‰∏ãÊ≤°Êúâ \(A\) ÁöÑÊÉÖÂÜµ„ÄÇ Ê∂âÂèäÂà∞Ê±ÇÁü©ÈòµÂπÇÂèØ‰ª•Áõ¥Êé•Âø´ÈÄüÂπÇÔºåÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶‰ªçÊòØ‰∏Ä‰∏™ \(\log\)„ÄÇ ÂÖ≥‰∫éÂÄºÂüü Êú¨È¢òÁöÑÂÄºÂüüÁâπÂà´Â§ßÔºåË¶ÅÂ∞èÂøÉÁàÜ long long„ÄÇ ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûêÂêÑ‰∏™ÂèòÈáèÂÜçÈÄíÂΩíËøáÁ®ã‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Ëøô‰∏™È¢òÊØîËæÉÊ∞¥„ÄÇ ÂÅáËÆæÊ≤°ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôêÔºåÈÇ£‰πàÂÖ∂ÂÆûË¶ÅÁÆó‰∏ÄÂè™ pony ËÉΩÊî∂ÂèñÁöÑ manaÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìËøôÊ¨°Êî∂ÂèñÂíå‰∏äÊ¨°Êî∂ÂèñÁöÑÊó∂Èó¥Èó¥ÈöîÔºå‰πò‰∏ä \(r_i\) Âç≥ÂèØ„ÄÇ Êàë‰ª¨Ë¶ÅÂú®Êìç‰ΩúÊó∂Áª¥Êä§ÊâÄÊúâ pony ÁöÑÊúÄÂêéÊìç‰ΩúÊó∂Èó¥ÔºåËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂå∫Èó¥Ë¶ÜÁõñÈóÆÈ¢òÔºåÂæàÂÆπÊòìÂÜô‰∏Ä‰∏™ÂùáÊëä \(\mathcal O(n \log n)\) ÁöÑÂÆûÁé∞ÔºöÂª∫‰∏Ä‰∏™Á∫øÊÆµÊ†ëÔºå‰øÆÊîπÊó∂ÂÖàÊääËØ¢ÈóÆÂå∫Èó¥Âú®Á∫øÊÆµÊ†ë‰∏äÊãÜÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÔºåÂØπÊØè‰∏™Âå∫Èó¥ÔºåÂÅö‰∏Ä‰∏™ËøôÊ†∑ÁöÑËøáÁ®ãÔºöÂÖàËÄÉËôëÂΩìÂâçÂå∫Èó¥ÊâÄÊúâÁÇπÊòØ‰∏çÊòØÊúÄÁªà‰øÆÊîπÊó∂Èó¥Áõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÔºåÂ∞±Â§ÑÁêÜËøô‰∏™Âå∫Èó¥ÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Âå∫Èó¥‰∏äÊâìÊ†áËÆ∞ÔºåÂê¶ÂàôÂ∞±‰∏§ËæπÈÄíÂΩí‰∏ãÂéª„ÄÇÊØèÊ¨°ÂæÄ‰∏ãÈÄíÂΩíÈÉΩ‰ºö‰ΩøÂæó‰∏Ä‰∏™Á∫øÊÆµÊ†ë‰∏äÂå∫Èó¥‰∏≠‰∏çÂêåÁöÑÊúÄÁªà‰øÆÊîπÊó∂Èó¥Êï∞ÂáèÂ∞ë‰∏ÄÔºå‰ªéËÄåËøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶ÊòØÂùáÊëä \(\mathcal O(n \log n)\)„ÄÇ ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôê‰πüÂèØ‰ª•Á±ª‰ººÁöÑÂ§ÑÁêÜÔºå‰∏çÂêåÁöÑÊòØÔºåÂõ†‰∏∫Êúâ‰∫Ü‰∏äÈôêÔºåÈúÄË¶ÅÂØπÊØè‰∏™Âå∫Èó¥Áª¥Êä§‰∏Ä‰∏™‰ª• \(\lceil \frac {m_i}{r_i}\rceil\) ‰∏∫ÂÖ≥ÈîÆÂ≠óÊéíÂ•ΩÂ∫èÁöÑ‰∏úË•ø„ÄÇËøôÊ†∑‰Ω†ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ãÂâçÂ§öÂ∞ë‰∏™ÈÉΩÊòØÂú®ËøôÊÆµÊó∂Èó¥ÈáåÈù¢ mana Êª°‰∫ÜÁöÑÔºåÁõ¥Êé•Âä†ËøõÁ≠îÊ°àÔºåÁÑ∂ÂêéÂêéÈù¢ÁöÑÂè™ÈúÄË¶ÅÁªüËÆ°‰∏Ä‰∏ã \(r_i\) ÁöÑÂíå‰πò‰∏äÊó∂Èó¥Â∑ÆÂä†ËøõÁ≠îÊ°àÂç≥ÂèØ„ÄÇËøô‰∏™‰∏úË•øÂæàÂÆπÊòìÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ„ÄÇ ÂàùÂßãÂÄºË¶ÅÁâπÂà´Â§ÑÁêÜÔºåÂú®ÊØè‰∏™ÁÇπÁ¨¨‰∏ÄÊ¨°‰øÆÊîπÊó∂Êö¥ÂäõÁÆó‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÊÑüËßâÂÆûÈôÖ‰∏äÂèØ‰ª•Áî®Á∫øÊÆµÊ†ëÂàÜË£ÇÂíåÂêàÂπ∂ÂÅöÂà∞‰∏Ä‰∏™ \(\log\)„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊØíÁò§ÂàÜÁ±ªËÆ®ËÆ∫.... Â∞±Êîæ‰∏™‰ª£Á†Å..ÁªìËÆ∫Â§™È∫ªÁÉ¶Â∞±‰∏çÂÜô‰∫Ü TAT„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Á•û‰ªôÈ¢òÔºåÁúãÈ¢òËß£‰∫Ü„ÄÇ Âèñ‰ªªÊÑè‰∏Ä‰∏™ÁîüÊàêÊ†ëÔºåÂèñËøô‰∏™Ê†ëÁöÑÈáçÂøÉÂíåÊâÄÊúâË∑®ËøáËøô‰∏™ÈáçÂøÉÁöÑÈùûÊ†ëËæπÁöÑÁ´ØÁÇπÔºàÂÆûÈôÖ‰∏ä‰∏§‰∏™Á´ØÁÇπ‰∏≠Âè™Ë¶Å‰ªªÂèñ‰∏Ä‰∏™Â∞±Ë°åÔºåÂè™Ë¶Å‰øùËØÅÂ≠êÊ†ë‰∏çËøûÈÄöÔºâÔºåËÄÉËôëË∑®ËøáËøô‰∫õÁÇπÁöÑË∑ØÂæÑÔºåÁÑ∂ÂêéÂÜçÂØπÊØè‰∏™Â≠êÊ†ëÁÇπÂàÜ„ÄÇ Ê≥®ÊÑè‰∏çË¶ÅÊääËøô‰∫õÁÇπÂà†ÊéâÂÜçÂØπÊØè‰∏™ËøûÈÄöÂùóÂÅöÁÇπÂàÜÊ≤ªÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØËÉΩ‰∏Ä‰∏™ËøûÈÄöÂùó‰∏çÊòØ‰∏Ä‰∏™Ê†ë‰∏äËøûÈÄöÂùóÔºåÂ∞±‰∏çÊòØÂæàÂ•ΩÂ§ÑÁêÜÔºàÂ∫îËØ•‰πüËÉΩÂ§ÑÁêÜÔºâ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÉèÂä®ÊÄÅÁÇπÂàÜÊ≤ª‰∏ÄÊ†∑Áª¥Êä§Â∞±Ë°åÔºåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÂà†ÂéªÁöÑÁÇπ‰∏éÂΩìÂâçËøûÈÄöÂùó‰∏≠ÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ª„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(nk\log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // ÁÇπÂàÜÊ†ë‰∏äÁà∂‰∫≤Ôºå‰∏Ä‰∏™ÁÇπË¢´Âà†ÊéâÊó∂ÂØπÂ∫îÁÇπÂàÜÊ†ë‰∏äÂì™‰∏™ÁÇπvector&lt;int&gt; vimp[maxn], mn[maxn]; // ÁÇπÂàÜÊ†ë‰∏ä‰∏ÄÊ¨°Âà†ÂéªÁöÑÁÇπÔºå‰ª•ÂèäÂà∞ËøûÈÄöÂùóÂÜÖÊúÄËøëË¢´ mark ÁÇπÁöÑË∑ùÁ¶ªunordered_map&lt;ll, int&gt; mdis; // Ë¢´Âà†ÂéªÁöÑÁÇπÂà∞ÂÜÖÈÉ®‰∏Ä‰∏™ÁÇπÁöÑË∑ùÁ¶ªint vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // ÁÇπÂàÜÊ≤ªÁî®ÂèòÈáèvoid dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // ÂéüÊú¨ËøôÈáåÊòØÊääÊâÄÊúâÂ§ÑÁêÜÁöÑÁÇπÂà†ÊéâÁöÑÔºåÂÜôÂæóÂèØËÉΩÊúâÁÇπÂ•áÊÄ™ÔºåÊáíÂæóÊîπ‰∫Ü vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ∫¶Êï∞Â∫èÂàó \(d\)ÔºåÂ≠òÂú®‰∏ÄÊ£µÂØπÂ∫îÁöÑ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(1 \le d_i &lt; n\) ‰∏î \(\sum {d_i} = 2(n-1)\)Ôºà‰ªéÂè∂Â≠êÂΩíÁ∫≥Ôºâ„ÄÇ ËÄÉËôëÂéªÈí¶ÂÆöËøô‰∏™Ê†ëÁöÑ \(k\) ‰∏™ÂåπÈÖçÔºåÂ¶ÇÊûúËÉΩÈí¶ÂÆöÂá∫Êù•Â∞±ËØ¥ÊòéÁ≠îÊ°à \(\ge k\)„ÄÇÈí¶ÂÆö‰∏§‰∏™ÁÇπÂåπÈÖçÂèØ‰ª•Áúã‰ΩúËøô‰∏§‰∏™ÁÇπË¢´Áº©Âà∞‰∫Ü‰∏ÄËµ∑ÔºåÂèòÊàê‰∫Ü‰∏Ä‰∏™Â∫¶Êï∞Âíå‰∏∫‰∏§‰∏™ÁÇπÁöÑÂ∫¶Êï∞‰πãÂíåÂáèÂéª \(2\) ÁöÑÁÇπ„ÄÇÂè™Ë¶Å‰øùËØÅÊâÄÊúâÂåπÈÖçÁº©Ëµ∑Êù•‰πãÂêéÂæóÂà∞ÁöÑÂ∫¶Êï∞Â∫èÂàó‰æùÁÑ∂Êª°Ë∂≥‰πãÂâçÊâÄËØ¥ÁöÑÊù°‰ª∂Âç≥ÂèØ„ÄÇËøôÊòØ‰∏Ä‰∏™‰ºóÊâÄÂë®Áü•ÁöÑË¥™ÂøÉÈóÆÈ¢òÔºåÊéíÂ∫èÂêéË¥™ÂøÉÁî®Â∞èÁöÑÂåπÈÖçÂ§ßÁöÑÂç≥ÂèØ„ÄÇÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè \(1\) Âíå \(1\) Âú®ÁÇπÊï∞Â§ß‰∫é \(2\) Êó∂‰∏çËÉΩÂåπÈÖçÔºàÂõ†‰∏∫ \(1+1-2=0\)ÔºâÔºå‰ΩÜÊòØÁÇπÊï∞Á≠â‰∫é \(2\) Êó∂ÂèØ‰ª•ÂåπÈÖç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â•áÊÄ™ÁöÑÈ¢òÁõÆ... ÂÖàÊääÁÇπÊåâ \(a_i\) ‰ªéÂ∞èÂà∞Â§ßÈáçÊñ∞Ê†á‰∏™Âè∑„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨ÂÅáËÆæ \(a_i &lt; a_{i+1}\)„ÄÇ Êää \(1\) Áúã‰ΩúÊ†πÔºåÊòæÁÑ∂ÂèØ‰ª•ÈÄöËøáË∞ÉÊï¥‰ΩøÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ÁºñÂè∑ÈÉΩÊØî‰ªñÂ∞è„ÄÇ Êää‰∏§ÁßçË¥°ÁåÆ‰∏ÄËµ∑ËÄÉËôëÔºåÂÆö‰πâËæπ \(\{u, fa(u)\}\) ÁöÑË¥°ÁåÆ‰∏∫ \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)ÔºåÂØπÊØè‰∏™ \(u\) ÂéªÊâæËÉΩ‰Ωø‰ª£‰ª∑ÊúÄÂ∞èÁöÑ \(fa(u)\)„ÄÇÁî±‰∫éËøô‰∏™Ê†ëÁöÑÁâπÊÆäÊÄßË¥®ÔºåÁÇπ \(u\) ÊúÄ‰ºòÁöÑÁà∂‰∫≤‰∏ÄÂÆöÊòØÂéüÊ†ë‰∏ä \(u\) ÁöÑÁ•ñÂÖàÔºåÊâÄ‰ª•ÂÄçÂ¢û‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // Ë∑ùÁ¶ª‰∏çË∂ÖËøá 2^k ÁöÑÁÇπint cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™ \(n\) ‰∏™ÁÇπ \(m\) Êù°ËæπÁöÑÂ∏¶ÊùÉÁÆÄÂçïÊúâÂêëÂõæÔºåÊ±Ç‰∏Ä‰∏™ÊúÄÂ∞èËæπÊùÉÂíåÁöÑÊòØ‰ª• \(r\) ‰∏∫Ê†πÁöÑÂÜÖÂêëÁîüÊàêÊ†ë„ÄÇ Â§ñÂêëÊ†ëÁöÑÊÉÖÂÜµÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´ÔºåËæπÂèç‰∏ÄÂèçÂ∞±Â•Ω„ÄÇ Êó†Ê†πÁöÑÊÉÖÂÜµÂèØ‰ª•Âä†‰∏Ä‰∏™ÁÇπËΩ¨Âåñ‰∏∫ÊúâÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ÁÆóÊ≥ï Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæÊòØ DAGÔºå‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑË¥™ÂøÉÊòØÔºåÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ„ÄÇÊòæÁÑ∂ËøôÊ†∑‰ºöÊûÑÊàê‰∏ÄÊ£µÂÜÖÂêëÊ†ëÔºå‰∏î‰∏çÂèØËÉΩÊúâÊùÉÂÄºÂíåÊõ¥Â∞èÁöÑÂÜÖÂêëÊ†ë„ÄÇ Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæ‰∏çÊòØ DAGÔºåÁõ¥Êé•ÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ‰∏ç‰∏ÄÂÆö‰ºöÂæóÂà∞‰∏ÄÊ£µÊ†ëÔºåÊ≠§Êó∂ÂèØËÉΩ‰ºöÊúâÂ§ö‰∏™Âº±ËøûÈÄöÂùóÔºåÊØè‰∏™ËøûÈÄöÂùóÊòØ‰∏ÄÊù°ÈìæÔºàÂåÖÂê´ \(r\) ÁöÑÔºâÊàñËÄÖ‰∏ÄÊ£µÂü∫ÁéØÂÜÖÂêëÊ†ë„ÄÇÂ¶ÇÊûú‰Ω†ÂæóÂà∞‰∫Ü‰∏Ä‰∏™ÂÜÖÂêëÁîüÊàêÊ†ëÂ∞±Ê±ÇÂá∫‰∫ÜÁ≠îÊ°àÔºå‰∏ãÈù¢Êàë‰ª¨ËÄÉËôëËá≥Â∞ëÊúâ‰∏Ä‰∏™ÁéØÁöÑÊÉÖÂÜµ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫é‰∏Ä‰∏™ÔºàÊüê‰∏™Âü∫ÁéØÊ†ëËøûÈÄöÂùó‰∏≠ÁöÑÔºâÁéØÔºå‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÊÅ∞Â•ΩÂè™Êúâ‰∏ÄÊù°ÁéØ‰∏äËæπ‰∏çÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºåÊàë‰ª¨ÂÖàÂÅáËÆæËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºà‰Ω†ÂèØ‰ª•Âä†ÂÖ•‰∏Ä‰∏™ÂÖÖÂàÜÂ∞èÁöÑÂÅèÁßªÈáèÔºåÂú®‰∏çÂΩ±ÂìçÁ≠îÊ°àÁöÑÂâçÊèê‰∏ã‰ΩøËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºâÔºåËÆæÁÇπ \(u\) ÁöÑÊúÄÂ§ßÂá∫ËæπËøûÂêëÁÇπ \(f(u)\)ÔºåËÄÉËôë‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÁÇπ \(u \neq r\)Ôºå\(f(u)\) ‰∏çÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠Ôºå‰∏î \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÊàë‰ª¨ÂèØ‰ª•Êää \(u\) ÁöÑÁà∂‰∫≤Êîπ‰∏∫ \(f(u)\)ÔºåÂæóÂà∞‰∏Ä‰∏™Êõ¥Â∞èÁöÑÂÜÖÂêëÁîüÊàêÊ†ëÔºåËøô‰∏éËøô‰∏™Ê†ëÊòØÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÁüõÁõæ„ÄÇËøôËØ¥ÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁéØ‰∏äÁöÑÁÇπ \(u\)Ôºå‰ΩøÂæó \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ (ÁéØ‰∏äÁÇπËÇØÂÆö‰∏çÊòØ \(r\))Ôºå\(f(u)\) Ë¶Å‰πàÊòØ \(u\) ÁöÑÁà∂‰∫≤Ë¶Å‰πàÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠„ÄÇËÄÉËôë‰ªé \(u\) Âá∫ÂèëÔºåÊØèÊ¨°‰ªé \(u\) Ëµ∞Âêë \(f(u)\)ÔºåÂú®Ëµ∞Âõû \(u\) ‰πãÂâçÔºå‰∏ÄÂÆö‰∏ç‰ºöÁªèËøá‰∏Ä‰∏™ÁÇπ‰∏§Ê¨°Ôºå‰ªéËÄåË∑ØÂæÑ‰∏äÂè™ÊúâÁ¨¨‰∏ÄÊ¨°Ëµ∞ÁöÑÊó∂ÂÄô \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÂõ†Ê≠§ÁéØ‰∏äÂè™Êúâ‰∏ÄÊù°ËæπÊ≤°ÊúâÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠Âá∫Áé∞„ÄÇ Âõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁéØ‰∏äÂì™‰∏ÄÊù°ËæπÊ≤°ÊúâÂá∫Áé∞„ÄÇËÄÉËôëÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÂæóÂà∞‰∏Ä‰∏™‰∏éÂéüÂõæÁ≠â‰ª∑ÁöÑÂõæ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠ \(e\) ÊòØ‰∏çÂú®ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ‰∏≠ÁöÑËæπÔºå‰ªéÂõæ‰∏≠ÂèØ‰ª•ÂæàÊòéÊòæÂú∞ÁúãÂà∞ÔºåÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÊääÁº©ÂÆåÂêéÁöÑÁöÑÁÇπÁöÑÂá∫ËæπËæπÊùÉÂáèÂéªÂéüÊù•ËøôÊù°Âá∫ËæπÂØπÂ∫îÁöÑ \(e\) ÁöÑÊùÉÂÄºÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™Á≠â‰ª∑ÁöÑÂõæ„ÄÇ Êö¥ÂäõÁº©ÁÇπÂèØ‰ª•Áî® \(\mathcal O(nm)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ê±ÇÂá∫ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ„ÄÇ Â§çÊùÇÂ∫¶‰ºòÂåñ Áî®Âπ∂Êü•ÈõÜÁª¥Êä§Âº±ËøûÈÄöÂùóÔºåÂÜçÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ÂΩìÂâçÂì™‰∫õÁÇπË¢´Áº©Êàê‰∫Ü‰∏Ä‰∏™ÁÇπ„ÄÇÁî®ÂèØÂπ∂Â†ÜÁª¥Êä§ÂΩìÂâçÊØè‰∏™ÁÇπÁöÑÂá∫ËæπÔºåÁº©ÁÇπÊó∂Â∏¶ tag ÂêàÂπ∂‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÂá∫ËæπÔºåÂ¶ÇÊûúÂú®Âêå‰∏ÄÂº±ËøûÈÄöÂùóÂèàÂèØ‰ª•Áº©ÁÇπ‰∫ÜÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÂíåÂÖ∂‰ªñÂº±ËøûÈÄöÂùóÂêàÂπ∂Âú®‰∫Ü‰∏ÄËµ∑„ÄÇ Áº©‰∏ÄÊ¨°Ëá≥Â∞ëÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºåÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O((n+m) \log n)\)„ÄÇ ÂÆûÁé∞ ÂíïÂíïÂíï„ÄÇ Áî±‰∫éÂÆûÁé∞Âíï‰∫ÜÊâÄ‰ª•‰πü‰∏çËÉΩ‰øùËØÅ‰∏äÈù¢ËØ¥ÁöÑÊòØÂØπÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Áåú‰∫Ü‰∏™ÁªìËÆ∫Ôºå‰∏ç‰ºöËØÅ‰ΩÜÊòØÂèàÊÉ≥‰∏çÂà∞ÂÖ∂‰ªñÂÅöÊ≥ï..Áúã‰∫ÜÁúºÈ¢òËß£ÂèëÁé∞ÊòØÂØπÁöÑ„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñÔºåÂÅáËÆæ‰Ω†‰π∞‰∫Ü \(x\) Ê¨°Ôºå‰Ω†‰ªéËøô‰∏™ÊäΩÂ•ñ‰∏≠Ëé∑ÂæóÁöÑÈí±Êï∞ÁöÑÊúüÊúõÊòØ \(p_i\frac {x} {x + l_i}\)„ÄÇÂÅáËÆæ‰Ω†Â∑≤Áªè‰π∞‰∫ÜÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñ \(x\) Ê¨°ÔºåÂÜç‰π∞‰∏ÄÊ¨°ÔºåÊúüÊúõÁöÑÂ¢ûÂä†ÈáèÊòØ \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)„ÄÇÂÆπÊòìÂèëÁé∞Ëøô‰∏™Â¢ûÂä†ÈáèÂÖ≥‰∫é \(x\) ÂçïË∞ÉÈÄíÂáèÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÂØπ‰∫éÊâÄÊúâÁöÑ \(i\) Âíå \(x \le i\)ÔºåÊää \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) ‰∏¢Ëøõ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ªéÂ§ßÂà∞Â∞èÊéí‰∏™Â∫èÔºåÂâç \(t\) ‰∏™Êï∞‰πãÂíåÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ§çÊùÇÂ∫¶‰∏çËÉΩÊé•Âèó„ÄÇ Êàë‰ª¨ÂÖàÁÆóÂá∫ÂàùÂßãÊ∏ÖÁ©∫ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÁªôÁ¨¨ \(k\) ‰∏™ÊäΩÂ•ñÂéüÊúâÁöÑÁ•®Êï∞Âä†‰∏ÄÂáè‰∏Ä‰πãÂêéÔºåËÄÉËôë‰∏§ÁßçÊìç‰ΩúÔºö‰∏ÄÔºåÂ∞ë‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ§ö‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñÔºõ‰∫åÔºåÂ§ö‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ∞ë‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñ„ÄÇÊàë‰ª¨ÊâæÂà∞ËÉΩ‰ΩøÊúüÊúõÂ¢ûÂä†ÈáèÊúÄÂ§ßÁöÑÊìç‰ΩúÔºåËøôÂæàÂÆπÊòìÁî®Â†ÜÊù•Áª¥Êä§„ÄÇÂè™ÈúÄË¶ÅÁªèËøá‰∏ÄÊ¨°ËøôÊ†∑ÁöÑÊìç‰ΩúÂç≥ÂèØÂæóÂà∞ÊúÄ‰ºòÊñπÊ°àÔºåËØÅÊòéÂ∞±‰∏çÂÖ∑‰ΩìÂÜôÂá∫‰∫Ü„ÄÇÔºàÊØîÂ¶ÇËØ¥Â¶ÇÊûúÊòØËøõË°åÊìç‰Ωú‰∫åÔºå‰ªéËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÂêéÔºåÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÊØîÂú®‰øÆÊîπÁ•®Êï∞‰πãÂâçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÂ§ßÊù•ËÄÉËôëÂç≥ÂèØÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÔºåÂÖàÊääÈ¢òÁõÆ‰∏≠ÁªôÂÆö‰∏≤ÁøªËΩ¨‰∏Ä‰∏ãÔºåÂèòÊàêË¶ÅÊâæ‰∏Ä‰∏™ÊØè‰∏™‰∏≤ÊòØÂêé‰∏Ä‰∏™‰∏≤Â≠ê‰∏≤ÁöÑÂ∫èÂàó„ÄÇ ‰∏ãÈù¢Êàë‰ª¨ËÆ§‰∏∫ÔºåËøô‰∏™Â∫èÂàó‰∏≠ÁöÑÂÖÉÁ¥†ÊòØ‰∏Ä‰∏™(ÂåÖÂê´‰ΩçÁΩÆÁöÑ)Â≠ê‰∏≤„ÄÇÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤Âá∫Áé∞Âú®‰∏çÂêå‰ΩçÁΩÆË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÁöÑ„ÄÇ ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Â∫èÂàóÔºå‰Ω†‰∏ÄÂÆöÂèØ‰ª•Âú®‰∏çÊîπÂèòÈïøÂ∫¶ÁöÑÊÉÖÂÜµ‰∏ãÊääÂÆÉË∞ÉÊï¥ÊàêÁ¨¨ \(i\) ‰∏™Â≠ê‰∏≤Èïø‰∏∫ \(i\)„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ËÄÉËôëËøôÁ±ªÂ∫èÂàó„ÄÇ Áß∞‰∏Ä‰∏™Â≠ê‰∏≤ \(s[l..r]\) ÊòØÂèØËææÁöÑÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏Ä‰∏™ËøôÁ±ªÂ∫èÂàó‰ª• \(s[l..r]\) ÁªìÂ∞æ„ÄÇÈ¢òÁõÆÂ∞±ÊòØË¶ÅÊ±ÇÊúÄÈïøÂèØËææÁöÑÂ≠ê‰∏≤„ÄÇ Ê≥®ÊÑèÂà∞Â¶ÇÊûú \(l &lt; r\)Ôºå\(s[l..r]\) ÂèØËææÔºåÈÇ£‰πà \(s[l..r-1]\) Âíå \(s[l+1..r]\) ‰∏ÄÂÆöÂèØËææ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(l\) Ê±ÇÂá∫ÊúÄÂ§ßÁöÑ \(r\) ‰ΩøÂæó \(s[l..r]\) ÂèØËææÔºåËÆæÂØπ‰∫é \(l=i\) ÊúÄÂ§ßÁöÑ \(r\) ÊòØ \(f_i\)„ÄÇÂØπ \(f\) ‰Ωú dpÔºåÊòæÁÑ∂ \(f_i \ge f_{i-1}\)ÔºåÊâÄ‰ª•ÊØèÊ¨°ÂÖà‰ª§ \(f_i = f_{i-1}\)ÔºåÁÑ∂ÂêéÊ£ÄÊü•‰∏Ä‰∏ã \(f_i\) ËÉΩ‰∏çËÉΩÂ¢ûÂ§ßÔºåÂ¶ÇÊûúËÉΩÂ¢ûÂ§ßÂ∞±‰∏ÄÁõ¥Â¢ûÂ§ßÂà∞‰∏çËÉΩÂ¢ûÂ§ßÂ∞±Ë°å‰∫Ü„ÄÇÊ£ÄÈ™åÂè™ÈúÄË¶ÅÂú® SAM ‰∏äÊâæÂà∞Ë¶ÅÊ£ÄÈ™åÁöÑ‰∏≤Âú®Êüê‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÊúÄÂêéÂá∫Áé∞‰ΩçÁΩÆÂ∞±Â•ΩÔºåËøôÂæàÂÆπÊòìÁî® SAM + Á∫øÊÆµÊ†ëÂÆûÁé∞Ôºà‰πüÂèØ‰ª•Áî®ÂÖ∂‰ªñÊñπÂºèÔºâ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™‰ºöÂ¢ûÂ§ß \(\mathcal O(n)\) Ê¨°ÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// ÊúâÊ≤°ÊúâÂè≥Á´ØÁÇπÂú® x Êàñ‰πãÂâçÁöÑint check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Êàë‰ª¨ÂÖà‰∏çË¶ÅËÄÉËôëËæπÊùÉ„ÄÇ ËÄÉËôëÁõ¥Êé• dpÔºå\(dp[u][i][j]\) Ë°®Á§∫ \(u\) ÁöÑÂ≠êÊ†ë‰∏≠‰øÆÊîπÂêéÊúâ \(i\) ‰∏™ÈªëÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøúÁöÑ‰∏éÂ≠êÊ†ë‰∏≠ÊâÄÊúâÈªëÁÇπË∑ùÁ¶ªÈÉΩÂ§ß‰∫é \(x\) ÁöÑÁ∫¢ÁÇπ‰∏éÊ†πÁöÑË∑ùÁ¶ª‰∏∫ \(j\)ÔºåÊúÄÂ∞èË¶Å‰øÆÊîπÂá†Ê¨°„ÄÇËΩ¨ÁßªÁöÑÊó∂ÂÄôÈúÄË¶ÅÂÜ≥ÂÆöË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÁ∫¢ÁÇπÔºåÊâÄ‰ª•ÈúÄË¶ÅÁü•ÈÅìË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÁöÑË∑ùÁ¶ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊàë‰ª¨ÂÜçËÆ∞‰∏Ä‰∏™ÊúÄËøëÈªëÁÇπÁöÑËØùÂ§çÊùÇÂ∫¶Â∞±ÁÇ∏‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞‰∏Ä‰∏™ÊÄßË¥®ÔºöÂ¶ÇÊûúÊ†πÊòØÁ∫¢ÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÊâÄÂú®ÁöÑ(Ê†πÁöÑÂÑøÂ≠êÁöÑ)Â≠êÊ†ë‰∏≠‰∏ÄÂÆöÊâÄÊúâÁ∫¢ÁÇπÈÉΩÂèØ‰ª•Âú®Ëøô‰∏™Â≠êÊ†ë‰∏≠ÊâæÂà∞Ë∑ùÁ¶ª‰∏çË∂ÖËøá \(x\) ÁöÑÈªëÁÇπ„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπ \(j = 0\) ÁöÑÊÉÖÂÜµÈ¢ùÂ§ñËÆ∞ÂΩï‰∏ãÊúÄËøëÁöÑÈªëÁÇπ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª• dp ‰∫Ü„ÄÇ Áé∞Âú®Êù•ËÄÉËôë‰∏Ä‰∏ãËæπÊùÉÔºåÊ≥®ÊÑèÂà∞Êàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåËøôÊ†∑Â∞±ËÉΩÂÅöÂ∏¶ÊùÉÁöÑÊÉÖÂÜµ‰∫Ü„ÄÇ ÂÜÖÂ≠òÈúÄË¶ÅÂç°‰∏Ä‰∏ã„ÄÇ È¢òËß£Á´üÁÑ∂ÊòØÂØπ \(500\) Á∫ßÂà´ÁöÑ‰∏úË•øË∑ëÂçïÁ∫ØÂΩ¢Ôºå‰∏çÂ§™ËÉΩÁêÜËß£Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇÁªèËøáËâ∞ÈöæÁöÑË∞ÉËØïÂíåÂç°Â∏∏Áªà‰∫é A ‰∫Ü„ÄÇÔºàÊó∂Èôê 1000 msÔºåÂºÄ Ofast 982 msÔºå‰∏çÂºÄ Ofast 998 msÔºåTATÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : Êúâ i ‰∏™ÈªëÁÇπÔºåÊâÄÊúâÁ∫¢ÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j // g : Êúâ i ‰∏™ÈªëÁÇπÔºåÊ≤°ÊúâÊú™ÂåπÈÖçÁ∫¢ÁÇπÔºåËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÈªëÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Âä®ÊÄÅËßÑÂàí</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÖàÊ±ÇÈáçÂøÉÔºöÈöè‰æøÊâæ‰∏™ÁÇπÔºåÊääÂ§öËæπÂΩ¢ÂàíÂàÜÊàêËã•Âπ≤‰∏™‰∏âËßíÂΩ¢ÔºåÊ±ÇÂá∫ÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºåÊåâÊúâÂêëÈù¢ÁßØÂä†ÊùÉÂπ≥Âùá„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁÇπ \((x_p,y_p)\)ÔºåËÆæ \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)„ÄÇÊääÂÆÉÁªï \((x_0,y_0)\) ÈÄÜÊó∂ÈíàÊóãËΩ¨ \(c\) ÂºßÂ∫¶ÔºåÁõ∏ÂΩì‰∫éÊää \(p\) Â∑¶‰πò‰∏Ä‰∏™Áü©Èòµ \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)„ÄÇÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ \(3 \times 3\) Áü©ÈòµÂ∞±ËÉΩÂø´ÈÄüËé∑ÂæóÊØè‰∏™ÁÇπÁöÑ‰ΩçÁΩÆ„ÄÇÊóãËΩ¨Êó∂ËÄÉËôë‰∏Ä‰∏ãÂõ∫ÂÆöÁöÑÁÇπÂíåÈáçÂøÉÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ Âê¨ÔºàÈ¢òËß£‰∏äÔºâËØ¥ÈúÄË¶ÅÊää‰∏Ä‰∏™ÁÇπÁßªÂà∞ \((0,0)\) ÈÅøÂÖçÁ≤æÂ∫¶ËØØÂ∑Æ„ÄÇ‰∏çÁü•ÈÅì‰∏çËøôÊ†∑ËÉΩ‰∏çËÉΩËøá„ÄÇ ÔºàÊ†∑‰æã 2 ÁúüÁöÑ‰ºöËΩ¨ÂêóÔºüÔºâ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n+m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // Áé∞Âú®Áî® p2 ÊóãËΩ¨ Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁúãÊàêÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™ÁÇπÊó∂‰ºöÁªôÂÆÉÊâÄÂú®ÁöÑËøûÈÄöÂùóÊØè‰∏™ÁÇπ‰∏Ä‰∏™Ë¥°ÁåÆ„ÄÇ ÂØπÊØè‰∏™ÁÇπÂØπ \((u,v)\) ËÆ°ÁÆó \(v\) ‰ºöÁªô \(u\) ‰∏Ä‰∏™Ë¥°ÁåÆÁöÑÊ¶ÇÁéáÔºå Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°à„ÄÇ È¢òÁõÆ‰∏≠ÁªôÂÆöÁöÑÂõæÊòØ‰∏ÄÊ£µÂü∫ÁéØÊ†ë„ÄÇ ÂØπ‰∫é \(u = v\)ÔºåËøô‰∏™Ê¶ÇÁéáÊòØ \(1\)„ÄÇÂØπ \(u \neq v\)ÔºåÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö ‰∏ÄÔºå \(u,v\) Âú®Âêå‰∏Ä‰∏™Â≠êÊ†ë‰∏≠„ÄÇÊää \(u\) Áúã‰ΩúÊ†πÔºåÈÇ£‰πàËøô‰∏™Ê¶ÇÁéáÂ∞±ÊòØÔºåÊØèÊ¨°‰ªéËøòÊú™Ë¢´Âà†Èô§ÁöÑÁÇπ‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÁÇπÔºåÂ∞ÜÂÖ∂Â≠êÊ†ëÂà†Èô§ÔºåÂΩì \(v\) Ë¢´Âà†Èô§Êó∂Ôºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÈô§‰∫Ü \(v\) ‰ª•Â§ñÁöÑÁÇπÈÉΩËøòÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéá„ÄÇËÆæÊÄªÂÖ±Êúâ \(n\) ‰∏™ÁÇπÔºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÊúâ \(k\) ‰∏™ÁÇπÔºåÁ±ª‰ººÁåé‰∫∫ÊùÄ‰∏ÄÈ¢ò‰∏≠ÁöÑÊäÄÂ∑ßÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìËøô‰∏™Ê¶ÇÁéáÁ≠â‰∫é‰∏çÊñ≠‰ªé \([1,n]\) ‰∏≠Á≠âÊ¶ÇÁéáÈöèÊú∫Âèñ‰∏Ä‰∏™Êï¥Êï∞Ôºå‰∏ÄÊó¶Âá∫Áé∞ \(v\) Êàñ \(v\) ÁöÑÁ•ñÂÖàÂ∞±ÂÅúÊ≠¢ÔºåÂÅúÊ≠¢Êó∂Èô§ \(v\) ‰ª•Â§ñ \(v\) ÁöÑÊâÄÊúâÁ•ñÂÖàÈÉΩÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéáÔºåÂç≥ \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)„ÄÇ ‰∫åÔºå\(u,v\) ‰∏çÂú®Âêå‰∏ÄÂ≠êÊ†ë‰∏≠Ôºå‰∏éÊÉÖÂÜµ‰∏ÄÁ±ª‰ººÔºå‰ΩÜÊòØ‰∏çÂêåÁöÑÊòØÊ≠§Êó∂ \(u\) Âà∞ \(v\) Êúâ‰∏§Êù°Ë∑ØÂæÑÔºåÂè™Ë¶ÅÂÖ∂‰∏≠‰∏ÄÊù°Â≠òÂú®Â∞±ÊúâË¥°ÁåÆ„ÄÇÂèØ‰ª•ÂÆπÊñ•ÊàêÁ¨¨‰∏ÄÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂä†‰∏äÁ¨¨‰∫åÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂáèÂéª‰∏§Êù°ÈÉΩÂ≠òÂú®ÁöÑÊ¶ÇÁéá„ÄÇËøô‰∏â‰∏™ÈóÆÈ¢òÈÉΩÂèØ‰ª•Á±ª‰ººÊÉÖÂÜµ‰∏ÄÂú∞Ëß£ÂÜ≥„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n^2)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÊú¨È¢ò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊÉ≥‰∫ÜÊå∫‰πÖÂè™‰ºöËÉ°‰∏™ \(\mathcal O(n \sqrt n \log n)\) ÁöÑËé´Èòü + Áª¥Êä§ huffman Ê†ëÔºåÂéªÁúã‰∫ÜÁúºÂà´‰∫∫ÁöÑÈ¢òËß£ÂèëÁé∞‰πüÊúâÊòØËøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ.....‰∏çËøáÊØîÊàëËÉ°ÁöÑÂ¶ôÂ§ö‰∫ÜÔºå‰∏ãÈù¢ÂÜôÁöÑÊòØÁúãÂà∞ÁöÑÂà´‰∫∫ÁöÑÂÅöÊ≥ï„ÄÇ Áî®Ëé´ÈòüÂ§ÑÁêÜËØ¢ÈóÆÔºåÁª¥Êä§‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÔºåÂπ∂ËÆ∞ÂΩï‰∏ãÂΩìÂâçÂá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞„ÄÇÂØπÊ¨°Êï∞‰∏çË∂ÖËøá \(x\) ÁöÑÊï∞ÔºåËÆ∞‰∏Ä‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÁÑ∂Âêé \(\mathcal O(x)\) ÁÆóÂá∫ÂêàÂπ∂‰ª£‰ª∑„ÄÇËΩ¨Âåñ‰∏∫Âè™ÊúâÂá∫Áé∞Ê¨°Êï∞Ë∂ÖËøá \(x\) ÁöÑÊï∞ÁöÑÊÉÖÂÜµÔºåËøôÊó∂ÊúÄÂ§öÂè™Êúâ \(\frac n x\) ‰∏™Êï∞ÔºåË¥™ÂøÉÂêàÂπ∂Âç≥ÂèØ„ÄÇËØ¢ÈóÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(x + \frac n x \log n)\)ÔºåÂèñ \(x = \sqrt {n \log n}\)ÔºåÂàô‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\sqrt {n \log n}\)„ÄÇ Ëé´ÈòüÁª¥Êä§Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞Êó∂ÂèØ‰ª•‰ΩøÁî®ÈìæË°®ÔºåËøôÊ†∑ÁöÑËØùËé´ÈòüÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï È¢òÁõÆ‰∏≠ÁöÑËøûËæπÊñπÂºèÂèØ‰ª•Ê¶ÇÊã¨‰∏∫ÔºåÂ¶ÇÊûú(ÂºÄ)Âå∫Èó¥ \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∫§‰∏ç‰∏∫Á©∫Ôºå‰∏î \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∏çÊòØ‰∏ÄÂØπÂ≠òÂú®ÂåÖÂê´ÂÖ≥Á≥ªÁöÑÂå∫Èó¥ÔºåÈÇ£‰πàËøô‰∏§‰∏™Âå∫Èó¥‰πãÈó¥Êúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇÂê¶ÂàôÔºåÂ¶ÇÊûú \((l_1,r_1)\) Ë¢´ \((l_2,r_2)\) ÂåÖÂê´Ôºå\((l_1,r_1)\) Âà∞ \((l_2,r_2)\) Êúâ‰∏ÄÊù°ÊúâÂêëËæπ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™‰ªÖÁî±ÂèåÂêëËæπÊûÑÊàêÁöÑËøûÈÄöÂùóÔºåËÆæËøô‰∏™ËøûÈÄöÂùó‰∏≠ÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂‰∏∫ \((L,R)\)ÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ§‰∏∫Áé∞Âú®Â∞±Â≠òÂú®ËøôÊ†∑‰∏Ä‰∏™Âå∫Èó¥ \((L,R)\)„ÄÇÂõ†‰∏∫ÈïøÂ∫¶ÊòØÈÄíÂ¢ûÁöÑÔºåÂ¶ÇÊûú‰πãÂêéÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ \((a,b)\)Ôºå\(a\) Ë¢´ \((L,R)\) ÂåÖÂê´ÊàñËÄÖ \(b\) Ë¢´ \((L,R)\) ÂåÖÂê´ÔºåÈÇ£‰πà \((a,b)\) ‰∏éËøô‰∏™ËøûÈÄöÂùó‰∏≠ÁöÑÊüê‰∏™ÁÇπÊúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇ‰∏çÈöæÂèëÁé∞Ôºå‰∏Ä‰∏™Âå∫Èó¥ \(a\) ËÉΩÂà∞ËææÂå∫Èó¥ \(b\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(a\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Ë¢´ \(b\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂ÂåÖÂê´„ÄÇËøôÊ†∑Êàë‰ª¨Âè™Ë¶ÅÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ËøûÈÄöÂùóÔºåÂπ∂ËÆ∞ÂΩï‰∏Ä‰∏ãËøûÈÄöÂùóÁöÑÂπ∂ÁöÑÂ∑¶Âè≥Á´ØÁÇπÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ËÉΩÂê¶Âà∞Ëææ‰∫Ü„ÄÇ update : ‰ªîÁªÜËØÅ‰∫Ü‰∏Ä‰∏ã‰πãÂêé‰ºº‰πéËøô‰∏ÄÁªìËÆ∫ÂÜç‰∏§‰∏™ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Áõ∏ÂêåÊó∂‰∏çÊàêÁ´ãÔºåÈúÄË¶ÅÁâπÂà´Âà§‰∏Ä‰∏ã‰ºö‰∏ç‰ºöÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂè™Êúâ‰∏Ä‰∏™ÁÇπ„ÄÇ Êàë‰ª¨Áî®Á∫øÊÆµÊ†ëÁª¥Êä§ÔºåÂØπ‰∫éÊØè‰∏™ÁÇπÊúâÂì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´Ëøô‰∏™ÁÇπ„ÄÇËøôÂèØ‰ª•ÈÄöËøáÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™ÁÇπÂºÄ‰∏Ä‰∏™ vector Êù•ÂÆûÁé∞ÔºåÊü•ËØ¢Âì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´‰∏Ä‰∏™ÁÇπÊó∂ÔºåÂè™ÈúÄÂèñËøô‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâ vector ÁöÑÂπ∂Âç≥ÂèØ„ÄÇÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÔºåÂ∞±ÂØπÂ∑¶Âè≥Á´ØÁÇπÊü•‰∏Ä‰∏ãÔºåÊääÂæóÂà∞ÁöÑËøûÈÄöÂùóÂêàÂπ∂ÔºåÁÑ∂ÂêéÂÜçÊääÊñ∞ÁöÑËøûÈÄöÂùóÂä†ÂÖ•Á∫øÊÆµÊ†ë„ÄÇÁî±‰∫éÊâÄÊúâË¢´‰Ω†Êü•ËøáÁöÑÁÇπ vector ‰∏≠ÊâÄÊúâÁÇπÈÉΩ‰ºöË¢´‰Ω†ÂêàÂπ∂ÔºåÊâÄ‰ª•‰Ω†ÊØèÊü•ËØ¢‰∏Ä‰∏™ÁÇπÁöÑ vector Â∞±ÂèØ‰ª•ÊääÂÆÉÁöÑ vector Ê∏ÖÁ©∫ÔºåËÄåÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÊúÄÂ§öÂ¢ûÂä†‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†Âè™‰ºöÁªô \(\mathcal O(\log n)\) ‰∏™ÁÇπÁöÑ vector Ê∑ªÂä†ÂÖÉÁ¥†„ÄÇÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n \alpha (n))\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x ÊòØÊ†πÔºåÊää y Âä†ÂÖ• xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰ΩúÈáçÈìæÂâñÂàÜÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÈáçÈìæÂâñÂàÜÂêéÁöÑ dfs Â∫è„ÄÇ ‰∏ÄÊù°ÈìæÂèØ‰ª•ÊãÜÊàê dfs Â∫è‰∏ä \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥„ÄÇ Êåâ dfs Â∫èÊääÊØè‰∏™ÁÇπÁöÑÂ≠óÁ¨¶ÊéíÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\)ÔºåÈ¢ÑÂÖàÂª∫‰∏Ä‰∏™ËÉΩ \(\mathcal O(1)\) ËØ¢ÈóÆ \(s\) ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcpÔºåËØ¢ÈóÆ \(s^R\) ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcp ÂíåËØ¢ÈóÆ‰∏Ä‰∏™ \(s\) ÁöÑÂêéÁºÄÂíå \(s^R\) ÁöÑ‰∏Ä‰∏™ÂêéÁºÄÁöÑ lcp ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂèØ‰ª•ÂØπ \(ss^R\) Âª∫Ê†ëÁä∂Êï∞ÁªÑÔºåÂõ†‰∏∫Êàë‰∏çÊìÖÈïøÂÜôÊ†ëÁä∂Êï∞ÁªÑÔºåÊâÄ‰ª•ÊàëÂØπÂÆÉ‰ª¨Áî® SAM Ê±ÇÂá∫‰∫ÜÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂÜô‰∫Ü‰∏Ä‰∏™ \(\mathcal O(n\log n) - \mathcal O(1)\) lca„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆÔºå‰∏ÄÊù°ÈìæÔºåÂèØ‰ª•ÁúãÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÔºåÊâÄ‰ª•Â∞±ÂèòÊàê‰∫Ü‰∏§ÁªÑËã•Âπ≤‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÁöÑ‰∏≤Ë¶ÅÊ±Ç lcpÔºåÂà©Áî®È¢ÑÂ§ÑÁêÜÁöÑ‰ø°ÊÅØ‰ªéÂâçÂæÄÂêé‰æùÊ¨°Ê±ÇÂ∞±Ë°å‰∫Ü„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // ÂÜô‰∏Ä‰∏™Áªô‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊîØÊåÅËØ¢ÈóÆ LCP ÁöÑ‰∏úË•ø int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind ÊòØÊ≠£‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ // rind ÊòØÂèç‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôëÊåâ‰∏≤ÈïøÊ†πÂè∑ÂàÜÁ±ª„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ§ß‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåËøôÊ†∑ÁöÑ‰∏≤‰∏ç‰ºöÂæàÂ§öÔºåÊûö‰∏æÊØè‰∏™ËøôÊ†∑ÁöÑ‰∏≤ÔºåÁî® AC Ëá™Âä®Êú∫ÁªüËÆ°ÂÖ∂‰ªñÊØè‰∏™‰∏≤‰Ωú‰∏∫Ëøô‰∏™‰∏≤Â≠ê‰∏≤Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÆó‰∏Ä‰∏ãÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÂõûÁ≠î‰∏Ä‰∏ãÂÖ≥‰∫éËøô‰∏™‰∏≤ÁöÑÊâÄÊúâËØ¢ÈóÆ„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ∞è‰∫éÁ≠â‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåÊääËØ¢ÈóÆ \([l,r]\) ÊãÜÊàê \([1,r]\) Âíå \([1,l-1]\) Áõ∏ÂáèÔºåÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÊØè‰∏™ÂâçÁºÄÔºåÂõûÁ≠î‰∏éÊØè‰∏™ÂâçÁºÄÁõ∏ÂÖ≥ÁöÑÊâÄÊúâÂõûÁ≠î„ÄÇÂú®Êâ´ÂâçÁºÄÁöÑËøáÁ®ã‰∏≠ÔºåÁî®‰∏Ä‰∏™ AC Ëá™Âä®Êú∫ \(\mathcal O(‰∏≤Èïø)\) ËØ¢ÈóÆËøô‰∏™ÂâçÁºÄ‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êüê‰∏™‰∏≤ÁöÑÂ≠ê‰∏≤Âç≥ÂèØ„ÄÇÈÇ£‰πàÂè™ÈúÄË¶ÅÂú® AC Ëá™Âä®Êú∫‰∏äÂÆûÁé∞‰∏Ä‰∏™ fail Ê†ë‰∏äÁöÑÂ≠êÊ†ëÂä†ÔºàÂä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑ‰∏≤ÔºâÔºåÂú® dfs Â∫è‰∏äËΩ¨‰∏∫Âå∫Èó¥Âä†ÔºåÁî®ÂàÜÂùóÂÅöÂà∞ \(\mathcal O(\sqrt n)\) Âå∫Èó¥Âä†Ôºå \(\mathcal O(1)\) ÂçïÁÇπËØ¢ÈóÆÂ∞±Ë°å‰∫Ü„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÂèØ‰ª•‰∫åÂàÜÁ≠îÊ°àÔºåËΩ¨Âåñ‰∏∫ËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºöÊØè‰∏™ËæπÁöÑËæπÊùÉÊòØÊ≠£Ë¥ü‰∏ÄÔºåÂà§Êñ≠ÊòØÂê¶ÊúâÈïøÂ∫¶Âú® \(l\) Âà∞ \(r\) ‰πãÈó¥ÁöÑË∑ØÂæÑÔºåÊùÉÂÄº‰πãÂíåÈùûË¥ü„ÄÇ ‰ªé‰∏ãÂæÄ‰∏äÂêàÂπ∂ÔºåÊØèÊ¨°ËÄÉËôëÂΩìÂâçÁÇπ‰Ωú‰∏∫ lca ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊääÂ≠êÊ†ëÂêàÂπ∂ÔºåÁî±‰∫é‰Ω†ÂêàÂπ∂Êó∂Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁÇπÂ≠êÊ†ë‰∏≠ÊØè‰∏™Ê∑±Â∫¶Âà∞Ê†πÊùÉÂÄºÂíåÊúÄÂ§ßÁöÑÁÇπÔºåÂèØ‰ª•Áî®ÈïøÈìæÂâñÂàÜÊù•Áª¥Êä§Ê∑±Â∫¶‰ø°ÊÅØ„ÄÇÂêàÂπ∂ÁöÑÊó∂ÂÄôÈ°∫‰æøËØ¢ÈóÆ‰∏Ä‰∏ãÁ≠îÊ°àÔºåÈïøÈìæÂâñÂàÜ + Á∫øÊÆµÊ†ëÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÈïøÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁÇπÂàÜÊ≤ª‰∏Ä‰∏ãÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãÈóÆÈ¢òÔºö Êúâ‰∏§‰∏™Èïø‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a_1\) Âíå \(d_1\)Ôºå‰∏§‰∏™Èïø‰∏∫ \(m\) ÁöÑÊï∞ÁªÑ \(a_2\) Âíå \(d_2\)ÔºåÊ±ÇÔºö \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] Êûö‰∏æ‰∏Ä‰∏ã \(i\)ÔºåÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂΩ¢Â¶Ç \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) ÁöÑ‰∏úË•ø„ÄÇ Ê≥®ÊÑèÂà∞ \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) ËÆæ \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) ÊòØÂæàÂÆπÊòìÂ§ÑÁêÜÁöÑÔºåÂè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(1\ldots m\) ‰∏≠ÁöÑÊï∞ \(i\) ËÄÉËôë \(d_2[i]\phi(a_2[i])\) ÂØπÊØè‰∏™ \(s\) ‰∏≠ \(i\) ÁöÑÁ∫¶Êï∞‰∏ãÊ†á‰ΩçÁΩÆÁöÑË¥°ÁåÆÂç≥ÂèØ„ÄÇ Â¶ÇÊûúÊö¥ÂäõËÆ°ÁÆó‰∏äÂºèÔºåÂ§çÊùÇÂ∫¶‰∏∫ \(1 \ldots n\) ‰∏≠ÊØè‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞‰πãÂíå‰πò‰ª•ÁÇπÂàÜÊ≤ªÁöÑ‰∏Ä‰∏™ \(\log\)„ÄÇÂâçÈù¢ÁöÑÈÉ®ÂàÜÂ§çÊùÇÂ∫¶ÊòØ \(\log^2\) ÁöÑÔºàËÄÉËôë \((\sum \frac 1 i )^2\)ÔºâÔºå‰ªéËÄåÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\log^3 n)\)„ÄÇ ÁªßÁª≠ÂØπ‰∏äÂºèÂèòÂΩ¢Ôºö ËÆæ \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)Ôºå\(t_k\) ÊòØ‰∏Ä‰∏™Â∏∏Êï∞„ÄÇ \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] ËÄÉËôëÂØπ \(t\) ËøõË°åÈ¢ÑÂ§ÑÁêÜ„ÄÇ\(t\) ÊòØ‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞ÔºàÂõ†‰∏∫ÂÆÉÊòØ‰∏§‰∏™ÁßØÊÄßÂáΩÊï∞ÁöÑÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºâÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•ÊääÂÆÉÁ≠õÂá∫Êù•„ÄÇ ‰ΩÜÊòØÂõ†‰∏∫ÊàëÊáíÔºåÊàëÈÄâÊã©Áõ¥Êé•Êö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(t\)ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;„ÄÇÔºå &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Êï∞ËÆ∫</tag>
        <tag>ÁÇπÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Èöè‰æøÂèñ‰∏Ä‰∏™ÁÇπ‰ΩúÊ†πÔºåÁî®Á∫øÊÆµÊ†ëÊåâ dfs Â∫èÁª¥Êä§Â≠òÂú®ÁöÑÁÇπÔºåÁª¥Êä§‰∏Ä‰∏ãÊâÄÊúâÂ≠òÂú®ÁöÑÁÇπÁöÑ lca ÂíåÂà∞Ê†πÁöÑË∑ØÂæÑÁöÑÂπ∂ÁöÑÈïøÂ∫¶Âç≥ÂèØ„ÄÇ ËØØ‰ª•‰∏∫Ë¶ÅÂáèÂéªÁÇπÊï∞ * lca ÁöÑÊ∑±Â∫¶ÔºåË∞É‰∫ÜÂ•Ω‰πÖ... ‰∏ÄÁõ¥Ë∞É‰∏çÂá∫Êù•ÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•‰∏Ä‰∏ãÊòØ‰∏çÊòØÂì™ÈáåÊÉ≥Èîô‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈúÄË¶ÅÁªèÂ∏∏Â§ç‰π†ÁöÑ‰∏úË•ø]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÊÑüËßâËá™Â∑±ËÄÉËØïÁöÑÊó∂ÂÄôÂæàÈöæÁã¨Á´ãÊÉ≥Âá∫Êù•‰ΩÜÊòØÂèàÁªèÂ∏∏‰ºöÂøòÁöÑ‰∏úË•ø„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπËßÅ ËøôÁØá blogÔºåËÄÉÂâçÂ§ç‰π†Áî®„ÄÇ Ê•ºÊàøÈáçÂª∫ÁöÑÂÅöÊ≥ï (2020.03.09) ÊîØÈÖçÊ†ë ‰ºØÂä™Âà©Êï∞‰∏éËá™ÁÑ∂Êï∞ÂπÇÂíå Ëá™ÁÑ∂Êï∞ÁöÑÔºàÂèØÈáç / ‰∏çÂèØÈáçÔºâÊó†Â∫èÊãÜÂàÜÔºöÊ†πÂè∑ÂÅöÊ≥ï‰∏é \(\log\) ÂÅöÊ≥ï jlsÁ∫øÊÆµÊ†ë ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó‰∏éÁ±ªÊ¨ßÂá†ÈáåÂæó Â§ÑÁêÜÂàÜÊØçÁ≠âÂ∑ÆÁîüÊàêÂáΩÊï∞ÁöÑÊñπÊ≥ï ‰Ω†ÁöÑÂêçÂ≠ó ÈÇ£‰∏™È¢òÁöÑÂÅöÊ≥ï ÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÊãìÊâëÂ∫è(ÊåáÊåâÁºñÂè∑‰ªéÂ∞èÂà∞Â§ßÊääÊØè‰∏™ÁÇπÂú®ÊãìÊâëÂ∫è‰∏äÁöÑ‰ΩçÁΩÆÂÜô‰∏ãÊù•ÁöÑÂ∫èÂàó)ÔºåËßÅ agc001_f Âà©Áî®Êó∂Èó¥Êà≥Á∫øÊÄßÂü∫ (ÊåâÊØè‰∏™ÂÖÉÁ¥†Ë¢´Âà†Èô§ÁöÑÊó∂Èó¥) ÂÆûÁé∞Á¶ªÁ∫øËøõË°å‰∏çÂ∏¶ log ÁöÑÁ∫øÊÄßÂü∫ÊèíÂÖ•Âà†Èô§ Âà§Á∫øÊÄßÊó†ÂÖ≥Êó∂ÊääÂÆûÊï∞ÊîπÊàêÂèñÊ®°Âπ∂‰∏ç‰ºöÊúâÂ§™Â§ßÊçüÂ§±ÔºåÁ±ª‰ººÂìàÂ∏åÔºàÈÄêÊ≠•ËÄÉËôëÁü©ÈòµÁöÑÂèòÂåñ~ÔºåÂÖ∂ÂÆûÂè™Ë¶Å‰∏çÂá∫Áé∞Ê®°Êï∞ÂÄçÊï∞Â∞±Ë°å Èìæ‰∏äËØ¢ÈóÆ / Âå∫Èó¥ËØ¢ÈóÆÂ∞è‰∫éÁ≠â‰∫é \(k\) (k ÊØèÊ¨°ÁªôÂÆö) ÁöÑÂÖÉÁ¥†ÁöÑ‰ø°ÊÅØ (‰∏çÂèØÂáè)ÔºåÊúâÂäûÊ≥ï‰∏Ä‰∏™ \(\log\) ÁÇπÂèåËÅîÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï (ÂÜô‰∫ÜÁØáÂÖ¨ÂºÄ blog) ‰∏ÄÁ±ª‰∫åÂàÜÂá∏‰ºòÂåñËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ï ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÂÖ∂Êâ©Â±ï ËÆ∞ÂæóÂç∑ÁßØÂΩ¢ÂºèÁöÑ dp ÂèØ‰ª•ÂàÜÊ≤ª fft ‰ºòÂåñ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éÂõûÊªöÊìç‰ΩúÁöÑÊäÄÂ∑ßÂú®ÈúÄË¶ÅÂõûÊªöÁöÑÊï∞ÁªÑÊØîËæÉÂ§öÁöÑÊó∂ÂÄô‰∏Ä‰∏™‰∏Ä‰∏™ÂºÄÊ†àÂõûÊªö‰ºöÊØîËæÉÈ∫ªÁÉ¶ÔºåÂèØ‰ª•ËØïÁùÄ‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; ËøôÊ†∑ËøòÂéüÁöÑÊó∂ÂÄô‰πüÂè™ÈúÄË¶ÅÊ†πÊçÆÊåáÈíàÊêû‰∏ÄÊêûÂ∞±Â•ΩÔºåÂè™ÈúÄË¶ÅÂºÄ‰∏Ä‰∏™Ê†àÂ∞±Ë°å‰∫ÜÔºåÊ≥®ÊÑè \(k\) ‰∏çË¶ÅÂºÄÂ∞è„ÄÇ ÊúâÊó∂ÂÄô‰Ω†ÈúÄË¶ÅËÆ∞ÂΩï‰∏Ä‰∏™ÊîØÊåÅÈöèÊó∂Ê∏ÖÁ©∫ÁöÑ \(01\) Êï∞ÁªÑÔºåËøôÊó∂ÂèØ‰ª•‰∏çÈ¢ùÂ§ñÂºÄÊ†áËÆ∞Êï∞ÁªÑ„ÄÇËÆ∞‰∏Ä‰∏™ÂèòÈáè \(tim\)ÔºåËµã \(1\) ÁöÑÊó∂ÂÄôÂ∞±ËÆæ‰∏∫ \(tim\)ÔºåÂà§Êñ≠ÊòØ \(0\) ËøòÊòØ \(1\) Â∞±ÁúãÊòØÂê¶Á≠â‰∫é \(tim\)ÔºåÊ∏ÖÁ©∫Â∞± \(tim \leftarrow tim + 1\)„ÄÇ ‰∏ä‰∏ãÁïåË¥πÁî®ÊµÅÔºåÂØπÊØèÊù°ÂøÖÈ°ªËæπ‰∏çË¶ÅÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂØπÊØè‰∏Ä‰∏™ÁÇπËÆ∞‰∏Ä‰∏™Â∫¶Êï∞ÔºåÂÖ®ÈÉ®Ê∑ªÂä†‰πãÂêéÂÜçÊ†πÊçÆÂ∫¶Êï∞ÂÜ≥ÂÆöÊØè‰∏™ÁÇπÂà∞Ë∂ÖÁ∫ßÊ∫êËøòÊòØË∂ÖÁ∫ßÊ±áÔºåËøûÂ§öÂ§ßÊµÅÈáèÁöÑËæπÔºåËøôÊ†∑ÂèØ‰ª•Â§ßÂ§ßÂáèÂ∞ëËæπÊï∞„ÄÇ Âú®ÂÅö dinic Êó∂‰ª•‰∏ã‰∏§‰ªΩ‰ª£Á†ÅÊúâÂ∑®Â§ßÂ∏∏Êï∞Â∑ÆË∑ùÔºå‰∏ãÈù¢ÁöÑÊúâÊó∂ÁîöËá≥ÂèØ‰ª•ÊØî‰∏äÈù¢ÁöÑÂø´ÂçÅÂÄçÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà„ÄÇ 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊääÊìç‰ΩúÁ¶ªÁ∫øÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºåÊääÈóÆÈ¢òÂèòÊàêÂè™ÈúÄË¶ÅÊîØÊåÅÂä†ËæπÔºåÂõûÊªöÔºåÁª¥Êä§‰∏§ÁÇπÈó¥ÊúÄÂ∞è \(xor\) Ë∑ØÂæÑ„ÄÇ Âú®ËØ¢ÈóÆ \(u,v\) ‰∏≠Ôºå‰Ω†ÂèØ‰ª•‰ªé \(u\) Ëµ∞Âà∞ \(t\) ÁÑ∂ÂêéËµ∞Âõû \(u\)ÔºåË∑ØÂæÑ‰∏äÊØèÊù°ËæπÈÉΩË¢´ÁªèËøá‰∏§Ê¨°ÔºåÊâÄ‰ª•Ë∑ØÂæÑ‰∏äÁöÑËæπË¥°ÁåÆ‰∏∫ \(0\)„ÄÇÂõ†Ê≠§Â¶ÇÊûúÊúâ‰∏ÄÊù° \(xor\) ‰∏∫ \(x\) ÁöÑ \(u,v\) Ë∑ØÂæÑÔºåÊúâ‰∏Ä‰∏™ \(xor\) ‰∏∫ \(c\) ÁöÑÁéØÔºåÂ∞±Â≠òÂú®‰∏ÄÊù° \(xor\) ‰∏∫ \(x\oplus c\) ÁöÑË∑ØÂæÑ„ÄÇ ‰ªªÊÑèËÄÉËôë‰∏ÄÊ£µÁîüÊàêÊ†ëÔºåÂØπ‰∫é‰∏Ä‰∏™ÈùûÊ†ëËæπ \(u,v,w\)ÔºåËÆæ \(u\) Âà∞ \(v\) ÁöÑÊ†ë‰∏äË∑ØÂæÑ \(xor\) ‰∏∫ \(x\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ \(xor\) ‰∏∫ \(x \oplus w\) ÁöÑÁéØÔºåÂõ†Ê≠§Â¶ÇÊûúÁªèËøá‰∫ÜËøôÊù°ÈùûÊ†ëËæπÔºåÊàë‰ª¨‰∏çÂ¶®ÊääÂÆÉÁúãÊàêÊòØÊ≤øÁùÄÊ†ë‰∏äË∑ØÂæÑ‰ªé \(u\) Ëµ∞Âà∞ \(v\)„ÄÇ‰πãÂêéÂÜçÂºÇÊàñ‰∏äËøô‰∏™Êç¢ÁöÑÊùÉÂÄº„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÊää \(u\) Âà∞ \(v\) ‰πãÈó¥ÁöÑÊ†ë‰∏äË∑ØÂæÑÂºÇÊàñ‰∏ä‰∏Ä‰∫õÁî±‰∏ÄÊù°ÈùûÊ†ëËæπ‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\)ÔºåÁ≠îÊ°àÊúÄÂ∞èÊòØ‰ªÄ‰πà„ÄÇ Áª¥Êä§ÊâÄÊúâÈùûÊ†ëËæπÂä†‰∏ä‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\) ÁöÑÁ∫øÊÄßÂü∫Âç≥ÂèØ„ÄÇ ÁÑ∂ÂêéËÄÉËôëÊÄé‰πàÂä†ËæπÁª¥Êä§Ëøô‰∏™‰∏úË•ø„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂõûÊªöÔºåÂùáÊëäÁÆóÊ≥ïÔºàÂ¶Ç LCTÔºåË∑ØÂæÑÂéãÁº©ÁöÑÂπ∂Êü•ÈõÜÔºâÊó†Ê≥ï‰ΩøÁî®„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊîØÊåÅËØ¢ÈóÆ‰∏§ÁÇπÊòØÂê¶ËøûÈÄöÔºåËØ¢ÈóÆ‰∏§ÁÇπ‰πãÈó¥ÁöÑ \(xor\)ÔºåÂä†ËæπÂíåÂõûÊªöÂç≥ÂèØ„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁªôÁÇπ \(i\) Áª¥Êä§‰∏Ä‰∏™ÂÄº \(v_i\)ÔºåÂàùÂßãÊó∂ÊâÄÊúâÁÇπÁöÑÂÄº \(=0\)ÔºåÁî®ÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÊù•Áª¥Êä§ËøûÈÄöÊÄß„ÄÇÊàë‰ª¨ÂßãÁªàË¶Å‰øùËØÅÂØπ‰∫é‰ªªÊÑèÁöÑ \(u,v\)ÔºåÂ¶ÇÊûú \(u,v\) ËøûÈÄöÔºåÈÇ£‰πà \(u,v\) ‰πãÈó¥Ê†ë‰∏äË∑ØÂæÑÁöÑ \(xor\) Á≠â‰∫é \(v_u \oplus v_v\)„ÄÇÊØèÊ¨°Âä†ËæπÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰∏§‰∏™ËøûÈÄöÂùóÂπ∂Êàê‰∫Ü‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†ÂèØ‰ª•ÈÄöËøáÊääÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑ \(v_i\) ÂºÇÊàñ‰∏ä‰∏Ä‰∏™Êï∞Êù•‰øùÊåÅËøô‰∏ÄÊÄßË¥®„ÄÇÊåâÁß©ÂêàÂπ∂Êó∂Êâì‰∏™ tag Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å ËøôÊ¨°Â∞ùËØï‰∫Ü‰∏ÄÁßçÊñ∞ÁöÑÁ†ÅÈ£é„ÄÇÁúã‰∏äÂéªÂ≠óÁ¨¶ÈáèÂ∞ë‰∫Ü‰∏çÂ∞ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // ÂáÜÂ§áÂ∑¶Âå∫Èó¥ for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // ÂáÜÂ§áÂè≥Âå∫Èó¥ for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊÑüËßâÊØî E È¢òÈöæ‰ΩÜÊòØËøáÁöÑ‰∫∫ËøúÊØî E È¢òÂ§ö... ‰∏çÁü•ÈÅì piece ÊÄé‰πàÁøªËØëÔºåÂêéÈù¢Áî®Áü≥Â≠ê‰ª£Êåá piece„ÄÇ ÂÖàÊûö‰∏æ‰∏Ä‰∏™ÁÇπ \(r\)ÔºåÁÑ∂ÂêéËÄÉËôëÊääÊâÄÊúâÁü≥Â≠êÈÉΩÁßªÂä®Âà∞ÁÇπ \(r\) ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÊää \(r\) ‰Ωú‰∏∫Ê†πÔºåËÄÉËôëÊØè‰∏™Áü≥Â≠êÂà∞ \(r\) ÁöÑË∑ùÁ¶ª‰πãÂíå \(s\)ÔºåÊòæÁÑ∂Êìç‰Ωú‰∏ç‰ºöÊîπÂèò \(s\) ÁöÑÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Â¶ÇÊûú \(s\) ÊòØÂÅ∂Êï∞Ôºå‰∏çÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°à„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°àÔºåÈÇ£‰πàÊúÄÂ∞ëÊ≠•Êï∞ÂøÖÁÑ∂ÊòØ \(\frac s 2\)ÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰∏™ÊñπÊ°à‰∏≠Êúâ‰∏ÄÊ¨°‰Ωø‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ∞èÔºåÂè¶‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ§ßÔºå‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏Ä‰∏™Ê≠•Êï∞Êõ¥Â∞ëÁöÑÁöÑÊñπÊ°à„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âè™ÈúÄËÄÉËôëÂ¶Ç‰ΩïÊ£ÄÈ™åÊñπÊ°àÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™ËÄÉËôë‰∏Ä‰∏™Â≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºå‰∏çÈöæÂèëÁé∞ÊúÄ‰ºòÊñπÊ°à‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏ÄÁßçÂÖàËøõË°åÂÆåÂÖ®Âú®Êüê‰∏™ÂÑøÂ≠êÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÔºåÂÜçËøõË°å‰∏§‰∏™Áü≥Â≠êÂú®‰∏çÂêåÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÁöÑÊñπÊ°à„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂÅöÊ†ëÂΩ¢ dpÔºåËÆæ \(f_{ij}\) Ë°®Á§∫ÊòØÂê¶ÂèØ‰ª•ÂØπ \(i\) ÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÁü≥Â≠êËøõË°åÊìç‰ΩúÔºå‰ΩøÂæó \(i\) Â≠êÊ†ëÂÜÖÈÉ®Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ª‰πãÂíå‰∏∫ \(j\)„ÄÇËÄÉËôëÊÄé‰πàËΩ¨ÁßªÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∫ÜÁÇπ \(u\) ÊØè‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºåÁªèËøáËøô‰∫õÊìç‰ΩúÊó∂ÂÄôÁ¨¨ \(i\) ‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÁü≥Â≠êÂà∞ \(u\) Ë∑ùÁ¶ª‰πãÂíå‰∏∫ \(s_i\)ÔºåÂÖ±Êúâ \(c\) ‰∏™ÂÑøÂ≠êÔºåËÆæ \(\max s_i = t\)ÔºåÂèØ‰ª•ËØÅÊòéÔºå\(f_{uj} = 1\)ÔºåÂΩì‰∏î‰ªÖÂΩì \(j\) ‰∏é \(\sum s_i\) Â•áÂÅ∂ÊÄßÁõ∏ÂêåÔºå‰∏î \(j \ge 2t - \sum s_i\)„ÄÇËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â§™Â§ß‰∫ÜÔºå‰∏çÈöæÂΩíÁ∫≥ËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(f_{ij} = 1\) ÁöÑ \(j\) ÂøÖÁÑ∂ÊòØÊüê‰∏™Âå∫Èó¥ÂÜÖÁöÑÊâÄÊúâÂ•áÊï∞ / ÂÅ∂Êï∞„ÄÇÂà©Áî®Ëøô‰∏™ÊÄßË¥®ÔºåÊàë‰ª¨ dp ‰ΩøÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™Âå∫Èó¥Âç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóËøô‰∏™Âå∫Èó¥ÁöÑÂè≥ËæπÁïåÊó∂ÔºåÂè™ÈúÄÊääÊâÄÊúâÂÑøÂ≠êÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁü≥Â≠êÂà∞Ëøô‰∏™ÂÑøÂ≠êÁöÑË∑ùÁ¶ª‰πãÂíåÈÉΩÂèñÂà∞ÊúÄÂ§ßÂç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóÂ∑¶ËæπÁïåÊó∂ÔºåÊûö‰∏æÂèñÂà∞Â∑¶ËæπÁïåÁöÑÊñπÊ°à‰∏≠Âì™‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) ÊúÄÂ§ßÔºåËÆ©ÂÖ∂‰ªñÂÑøÂ≠êÁöÑ \(s_i\) ÈÉΩÂ∞ΩÈáèÂ∞èÔºåËøô‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) Âú®Â§ß‰∫éÁ≠â‰∫éÂÖ∂‰ªñÂÑøÂ≠êÁöÑÂâçÊèê‰∏ãÂ∞ΩÈáèÂ∞èÔºåÊõ¥Êñ∞‰∏Ä‰∏ãÂ∑¶ËæπÁïåÂç≥ÂèØ„ÄÇÂÖ∑‰ΩìÂÆûÁé∞ÂèØ‰ª•Áúã‰ª£Á†Å„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂæàÊúâÂêØÂèëÊÄßÁöÑÈóÆÈ¢ò...ÂÅö‰∫Ü‰∏ÄÈÅçÊääÂØπ FWT ÁêÜËß£ÁöÑ‰∏çÂΩªÂ∫ïÁöÑÂú∞ÊñπÈÉΩÊêûÊ∏ÖÊ•ö‰∫Ü„ÄÇ ÂÄíËøáÊù•ÁúãÔºåËÆ°ÁÆóÊØè‰∏™Êï∞ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåÊòæÁÑ∂Á≠îÊ°àÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ È¶ñÂÖàËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Âàó \(2^n\) ÂÖÉÁ∫øÊÄßÊñπÁ®ãÁªÑÂéªËß£Ôºå‰ΩÜÊòØÊö¥ÂäõÈ´òÊñØÊ∂àÂÖÉÁöÑÂ§çÊùÇÂ∫¶Â§™È´ò‰∫Ü„ÄÇ Êàë‰ª¨ËÆæ \(f_i\) Ë°®Á§∫ \(i\) ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞Ôºå\(p_i\) Ë°®Á§∫ÈöèÊú∫Êï∞ÁîüÊàêÂô®ÁîüÊàê \(i\) ÁöÑÊ¶ÇÁéá„ÄÇÈÇ£‰πàÂèØ‰ª•ÂèëÁé∞ \(f\) Êï∞ÁªÑÊª°Ë∂≥ÊñπÁ®ã \(f = f\cdot p + w x^0 + \sum x^S\)„ÄÇÂÖ∂‰∏≠‰πòÊ≥ïË°®Á§∫ÈõÜÂêàÂºÇÊàñÂç∑ÁßØ„ÄÇ ÁßªÈ°πÂæóÂà∞ \((x^0-p)f = w x^0 + \sum x^S\)ÔºåÂØπ‰∏§ËæπÂêåÊó∂ FWTÔºåÂæó \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)„ÄÇÊòæÁÑ∂ \(\hat{p}_{0} = \sum p_S= 1\)Ôºå‰ªéËÄå \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)ÔºåËøôÂ∞±Êé®Âá∫‰∫Ü \(w = -2^n\)„ÄÇÊòæÁÑ∂ \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)Ôºå‰ªéËÄåÂèØ‰ª•Êé®Âá∫ \(\hat{f}_S\) ÁöÑÂÄº„ÄÇÊé•‰∏ãÊù•ÔºåÂè™Ë¶ÅÁü•ÈÅì \(\hat f_0\) Â∞±ÂèØ‰ª• IFWT Âá∫ \(f\) ‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞Ôºå\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)ÔºåÂè™ÈúÄÈöè‰æøÁªô \(\hat f_0\) ËÆæ‰∏Ä‰∏™ÂÄºÔºåÁÑ∂Âêé IFWT Âá∫‰∏Ä‰∏™Êï∞ÁªÑ \(f\)ÔºåÂØπÊØè‰∏™ \(i\) Êää \(f_i\) ÂáèÂéª \(f_0\) Âç≥ÂèØ„ÄÇÔºàËøôÈáåÁî®Âà∞‰∫Ü \(f_0 = 0\) ÁöÑÊù°‰ª∂Ôºâ Ê®°Êï∞ÂÜôÊàê \(10^9+7\) ËøòË∞É‰∫ÜÂ•Ω‰πÖ...ÊàëÁúüÁöÑÊòØ zz„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc È¢òÂè∑ÂæàÁ•ûÂ•á...‰ª•ÈìæÊé•‰∏≠ÁöÑ‰∏∫ÂáÜ„ÄÇ È¢òËß£ ÁªôÁÇπ \(i\) ‰∏Ä‰∏™ÊùÉÈáç \(w_i\)ÔºåÈáçÊñ∞ÂÆö‰πâ \(D_i = \sum_k w_k dis(i,k)\)„ÄÇÂàùÂßãÊó∂ÂØπ‰∫éÊâÄÊúâÁöÑ \(i\)Ôºå\(w_i = 1\)„ÄÇ‰ªªÊÑèÊó∂ÂàªÔºå\(\sum_i w_i = n\)„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁÇπ \(v\) ‰∏éÁÇπ \(u\) Áõ∏ÈÇªÔºå‰ª•ÁÇπ \(u\) ‰∏∫Ê†πÊó∂ÁÇπ \(v\) ÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáç‰πãÂíå‰∏∫ \(s\)ÔºåÂàô \(D_v - D_u = n - 2s\)„ÄÇ ÊâæÂà∞ \(D_u\) ÊúÄÂ§ßÁöÑÁÇπ \(u\)ÔºåÁî±‰∫é‰ªª‰Ωï‰∏é \(v\) Áõ∏ÈÇªÁöÑÁÇπÈÉΩÊª°Ë∂≥ \(D_v - D_u \le 0\)ÔºåÊâÄ‰ª•‰ª• \(u\) ‰∏∫Ê†π \(v\) Â≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáçÂíåËá≥Â∞ë‰∏∫ \(\frac n 2\)ÔºåÊâÄ‰ª• \(u\) Ëá≥Â§öÊúâ‰∏Ä‰∏™Áõ∏ÈÇªÁÇπ„ÄÇÊàë‰ª¨‰∏çËÄÉËôë \(n = 1\) ÁöÑÊÉÖÂÜµ„ÄÇ\(u\) ÊòØ‰∏Ä‰∏™Âè∂Â≠ê„ÄÇ ÂÅáËÆæ‰∏é \(u\) Áõ∏ÈÇªÁöÑÁÇπÊòØ \(f\)ÔºåÈÇ£‰πà \(D_f-D_u = 2w_u - n\)ÔºåÁî±‰∫é \(D_i\) ‰∫í‰∏çÁõ∏ÂêåÔºåËøôÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü \(u\) ÁöÑÁà∂‰∫≤ \(f\)„ÄÇÊàë‰ª¨ËÆ∞ÂΩï‰∏Ä‰∏ãÁÇπ \(u\) ÂíåÁÇπ \(f\) Ëøû‰∏ÄÊù°ËæπÔºåÊääÁÇπ \(f\) ÁöÑÊùÉÈáçÂä†‰∏äÁÇπ \(u\) ÁöÑÊùÉÈáçÔºåÁÑ∂ÂêéÊääÁÇπ \(u\) Âà†Âéª„ÄÇËøôÊ†∑ÂØπËøòÂú®Ê†ë‰∏äÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÁÇπ \(i\)ÔºåÁªèËøáËøôÊ¨°Êìç‰Ωú \(D_i\) ÊÅ∞Â•ΩÂáèÂ∞ë‰∫Ü \(w_u\)„ÄÇÊõ¥Êñ∞‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰∏ÄÁõ¥ËøôÊ†∑Êìç‰Ωú‰∏ãÂéªÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü‰∏ÄÊ£µÊ†ëÔºåÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÔºàÊáíÂæóÂà§ÁâπÊÆäÊÉÖÂÜµÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõÈ™åËØÅ‰∫ÜÔºâ ÂÆûÈôÖ‰∏ä‰∏çÈúÄË¶ÅÊõ¥Êñ∞ \(D_i\)ÔºåÂõ†‰∏∫ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØÊï¥‰ΩìÂä†ÔºåËÄåÊàë‰ª¨ÂßãÁªàÂè™‰ºöÁî®Âà∞ \(D_i\) ÁöÑÁõ∏ÂØπÂ§ßÂ∞èÂÖ≥Á≥ªÂíå \(D_f-D_u\) ÁöÑÂÄº„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ËÆæ \(f_{ij}\) Ë°®Á§∫ \(A_i &lt; A_j\) ÁöÑÊ¶ÇÁéá„ÄÇ ÊØèÊ¨°‰øÆÊîπ \(\mathcal O(n)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ ÊúÄÂêéÊ±ÇÂá∫ÈÄÜÂ∫èÂØπ‰∏™Êï∞ÁöÑÊúüÊúõÔºå‰πò‰ª• \(2^q\) Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÁªìËÆ∫ÔºåÊääËæìÂÖ•ÁöÑÊï∞ÁªÑÁúã‰Ωú \(n\) ‰∏™Ê†ºÂ≠êÔºåÊØè‰∏™Ê†ºÂ≠êÈáåÂ°´‰∫Ü‰∏Ä‰∏™Êï∞Â≠ó„ÄÇÂØπÊ†ºÂ≠êÈªëÁôΩÊüìËâ≤ÔºåÁ¨¨‰∏Ä‰∏™Ê†ºÂ≠êÊòØÈªëËâ≤ÔºåÁõ∏ÈÇª‰∏§‰∏™Ê†ºÂ≠êÈ¢úËâ≤‰∏çÂêå„ÄÇ ‰∏çÈöæÂèëÁé∞ÁªìËÆ∫ÔºöÂ¶ÇÊûú \(n\) ‰∏∫ÂÅ∂Êï∞ÔºåÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÂæóÂà∞ÁöÑÊî∂ÁõäÊòØÈªëÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏éÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíåÁöÑÊúÄÂ§ßÂÄº„ÄÇÂ¶ÇÊûú \(n\) ‰∏∫Â•áÊï∞ÔºåËÆæÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏∫ \(s\)ÔºåÂÖàÊâãËÉΩÂ§üËé∑ÂæóËá≥Â∞ë \(x\) ÁöÑÊî∂ÁõäÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏ÄÁßçÈÄâÂá∫Ëã•Âπ≤‰∏™ÁôΩÊ†ºÂ≠êÁöÑÊñπÊ°àÔºåÁî®Ëøô‰∫õÁôΩÊ†ºÂ≠êÊää \(n\) ‰∏™Ê†ºÂ≠êÂàÜÊàêËã•Âπ≤‰∏™ËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÂÜÖÈªëÊ†ºÂ≠êÁöÑÂíåÂáèÂéªÁôΩÊ†ºÂ≠êÁöÑÂíåÈÉΩÂ§ß‰∫éÁ≠â‰∫é \(x-s\)„ÄÇ ËØÅÊòéÊØîËæÉÊòæÁÑ∂ÔºåÂÖ∑‰ΩìËøáÁ®ã‰∏çÂÜôÂá∫‰∫Ü„ÄÇÂ§ßÊ¶ÇÊÄùË∑ØÂ∞±ÊòØË¶ÅËØÅÊòéÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÁöÑÊî∂ÁõäÊòØ \(x\)ÔºåÂè™ÈúÄÂÖàÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•ÔºåÊó†ËÆ∫ÂêéÊâãÊÄé‰πàÊìç‰ΩúËá≥Â∞ëËÉΩÂ§ü \(x\) ÁöÑÊî∂ÁõäÔºåÂêéÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•Êó†ËÆ∫ÂÖàÊâãÊÄé‰πàÊìç‰Ωú‰∏ÄÂÆöËÉΩ‰ΩøÂÖàÊâãËé∑ÂæóËá≥Â§ö \(x\) ÁöÑÊî∂Áõä„ÄÇ\(n\) ‰∏∫Â•áÊï∞Áõ¥Êé•ÂÅöÔºå\(n\) ‰∏∫ÂÅ∂Êï∞‰∫åÂàÜ dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂèØ‰ª•ÂèëÁé∞ÔºåÂÅáËÆæÊúÄÁªàËÉΩÂèòÊàê 0ÔºåÂ¶ÇÊûúÊúâ 000ÔºåÁ¨¨‰∏ÄÊ≠•Êìç‰ΩúÊääÂÆÉÂèòÊàê 0 ‰∏ÄÂÆöÊúÄÁªà‰ªçÁÑ∂ËÉΩÂèòÊàê 0„ÄÇËøôÊòØÂõ†‰∏∫ÔºåÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™Á¨¨‰∏ÄÊ≠•‰∏çÊòØÂØπËøô‰∏â‰∏™Êï∞Êìç‰ΩúÔºåËÄÉËôëÁ¨¨‰∏ÄÊ¨°ÂΩ±ÂìçÂà∞Ëøô‰∏â‰∏™Êï∞‰∏≠Êüê‰∏™Êï∞ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøô‰∏™Êìç‰ΩúÂ∞±ÊòØÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0ÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ÊääËøôÊ¨°Êìç‰ΩúÁßªÂä®Âà∞Á¨¨‰∏ÄÊ¨°Êìç‰Ωú„ÄÇÂê¶ÂàôÁöÑËØùÔºåÈÇ£‰πàÊääËøôÊ¨°Êìç‰ΩúÊîπ‰∏∫ÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0 ËÇØÂÆö‰∏ç‰ºöÊõ¥Âä£„ÄÇÔºàÂõ†‰∏∫ÊääÂ∫èÂàó‰∏äÁöÑ‰∏Ä‰∏™ 0 Êîπ‰∏∫ 1 ÂæóÂà∞ÁöÑÂ∫èÂàó‰∏ÄÂÆö‰∏ç‰ºöÊõ¥Âä£ÔºâÁî®Á±ª‰ººÁöÑÊÄùË∑ØÂèØ‰ª•ËØÅÊòéÔºåÂ¶ÇÊûúÊúâ 010ÔºåÁ¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 0 ‰πü‰∏ç‰ºöÊõ¥Âä£ÔºåÂ¶ÇÊûúÊúâ 101 Á¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 1 ‰πü‰∏ç‰ºöÊõ¥Âä£„ÄÇ ËÄÉËôë‰∏Ä‰∏™Â∫èÂàóÔºåÂèçÂ§çËøõË°å‰ª•‰∏ä‰∏âÁßçÊìç‰ΩúÁõ¥Âà∞‰∏çËÉΩÊìç‰ΩúÔºåÊääÂæóÂà∞ÁöÑÂ∫èÂàóÂàíÂàÜ‰∏∫Ëã•Âπ≤‰∏™ 0 / 1 ÁöÑËøûÁª≠ÊÆµÔºåÈô§‰∫ÜÂºÄÂ§¥ÂíåÁªìÂ∞æÁöÑËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ \(2\)Ôºå‰∏î 0 ÁöÑËøûÁª≠ÊÆµÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá \(2\)„ÄÇÊòæÁÑ∂Êää 111 ÂèòÊàê 1 ÊòØ‰∏ç‰ºòÁöÑ„ÄÇ‰∏çÈöæÁî®ÂΩíÁ∫≥Ê≥ïËØÅÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÔºåÈÉΩ‰∏ç‰ºöÂá∫Áé∞ 000„ÄÇÔºàËÄÉËôëÂú®ËøõË°å‰∏ÄÊ≠•Êìç‰Ωú‰πãÂêéÔºåÂà©Áî® 010 Âèò‰∏∫ 0 ÁöÑÁªìËÆ∫ÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰ΩúÔºåËøôÊ†∑Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™Êõ¥Áü≠ÁöÑÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºâËÄåÂÖ∂‰ªñÊìç‰ΩúÈÉΩ‰ºö‰Ωø 0 ÁöÑ‰∏™Êï∞Âíå 1 ÁöÑ‰∏™Êï∞ÂêåÊó∂ÂáèÂ∞ë 1„ÄÇËøôÂ∞±ËØ¥ÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÊúÄÁªàËÉΩÂèòÊàê 1ÔºåÂΩì‰∏î‰ªÖÂΩì 1 ÁöÑ‰∏™Êï∞Â§ß‰∫é 0 ÁöÑ‰∏™Êï∞„ÄÇÔºàÈïøÂ∫¶ÂøÖ‰∏∫Â•áÊï∞Ôºâ ÂØπËøô‰∏™‰∏úË•ø dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂâçÁºÄ 1 ÁöÑ‰∏™Êï∞ÂáèÂéª 0 ÁöÑ‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫é \(2\)ÔºåËøô‰∏™Â∫èÂàóÂøÖÁÑ∂ÂèØ‰ª•ÂèòÊàê 0„ÄÇÊâÄ‰ª•ÂÆûÈôÖÈúÄË¶ÅËÆ∞ÁöÑÁä∂ÊÄÅÊï∞ÂæàÂ∞ë„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂØπ‰∫é \(i, j\)ÔºåËÄÉËôë \(P_i &gt; P_j\) ÁöÑÊñπÊ°àÊï∞„ÄÇÂè™ÈúÄËÄÉËôë \(A_i \le A_j\) ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇËøôÁõ∏ÂΩì‰∫éÊòØÊää \(A_j\) Êîπ‰∏∫ \(A_i\) ‰πãÂêéÊª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÈôêÂà∂ÁöÑÊéíÂàóÊï∞Èô§‰ª• \(2\)„ÄÇ Êää \(1 \ldots n\) Êåâ \(A_i\) ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåËÆæÊéíÂ∫èÂêéÁ¨¨ \(i\) ‰∏™Êï∞ÊòØ \(p_i\)„ÄÇÊòæÁÑ∂Êª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÊéíÂàóÊÄªÊï∞‰∏∫ \(\prod_i A_{p_i}-i+1\)„ÄÇËÆæÊÄªÊï∞‰∏∫ \(C\)„ÄÇ ËÆæ \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) ÂØπÊâÄÊúâÊª°Ë∂≥ \(p_i &lt; p_j\) ÁöÑ \((i,j)\) ËÆ°ÁÆó \(P_{p_i} &gt; P_{p_j}\) ÁöÑÊéíÂàóÊï∞„ÄÇÂØπ‰∫éÊØè‰∏ÄÂØπ \(i &lt; j\)ÔºåÂ¶ÇÊûú \(p_i &lt; p_j\)ÔºåÈÇ£‰πàÂÆÉÁöÑË¥°ÁåÆÊòØ \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)„ÄÇ\(p_i &gt; p_j\) ÁöÑÊÉÖÂÜµÊ≤°ÊúâÂæàÂ§ßÂå∫Âà´ÔºåÂÖ∑‰ΩìÂºèÂ≠êÂ∞±‰∏çÂÜôÂá∫Êù•‰∫Ü„ÄÇÊûö‰∏æ \(j\)ÔºåÁî®Á∫øÊÆµÊ†ëÂØπÊØè‰∏™ \(p_i\) Áª¥Êä§‰∏ãËøô‰∏™ÂºèÂ≠êÔºåÊØèÊ¨°ÁßªÂä® \(j\) ÁöÑÊó∂ÂÄôÂå∫Èó¥‰πòÊõ¥Êñ∞ÔºåÁªüËÆ°Á≠îÊ°àÊó∂Âå∫Èó¥Ê±ÇÂíåÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ËÆ°Êï∞</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ update: ÊÑüËßâÊàëÂÅöÈ∫ªÁÉ¶‰∫ÜÔºåÈ¢òËß£ÂÅöÊ≥ïÂ•ΩÁÆÄÂçï„ÄÇËøôÁØá blog Â∞±‰∏¢ËøôÂêß‚Ä¶..ÊÑüËßâÊ≤°‰ªÄ‰πàÈîôËØØ„ÄÇ Â¶ÇÊûúÂè™Êää \(0\) ÂèòÊàê \(1\) ËÄå‰∏çÊää \(1\) ÂèòÊàê \(0\)Ôºå‰ºöÂØºËá¥ \(0\) ÁöÑ‰∏™Êï∞ÂáèÂ∞ëÔºåËøò‰∏çÂ¶Ç‰∏çÊîπÂèòÂéüÂ∫èÂàó„ÄÇ Â¶ÇÊûúÊó¢Âá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ‰πüÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\)ÔºåËÆæÊüê‰∏Ä‰∏™Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_1\)ÔºåÊüê‰∏Ä‰∏™Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_2\)„ÄÇ ‰∏çÂ¶®ËÆæ \(p_1 &lt; p_2\)„ÄÇÔºàÂ¶ÇÊûú \(p_1 &gt; p_2\)Ôºå‰∫§Êç¢ÂéüÂ∫èÂàóÂíåÊñ∞Â∫èÂàóÂ∞±Âíå‰∏ÄÁßç \(p_1 &lt; p_2\) ÁöÑÊÉÖÂÜµÁ≠â‰ª∑‰∫ÜÔºâ ËÆæ \(f[l,r]\) Ë°®Á§∫ÂéüÂ∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶Ôºå\(g[l,r]\) Ë°®Á§∫Êñ∞Â∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ ÂÆö‰πâ \(f[l,r] = g[l,r] = 0(l &gt; r)\)„ÄÇ ÈÇ£‰πà \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)„ÄÇ Âõ†Ê≠§Êñ∞Â∫èÂàó‰∏ä \([p_1,p_2]\) ‰∏≠ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂøÖÁÑ∂Ë¶ÅÂåÖÂê´ \(p_1\) Âíå \(p_2\)Ôºå‰ΩÜÊòØÊñ∞Â∫èÂàó‰∏ä \(p_1\) ‰ΩçÁΩÆ‰∏∫ \(1\)Ôºå\(p_2\) ‰ΩçÁΩÆ‰∏∫ \(0\)ÔºåËøôÊòØ‰∏çÂèØËÉΩÁöÑ„ÄÇ Âõ†Ê≠§ÔºåÂè™‰ºöÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆÔºå‰∏ç‰ºöÂá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ„ÄÇ ËÄÉËôëÊää‰∏Ä‰∏™‰ΩçÁΩÆÂú®ÂéüÂ∫èÂàóÂ∑¶Á´ØÊàñÂ∑¶Ëæπ‰∏ç‰∏∫ \(1\) ÁöÑ \(1\) ÂèòÊàê \(0\)Ôºå‰∏çÂØπ‰ªªÊÑèÂå∫Èó¥ÂÜÖÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàó‰∫ßÁîüÂΩ±ÂìçÁöÑÊù°‰ª∂„ÄÇ ÂÅáËÆæËøô‰∏™‰ΩçÁΩÆÊòØ \(p\)„ÄÇÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö \(p &lt; n\) ‰∏î‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(1\). \(p = n\) Êàñ‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\). ÂÖàÁúãÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ„ÄÇÊää‰ΩçÁΩÆ \(p\) ‰∏äÁöÑ \(1\) ÂèòÊàê \(0\) Áúã‰ΩúÊñ∞Â∫èÂàóÔºàÁî® \(g[l,r]\) ÊèèËø∞Êñ∞Â∫èÂàó‰∏äÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºâ„ÄÇÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)ÔºåËÄåÊñ∞Â∫èÂàó‰∏ä‰ΩçÁΩÆ \(p\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøôËØ¥Êòé \([i,p-1]\) Â≠òÂú®ÁªìÂ∞æ‰∏∫ \(0\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂç≥ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÁ≠â‰∫é \([i, p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞„ÄÇÂèØ‰ª•ËØÅÊòéËøô‰∏™Êù°‰ª∂ÂØπ‰ªªÊÑèÁöÑ \(i &lt; p\) ÈÉΩÊàêÁ´ãÁöÑÂÖÖË¶ÅÊù°‰ª∂‰∏∫ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\([i,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºöÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑÔºåÂè™ÈúÄËØÅÂÖÖÂàÜÊÄßÔºåÂÅáËÆæ \([i, p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂ§ß‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºå‰ªªÂèñ‰∏Ä‰∏™ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂÆÉÂøÖÁÑ∂ÂåÖÂê´‰∏Ä‰∏™ \(1\)ÔºåËÆæÁ¨¨‰∏Ä‰∏™ \(1\) ‰ΩçÁΩÆ‰∏∫ \(k\)ÔºåÈÇ£‰πàËøô‰∏™Â≠êÂ∫èÂàó \(k\) ‰πãÂâçÁöÑÂÖÉÁ¥†ÂÜçÊãº‰∏ä \([k,p-1]\) ‰∏≠ÊâÄÊúâÁöÑ \(0\) ÂøÖÁÑ∂ÊòØ‰∏Ä‰∏™ÂÖ® \(0\) ÁöÑ‰∏ç‰ºöÊõ¥Áü≠ÁöÑÂ≠êÂ∫èÂàóÔºàÂõ†‰∏∫ \([k,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºâÔºåËøô‰∏é‰∏çÂ≠òÂú®ÂÖ®‰∏∫ \(0\) ÁöÑ‰∏çÈôçÂ≠êÂ∫èÂàóÁüõÁõæ„ÄÇ‰∏çÈöæÈ™åËØÅËøô‰πüÊòØÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏≠ËÉΩÊää \(p\) ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂„ÄÇ Á¨¨‰∫åÁßçÊÉÖÂÜµÊòæÁÑ∂‰πüÂøÖÈ°ªË¶ÅÊª°Ë∂≥Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑÊù°‰ª∂„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÁî±‰∫é‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøòÈúÄÊª°Ë∂≥ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &gt; p\)Ôºå\([p+1,i]\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºà‰∏éÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑËØÅÊòéÁ±ª‰ººÔºåËØ¶ÁªÜËøáÁ®ãÂ∞±‰∏çÂÜô‰∫ÜÔºâ„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ë¥™ÂøÉÔºåÂØπ‰∫é‰∏Ä‰∏™‰ΩçÁΩÆÔºåÂ¶ÇÊûúÂÆÉÊòØ \(1\)Ôºå‰∏îËÉΩÂ§ü‰øùÊåÅ‰ªªÊÑèÂå∫Èó¥ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏çÂèòÂú∞Âèò‰∏∫ \(0\)ÔºåÂ∞±ÊääÂÆÉÂèòÊàê \(0\)„ÄÇ‰∏çÈöæËØÅÊòéËøôÁßçË¥™ÂøÉÊòØÊ≠£Á°ÆÁöÑÔºåËØ¶ÁªÜËØÅÊòéËøôÈáå‰∏çÂÜô‰∫Ü„ÄÇÔºàÊèêÁ§∫ÔºöËÄÉËôëÊúÄ‰ºòËß£‰∏≠ \(1\rightarrow0\) ÁöÑÊúÄÂ∞è‰ΩçÁΩÆÔºâ Âà§Êñ≠ÊòØÂê¶Â≠òÂú®ÂâçÁºÄ / ÂêéÁºÄ \(0\) ÁöÑ‰∏™Êï∞Â§ö‰∫é / Â∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºåÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÊØè‰∏™ÂâçÁºÄ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞Âáè \(1\) ÁöÑ‰∏™Êï∞ÂæàÂÆπÊòìÂú∞Â§ÑÁêÜ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[ËøòÊ≤°ÂÜôËøá„ÄÇÂ¶ÇÊûúÊúâÈîôËØØÂèØ‰ª• QQ / ËØÑËÆ∫ÂëäËØâÊàë„ÄÇ È¢òËß£ ËøôÊ†∑ÁêÜËß£Ëøô‰∏™ÈóÆÈ¢òÔºöÂàùÂßãÊó∂Êó∂Èó¥‰∏∫Á¨¨ \(0\) Áßí„ÄÇÊØèÁßí‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™ \(i\)ÔºåÁÑ∂ÂêéÊää \(a_i\) Âä†‰∏ä \(k\)ÔºåÊé•‰∏ãÊù•ÂÜçÊääÊâÄÊúâ \(a_i\) ÂáèÂéª \(1\)„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÂÅúÊ≠¢Ëøô‰∏™ËøáÁ®ãÔºåÂπ∂ÊääÂΩìÂâçÁöÑ \(a\) Êï∞ÁªÑ‰Ωú‰∏∫ÁªìÊûú„ÄÇÈóÆÂú®‰∏çÁªèËøá‰ªª‰ΩïÂ≠òÂú® \(a_i &lt; 0\) ÁöÑÁä∂ÊÄÅÁöÑÂâçÊèê‰∏ãÔºåËÉΩÂ§üÂæóÂà∞Â§öÂ∞ëÁßç‰∏çÂêåÁöÑÁªìÊûú„ÄÇ ‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÔºåÂ¶ÇÊûú‰∏çËÄÉËôë \(+k\) Êìç‰ΩúÔºåÊØèÁßíÊØè‰∏™ \(a_i\)ÈÉΩ‰ºöÂáèÂ∞ë \(1\)„ÄÇ ËÆæ \(c_{t,i}\) Ë°®Á§∫Ââç \(t\) Áßí \(a_i\) Ë¢´ÊâßË°å \(+k\) Êìç‰ΩúÁöÑÊ¨°Êï∞„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúËøô‰∏™ËøáÁ®ãÂú®ËøõË°å‰∫Ü \(T\) Áßí‰πãÂêéÁªìÊùüÔºå\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)Ôºå‰πüÂ∞±ÊòØËØ¥ \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)„ÄÇ ‰∏çÈöæËØÅÊòéÂ≠òÂú®ÁªèËøá \(T\) ÁßíÊ≤°ÊúâÂá∫Áé∞ËøáË¥üÊï∞ÁöÑÊñπÊ°àÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºö \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] ÂØπ‰∫é \(t \in \mathbb{N}\)Ôºå\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) ÊòØÂê¶ÊàêÁ´ãÊòØ‰∏é \(T\) Êó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåË¶Å‰πàÂØπÊâÄÊúâÁöÑ \(T\) ÈÉΩÂ≠òÂú®‰∏çÁªèËøáË¥üÊï∞ÁöÑÊñπÊ°àÔºåË¶Å‰πàÂ≠òÂú®‰∏Ä‰∏™ÈùûË¥üÊï¥Êï∞ \(T_0\)ÔºåÂΩì \(T \le T_0\) Êó∂Â≠òÂú®ÊñπÊ°àÔºå\(T &gt; T_0\) Êó∂‰∏çÂ≠òÂú®ÊñπÊ°à„ÄÇ Â§™Êôö‰∫ÜÂÖàÁù°‰∫Ü„ÄÇÂùëÂæÖÂ°´„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[Âè£ËÉ°ÁöÑÊ≤°ÂÆûÁé∞ËøáÔºåÂ¶ÇÊúâÈîôËØØËØ∑ QQ ÊàñËØÑËÆ∫ÂëäËØâÊàëÔºÅ È¢òËß£ ËÄÉËôëÂè™Êúâ‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÁöÑÊÉÖÂÜµ„ÄÇ Á¨¨‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_1, a_1b_1, a_1b_1^2, \ldots\) Á¨¨‰∫å‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_2,a_2b_2,a_2b_2^2,\ldots\) ÂÅáËÆæ \(v\) ÂêåÊó∂Âá∫Áé∞Âú®‰∏§‰∏™Á≠âÊØîÊï∞Âàó‰∏≠ÔºåÈÇ£‰πà \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)„ÄÇ ËÆæ \(p_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™Á¥†Êï∞„ÄÇ \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) ËÄÉËôë‰ªªÊÑè‰∏§‰∏™‰∏çÂêåÁ¥†Êï∞ \(p_i\) Âíå \(p_j\)ÔºåÂÅáËÆæ \(p_i\) Âú® \(a_1,a_2\) ‰∏≠Âá∫Áé∞Ê¨°Êï∞ÂàÜÂà´ÊòØ \(w_{1i},w_{2i}\)„ÄÇ ÈÇ£‰πàÊúâ \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] ËøôÊòØ‰∏Ä‰∏™‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑ„ÄÇÂÅáËÆæ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåËøô‰∏™ÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ ÂÅáËÆæÂ≠òÂú® \(i &lt; j\)Ôºå \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåÈÇ£‰πàËß£Âá∫Ëøô‰∏™ÊñπÁ®ã„ÄÇËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÂîØ‰∏Ä‰∏Ä‰∏™ÂèØËÉΩÊòØÊâÄÊúâÁ≠âÊØîÊï∞ÂàóÂÖ±ÊúâÂÖÉÁ¥†ÁöÑÊï∞ÔºàÁöÑÁ¥†Âõ†Êï∞ÂàÜËß£ÔºâÔºåÁÑ∂ÂêéÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; j\) ÈÉΩÊúâ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÁõ∏ÂÖ≥„ÄÇ ÈÇ£‰πàÂ≠òÂú®Ê≠£Êï¥Êï∞ \(w\)Ôºå\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)„ÄÇ \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] ‰∏çÂ¶®ËÆæ \(a_1 \le a_2\)„ÄÇÈÇ£‰πà‰∏ÄÂÆöÊúâ \(a_1 \mid a_2\)„ÄÇ ËÆæ \(\frac {a_2} {a_1} = x\)ÔºåÂ¶ÇÊûúÊúâËß£ÔºåÂøÖÊúâ \(x = w^n, n \in \mathbb{N}\)„ÄÇ ÊñπÁ®ãÂèò‰∏∫ \(k_1i_1-k_2i_2 = n\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰∏çÂÆöÊñπÁ®ã„ÄÇ‰∏çÈöæÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑ‰∏ÄÁªÑËß£ \(k_1= x, k_2 = y\)„ÄÇÔºàÂÖ∑‰ΩìÊù•ËØ¥ÂÖàÊâæÂà∞ \(k_1i_1-k_2i_2=1\) ÁöÑËß£ÔºåÁÑ∂ÂêéÂú®‰∏§Ëæπ‰πò‰ª• \(n\)Ôºâ ÈÇ£‰πàËøô‰∏™ÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)„ÄÇ ‰∏çÈöæÊâæÂà∞ \(k_1\) ÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞Ëß£ÔºåÂÅáËÆæËøôÊó∂ \(a_1w^{k_1c_1}=t\)„ÄÇËøôÊ†∑‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÂ∞±Ë¢´ÂêàÂπ∂‰∏∫‰∫Ü‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)„ÄÇ ÁªßÁª≠ÊääÂêàÂπ∂ÂæóÂà∞ÁöÑÁ≠âÊØîÊï∞ÂàóÂíåÂÖ∂‰ªñÁ≠âÊØîÊï∞ÂàóËøõË°åÁõ∏ÂêåÁöÑÊìç‰ΩúÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÊîØÈÖçÊ†ë]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÊîØÈÖçÊ†ëÁöÑÁÆóÊ≥ïÂæàÂ¶ô„ÄÇÂÆÉÁöÑËØÅÊòéÂÆûÂú®Â§™Èïø‰∫Ü‚Ä¶.ÂÆåÊï¥ÂÜô‰∏ÄÈÅçÊØîËæÉË¥πÊó∂Èó¥ÔºåËøôÈáåÂ∞±Âè™ÂÜôÁªìËÆ∫‰∫Ü„ÄÇ ÊòæÁÑ∂ÊîØÈÖçÂÖ≥Á≥ªÊûÑÊàê‰∏ÄÊ£µÊ†ë„ÄÇ ÂÆö‰πâ \(sdom(u)\) ÊòØËÉΩÂ§ü‰ªé \(v\) Âá∫ÂèëÂè™ÁªèËøá \(dfn\) ÊØî \(u\) Â§ßÁöÑÂà∞Ëææ \(u\)Ôºà\(u\) Âíå \(v\) ‰∏çÁÆóÂú®ÈáåÈù¢ÔºâÁöÑ \(dfn\) ÊúÄÂ∞èÁöÑ \(v\)„ÄÇ \(sdom(u)\) Ë¶Å‰πàÊòØËÉΩÂ§üÈÄöËøá‰∏ÄÊù°ÂâçÂêëËæπ / Ê†ëËæπÁõ¥Êé•Âà∞Ëææ \(u\) ÁöÑÁÇπÔºåË¶Å‰πàÊòØÊª°Ë∂≥Â≠êÊ†ë‰∏≠Â≠òÂú®Ëá≥Â∞ë‰∏Ä‰∏™ÁÇπËÉΩÂ§üÁõ¥Êé•Ëµ∞Âà∞ \(u\) ‰∏î \(dfn\) ÊØî \(u\) Â§ßÁöÑÁÇπÁöÑ \(sdom\)„ÄÇÊ†πÊçÆËøô‰∏ÄÁÇπÂèØ‰ª•Âπ∂Êü•ÈõÜËÆ°ÁÆó \(sdom\)„ÄÇÂπ∂Êü•ÈõÜÁª¥Êä§ÁöÑÊòØÈìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇ ËÆæ \(v\) ÊòØ \(u\) Âà∞ \(sdom(u)\) ÁöÑÈìæ‰∏äÔºà‰∏çÂê´ \(sdom(u)\)Ôºâ\(sdom\) ÊúÄÂ∞èÁöÑÁÇπ ÔºåÈÇ£‰πàÂ¶ÇÊûú \(sdom(v) = sdom(u)\)Ôºå\(idom(u) = sdom(u)\)ÔºåÂê¶Âàô \(idom(u) = idom(v)\)„ÄÇËøô‰∏™‰∏úË•ø‰πüÊòØË¶ÅÊ±Ç‰∏Ä‰∏™Èìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇÂèØ‰ª•Ê±Ç \(sdom\) ÁöÑÊó∂ÂÄôÈ°∫‰æøÁª¥Êä§‰∏Ä‰∏ã„ÄÇ Âú®Ëøô‰ªΩ‰ª£Á†Å‰∏≠ \(sdom\) Â≠òÁöÑÊòØ \(dfn\) ÊúÄÂ∞èÁöÑÁÇπÁöÑ \(dfn\) ËÄå‰∏çÊòØÁºñÂè∑ÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè„ÄÇ ÔºàÂê¨ËØ¥ËøôÈ¢òÊï∞ÊçÆÂæàÊ∞¥‚Ä¶ËØ¥‰∏çÂÆöÊúâÈîôÊ≤°Ë¢´Êü•Âá∫Êù•Ôºâ Ëøô‰ªΩ‰ª£Á†ÅË¢´Êèê‰∫§Âà∞ „ÄêÊ®°Êùø„ÄëÊîØÈÖçÊ†ë„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT ÈóÆÈ¢òÊÄªÁªì]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥‰ª•Êù•ÂØπ 2-SAT ÁöÑÁêÜËß£ÊØîËæÉÊ®°Á≥äÔºåÊâÄ‰ª•ÂÜôËøôÊ†∑‰∏Ä‰∏™Â∞ΩÂèØËÉΩÊ∏ÖÊô∞ÁöÑÊÄªÁªìÊù•ÁêÜÊ∏ÖÊÄùË∑Ø„ÄÇ 2-SAT ÈóÆÈ¢òÁöÑÂÆö‰πâÔºöÊúâ \(n\) ‰∏™ÈÄªËæëÂèòÈáèÔºåÁî® \(b_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™ÈÄªËæëÂèòÈáè„ÄÇ\(m\) ‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏Ä‰∏™ÈôêÂà∂Êù°‰ª∂ÂΩ¢Â¶ÇÔºö\((\neg)b_i \to (\neg) b_j\)„ÄÇÈóÆÊòØÂê¶Â≠òÂú®Êª°Ë∂≥ÈôêÂà∂ÁöÑ \(b\)„ÄÇ Áî®ÂõæÊù•ÊèèËø∞ÈôêÂà∂Êù°‰ª∂„ÄÇÂØπÊØè‰∏™ÈÄªËæëÂèòÈáèÂª∫‰∏§‰∏™ÁÇπÔºåÂàÜÂà´‰ª£Ë°®ÂèñÂÄº‰∏∫ \(0\) ÂíåÂèñÂÄº‰∏∫ \(1\)„ÄÇ‰ª£Ë°® \(b_i=0\) ÁöÑÁÇπ‰∏∫ \(p_i\)Ôºå‰ª£Ë°® \(b_i = 1\) ÁöÑÁÇπ‰∏∫ \(q_i\)„ÄÇÂØπÊØè‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÂú®Âõæ‰∏äËøû‰∏ÄÊù°ÊúâÂêëËæπÔºåË°®Á§∫‰∏Ä‰∏™ÂëΩÈ¢òÊé®Âá∫Âè¶‰∏Ä‰∏™ÂëΩÈ¢òÔºåÁÑ∂ÂêéÂÜçÂä†‰∏ÄÊù°ËæπË°®Á§∫ËØ•ÈôêÂà∂Êù°‰ª∂ÁöÑÈÄÜÂê¶ÂëΩÈ¢ò„ÄÇ‰∏æ‰æãÊù•ËØ¥ÔºåÂ¶ÇÊûúÊúâÈôêÂà∂Êù°‰ª∂ \(\neg b_i \rightarrow b_j\)ÔºåÂ∞±Âä†ÂÖ• \((p_i, q_j)\) Âíå \((p_j, q_i)\) Ëøô‰∏§Êù°ÊúâÂêëËæπ„ÄÇÈóÆÈ¢òÂ∞±Âèò‰∏∫Âà§ÂÆöÊòØÂê¶Â≠òÂú®ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)ÔºåÊÅ∞Â•ΩÂåÖÂê´ \(p_i\) Âíå \(q_i\) ‰∏≠ÁöÑ‰∏Ä‰∏™ÁÇπÁöÑÈó≠ÂêàÂ≠êÂõæ„ÄÇ ÂÆöÁêÜÔºö2-SAT ÊúâËß£ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂú®Âêå‰∏ÄÂº∫ËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ ÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑ„ÄÇ ‰∏ãÈù¢Áî®ÊûÑÈÄ†ËØÅÊòéÂÖÖÂàÜÊÄßÔºö ÂÖà tarjan Ê±ÇÂá∫Âº∫ËøûÈÄöÂàÜÈáèÔºåÊääÊØè‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÁº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÁî±‰∫é‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÁöÑÁÇπÂØπÂ∫îÁõ∏ÂèçÂèñÂÄºÁöÑÁÇπ‰πüÊûÑÊàê‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÔºåÊâÄ‰ª•Áº©ÁÇπÂêéÔºåËøô‰∏™ÈóÆÈ¢òÂèò‰∏∫‰∫Ü‰∏Ä‰∏™Êõ¥Â∞èÁöÑ 2-SAT ÈóÆÈ¢ò„ÄÇÂè™ÈúÄË¶ÅËß£ÂÜ≥ÂõæÊòØ DAG Êó∂ÁöÑÈóÆÈ¢òÂç≥ÂèØ„ÄÇ ÊääÊâÄÊúâÁöÑËæπÊñπÂêëÂèçËøáÊù•„ÄÇ‰∏ãÈù¢ÊâÄÊúâÁöÑËÆ®ËÆ∫ÈÉΩÊòØÂú®ÂèçÂõæ‰∏äÁöÑ„ÄÇ Áî®Á¨¶Âè∑ \(v^r\) Ë°®Á§∫‰∏éÁÇπ \(v\) ÂØπÂ∫îÁöÑÁÇπÔºö\(p_i^r = q_i, q_i^r = p_i\)„ÄÇ Ê±ÇÂá∫ÊãìÊâëÂ∫èÔºåÊåâÊãìÊâëÂ∫è‰æùÊ¨°Â§ÑÁêÜÊØè‰∏™ÁÇπÔºöÂ¶ÇÊûúÂΩìÂâçÁÇπ \(u\) Ë¢´Êâì‰∫ÜÊ†áËÆ∞ÔºåÈÇ£‰πà‰∏çÈÄâÔºõÂê¶ÂàôÈÄâÊã© \(u\)ÔºåÂπ∂Êää \(u^r\) ‰ª•Âèä \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÊâÄÊúâÁÇπÊâì‰∏äÊ†áËÆ∞ÔºàÈÄíÂΩíËøõË°åÔºåÂ¶ÇÊûúÂ∑≤ÁªèË¢´ÊâìËøáÊ†áËÆ∞Â∞±Ë∑≥ËøáÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºöË¢´Ê†áËÆ∞‰∏ÄÊ¨°Ôºâ„ÄÇ ËøôÊ†∑ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂèØËÉΩÂêåÊó∂Ë¢´ÈÄâÔºåÂ∑≤ÈÄâÁöÑÁÇπ‰πü‰∏ç‰∏éÈôêÂà∂ÁüõÁõæÔºåÂè™ÈúÄË¶ÅËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(u\)Ôºå\(u\) Âíå \(u^r\) ‰∏≠Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÈÄâÂç≥ÂèØ„ÄÇ Â¶ÇÊûú \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´Ê†áËÆ∞ÁöÑÂéüÂõ†ÊòØ \(v\) Ë¢´ÈÄâÊã©Ôºå ÈÇ£‰πà \(u\) ÊòØ \(v^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºåÁî± 2-SAT ÁöÑÊÄßË¥®ÂèØÂæó \(v\) ÊòØ \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºå‰ªéËÄå \(v\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†Âêé„ÄÇ ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ \(u\)Ôºå\(u\) Âíå \(u^r\) ÈÉΩË¢´Ê†áËÆ∞‰∫ÜÔºåÊ†áËÆ∞ \(u\) ÁöÑÂéüÂõ†ÊòØ \(v_1\) ÊòØË¢´ÈÄâÊã©ÔºåÊ†áËÆ∞ \(u^r\) ÁöÑÂéüÂõ†ÊòØ \(v_2\) Ë¢´ÈÄâÊã©„ÄÇÈÇ£‰πà \(v_1\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºå\(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u\) Èù†Âêé„ÄÇ‰∏çÂ¶®ËÆæ \(u\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÈÇ£‰πà \(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÂú®Â§ÑÁêÜ \(v_2\) ‰πãÂâçÂ∞±‰ºöÂÖàÂ§ÑÁêÜ \(u^r\)ÔºåÁüõÁõæ„ÄÇ ÊâÄ‰ª•ËØ•ÁÆóÊ≥ï‰ºöÂæóÂà∞‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊñπÊ°à„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢ò]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Áî®Êù•ËÆ∞ÂΩïÂè£ËÉ°ÁöÑÈ¢òÁõÆ„ÄÇ Â¶ÇÊúâÈîôËØØËØ∑Âä°ÂøÖ qq ÊàñËÄÖËØÑËÆ∫ÂëäËØâÊàëÔºåË∞¢Ë∞¢ÔºÅ JOISC 2018 Day4 T1 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Â¶ÇÊûúËÆ§‰∏∫Áõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥Êúâ‰∏ÄÊù°ËæπÔºåÊú¨È¢òÂ∞±ÂèØ‰ª•ÁúãÊàêÊ±ÇÊúÄÂ§ßÊùÉÁÇπÁã¨Á´ãÈõÜ„ÄÇ ÊòæÁÑ∂‰∏ÄÊù°ÈìæÊòØ‰∫åÂàÜÂõæÔºåÈÇ£‰πàÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫Áî®Ë¥πÁî®ÊµÅÊ±ÇÊúÄÂ∞èÊùÉÁÇπË¶ÜÁõñÈõÜ„ÄÇ ËÆ∞ÂΩïÁõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥ËæπÁöÑÊñπÂêëÔºåÊääËøûÁª≠‰∏ÄÊÆµÊñπÂêëÁõ∏ÂêåÁöÑËßÜ‰Ωú‰∏Ä‰∏™ÊÆµ„ÄÇÁî®Á∫øÊÆµÊ†ëÁª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÊØèÊ¨°ÊúâÊÆµÂèëÁîüÂèòÊõ¥Êó∂Â∞±ËØ¢ÈóÆËøô‰∏™ÊÆµÔºåÁÑ∂Âêé‰øÆÊîπÁ∫øÊÆµÊ†ë‰∏äÁöÑ‰ø°ÊÅØ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Áª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÂ∞±Âú® \(\mathcal O(n \log n)\) ÁöÑÊó∂Èó¥Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ JOISC 2018 Day4 T2 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Áúã‰ΩúÊòØËØ¢ÈóÆ‰∏ÄÊù°Èìæ‰∏ä‰∏ÄÈÉ®ÂàÜÁÇπÁöÑÂØºÂá∫Â≠êÂõæÁöÑËøûÈÄöÂùóÊï∞„ÄÇ‰æùÊ¨°Âä†ÁÇπÔºåÈÄöËøá‰∫åÂàÜÊ±ÇÂá∫Êñ∞Âä†ÁöÑÁÇπÂíåÂ∑≤ÊúâÁÇπÊûÑÊàêÁöÑËøûÈÄöÂùó‰πãÈó¥ÁöÑËøûËæπ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™Êúâ \(n-1\) Êù°ËæπÔºåËØ¢ÈóÆÊ¨°Êï∞‰∏ç‰ºöË∂ÖËøá \(\lceil \log n\rceil (n-1)\)„ÄÇ LOJ 6191 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÈÖçÂØπÊ∏∏Êàè ÁÇπÂáªÊü•ÁúãÈ¢òËß£ ÊúÄÂêé‰∏ÄÂÆö‰ºöÂèòÊàê &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;„ÄÇ \(f_{i,j}\) Ë°®Á§∫Ââç \(i\) ‰∏™Ê∂àÂÆåÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶ÊúÄÂêéÊúâËøûÁª≠ \(j\) ‰∏™ &gt;ÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶‰∏≠ &lt; ÁöÑÊï∞ÈáèÁöÑÊúüÊúõ„ÄÇ ÊúÄÂêéÂæàÂÆπÊòìÁªüËÆ°Á≠îÊ°à„ÄÇ LOJ 6192 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÂüéÂ∏ÇÁΩëÁªú Ê≤°Âï•Â•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÂÄçÂ¢û‰∏Ä‰∏ã„ÄÇ LOJ 6194 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÊéíÂàó ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Êåâ \(a_i\) ‰∏∫Á¨¨‰∏ÄÂÖ≥ÈîÆÂ≠óÔºå\(b_i\) ‰∏∫Á¨¨‰∫åÂÖ≥ÈîÆÂ≠óÊéíÂ∫è„ÄÇÈáçÊñ∞ÁªôÁÇπÁºñÂè∑„ÄÇ ÂÅáËÆæ‰Ωø saved ÂèòÂä®ÁöÑÁÇπÁöÑÁºñÂè∑ÂàÜÂà´ÊòØ \(c_1, \ldots, c_k\)ÔºåÊúâ \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)„ÄÇ ËÄÉËôëÂØπ‰∫éÁªôÂÆöÁöÑ \(c_i\) Âíå \(k\)ÔºåÂ¶Ç‰ΩïËÆ°ÁÆó \(p\) ÁöÑÊï∞Èáè„ÄÇ ËÆæ \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)ÔºåÂÆö‰πâ \(d_0 = n\)„ÄÇ Â¶ÇÊûú \(d_k &gt; 1\)Ôºå\(p\) ÁöÑÊï∞Èáè‰∏∫ \(0\)„ÄÇ Âê¶Âàô \(p\) ÁöÑÊï∞Èáè‰∏∫ \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÆπÊòì \(dp\) Â§ÑÁêÜÁöÑÂºèÂ≠ê„ÄÇÂàÜÊ≤ª‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ÂÅöÂÆå‰∫Ü„ÄÇ LOJ 6212 „ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçmelon ÁÇπÂáªÊü•ÁúãÈ¢òËß£ \(n \le L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(n\)Ôºå\(L &lt; n \le 2L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(L\)Ôºå‰∏ãÈù¢ËÆ®ËÆ∫ \(n &gt; 2L\) ÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûú Alice ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæÁìúÁöÑÊï∞ÈáèÂ§ß‰∫é \(2L\)ÔºåÂèñËµ∞‰∏Ä‰∏™ÁìúÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÁìúÔºåÂ∞±ËÉΩ‰øùËØÅËá≥Â∞ëÊãøÂà∞ \(\lceil \frac {n} 2\rceil\) ‰∏™Áìú„ÄÇÔºàÂõ†‰∏∫ËøôÊ†∑ Alice ÊãøÂà∞ÁöÑÁìú‰∏ÄÂÆö‰∏ç‰ºöÊØî Bob Â∞ëÔºâ Â¶ÇÊûú Bob ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæ Alice ÂàöÂàöÊãøËµ∞‰∫Ü \(x\) ‰∏™ÁìúÔºåÁé∞Âú®ËøòÂâ©‰∏ã \(c\) ‰∏™ÁìúÔºåÂ¶ÇÊûú \(c-x \ge 2L\)ÔºåÈÇ£‰πàÂèñËµ∞ \(x\) ‰∏™ÁìúÔºõÂê¶ÂàôÂÖàÂèñËµ∞ \(x-1\) ‰∏™ÁìúÔºåÂêÉÂÆåÂêéÔºåÂâ©‰ΩôÁìúÊï∞‰∏∫ \(c-(x-1)\)ÔºåÂõ†‰∏∫ \(c-x &lt; 2L\)ÔºåÊâÄ‰ª• \(c-x+1 \le 2L\)ÔºåÂ¶ÇÊûú \(c-x+1 \le L\)ÔºåÁõ¥Êé•ÂèñËµ∞Ââ©‰ΩôÂÖ®ÈÉ®ÁìúÔºåËøôÁßçÊÉÖÂÜµ‰∏ã Bob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÔºåÂõ†‰∏∫ \(c-x+1 \le 2L\)ÔºåÂú®Ââ©‰ΩôÁöÑ \(c-x+1\) ‰∏™Áìú‰∏≠ÔºåBob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÊúÄÂùè‰πüÂè™ÊòØÁî±‰∫é‰∏ä‰∏ÄÊ¨° Alice Êìç‰ΩúÁöÑÊó∂ÂàªÔºåAlice ÂèñËµ∞‰∫Ü \(x\) ‰∏™ËÄå Bob ÂèñËµ∞‰∫Ü \(x-1\) ‰∏™ÔºåBob ÊØî Alice ÊãøÁöÑÁìúÂ∞ë‰∫Ü‰∏Ä‰∏™„ÄÇÊâÄ‰ª• Bob ÊãøÁöÑÁìúÁöÑÊï∞ÈáèÊúÄÂùèÊØî Alice Â∞ë \(1\)„ÄÇ Âõ†Ê≠§ÔºåÂú®ÂèåÊñπÈÉΩÈááÂèñÊúÄ‰ºòÁ≠ñÁï•Êó∂ÔºåAlice ËÉΩËé∑ÂæóÊÅ∞Â•Ω \(\lceil \frac{n} 2\rceil\) ‰∏™Áìú„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂΩì \(n \le L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(n\)ÔºõÂΩì \(L &lt; n \le 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(L\)ÔºõÂΩì \(n &gt; 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(\lceil \frac {n} 2\rceil\)„ÄÇ CF 1215F Radio Stations ÈùûÂ∏∏Â¶ôÁöÑ 2SAT È¢òÔºåÊ≤°ÊÉ≥Âá∫Êù•„ÄÇÁúã‰∫ÜÈ¢òËß£ËßâÂæóÂæà nb„ÄÇÂÖ∑‰ΩìÂÅöÊ≥ïÂ∞±‰∏çÂÜô‰∫Ü„ÄÇÂèØ‰ª•ÁúãÂÆòÊñπÈ¢òËß£„ÄÇ CF 1188E Problem from Red Panda ÂæÖÂ°´Âùë„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á±ªÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥Áî®‰∏ÄÁõ¥Êã∑Êùø...ÈúÄË¶ÅË°•‰∏ÄË°•‰∫Ü„ÄÇ ÈóÆÈ¢ò Ê±Ç \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] Âç≥Âú®‰∏ÄÊù°Áõ¥Á∫ø‰∏ãÁöÑÊï¥ÁÇπÊï∞. ÂÅöÊ≥ï Â¶ÇÊûú \(a \ge c\) Êàñ \(b \ge c\)ÔºåÂàô \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) Âê¶Âàô \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] ÔºàÂõ†‰∏∫ \(i\) ‰ªé \(0\) ÂºÄÂßãÔºåÊâÄ‰ª•Ë¶ÅÁî®Â∞è‰∫éÂè∑Ôºâ ËøôÊ†∑ÊØèÈÄíÂΩí‰∏§Ê¨°Ôºå\((a,c)\) Â∞±ÂèòÊàê \((c, a\bmod c)\)ÔºåÂõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(O(\log (a+c))\). Áî±‰∫é \(a &lt; c, b &lt; c\)ÔºåÊâÄ‰ª• \(n\) ÁöÑÂÄº‰∏ç‰ºöÂ¢ûÂ§ßÔºåÊó†ÈúÄÊãÖÂøÉÁàÜ long long.]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] ÂÆåÁæéÁöÑÈòüÂàó]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òËß£ Â§çÊùÇÂ∫¶ËÆ®ËÆ∫‰∏≠ÈªòËÆ§ \(n,m\) ÂêåÈò∂„ÄÇ ÂÆö‰πâÁ¨¨ \(i\) ‰∏™Êìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥‰∏∫ \(i\)„ÄÇ Ê±ÇÂá∫ÊØèÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÊñ∞ÁöÑ \(x\) ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥ÔºåÂ∞±ÂæàÂ•ΩÊ±ÇÁ≠îÊ°à‰∫Ü„ÄÇ ‰ªéÂêéÂæÄÂâçËÄÉËôëÊØè‰∏™Êìç‰ΩúÔºåËÆ°ÁÆóËøôÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥„ÄÇ ÂÆö‰πâ‰∏Ä‰∏™ÈòüÂàó \(i\) ÁöÑÂºπÂá∫Êó∂Èó¥‰∏∫‰ªéÂΩìÂâçÊìç‰ΩúÂºÄÂßãÔºåÂæÄÂêéÁ¨¨ \(a_i\) ‰∏™ÂΩ±ÂìçÈòüÂàó \(i\) ÁöÑÊìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥„ÄÇ ÂàÜÂùóÔºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØè‰∏™Êìç‰ΩúÔºåÂàÜÂà´Áª¥Êä§ÊØè‰∏ÄÂùó‰∏≠ÁöÑÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄº„ÄÇÊàë‰ª¨Êää‰∏ÄÂùó‰∏≠ÊâÄÊúâÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄºÁß∞‰∏∫Ëøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Âú®Âä†ÂÖ•Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂêéÔºåÁ¨¨ \(i\) ‰∏™Âùó \([a_i,b_i]\) Áª¥Êä§ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t_i\)ÔºåËÆæ \(c_p\) ‰∏∫Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂà∞Á¨¨ \(t_i-1\) ‰∏™Êìç‰Ωú‰∏≠Á¨¨ \(p\) ‰∏™ÈòüÂàóË¢´ push ÁöÑÊ¨°Êï∞ÔºåÁª¥Êä§ \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)„ÄÇÂêåÊó∂Áª¥Êä§ \(c_p\) ÁöÑÂÄº„ÄÇÔºàÈÄöËøáÊâìÊ†áËÆ∞Ôºâ ËÄÉËôëÂú®Âä†ÂÖ•Êìç‰Ωú \(i\) ÂêéÔºåÂ¶Ç‰ΩïÊõ¥Êñ∞ÊØèÂùóÁª¥Êä§ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÅáËÆæËøô‰∏™ÂùóÊòØÁ¨¨ \(k\) ‰∏™Âùó„ÄÇ ÂØπ‰∫éËøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â§ß‰∫éÁ≠â‰∫é \(m\) ÁöÑÊÉÖÂÜµÈ¢ÑÂÖàÂ§ÑÁêÜÂ•Ω„ÄÇ‰∏ãÈù¢Âè™ËÆ®ËÆ∫ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â∞è‰∫é \(m\) ÁöÑÊÉÖÂÜµ„ÄÇ Êõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ Â¶ÇÊûúËøô‰∏™ÂùóË¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êõ¥Êñ∞ \(mn_k \leftarrow mn_k+1\)„ÄÇÊõ¥Êñ∞ \(c_p\) ÁöÑÂÄºÔºåÂç≥Êâì‰∏Ä‰∏™Êï¥ÂùóÂä† \(1\) Ê†áËÆ∞„ÄÇ Â¶ÇÊûúËøô‰∏™ÂùóÊú™Ë¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êö¥ÂäõÈáçÊûÑÔºåÊõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ„ÄÇ Êõ¥Êñ∞ \(t_k\) Êåâ‰ª•‰∏ãÊ≠•È™§ËøõË°åÔºö Â¶ÇÊûú \(mn_k \ge 0\)ÔºåËØ¥Êòé \(t_k\) ÂèØ‰ª•ÂáèÂ∞èÔºåÈÇ£‰πà \(t_k \leftarrow t_k-1\)„ÄÇÂê¶Âàô‰∏çÁî®Êõ¥Êñ∞ÔºåÁªìÊùüÊìç‰Ωú„ÄÇ Â¶ÇÊûúÁ¨¨ \(t_k\) Ê¨°Êìç‰ΩúÂåÖÂê´Êï¥‰∏™ÂùóÔºåÈÇ£‰πà \(mn_k \leftarrow mn_k-1\)ÔºåÊâì \(-1\) Ê†áËÆ∞Êõ¥Êñ∞ \(c_p\) ÁöÑÂÄº„ÄÇÂê¶ÂàôÊö¥ÂäõÈáçÊûÑÊõ¥Êñ∞ \(mn_k\) Âíå \(c_p\) ÁöÑÂÄº„ÄÇ ËΩ¨Âà∞Êìç‰Ωú 1„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂú® \(O(n \sqrt n)\) Êó∂Èó¥ÂÜÖÁª¥Êä§ÊØè‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Ââ©‰ΩôÁöÑÈóÆÈ¢òÊòØ: Â¶Ç‰ΩïÂú®‰ªéÂè≥ÂæÄÂ∑¶Âä†ÂÖ•Êìç‰ΩúÁöÑËøáÁ®ã‰∏≠ÔºåÊîØÊåÅÊü•ËØ¢‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇÊääÂå∫Èó¥ÊãÜÊàêËã•Âπ≤‰∏™ÂùóÂíå‰∏çË∂ÖËøá \(2 \sqrt n\) ‰∏™Â§öÂá∫Êù•ÁöÑÁÇπ„ÄÇÂØπ‰∫éËøô‰∫õÂùóÔºåÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ÔºåÂèñ \(\max\) Âç≥ÂèØ„ÄÇÂØπ‰∫éËøô‰∫õÂ§öÂá∫Êù•ÁöÑÁÇπÔºåÈúÄË¶ÅÂä®ÊÄÅËØ¢ÈóÆ‰ªñ‰ª¨ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Â§ÑÁêÜÂçïÁÇπ‰ø°ÊÅØ Ë¶ÅÊîØÊåÅ‰ªéÂêéÂæÄÂâçÊ∑ªÂä†Êìç‰ΩúÔºåËØ¢ÈóÆÂçï‰∏™ÈòüÂàóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ ÂêåÊ†∑ÂàÜÂùóÁª¥Êä§„ÄÇÂØπÊØè‰∏™ÂùóÂºÄ‰∏Ä‰∏™ vectorÔºåÂØπÊØè‰∏™ÈòüÂàóÂºÄ‰∏Ä‰∏™ vector„ÄÇÂú®ËøõË°å‰øÆÊîπÊó∂ÔºåÂØπÂÆåÊï¥ÂåÖÂê´ÁöÑÊØè‰∏™ÂùóÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑ÔºåÂÜçÂØπ‰∏§ËæπÂ§öÂá∫ÁöÑ \(O (\sqrt n)\) ‰∏™ÈòüÂàóÂØπÂ∫îÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑„ÄÇ ÈÇ£‰πà‰∏Ä‰∏™ÈòüÂàóÁöÑÊìç‰ΩúÂ∫èÂàóÂ∞±ÊòØÂÆÉÁöÑ vector ÂíåÂÆÉÊâÄÂú®ÁöÑÂùóÁöÑ vector ÂΩíÂπ∂ÂêéÁöÑÁªìÊûú„ÄÇÂØπÊØè‰∏™ÁÇπËÆ∞ÂΩïÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t\) (ÊØèÊ¨°ËØ¢ÈóÆÊó∂Êõ¥Êñ∞Ôºå‰øÆÊîπÊó∂‰∏ç‰∏ÄÂÆöÊòØÊúÄÊñ∞ÁöÑ)ÔºåÂÆÉÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâçÁöÑ‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_1\)ÔºåÂÆÉÊâÄÂú®ÂùóÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâç‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_2\)„ÄÇÂØπÊØè‰∏™ÂùóËÆ∞ÂΩïËøô‰∏™Âùó‰∏≠ÁöÑÈòüÂàóÂú®‰∏ä‰∏ÄÊ¨°Êõ¥Êñ∞‰ø°ÊÅØ‰πãÂêé‰øÆÊîπÁöÑÊ¨°Êï∞ \(c\)„ÄÇÈÇ£‰πà‰øÆÊîπÁöÑÊó∂ÂÄôÂØπÊï¥ÂùóÂè™ÈúÄË¶Å \(c \leftarrow c+1\)ÔºåÂØπ‰∏§Á´ØÁöÑÂùóÊõ¥Êñ∞ÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™ÈòüÂàóÁöÑ \(t, p_1, p_2\)ÔºåÂπ∂Êää \(c\) ËÆæ‰∏∫ \(0\)„ÄÇÊõ¥Êñ∞ÊñπÊ≥ïÂ§ßËá¥‰∏∫ÔºöÂØπ‰∫é‰∏Ä‰∏™ÈòüÂàóÔºåÂÖàÂà§Êñ≠ \(t\) ÊòØÂú®ÂÆÉ vector ‰∏≠ËøòÊòØÂú®ÂùóÁöÑ vector ‰∏≠ÔºàÈÄöËøá \(p_1, p_2\) ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ÔºâÔºåËøô‰∏§ÁßçÊÉÖÂÜµÂå∫Âà´‰∏çÂ§ßÔºåÊâÄ‰ª•ËøôÈáåÂè™ÂÜôÂú®Âùó vector ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÂÆö‰πâ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáè \(t = c\)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂùóÁöÑ vector ‰∏≠ÁöÑÁ¨¨ \(p_2+t\) È°πÁöÑÂ∞è‰∫éËøô‰∏™ÈòüÂàóÁöÑ vector ‰∏≠ÁöÑ \(p_1\) È°πÔºåÈÇ£‰πà \(p_1 \leftarrow p_1+1\)ÔºåÁÑ∂Âêé \(t \leftarrow t-1\)ÔºåÁÑ∂ÂêéÂÜçÊ¨°Ê£ÄÊü•ÔºåËøôÊ†∑Âæ™ÁéØÁõ¥Âà∞ÂèØ‰ª•Áõ¥Êé•Êää \(p_2\) Êîπ‰∏∫ \(p_2+t\) ÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ \(p_2\) Â∞±ÂÆåÊàê‰∫ÜÊõ¥Êñ∞„ÄÇ ‰∏Ä‰∏™ÈòüÂàóË¢´Êõ¥Êñ∞Êó∂ËøõË°åÁöÑÂà§Êñ≠ÁöÑÊÄªÊ¨°Êï∞‰∏éÂÆÉÁöÑ vector ‰∏≠ÂÖÉÁ¥†‰∏™Êï∞ÂêåÁ∫ßÔºåÊâÄ‰ª•Êõ¥Êñ∞ÁöÑÊÄªÂ§çÊùÇÂ∫¶ÊòØ \(O(n)\) ÁöÑ„ÄÇÔºà‰ΩÜÊòØÁª¥Êä§ vector ÂíåËøõË°åÊìç‰ΩúÊòØ \(O(\sqrt n)\) ÁöÑÔºâ„ÄÇ ËøôÊ†∑Â∞±‰ª• \(O(n \sqrt n)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ÂÆûÁé∞ 1ÂæÖÂ°´]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊìç‰ΩúÊ®°Êùø]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI ÂâçÂ§ç‰π†„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //ÊúÄÂ§ßÂ§öÈ°πÂºèÈïøÂ∫¶ÔºåÂÄçÊï∞ÈóÆÈ¢òÂ∑≤ÁªèËÄÉËôëconst int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé®]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[Â§öÈ°πÂºèÂèñÊ®°‰ºòÂåñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // ÁâπÂæÅÂ§öÈ°πÂºèint wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //‰πò‰ª• A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÈîôËØØËÆ∞ÂΩï]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ÊØîËæÉÂáΩÊï∞ÂÆö‰πâ‰∏ç‰∏•Ê†ºÔºåÂ≠òÂú®ËøîÂõûÁõ∏Á≠â‰ΩÜÊòØÂÆûÈôÖ‰∏äÊúâÂå∫Âà´ÁöÑÊÉÖÂÜµ„ÄÇËøôÂèØËÉΩÂØºËá¥ÂèåÂ†ÜÁª¥Êä§Âà†Èô§Êìç‰ΩúÊó∂Âá∫Áé∞ÈóÆÈ¢ò„ÄÇÔºàÂ∫îÂΩìÂêåÊó∂ÂºπÊ†à‰ΩÜÊòØÊ†àÈ°∂ÂÖÉÁ¥†‰∏çÁõ∏Á≠âÔºâ for (int i = 1; i &lt;= n; i++) a[n] = inf„ÄÇ Âú®‰∏Ä‰∫õÂõûÊ∫ØÊó∂ÈúÄË¶ÅÊí§ÈîÄÊìç‰ΩúÁöÑ dfs ‰∏≠ÔºåÂõ†‰∏∫ÂÖ∂‰ªñÂéüÂõ† return ÁöÑÊó∂ÂÄôÊ≤°ÊúâÊí§ÈîÄÊìç‰Ωú„ÄÇ Âæ™ÁéØ/if ÈáåÂ±ÇÂ§ñÂ±ÇÂèòÈáèÂêçÊ∑∑Ê∑Ü„ÄÇ ËøõË°å dfs / ÈÄíÂΩíÊó∂ÔºåÂõ†‰∏∫‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè‰∏ãÂ±Ç dfs Êó∂Á†¥Âùè‰∫Ü‰∏äÂ±Ç‰πãÂêéË¶ÅÁî®Âà∞ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÆπÊñ•Êó∂ÔºåÂè™Êûö‰∏æ‰∫ÜÈõÜÂêàÂ§ßÂ∞èÂøòËÆ∞‰∫Ü‰πòÁªÑÂêàÊï∞„ÄÇ ÊèíÂ§¥ dp ‰∏çË¶ÅÂøòËÆ∞ËøûÊé•‰∏§‰∏™Â∑¶Êã¨Âè∑ÊàñËÄÖËøûÊé•‰∏§‰∏™Âè≥Êã¨Âè∑ÁöÑÊÉÖÂÜµ„ÄÇ Ê†ëÈìæÂâñÂàÜÊó∂ÔºåËØ¢ÈóÆÈìæÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèÊòØÊØîËæÉÈáçÈìæÈ°∂Á´ØÊ∑±Â∫¶Â§ßÂ∞èÔºå‰∏çËÉΩÁõ¥Êé•ÊØîËæÉ‰∏§‰∏™ÁÇπÊ∑±Â∫¶Â§ßÂ∞è„ÄÇ sort Êó∂ÂøòËÆ∞Âä†ÊØîËæÉÂáΩÊï∞„ÄÇ Áª¥Êä§Áü©Èòµ‰πòÊ≥ïÊó∂Â∑¶‰πòÂè≥‰πòÊêûÈîô„ÄÇ Á∫øÊÆµÊ†ëÂêàÂπ∂Êó∂ÔºåÂ¶ÇÊûúË¶ÅÂèØÊåÅ‰πÖÂåñÔºåÁ©∫Èó¥Ë¶ÅÂºÄ‰∏§ÂÄç„ÄÇ Âú®Â§ÑÁêÜÊ∂âÂèä‰∏çÂêåÈïøÂ∫¶Â≠óÁ¨¶‰∏≤ÁöÑÂ≠óÁ¨¶‰∏≤ÂìàÂ∏åÊó∂Ôºå‰∏ÄÂÆöË¶ÅÁî® str[i] - 'a' + 1 ËÄå‰∏çÊòØ str[i] - 'a' Âú®Â§ÑÁêÜÂ≠êÊ†ëÊúÄÈïø‰ªéÊ†πÂºÄÂßãË∑ØÂæÑ‰πãÁ±ªÁöÑÈóÆÈ¢òÊó∂ÔºåÂ¶ÇÊûúËøô‰∏™Â≠êÊ†ë‰∏çËÉΩÈÄâÔºådp ÂÄºËÆæ‰∏∫ \(0\) ‰ªç‰ºö +1 Âêë‰∏äË¥°ÁåÆ Âú®Áî® new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Âá∫Áé∞Ë∂äÁïå„ÄÇËøôÊó∂‰∏ç‰ºöÊä•ÈîôÔºåÂá∫Áé∞ new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Ôºå‰∏ÄÂÆöË¶ÅË∞®ÊÖéËÆ°ÁÆóÊØèÊ¨°Ë∞ÉÁî®ÁöÑÂ§ßÂ∞è„ÄÇÔºàÂ∞§ÂÖ∂ÊòØÂÜôÂ§öÈ°πÂºèÊó∂Ôºâ Áª¥Êä§Á∫øÊÆµÊ†ëÂå∫Èó¥Âä†Êó∂ÔºåÁªìÊûúÂèØËÉΩÂæàÂ§ßÁöÑÊó∂ÂÄô modify ÂáΩÊï∞ÂèÇÊï∞‰∏çÂºÄ long long]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[ÂèëËøôÁØáÂçöÂÆ¢‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆ∞ÂΩï‰∏Ä‰∏™ÊûÅ‰∏∫ÈöêËîΩÁöÑÈîôËØØ„ÄÇ ÂÜôÊØîËæÉÂáΩÊï∞‰∏ÄÂÆöË¶Å‰øùËØÅÊòØ‰∏•Ê†ºÁöÑÂ∞è‰∫éÂè∑„ÄÇË¶ÅÁâπÂà´Â§ÑÁêÜÁ≠â‰∫é„ÄÇÂê¶ÂàôÂú®ÈÅáÂà∞Â†ÜÊâìÊ†áËÆ∞Âà†Èô§ËøôÁßçÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÂÖÉÁ¥†Âú®Â†Ü‰∏≠ÁöÑÈ°∫Â∫è‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] „ÄåZJOI2017„ÄçÂ≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÂÅöÊ≥ï ‰∏çÈöæËØÅÊòéÂ¶ÇÊûú‰∏Ä‰∏™Â≠ê‰∏≤ \(s\) Êúâ‰∏§‰∏™ÂêéÁºÄ \(s_1, s_2\)Ôºå\(s_2\) ÊòØ \(s_1\) ÁöÑ border ‰∏î \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)ÔºåÈÇ£‰πàÂØπ‰∫é‰ªªÊÑèÁöÑÂ≠óÁ¨¶‰∏≤ \(t\)Ôºå\(s_2\) ‰∏çÂèØËÉΩÊòØ \(st\) ÁöÑÊúÄÂ∞èÂêéÁºÄ„ÄÇ Áî®‰∏Ä‰∏™Á∫øÊÆµÊ†ëÁª¥Êä§ÊØè‰∏™Âå∫Èó¥ÂÜÖÂèØËÉΩÊàê‰∏∫ÊúÄÂ∞èÂêéÁºÄÁöÑÁÇπÔºåËøôÊ†∑ÁöÑÁÇπÂè™Êúâ \(\mathcal O (\log n)\) ‰∏™„ÄÇpush up ÁöÑÊó∂ÂÄôÊö¥ÂäõÂêàÂπ∂Âç≥ÂèØ„ÄÇ ÊØîËæÉÂ§ßÂ∞èÁöÑÊó∂ÂÄôÈúÄË¶ÅÊü• lcpÔºåÂàÜÂùóÁª¥Êä§ÂâçÁºÄÂìàÂ∏åÂç≥ÂèØÂÅöÂà∞ \(\mathcal O(\sqrt n)\) ‰øÆÊîπÔºå\(\mathcal O(\log n)\) ËØ¢ÈóÆÔºàË∞ÉÊï¥ÂùóÂ§ßÂ∞èÂ∫îËØ•ÂèØ‰ª•ÂÅöÂà∞Êõ¥‰ºòÁöÑÂ§çÊùÇÂ∫¶Ôºâ„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)„ÄÇ ÔºàÁúüÁöÑÊØíÁò§Ôºâ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø]-Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ ÁÆÄÂçïÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] Âå∫Èó¥Á¥†Êï∞‰∏™Êï∞]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ËØïÁùÄÂÆûÁé∞‰∏ã min_25 Á≠õÁöÑÁ¨¨‰∏ÄÊ≠•„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/problemset/problem/715/E È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏§‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàó \(p_1\) Âíå \(p_2\)ÔºåÂÖ∂‰∏≠Êúâ‰∏Ä‰∫õ‰ΩçÁΩÆË¢´ÊåñÁ©∫ÔºåËÆ©‰Ω†Ëá™Â∑±Â°´Êï∞Â≠ó„ÄÇ ËØ∑‰Ω†ÂØπÊØè‰∏™ \(k\) ËæìÂá∫ÔºåÊúâÂ§öÂ∞ëÁßçÂ°´Êï∞Â≠óÊñπÊ°àÔºå‰ΩøÂæó \(p_1\) ÊúÄÂ∞ë‰∫§Êç¢ \(k\) Ê¨°ÂèØ‰ª•ÂèòÊàê \(p_2\)„ÄÇ \(n \le 250\)„ÄÇ Ëß£Ê≥ï È¶ñÂÖàÈ¢òÁõÆ‰øùËØÅËá≥Â∞ëÂ≠òÂú®‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°à‰ΩøÂæó \(p_1\) Âíå \(p_2\) ÊòØÊéíÂàóÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊï∞‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµ„ÄÇ ÂÆπÊòìÁúãÂá∫‰∫§Êç¢Ê¨°Êï∞ \(n-(p_1p_2^{-1}\) ÁöÑËΩÆÊç¢Êï∞\()\)„ÄÇ ÈóÆÈ¢òÂèòÊàê‰∫ÜÊ±ÇÊª°Ë∂≥ \(p_1p_2^{-1}\) ÊÅ∞Â•ΩÂèØ‰ª•ÂàÜËß£‰∏∫ \(k\) ‰∏™‰∏çÁõ∏‰∫§ËΩÆÊç¢ÁöÑÊñπÊ°àÊï∞„ÄÇ ËÆæ \(p_1p_2^{-1}=w\)ÔºåÂàô \(p_1=wp_2\)ÔºåÂç≥ \(p_1[i]=w[p_2[i]]\)„ÄÇ ËÆæÊâÄÊúâ \(p_1\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_1\)ÔºåÊâÄÊúâ \(p_2\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_2\)„ÄÇ ÂÅáËÆæ \(w\) ÊòØÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊéíÂàó„ÄÇÈÇ£‰πàÂØπ‰∫é \(i \in S_1\)ÔºåÊúâ \(p_2[i]=w^{-1}[p_1[i]]\)ÔºõÂØπ‰∫é \(i \in S_2\)ÔºåÊúâ \(p_1[i]=w[p_2[i]]\)„ÄÇÊâÄ‰ª• \(\forall i \in S_1 \cap S_2\)Ôºå\(p_1[i]\) Âíå \(p_2[i]\) ÈÉΩÊòØÁ°ÆÂÆöÁöÑ„ÄÇÂØπ‰∫é \(p_1\) Êù•ËØ¥ÔºåËøòÊúâ \(n-\lvert S_1\cup S_2 \rvert\) ‰∏™‰ΩçÁΩÆË¶ÅÂ°´ÁöÑÊï∞Ê≤°ÊúâÁ°ÆÂÆö„ÄÇÈÇ£‰πàÂ¶ÇÊûúÂ≠òÂú®Ëá≥Â∞ë‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°àÔºåÂ∞±ÊÅ∞Â•ΩÊúâ \((n-\lvert S_1\cup S_2 \rvert)!\) Áßç‰ΩøÂæó \(p_1p_2^{-1}=w\) ÁöÑÂ°´Êï∞ÊñπÊ°à„ÄÇ ÂÜçËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÂêàÊ≥ïÁöÑ \(w\)„ÄÇÂØπ‰∫é \(i \in S_1\cap S_2\)Ôºå\(w[p_2[i]]=p_1[i]\)„ÄÇÊâÄ‰ª• \(w\) ÁöÑ‰∏Ä‰∫õ‰ΩçÁΩÆÂ∑≤ÁªèÁ°ÆÂÆö‰∫Ü„ÄÇÂêåÊó∂ \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)„ÄÇ\(w\) ‰∏≠Á°ÆÂÆöÁöÑ‰ΩçÁΩÆÂ∑≤ÁªèÊûÑÊàê‰∫Ü‰∏Ä‰∫õÈìæÂíå‰∏Ä‰∫õÁéØ„ÄÇÊûÑÊàêÁéØÂêé‰∏çÂèØËÉΩ‰∏éÂÖ∂‰ªñÁÇπËøûËæπÔºåÂèØ‰ª•Áõ¥Êé•ÂøΩÁï•„ÄÇÈìæÂèØ‰ª•Áº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÈÇ£‰πàÈóÆÈ¢òËΩ¨Âåñ‰∏∫ÔºåÁªôÂÆö‰∏§‰∏™ÈõÜÂêà \(A\) Âíå \(B\)ÔºåÊ±ÇÊúâÂ§öÂ∞ë‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàóÔºåÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÊéíÂàóÔºåÊª°Ë∂≥ \(\forall i \in A, w[i] \notin B\)„ÄÇÊòæÁÑ∂Ëøô‰∏™ÈóÆÈ¢òÂè™‰∏é \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) ÊúâÂÖ≥„ÄÇ ÂÖàËÄÉËôë \(A\cap B =\emptyset\)„ÄÇÂÆπÊñ•‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] ÂÜçËÄÉËôë \(A\cap B \neq \emptyset\)„ÄÇÊääÈôêÂà∂Êù°‰ª∂Áúã‰Ωú \(\forall i \in A\setminus B,w[i]\notin B\) Âíå \(\forall i \in A \cap B, w[i] \notin B\)„ÄÇÂØπÁ¨¨‰∫å‰∏™Êù°‰ª∂ÂÆπÊñ•„ÄÇËÆæ \(G(n, c, i)\) ‰∏∫ \(n\) ‰∏™Êï∞ÁöÑÊéíÂàóÔºåÂÜ≥ÂÆö \(c\) ‰∏™‰ΩçÁΩÆÂ°´‰ªÄ‰πàÔºå‰ΩøÂ∑≤ÁªèÂÜ≥ÂÆöÁöÑËæπÊûÑÊàê \(i\) ‰∏™ÁéØÊñπÊ°àÊï∞ÔºàÊòæÁÑ∂Ê≠§Êó∂Êúâ \(n-c\) Êù°ÈìæÔºâ„ÄÇ \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) ÂÆûÈôÖÂè™Êúâ \(n^2\) ÁßçÔºåÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(F\) Âç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n^3)\)„ÄÇ ÂÜçËÄÉËôë \(G\) ÊÄé‰πàËÆ°ÁÆó„ÄÇ\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) ËÆ°ÁÆóÈùûÂ∏∏Êñπ‰æø„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï È¶ñÂÖàÔºå‰∏Ä‰∏™‰ª• \(A\) ‰∏∫ÂºÄÂ§¥‰ª• \(B\) ‰∏∫ÁªìÂ∞æÁöÑÂ∫èÂàóÊòØÂê¶Â≠òÂú®Ôºå‰ªÖ‰∏é \(A\oplus B\) ÊúâÂÖ≥„ÄÇ Â¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÈÇ£‰πà \(A\oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏ÄÂÆöÊòØÂ•áÊï∞„ÄÇ ‰∏Ä‰∏™ÁªìËÆ∫ÊòØÔºåÂ¶ÇÊûú \(A \oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÈÇ£‰πàÊª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàó‰∏ÄÂÆöÂ≠òÂú®„ÄÇ ‰∏ãÈù¢ÈÄíÂΩíÂú∞ÁªôÂá∫ÊûÑÈÄ†„ÄÇ ÂÆö‰πâ \(build(n,A,B)\) ËøîÂõû‰∏Ä‰∏™ \(0 \ldots 2^n-1\) ÁöÑ‰ª• \(A\) ‰∏∫ÂºÄÂ§¥Ôºå\(B\) ‰∏∫ÁªìÂ∞æÁöÑÊéíÂàó„ÄÇÔºà\(A\oplus B\) ‰∏≠ÊúâÂ•áÊï∞‰∏™ \(1\)Ôºâ Ëã• \(n=1\)ÔºåÂ¶ÇÊûú \(A = 0\)ÔºåËøîÂõû \(A, B\)„ÄÇ Ëã• \(A \oplus B\) ‰∏≠ÊÅ∞Êúâ‰∏Ä‰∏™ \(1\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^{n-1}\)ÔºàÂÖ∂‰ªñÊÉÖÂÜµÂè™ÈúÄË¶ÅÊääÊâÄÊúâÊï∞ÂºÇÊàñ‰∏ä \(A\) Âπ∂Êää \(1\) ÊâÄÂú®Âú®‰ΩçÂíåÊúÄÈ´ò‰Ωç‰∫§Êç¢Âç≥ÂèØÔºâ„ÄÇ ËÆæ \(a=build(n-1, 0, 1)\)ÔºåÈÇ£‰πà \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠Â≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæÂÖ∂‰∏≠ \(0\) Âú®ÊúÄ‰Ωé‰Ωç‰∏ä‰∏î \(A\) ÁöÑÊúÄ‰Ωé‰Ωç‰∏∫ \(0\)„ÄÇ ËÆæ \(a = build(n-1, \frac A 2, \frac B 2)\)Ôºå\(b = build(n-1, a_1, a_2)\)„ÄÇ ÈÇ£‰πà \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠‰∏çÂ≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^n-1\)„ÄÇ ËÆæ \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)„ÄÇ Âàô \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊéíÂàó„ÄÇ Áî®‰∏ªÂÆöÁêÜÂèØ‰ª•ÂàÜÊûêÂá∫Áõ¥Êé•ÈÄíÂΩíÁöÑÂ§çÊùÇÂ∫¶Âπ∂‰∏çÈ´ò„ÄÇÊâÄ‰ª•Áõ¥Êé•ÈÄíÂΩí‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï ËÆæ \(f_{i,j}\) Ë°®Á§∫Êää \(p_i \ldots p_n\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÊéíÂ∫èÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇ ËÆæ \(k\) ÊòØ \(p_i \ldots p_n\) ‰∏≠Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÁöÑ‰ΩçÁΩÆÔºå\(p_i\ldots p_k\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÂÖ±Êúâ \(c\) ‰∏™„ÄÇ \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] È¢ÑÂ§ÑÁêÜÂá∫ \(p\) Âíå \(c\)Ôºå\(n^2\) dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ È¢òÁõÆÂ§ßÊÑè Áªô‰Ω†‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÔºåËæπ‰∏äÊúâÂ≠óÁ¨¶„ÄÇÂÆö‰πâË∑ØÂæÑ \(u\) Âà∞ \(v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Â∞±ÊòØÊääË∑ØÂæÑ‰∏äÁöÑÂ≠óÁ¨¶‰æùÊ¨°Êé•Ëµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁªôÂÆö \(m\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s_1,s_2\ldots s_m\)„ÄÇ\(q\) Ê¨°ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏â‰∏™Êï∞ \(i, j, k\)ÔºåËØ¢ÈóÆÂú®Ë∑ØÂæÑ \(i\) Âà∞ \(j\) ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠Ôºå\(s_k\) Âá∫Áé∞‰∫ÜÂá†Ê¨°„ÄÇ Ëß£Ê≥ï Á¨¶Âè∑ËØ¥ÊòéÔºö\(s^R\) Ë°®Á§∫ \(s\) ÁöÑÂèç‰∏≤„ÄÇ\(pre(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂâçÁºÄÔºå\(suf(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂêéÁºÄ„ÄÇ\(s+t\) Ë°®Á§∫ÊääÂ≠óÁ¨¶‰∏≤ \(s\) ÂíåÂ≠óÁ¨¶‰∏≤ \(t\) ÊãºËµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇ ÂÖàÂÅö‰∏ÄÊ¨°ÁÇπÂàÜÊ≤ªÂ∞±ÂèØ‰ª•ÊääÈóÆÈ¢òËΩ¨Âåñ‰∏∫ \(u \rightarrow v\) ÁªèËøáÊ†πÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•Âè™ËÆ®ËÆ∫ÁªèËøáÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ËÆæÊ†π‰∏∫ \(r\)ÔºåËØ¢ÈóÆÁöÑË∑ØÂæÑ‰∏∫ \(u \rightarrow v\)ÔºåËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(s_k\)„ÄÇ ÂèØ‰ª•Êää \(s_k\) Âú®Ë∑ØÂæÑ \(u \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÂàÜÊàê‰∏âÈÉ®ÂàÜËÆ°ÁÆóÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØÂú® \(u\rightarrow r\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∫åÈÉ®ÂàÜÊòØÂú® \(r \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∏âÈÉ®ÂàÜÊòØÂú®Ë∑®Ëøá \(r\) ÁöÑÂåπÈÖç„ÄÇ Ââç‰∏§ÈÉ®ÂàÜÊòØÊØîËæÉÂ•ΩËÆ°ÁÆóÁöÑ„ÄÇÁ¶ªÁ∫ø‰∏Ä‰∏ãÔºåÂØπÊâÄÊúâÁöÑ \(s_i\) Âª∫ACËá™Âä®Êú∫ÔºåÂú®Ê†ë‰∏ädfsÔºåÊØèÊ¨°Âú®ACËá™Âä®Êú∫‰∏äËµ∞‰∏ÄÊù°ËΩ¨ÁßªËæπÔºåÁî® BIT Áª¥Êä§‰∏Ä‰∏ãÊØè‰∏™ÁÇπË¢´Ëµ∞‰∫ÜÂá†Ê¨°ÔºåÂú® dfs Âà∞ÁÇπ \(x\) Êó∂ÔºåÂè™ÈúÄ‰Ωú‰∏ÄÊ¨°Â≠êÊ†ëËØ¢ÈóÆÂç≥ÂèØÂø´ÈÄüÂæóÂà∞ \(s_k\) Âú® \(r\rightarrow x\) ‰∏äÂá∫Áé∞‰∫ÜÂá†Ê¨°ÔºàÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØ¢ÈóÆ \(s_k\) ÁöÑÂèç‰∏≤Âá∫Áé∞‰∫ÜÂá†Ê¨°Ôºâ„ÄÇ ÊØîËæÉÁÆÄÂçïÂ∞±‰∏çËØ¶ÁªÜÊèèËø∞‰∫Ü„ÄÇ Á¨¨‰∏âÈÉ®ÂàÜÊØîËæÉÂ§çÊùÇ„ÄÇËÆæË∑ØÂæÑ \(u\rightarrow r\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(x\)ÔºåË∑ØÂæÑ \(r \rightarrow v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(y\)„ÄÇËÆæ \(p\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(pre(s_k,p)=suf(x,p)\) ÁöÑÊï¥Êï∞Ôºå\(q\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(suf(s_k,q)=pre(y,q)\) ÁöÑÊï¥Êï∞„ÄÇÈÇ£‰πàËÆ°ÁÆóÁ¨¨‰∏âÈÉ®ÂàÜÂèØ‰ª•ËΩ¨Âåñ‰∏∫ËÆ°ÁÆó \(s_k\) Âú® \(suf(x,p)+pre(y,q)\) ‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞„ÄÇ ËÆæ \(t_i\) Ë∑ØÂæÑË°®Á§∫ \(r\rightarrow i\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂàô \(suf(x,p)+pre(y,q)\) ÂèØ‰ª•Ë°®Á§∫‰∏∫ \(pre(s_k,p)+suf(s_k,q)\)ÔºåËøôÊ†∑Â∞±ËΩ¨Âåñ‰∏∫‰∫ÜÂè™‰∏é \(s_k\) Áõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ\(p\)„ÄÅ\(q\) ÁöÑÂÖ∑‰ΩìÊ±ÇÊ≥ïÂêéÈù¢‰ºöËØ¶ÁªÜÊèèËø∞„ÄÇÂÅáËÆæÂ∑≤ÁªèÊ±ÇÂæó‰∫Ü \(p\)„ÄÅ\(q\)ÔºåËÄÉËôëÊÄé‰πàÂø´ÈÄüÂæóÂà∞Á¨¨‰∏âÈÉ®ÂàÜÁöÑÂåπÈÖçÊ¨°Êï∞„ÄÇ ÊääËØ¢ÈóÆÁ¶ªÁ∫ø„ÄÇÂØπÊØè‰∏™ \(i\)ÔºåÂª∫‰∏ÄÊ£µ \(s_i\) ÁöÑÂêéÁºÄÊ†ëÂíå \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë„ÄÇÂú® \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë‰∏ä \(dfs\)Ôºå\(dfs\) ÁöÑËøáÁ®ã‰∏≠ÔºåÁª¥Êä§‰∏ÄÊ£µÁ∫øÊÆµÊ†ë„ÄÇÂ¶ÇÊûú \(dfs\) Âà∞‰∏Ä‰∏™‰ª£Ë°® \(s_i^R\) ÂêéÁºÄÁöÑÁÇπÔºåËÆæËøô‰∏™ÁÇπÂØπÂ∫îÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ \(l\)ÔºåÈÇ£‰πàÂ∞±Âú®Á∫øÊÆµÊ†ë‰∏äÊää \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÂØπÂ∫î \(s_i[l+1\ldots \lvert s_i \rvert]\) ÁöÑÁÇπÁöÑÂ≠êÊ†ë \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂä†‰∏Ä„ÄÇÔºàÂèØËÉΩÊèèËø∞ÁöÑ‰∏çÊòØÂæàÊ∏ÖÊ•ö...Êàë‰πü‰∏çÁü•ÈÅìÊÄé‰πàÊèèËø∞‰∫ÜÔºâÂõûÊ∫ØÊó∂Êí§ÈîÄÊìç‰Ωú„ÄÇÁÑ∂ÂêéÂØπÊØè‰∏™ËØ¢ÈóÆ \(p, q\)ÔºåÂè™Ë¶ÅÂú® \(dfs\) Âà∞ \(s_i^R\) ÈïøÂ∫¶‰∏∫ \(p\) ÁöÑÂêéÁºÄÊó∂ÔºåËØ¢ÈóÆ‰∏Ä‰∏ã \(s_i\) ÈïøÂ∫¶‰∏∫ \(q\) ÁöÑÂêéÁºÄÂú® \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÁöÑ \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÁöÑÂÄºÂç≥ÂèØ„ÄÇ ËÄÉËôëÂ¶Ç‰ΩïÊ±Ç \(p\)„ÄÅ\(q\)„ÄÇÁî±‰∫éÊ±Ç \(q\) ÁöÑËøáÁ®ãÂíåÊ±Ç \(p\) Á±ª‰ººÔºåËøôÈáåÂè™ËØ¶ÁªÜÊèèËø∞Ê±Ç \(p\) ÁöÑËøáÁ®ã„ÄÇÂØπÊâÄÊúâ \(s_i\) ‰ª•Âèä \(s_i^R\) Âª∫Âá∫‰∏Ä‰∏™Âπø‰πâSAM„ÄÇÁÑ∂ÂêéÁ±ª‰ººACËá™Âä®Êú∫+BITÁöÑËøáÁ®ãÂú∞ÔºåÁª¥Êä§‰∏Ä‰∏™‰ª•parentÊ†ë \(dfs\) Â∫è‰∏∫‰∏ãÊ†áÁöÑÁ∫øÊÆµÊ†ë„ÄÇÁÑ∂ÂêéÂú®ÁÇπÂàÜÊ≤ªÂêéÂæóÂà∞ÁöÑËøûÈÄöÂùó‰∏ä \(dfs\)Ôºå\(dfs\) Âà∞ \(u\) Êó∂Áª¥Êä§ \(r\rightarrow u\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Âú®SAM‰∏äÁöÑ‰ΩçÁΩÆÔºåÂπ∂ÊääÂÆÉÁöÑÂ≠êÊ†ëÂú® \(dfs\) Â∫è‰∏äÁöÑ‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÂ≠êÊ†ëÂØπÈïøÂ∫¶Âèñ \(max\)„ÄÇÁÑ∂ÂêéÊ±Ç \(p\) Êó∂Âè™ÈúÄË¶ÅËØ¢ÈóÆ‰∏Ä‰∏ã \(s_k^R\) Âú® \(SAM\) ‰∏äÁöÑ‰ΩçÁΩÆÂú®parent tree‰∏≠ÁöÑ \(dfs\) Âú®Á∫øÊÆµÊ†ë‰∏äÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• „ÄåPKUWC2018„ÄçMinimax„ÄÇ Â§ßËá¥ÊÄùË∑Ø&amp;&amp;ÂêêÊßΩ Á∫øÊÆµÊ†ëÂêàÂπ∂ÔºåÁª¥Êä§Êüê‰∏™ÁÇπÊúÄÂêéÁöÑÂÄºÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™Âå∫Èó¥ÁöÑÊ¶ÇÁéá„ÄÇ merge ÁöÑÊó∂ÂÄôËÆ∞‰∏Ä‰∏ãÂâçÂêéÁºÄÊ¶ÇÁéáÂ∞±ËÉΩËΩ¨Áßª‰∫Ü„ÄÇ ‰ª£Á†ÅËÉΩÂäõÁúüÊòØË∂äÊù•Ë∂äÂ∑Æ‰∫Ü..Á∫øÊÆµÊ†ëÂêàÂπ∂ÈÉΩÂÜô‰∏çÁÜü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 Êï¥Êï∞]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) ‰∏™ \(bit\) Âéã‰∏ÄËµ∑ÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥Â∑¶ËæπËøûÁª≠ \(0\) Âíå \(2^{30}-1\) ÁöÑ‰∏™Êï∞„ÄÇ ‰ª£Á†ÅËÉΩÂäõÂ§™Ëèú‰∫ÜË°•Ë°•Ê∞¥È¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ Ë¥®Êï∞Âà§ÂÆö„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] ÂèçÂõûÊñá‰∏≤]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄåSDOI2018„ÄçÂèçÂõûÊñá‰∏≤„ÄÇ È¢òËß£ ËÄÉËôë‰ªÄ‰πàÊ†∑ÁöÑÂõûÊñá‰∏≤Âú®Âæ™ÁéØÁßª‰Ωç \(k\) ‰ΩçÂêéËøòÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤„ÄÇ ËÆæ \(s\) ÊòØ‰∏Ä‰∏™Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶‰∏∫ \(n\) ÂõûÊñá‰∏≤„ÄÇ ËÆ∞Â≠óÁ¨¶‰∏≤ \(a\) ÁöÑÂèç‰∏≤‰∏∫ \(a^R\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØÂõûÊñá‰∏≤ÔºåÂØπ‰∫é \(1\le i \le n\)Ôºå\(s[i]=s[n-i+1]\)„ÄÇ ÂèàÂõ†‰∏∫ \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤Ôºö ÂØπ‰∫é \(1 \le i \le n-2k\)Ôºö \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) ÂØπ‰∫é \(n-2k &lt; i \le n-k\)Ôºö \(s[i] = s[2n-2k-i+1] = s[i+2k]\) ÂØπ‰∫é \(n-k&lt;i \le n\)Ôºö \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) ÂèØ‰ª•ÁúãÂá∫ \(2k\) ÊòØ \(s\) ÁöÑÂë®ÊúüÔºå‰∏î \(s\) Âæ™ÁéØÂè≥Áßª \(2k\) ‰ΩçÂêéÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤‰∏é \(s\) Áõ∏Á≠â„ÄÇÂõ†Ê≠§ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÊòØ \(n\) ÁöÑÁ∫¶Êï∞„ÄÇËÆæ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÈïøÂ∫¶‰∏∫ \(t\)Ôºå\(t \mid n\)„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûú \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰Ωç‰ªçÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÈÇ£‰πà \(t \mid 2k\)„ÄÇÊúâ \(t\) Áßç‰∏çÂêåÁöÑ‰∏é \(s\) Âæ™ÁéØÂêåÊûÑÁöÑ‰∏≤„ÄÇËã• \(t\) ‰∏∫ÂÅ∂Êï∞ÔºåÈÇ£‰πà \(s\) Âæ™ÁéØÂè≥Áßª \(\frac t 2\) ‰ΩçÊàñÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇÂê¶ÂàôÂè™ÊúâÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇ ‰∏∫‰∫ÜËÆ°ÁÆó‰∏éÊüê‰∏™ÂõûÊñá‰∏≤Âæ™ÁéØÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÔºåËÄÉËôëÊûö‰∏æÂõûÊñá‰∏≤Âπ∂ËÆ°ÁÆó‰∏éËøô‰∏™ÂõûÊñá‰∏≤ÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤ÊúâÂ§öÂ∞ëÁßçÔºåËøôÊ†∑ÊúÄÂ∞èÂë®ÊúüÊòØÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤‰ºöË¢´ÁÆóÊÅ∞Â•Ω‰∏§Ê¨°ÔºåÂÖ∂‰ªñÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤Âè™‰ºöË¢´ÁÆó‰∏ÄÊ¨°„ÄÇÁâπÂà§ÊúÄÂ∞èÂë®Êúü‰∏∫ÂÅ∂Êï∞ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå‰∏çÂèØËÉΩÊûö‰∏æÊâÄÊúâÁöÑÂõûÊñá‰∏≤„ÄÇËÄÉËôëÊääÊúÄÂ∞èÂë®ÊúüÁõ∏ÂêåÁöÑÂõûÊñá‰∏≤ÊîæÂú®‰∏ÄËµ∑Êûö‰∏æ„ÄÇËÆæÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è‰∏∫ \(K\)ÔºåÊúÄÂ∞èÂë®Êúü‰∏∫ \(i\) ÁöÑÁ∫¶Êï∞ÁöÑÂõûÊñá‰∏≤Êúâ \(K^{\lceil \frac i 2 \rceil}\) ‰∏™„ÄÇËé´ÊØî‰πåÊñØÂèçÊºî‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå \(n\) ÈùûÂ∏∏ÁöÑÂ§ßÔºåÊ≤°ÊúâÂäûÊ≥ïÁõ¥Êé•ÂèçÊºîÂá∫‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ ÊääÁ≠îÊ°àÂÜôÂá∫Êù•ÂåñÁÆÄÔºö \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] Êûö‰∏æ \(d\)„ÄÇ \(d\) ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)„ÄÇ \(d\) ‰∏∫Â•áÊï∞Êó∂ÔºåËã• \(n\) ‰∏∫Â•áÊï∞Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)ÔºåÂê¶Âàô \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)„ÄÇ \(Pollard-Rho\) ÂàÜËß£Á¥†Âõ†Êï∞ÂêéÁÆÄÂçïÁªüËÆ°‰∏Ä‰∏ãÁ≠îÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [Ynoi2016]Èïú‰∏≠ÁöÑÊòÜËô´„ÄÇ ËÆ∞ÂΩïÊØè‰∏™ÁÇπ \(i\) ÂâçÈù¢Á¨¨‰∏Ä‰∏™‰∏é‰ªñÂêåËâ≤ÁöÑ‰ΩçÁΩÆ \(pre_i\)„ÄÇËØ¢ÈóÆÂå∫Èó¥È¢úËâ≤Êï∞ÂèòÊàêËØ¢ÈóÆÂå∫Èó¥ÂÜÖÊúâÂ§öÂ∞ë‰∏™ \(pre_i &lt;l\)ÔºåËøôÊòØ‰∏Ä‰∏™‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò„ÄÇÊ≥®ÊÑèÂà∞‰øÆÊîπ \(pre\) Êï∞ÁªÑÊ¨°Êï∞ÂùáÊëä \(\mathcal O (n)\)ÔºåÁî® \(set\) Áª¥Êä§ÊØè‰∏ÄÊÆµÔºåcdqÂàÜÊ≤ªÊàñËÄÖÊ†ëÂ•óÊ†ëÂÅö‰∏Ä‰∏ã‰∫åÁª¥ÂÅèÂ∫èÂç≥ÂèØ„ÄÇ ËøôÈ¢òÊúâ‰∏ÄÁÇπÂç°Â∏∏..cdqÂàÜÊ≤ªÂÜôÂΩíÂπ∂ÈÄüÂ∫¶‰ºöÂø´ÂæàÂ§ö„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //Á¶ªÊï£Âåñint pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //ÂØπ l+1-r ÁöÑpreÊõ¥Êñ∞ set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[È¢òËß£] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[ËôΩÁÑ∂ÂâçÈù¢ËøòÊúâÂæàÂ§öÂùëÊ≤°Ë°•ÂÆå...‰ΩÜÊòØÊàëÂèëÁé∞Ëá™Â∑±‰ª£Á†ÅËÉΩÂäõÈóÆÈ¢òÊØîËæÉ‰∏•Èáç„ÄÇÊâÄ‰ª•Êù•ÂÅöÂÅöynoi„ÄÇ ÂùëÂÖàÊîæÂú®Ëøô...Ê∏ÖÈÜíÁöÑÊó∂ÂÄôÊÖ¢ÊÖ¢Â°´„ÄÇ [YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢„ÄÇ ÂÖàÂíïÁùÄ„ÄÇ„ÄÇ„ÄÇ‰∏á‰∏ÄÈÅá‰∏äÁé∞Êé®Âêß„ÄÇ]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÊâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ„ÄÇ ËøôÈ¢òÁõÆÊúâÈóÆÈ¢òÂêß....Ê®°Êï∞ÂèØ‰ª•ÁàÜ long long ÁöÑ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÂêéÁºÄËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂêéÁºÄËá™Âä®Êú∫„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Splay(Áª¥Êä§Â∫èÂàó)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [NOI2005]Áª¥Êä§Êï∞Âàó„ÄÇ Â∏∏Êï∞ÈùûÂ∏∏ÈùûÂ∏∏Â§ß.....ÂÖàÂΩìÊùøÂ≠êËÉå‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèexp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÂØπÊï∞ÂáΩÊï∞„ÄÇ ‰ª£Á†ÅÁâπÂà´‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊ±ÇÈÄÜ]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÊ±ÇÈÄÜ„ÄÇ \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) ‰ª£Á†Å‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ‰ªªÊÑèÈïøÂ∫¶DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm Ê±Ç \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) ËÆæ \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)„ÄÇ Âàô \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)„ÄÇ \(i-k\) ÂèØËÉΩ‰ºöÂá∫Áé∞Ë¥üÊï∞„ÄÇÂπ≥Áßª‰∏ãÂÅö‰∏™Âç∑ÁßØÂç≥ÂèØ„ÄÇ ÊáíÂæóÂÜôQAQ„ÄÇÔºàÂ•ΩÂÉè‰πüÊ≤°Âï•Â•ΩÂÜôÁöÑÔºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] NTTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∏™ÊôÆÈÄöÁöÑ NTT Ê®°Êùø„ÄÇ‰ª£Á†ÅÈùûÂ∏∏‰∏ë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FFTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÁúÅÈÄâÂâçÂ§ç‰π†„ÄÇËøôÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ fft Ê®°Êùø„ÄÇ ÔºàÂèëÁé∞Ëá™Â∑±Â∑ÆÁÇπfftÊ®°Êùø‰∏ç‰ºöÊâì‰∫ÜÔºâ Âõ†‰∏∫Ê≤°ÊúâÈ¢ÑÂ§ÑÁêÜ&amp;&amp;Áî®‰∫ÜcomplexÁ±ªÂèØËÉΩÂ∏∏Êï∞ÊØîËæÉÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÊàëÂèëÁé∞Ëá™Â∑±ÁöÑ‰ª£Á†ÅËÉΩÂäõÂ§™Âº±‰∫Ü...... Êúâ‰∫õÊ®°ÊùøÈúÄË¶ÅÂπ≥Êó∂ÂÜô‰∏Ä‰∏ãÔºå‰∏çËÉΩÁé∞Âú∫ÂÜôÔºåÂê¶Âàô‰∏ç‰∏ÄÂÆöË∞ÉÁöÑÂá∫Êù•„ÄÇËøôÈáåÂàóÂá∫‰∏Ä‰∫õÂ∏∏Áî®Ê®°Êùø„ÄÇÔºà‰ºòÂåñÂ∏∏Êï∞&amp;&amp;‰ºòÂåñ‰ª£Á†ÅÂ§çÊùÇÂ∫¶&amp;&amp;ËÉå‰∏ãÊù•Ôºâ„ÄÇ Â§öÈ°πÂºèÔºö FFT NTT Â§öÈ°πÂºèÊ±ÇÈÄÜ Â§öÈ°πÂºèln Â§öÈ°πÂºèexp Â§öÈ°πÂºèÂèñÊ®° Â§öÈ°πÂºèÂ§öÁÇπÊ±ÇÂÄº Â§öÈ°πÂºèÂø´ÈÄüÊèíÂÄº Â§öÈ°πÂºèÂ§çÂêàÈÄÜ Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé® Êï∞ËÆ∫Ôºö LucasÂÆöÁêÜ exCRT ÊùúÊïôÁ≠õ Pollard-Rho Miller-Rabin min_25Á≠õ Á±ªÊ¨ßÂá†ÈáåÂæó ‰∫åÊ¨°Ââ©‰Ωô Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºö Á∫øÊÆµÊ†ëÂêàÂπ∂ Ê†ëÁä∂Êï∞ÁªÑ Splay LCT ETT ÁÇπÂàÜÊ†ë Ê†ëÈìæÂâñÂàÜ Âä®ÊÄÅdp Â≠óÁ¨¶‰∏≤Ôºö ÂêéÁºÄËá™Âä®Êú∫ Âª∫ÂêéÁºÄÊ†ë ÂêéÁºÄÊï∞ÁªÑ trieÊ†ëSAM ACËá™Âä®Êú∫ ÂõûÊñáÊ†ë ÂÖ∂‰ªñÔºö FWT ÂçäÂπ≥Èù¢‰∫§ Áü©Èòµ-Ê†ëÂÆöÁêÜ ÂõæËÆ∫Ôºö ÊîØÈÖçÊ†ë ÂúÜÊñπÊ†ë ËæπÂèå]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢òÁõÆ]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑËøô‰πàËèú‰∫ÜËøòÂè£ËÉ°È¢òÁõÆ...Â§ßÊ¶Ç‰ºöË∂äÊù•Ë∂äËèúÂêß.. 2019.3.29 CF 1097G \(k\) Ê¨°ÊñπÁúã‰ΩúÊòØÈÄâ \(k\) Êù°Ëæπ„ÄÇËÄÉËôëÊâÄÊúâ \(k\) Êù°ËæπÁöÑÊúâÂ∫èÂØπÔºåËÆ°ÁÆóÂåÖÂê´ÂÆÉ‰ª¨ÁöÑÈõÜÂêàÊï∞„ÄÇËÉåÂåÖ \(dp\) ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇÊ†πÊçÆÊüêËÄÉËøáÂæàÂ§öÊ¨°ÁöÑÂ§çÊùÇÂ∫¶ÂàÜÊûêÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ \(\mathcal O (nk)\)„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Ôºö https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf È¢òÁõÆÂ§ßÊÑè ËæìÂÖ•‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ≠óÁ¨¶‰∏≤ \(s\)„ÄÇ‰Ω†Êúâ‰∏Ä‰∏™Á©∫‰∏≤ \(t\)Ôºå‰Ω†Ë¶ÅÊääÂÆÉÂèòÊàêËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂèØ‰ª•ËøõË°å‰ª•‰∏ãÂá†ÁßçÊìç‰ΩúÔºö Âú® \(t\) ÁöÑÂºÄÂ§¥ÊàñËÄÖÊú´Â∞æÊ∑ªÂä†‰∏Ä‰∏™Â≠óÁ¨¶„ÄÇ Êää \(t\) ÁøªËΩ¨ËøáÊù•ÔºåÁÑ∂ÂêéÊé•Âú®ÂéüÊù•ÁöÑ \(t\) ÁöÑÂºÄÂ§¥ÊàñÊú´Â∞æ„ÄÇ Ê±ÇÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ \(n \le 10^5\) Ëß£Ê≥ï Âú®ÊúÄÂêéËøûÁª≠ÁöÑËã•Âπ≤Ê¨°Âä†Â≠óÁ¨¶Êìç‰Ωú‰πãÂâçÔºå\(t\) ‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÂÄíËøáÊù•ËÄÉËôëÔºåÁî®ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞Êää \(s\) ÂèòÊàêÁ©∫‰∏≤„ÄÇÂè™ÈúÄË¶ÅÂàÜÂà´ËÄÉËôëÊØè‰∏™ÂõûÊñá‰∏≤ÁöÑÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Âª∫Á´ãÂõûÊñáÊ†ë„ÄÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏âÁßçËΩ¨ÁßªÔºö ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤Âèò‰∏∫‰ªñÁöÑ‰∏ÄÂçä„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂéªÊéâ‰ªñ‰∏§Á´ØÁöÑÂ≠óÁ¨¶„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåËΩ¨ÁßªÂà∞‰ªñÁöÑÊúÄÈïøÂõûÊñáÂâçÁºÄ„ÄÇ ÊåâÈïøÂ∫¶‰ªéÂ∞èÂà∞Â§ßÈ°∫Â∫è \(dp\)„ÄÇÂêé‰∏§ÁßçËΩ¨ÁßªÂèØ‰ª•Áõ¥Êé•ËÆ°ÁÆó„ÄÇÂØπÁ¨¨‰∏ÄÁßçËΩ¨ÁßªÔºåÂÄçÂ¢û‰∏Ä‰∏ãÂà§Êñ≠ \(fail\) Ê†ë‰∏äÊúâÊ≤°ÊúâÈïøÂ∫¶ÊÅ∞Â•Ω‰∏∫‰∏ÄÂçäÁöÑÁ•ñÂÖàÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØÂÅáÁöÑ„ÄÇË¶ÅÁúÅÈÄâ‰∫Ü..ÂÖàË°•ÁÇπÂà´ÁöÑÂÜçÊù•ÊâìËøôÈ¢òQAQ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â≠óÁ¨¶‰∏≤ÊäÄÂ∑ß„ÄÅÊÄùÊÉ≥„ÄÅÁü•ËØÜÁÇπÊï¥ÁêÜ]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! U2FsdGVkX19jdprPOJylyRNj2MyDzdHnCCwAlTl2P1oLOLGbcEIYjF7uVxPLjpb8SXGo2jfdlLW6cjRsby13cCBV1ZjyOpQOdwdQvcp2lybFtynavQhr892ZfZOAUcn+FkaX4NEIC3iSnGotEiDizgidjZuRY4r+n/Asstq+yHpHv02GSGXxgfTy3nDgpe0pbL/xveZWV635GAHb7FPNgomWgpZj7OtNzjpxWtK2Wnqi2mgytVNZJDiiKPYuS08ujrvALfdeUmDhkUZHN0jxnhv9UNSnsRx/HFREX9hwBol1/vwpgADHNHebdMJ8POVav7BCeEN7eCwT7dawE0Uo/vppjxlGsd224UtP1CceNaDIMDkHUJjc4PSsYazG7FmwpozGpgwFkkb826WTQfclf2FgVb0ccFGDj5yCjDHWSKR7R7s8nAb2prWHSerMw1GRdBq+MYmSLFDkQDrcQdtKzWXKvkW8wMgnHBoVw7ew9FrSDSS6hX1/Ub61o8sz5yAzboDbIzwDgHdEXrGZygJjgpCoMb2BMCG/m+tKXZ0cUxctIVVrHR8roCFXNXMOBmbn2sd3eGZIReq5JFVzoWf3pdvGgO1zJOOU7IxAML9P14F4aL+XXLA/RkOwhPPvwtb2EZvIXk8fiKSFrKowA61ex87y7csG2MHDvfXhz5DnKlJvquu+qUDltIytIVC0+rehAvw8HavglB4Z+rwp0oklTBBZFpYUVIEy2lXajeMDxqFpfMIuXY2HcYJ8FIthJMThnSSsKvfsi0FHryJqfv1ZqFI89/d8MW8Fv4KKDYfW/mtilUJvjgjYRWRGHpbgN50CEAj7uOcXOMhDVj98D0OxsocDz8CuPu8v1w1Y6nZ/GBDLNgXeW1L0cQD0LFDm3xJDgnqp2Q9CSz+Of3I+r+nE2e5E61ggWEfiTlRIbN2VwVYY0bXaBd1W4LcBhlG+j35g+epqhIKSrZL1PjBl8GCMbdhA7w68GhgPKHOQwDg5NWQ9JY8M8g769LQX/BXyvq1nq096stGoZTQGU/yxaeGFCIuc6BKezm00ilGNAqnBYT7GKr+zpbihNiVISEIJJ9c+pq6f+TZIDVFPtz9krUJGBD/voYGAyqSXcOxxeE5aoG8PC8B+0imPZo6COyvgvzpWw0Zy+n44mL/Llzfsyw7KABZIX/8bhi6DQH1f4R9fQbhv/k2ucUc60Jx+GK9P6boThqqPEPR+JaskvDYaJ2QKRdm6qbJnU4roWAhppGkJZ8Dpauid6fa8CWOxZqsvux6MogSU7HZlfXMz+5NVTtw/mLNmKeCRZFB/xSm6m9BoI9YfkxxPuVihjKJlGd0wpNG3R0eLMvh52mK87IpiFbHvneGt1Bxycv7/UgJzBn8id9tyzewOa9iwhlh6G+PaMjEiKkeBmcpq9ylJkuzXOYbx5KfjSz98hv2d4oNokCOMPumYMeXh4bXz7Ip9zwg8OmL/JMqxgjmkstcioSotyXToQjNxsIq49RQtsI0SfJU+obWNqrGQQCPWwDvxI35nLO66GXEDcWDWhlIIYhyVlaHOJi2WeFrcBlNYHdTHlumQfKcVs6NNEX7Tns1WjJunpwb0FYyKd6EZ0NaTxQU0WjVpQXmndYpZXP/lhaILYSia9+xc7db+Mr6Uz6eqYjDDDeYoajQPgAW6BxAdG3Uusc93uwisoZiST3nKVU3/vIV3eMvGXIEbJZDBppCSsW46o7ery/ikJppTo+yQDWDOBr+xeCp1kg/9/3OHf6OmqhVODmEPUMW2y/AUbuK2JVgIWtWqygo/81hV1FTvPXLFfo0qBpWPgFl0c8Xr+zXxbYHbhMFIjhDiC/JZAxG5zG+ihgyXqizDTaAsZcyhhIag4zm0uW7lj7XGWNZtM8dtUEp05hLra0hiOS59eL43rULcz9oBNotzB8E5KEtOQ57mdRV67yZieu0/9+DDEl3RTuiSta35y5kq4MQorpW5WIhr6PN9hYk4MYzSB915US0UkDMeaAeU9blIJB2pWx8mzDLPPw6exBrYYNjJ2qB5O0yyQ0Vl+r9b/T5RjiIrrEA/RAo/6YOdskeTdgned87kCe3QBn2nQjgMecAlQhwbHOG4wprtVkelsCgQGnGuxQCh1kHmnLt6AMWL5Ti4lmVLEzoLFVgi3fcv59T6hLuXTZ5Xr/DviVjGOrn1M2DtYszVIE2HOhW3J3YDNpfr3Koc2d8k7O28+KwFJmcC1OWFQo4Lp9Nubtbv4xrZGy7ED1+mQAhRn+L4uXA/By2UNhui620YCrmxgGvjO/q9JQ1rWIJLjTUsCd0p985Ry1M4ofbnaNP6PxidPo3QKYZTRF6y0nAwH1S7G92qgHPm6hSBKKOaSOaFcES2e151HLow5+J/UbeQCVp66DbViD2DkgCXC/UCtNFlfG6hAepoqnofbja6Sb9LD1FoS1I6g3muV3KnxWi4BrdKtdYTIZhJE5GSX3ZIxkDCyysZQKAZpApzTBk27/sKUQga4JkLtP2HG0hlsoJ1Ig==]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon wordÁöÑ‰∏Ä‰∫õÊÄßË¥®]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Lyndon_word ÂÆö‰πâ Â¶ÇÊûú‰∏Ä‰∏™‰∏≤ÊúÄÂ∞èÂêéÁºÄÊòØÂÆÉÊú¨Ë∫´ÔºåÈÇ£‰πàÁß∞‰ªñ‰∏∫ Lyndon word„ÄÇÔºà‰∏é‰∏•Ê†ºÊúÄÂ∞èÂæ™ÁéØÁßª‰ΩçÁöÑÂÆö‰πâÊòØÁ≠â‰ª∑ÁöÑÔºâ Áõ∏ÂÖ≥ÊÄßË¥®ÂíåÁÆóÊ≥ï ÊÄßË¥®1 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºåÈÇ£‰πà \(s\) ‰∏çÂ≠òÂú® border„ÄÇ ÊÄßË¥®2 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºå\(s=uv\) ‰∏î \(u\) Âíå \(v\) ÈùûÁ©∫ÔºåÈÇ£‰πà \(u&lt;v\)„ÄÇ ÊÄßË¥®3 Â¶ÇÊûú \(s,t\) ÊòØ Lyndon word ‰∏î \(s &lt; t\)ÔºåÈÇ£‰πà \(st\) ‰πüÊòØ Lyndon word„ÄÇ ÊÄßË¥®4 ‰∏Ä‰∏™ÈïøÂ∫¶Â§ß‰∫éÁ≠â‰∫é \(2\) Â≠óÁ¨¶‰∏≤ÁöÑ \(s\) ÊòØ Lyndon word ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå\(s\) ÂèØ‰ª•ÊãÜÊàê‰∏§‰∏™ÈùûÁ©∫‰∏≤ \(u,v\)ÔºåÊª°Ë∂≥ \(u &lt; v\) ‰∏î \(u\) Âíå \(v\) ÈÉΩÊòØ Lyndon word„ÄÇ ËØÅÊòé ÂÖÖÂàÜÊÄßÂç≥‰∏ä‰∏ÄÊù°ÊÄßË¥®ÔºåÂè™ËØÅÂøÖË¶ÅÊÄß„ÄÇ ËÆæ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(n\)ÔºåÂêéÁºÄ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄ„ÄÇ ÂÅáËÆæ \(s[1..i-1]\) ÊúâÈïøÂ∫¶‰∏∫ \(k\) ÁöÑ borderÔºåÂç≥ \(s[1..k]=s[i-k..i-1]\)„ÄÇ Âõ†‰∏∫ \(k &lt; i-1\)ÔºåÊâÄ‰ª• \(k+1 \neq i\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØ Lyndon wordÔºå\(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊâÄ‰ª• \(s[i..n]&lt;s[k+1..n]\)„ÄÇÂèàÂõ†‰∏∫ \(s[i-k..i-1]=s[1..k]\)ÔºåÊâÄ‰ª• \(s[i-k..n]&lt;s[1..n]\)ÔºåËøô‰∏é \(s\) ÊòØ Lyndon word ÁüõÁõæ„ÄÇÊâÄ‰ª• \(s[1..i-1]\) Ê≤°Êúâ border„ÄÇ Ê†πÊçÆ Lyndon word ÁöÑÂÆö‰πâÂèä \(s[1..i-1]\) Ê≤°Êúâ borderÔºåÊúâ \(\forall 1 &lt; j \le i-1\)Ôºå\(\exists j \le k \le i-1\)ÔºåÊª°Ë∂≥ \(s[k] &gt; s[k-j+1]\)ÔºåÂç≥ \(s[j..i-1] &gt; s[1..i-1]\)„ÄÇÊâÄ‰ª• \(s[1..i-1]\) ÊòØ Lyndon word„ÄÇ Âõ†‰∏∫ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊòæÁÑ∂‰∏çÂ≠òÂú® \(j&gt;i\) Êª°Ë∂≥ \(s[j..n]&lt;s[i..n]\)ÔºåÊâÄ‰ª• \(s[i..n]\) ÊòØ Lyndon word„ÄÇ ÊâÄ‰ª• \(u=s[1..i-1],v=s[i..n]\) ÊòØ‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊãÜÂàÜÔºåÂøÖË¶ÅÊÄßÂæóËØÅ„ÄÇ ÊÄßË¥®5 ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\) ÈÉΩÂèØ‰ª•ÂîØ‰∏ÄÂú∞ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÂÖ∏Â∫è‰∏çÂ¢ûÁöÑ Lyndon Word„ÄÇ ÊàëÊäΩ‰ª£Â§™Ëèú‰∫Ü...ÂÖ∂‰ªñÁöÑÊÄßË¥®‰ª•ÂêéÂÜçË°•Âêß„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon ÂàÜËß£]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ëß£Ê≥ï ÂÖ≥‰∫é Lyndon word ÁöÑ‰∏Ä‰∫õÁªìËÆ∫ÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/D È¢òÁõÆÂ§ßÊÑè ÁªôÂÆö‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÔºå‰ª• \(1\) ‰∏∫Ê†πÁöÑÊ†ëÔºåÁ¨¨ \(i\) ‰∏™ÁÇπÊúâ‰∏Ä‰∏™‰ª∑Ê†º \(c_i\)„ÄÇ ‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™‰∫∫‰ºöÁªôÊØè‰∏™Âè∂ËäÇÁÇπËÆæÁΩÆ‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ‰Ω†Âè™ËÉΩÂØπÂ∑≤ÁªèÈÄâÊã©ÁöÑÁÇπÂÅöÂ≠êÊ†ëÂä†‰ªªÊÑèÊï∞Â≠óÁöÑÊìç‰Ωú„ÄÇ ‰Ω†Ë¶ÅÈÄöËøáËã•Âπ≤Ê¨°Êìç‰ΩúÊääÊâÄÊúâÂè∂Â≠êËäÇÁÇπ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\)„ÄÇ ÈóÆÔºöË¶ÅÁ°Æ‰øùÂè¶‰∏Ä‰∏™‰∫∫Êó†ËÆ∫ÊÄé‰πàÊìç‰Ωú‰Ω†ÈÉΩËÉΩÊääÂè∂Â≠ê‰∏äÁöÑÊï∞ÂèòÊàê \(0\)Ôºå‰Ω†ÈÄâÊã©ÁöÑÁÇπ‰ª∑Ê†ºÊÄªÂíåÊúÄÂ∞èÊòØ‰ªÄ‰πàÔºüÊúâÂì™‰∫õÁÇπË¢´Ëá≥Â∞ë‰∏ÄÁßçÊúÄÂ∞è‰ª∑Ê†ºÁöÑÊñπÊ°àÂåÖÂê´Ôºü \(n \le 200000\)Ôºå\(0\le c_i \le 10^9\)„ÄÇ Ëß£Ê≥ï Ëøô‰∏™ÈóÆÈ¢òÂèØ‰ª•ÁúãÊàêÔºå‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπ‰Ωú‰∏∫Êú™Áü•Êï∞ÔºåÊØè‰∏™Âè∂Â≠êÁöÑÈôêÂà∂ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÊñπÁ®ãÔºå‰Ω†Ë¶ÅËÆ©Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÊª°Ë∂≥ÔºåÊó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåËøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Âõ†‰∏∫‰ª∑Ê†ºÊòØÈùûË¥üÊï¥Êï∞ÔºåÂ¶ÇÊûúÁ≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÁõ∏ÂÖ≥ÔºåÂøÖÂèØ‰ª•Âà†Èô§Êüê‰∏ÄÂàóÔºåÂç≥ÂèØ‰ª•Â∞ëÈÄâ‰∏Ä‰∏™ÁÇπÔºåËøôÊ†∑‰∏ÄÂÆö‰∏ç‰ºöÂèòÁöÑÊõ¥Â∑ÆÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥„ÄÇÂõ†‰∏∫Êó†ËÆ∫Â∏∏Êï∞È°πÁöÑÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩË¶ÅÊúâËß£ÔºåÊâÄ‰ª•Ë°åÊï∞Á≠â‰∫éÂàóÊï∞„ÄÇ ÁªìËÆ∫ ËÆæÂè∂ËäÇÁÇπ‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∏Ä‰∏™ÂåÖÂê´ÊÅ∞Â•Ω \(x\) ‰∏™ÁÇπÁöÑÈÄâÂèñÊñπÊ°àËÉΩ‰øùËØÅÂèØ‰ª•Â∞ÜÊâÄÊúâÂè∂Â≠ê‰∏äÁöÑÊï∞Â≠óÂèòÊàê \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÔºåÂ≠òÂú®Ë¢´ÈÄâÂèñÁöÑÁÇπÔºå‰∏îÊ∑±Â∫¶ÊúÄÂ§ßÁöÑË¢´ÈÄâÂèñÁÇπ‰∏çÂêå„ÄÇ ËØÅÊòé ÂøÖË¶ÅÊÄßÊòæÁÑ∂„ÄÇ ÂÖÖÂàÜÊÄßÔºöÊääÊñπÁ®ãÁªÑÁöÑÊú™Áü•Êï∞Êåâ‰ªªÊÑè‰∏ÄÁßç \(dfs\) Â∫èÊéíÂàóÔºåÁ≥ªÊï∞Áü©Èòµ‰∏≠ÔºåÊØè‰∏ÄË°åÁöÑÁ¨¨‰∏Ä‰∏™Èùû \(0\) ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂàóÈÉΩ‰∏çÂêåÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥ÔºåÂèàÂõ†‰∏∫Ë°åÊï∞Á≠â‰∫éÂàóÊï∞ÔºåÊâÄ‰ª•Êó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Áä∂ÊÄÅ \(dp[i][j][k]\) Ôºö \(i\) Ë°®Á§∫Âè™ËÄÉËôë‰ª• \(i\) ‰∏∫Ê†πÁöÑÂ≠êÊ†ë„ÄÇ \(j\) Ë°®Á§∫ \(i\) ÊòØÂê¶Ë¢´ÈÄâÊã©„ÄÇ \(k\) Ë°®Á§∫ÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Âè∂Â≠êÔºå‰ªñÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏≠Ê≤°ÊúâÁÇπË¢´ÈÄâÊã©„ÄÇ \(dp\) Êï∞ÁªÑ‰∏≠Â≠òÁöÑÊòØÔºåÊª°Ë∂≥‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏äÊ∑±Â∫¶ÊúÄÂ§ßÁöÑÁ•ñÂÖà‰∏çÂêåÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÁúã‰Ωú \(0\)ÔºâÁöÑÊúÄÂ∞è‰ª∑Ê†ºÂíå„ÄÇ \(dp\) ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéËÆ∞ÂΩïÂì™‰∫õËΩ¨ÁßªÂèØ‰ª•ÂèñÂà∞ÊúÄ‰ºòÂÄºÔºåÊúÄÂêé‰ªéÊ†πÂºÄÂßã \(dfs\) ‰∏ÄÈÅçÊ±ÇÊñπÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ÔºàÂ∑®‰∏ëÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/C È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s\)„ÄÇ ËØ∑‰Ω†Êää \(s\) ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÁ¨¶‰∏≤ \(s=t_1t_2\cdots t_k\)„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∏≤ÔºåËã• \(t_i\) ÊòØ \(t_1t_2\cdots t_{i-1}\) ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(b\) ÁöÑ‰ª£‰ª∑ÔºåÂê¶Âàô \(t_i\) ÈïøÂ∫¶ÂøÖÈ°ª‰∏∫ \(1\)Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(a\) ÁöÑ‰ª£‰ª∑„ÄÇÊ±ÇÊúÄÂ∞è‰ª£‰ª∑„ÄÇ \(n \le 5000\)ÔºåÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è \(26\)„ÄÇ Ëß£Ê≥ï ËÆæ \(dp_i\) Ë°®Á§∫Ââç \(i\) ‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂ∞èÂàíÂàÜÔºåÂú®Ê±ÇÂá∫ \(dp_i\) ÂêéÁî® \(kmp\) ÊâæÊúÄÈïøÂú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑ‰ªé \(i+1\) ÂºÄÂßãÁöÑ‰∏≤ÔºåÊõ¥Êñ∞ÊâÄÊúâ \(dp_j\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÊï¥ÁêÜÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Impartial_game impartial game ÊòØÊåáÊª°Ë∂≥Â¶Ç‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÔºö - ‰∏§‰∏™Áé©ÂÆ∂ËΩÆÊµÅÊìç‰ΩúÔºåÁõ¥Âà∞ËææÂà∞‰∏çËÉΩÊìç‰ΩúÁöÑÁä∂ÊÄÅÔºàterminal positionÔºâ„ÄÇ - ÂΩì‰∏Ä‰∏™Áé©ÂÆ∂‰∏çËÉΩÊìç‰ΩúÊó∂Ôºåwinner Â∞±Ë¢´Á°ÆÂÆö‰∫Ü„ÄÇ - ÊØè‰∏™Áä∂ÊÄÅÁöÑÊìç‰ΩúÊï∞ÂíåÁä∂ÊÄÅÊÄªÊï∞ÊòØÊúâÈôêÁöÑ„ÄÇ - ÊâÄÊúâÁöÑÊìç‰ΩúÂøÖÈ°ªÂêåÊó∂ËÉΩË¢´‰∏§‰∏™Áé©ÂÆ∂ËøõË°å„ÄÇ - ÊâÄÊúâÊìç‰ΩúÁöÑÁªìÊûúÈÉΩÊòØÁ°ÆÂÆöÊÄßÁöÑ„ÄÇ Normal play convention wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Normal_play_convention Impartial game ÁöÑ Normal play convention ÔºöÊúÄÂêé‰∏Ä‰∏™ÂèØ‰ª•Êìç‰ΩúÁöÑÁé©ÂÆ∂Ëé∑ËÉú„ÄÇ NimÊ∏∏Êàè wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Nim ÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅÂèñÁü≥Â≠ê„ÄÇÊØèÊ¨°ËΩÆÂà∞ÁöÑ‰∫∫ÂèØ‰ª•ÈÄâÊã©‰ªéÊüê‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Ëã•Âπ≤È¢óÁü≥Â≠êÔºà‰∏çËÉΩ‰∏çÊãøÔºâÔºå‰∏çËÉΩÊåâËßÑÂàôÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ Nim Ê∏∏ÊàèÂ±û‰∫é Impartial game„ÄÇ NimÊ∏∏ÊàèÁöÑËÉúÂà©Êù°‰ª∂ ÂÆöÁêÜÔºöÂΩì‰∏î‰ªÖÂΩìÊØèÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) Êó∂ÔºåÂÖàÊâãÂøÖËÉú„ÄÇ ËØÅÊòéÔºö ÂØπ‰∫é terminal positionÔºåÂç≥Ê≤°ÊúâÁü≥ÁöÑÊÉÖÂÜµÔºåÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåËΩÆÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑ‰∫∫Ëæì„ÄÇÂÆöÁêÜÂØπ terminal position ÊàêÁ´ã„ÄÇ ÂºïÁêÜ1 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\)ÔºåÂàôÂÆÉÂøÖÂÆöÂèØ‰ª•ËΩ¨ÁßªÂà∞‰∏Ä‰∏™Áü≥Â≠ê‰∏™Êï∞‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\)„ÄÇ ËÆæ \(s\) ÊúÄÈ´òÁöÑ‰∫åËøõÂà∂‰ΩçÊòØÁ¨¨ \(k\) ‰ΩçÔºà‰ªé‰ΩéÂà∞È´òÔºåÊúÄ‰Ωé‰Ωç‰∏∫Á¨¨ \(0\) ‰ΩçÔºâ„ÄÇ ‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÂ†ÜÁü≥Â≠ê‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∫åËøõÂà∂‰∏ã \(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)„ÄÇ Èô§‰∫ÜËøôÂ†ÜÁü≥Â≠êÂ§ñÔºåÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\oplus x\)„ÄÇ \(s\oplus x\) Âíå \(x\) Âú®ÊâÄÊúâÊØîÁ¨¨ \(k\) ‰ΩçÈ´òÁöÑ‰∫åËøõÂà∂‰Ωç‰∏äÁõ∏Á≠âÔºå\(s\oplus x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(0\)Ôºå\(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)ÔºåÊâÄ‰ª• \(s \oplus x &lt; x\)„ÄÇ ÂèØ‰ª•‰ªéËøôÂ†ÜÁü≥Â≠ê‰∏≠ÂèñËµ∞ \(x-s\oplus x\) ‰∏™Áü≥Â≠êÔºå‰ΩøÂºÇÊàñÂíåÂèò‰∏∫ \(0\)„ÄÇ ÂºïÁêÜ2 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÈÉΩ‰ºöËΩ¨ÁßªÂà∞‰∏Ä‰∏™ÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊìç‰ΩúÁöÑÂ†ÜÂú®Êìç‰ΩúÂâçÊúâ \(x\) È¢óÁü≥Â≠ê„ÄÇ ÈÇ£‰πàÈô§‰∫ÜËøôÂ†Ü‰ª•Â§ñÁöÑÂÖ∂‰ªñÂ†ÜÁü≥Â≠êÊï∞ÂºÇÊàñÂíå‰πü‰∏∫ \(x\)„ÄÇ Âú®ÂèñÁü≥Â≠êÂêéÔºåËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏ÄÂÆö‰∏ç‰∏∫ \(x\)„ÄÇ Âè™ÊúâËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏∫ \(x\) Êó∂Ôºå‰∏éÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíåÊâç‰ºö‰∏∫ \(0\)„ÄÇ ÊâÄ‰ª•Êìç‰ΩúÂêéÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏ÄÂÆöÈùû \(0\)„ÄÇ Ê†πÊçÆÁªìÊûÑÂΩíÁ∫≥Ê≥ïÂèØÁü•ÂÆöÁêÜÊàêÁ´ã„ÄÇ Sprague‚ÄìGrundy ÂÆöÁêÜ wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Sprague‚ÄìGrundy_theorem ÂÆö‰πâ \(mex\) ËøêÁÆóÔºå‰∏Ä‰∏™ÈõÜÂêàÁöÑ \(mex\) ÂÄºÊòØÊúÄÂ∞èÁöÑÊ≤°ÊúâÂá∫Áé∞Âú®Ëøô‰∏™ÈõÜÂêà‰∏≠ÁöÑËá™ÁÑ∂Êï∞„ÄÇ ÂÆö‰πâ Sprague-Grundy ÂáΩÊï∞ÔºöÂØπ‰∫é‰∏Ä‰∏™Áä∂ÊÄÅ \(x\)ÔºåÂΩì \(x\) ÊòØ terminal position Êó∂Ôºå\(SG(x)=mex\{SG(y)|x\) ÂèØ‰ª•ËΩ¨ÁßªÂà∞ \(y\}\)„ÄÇ ÂèØ‰ª•Áî® Sprague-Grundy ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏™Áä∂ÊÄÅÊòØÂøÖËÉúÁä∂ÊÄÅËøòÊòØÂøÖË¥•Áä∂ÊÄÅÔºåÂõ†‰∏∫ÂøÖËÉúÁä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏ç‰∏∫ \(0\)ÔºåÂøÖË¥•Áä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏∫ \(0\)„ÄÇ ÂÆö‰πâ‰∏§‰∏™Ê∏∏ÊàèÁöÑ disjunctive sum ‰∏∫‰∏Ä‰∏™Ê∏∏ÊàèÔºöËΩÆÂà∞ÊØè‰∏™Áé©ÂÆ∂ÁöÑÊó∂ÂÄôÔºå‰ªñÂèØ‰ª•ÈÄâÊã©‰∏§‰∏™Ê∏∏Êàè‰∏≠ÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Ê∏∏Êàè‰∏äÊìç‰Ωú‰∏ÄÊ≠•ÔºåÊó†Ê≥ïÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÊòæÁÑ∂ disjunctive sum Êª°Ë∂≥‰∫§Êç¢ÂæãÂíåÁªìÂêàÂæã„ÄÇ ÂÆöÁêÜ Êúâ \(n\) ‰∏™Ê∏∏Êàè \(G_1,G_2,\cdots,G_n\)ÔºåËÆæ‰ªñ‰ª¨ÁöÑ disjunctive sum ‰∏∫ \(G\)„ÄÇÈÇ£‰πà \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)„ÄÇ ËØÅÊòéÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ Ëøô‰πüËØ¥Êòé‰∫ÜÊØè‰∏Ä‰∏™ normal play convention ‰∏ãÁöÑ impartial game ÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰∏™NimÊ∏∏Êàè„ÄÇ]]></content>
      <tags>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
