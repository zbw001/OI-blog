<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LOJ2504] „Äå2018 ÈõÜËÆ≠Èòü‰∫íÊµã Day 5„ÄçÂ∞è H Áà±ÊüìËâ≤]]></title>
    <url>%2F2020%2F05%2F12%2Floj2504%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÁºñÂè∑ÊúÄÂ∞èÈªëÁêÉÁºñÂè∑‰∏∫ \(k\) ÁöÑÊñπÊ°àÊúâ \(\binom{n-k+1}m^2 - \binom {n-k}m^2\) Áßç„ÄÇ ËÆæ \(F_p(x) = \binom x p\)ÔºåËÆæ \[ c_p = \sum_{k \ge 1} (\binom{n-k+1}m^2 - \binom {n-k}m^2) F_p(k) \\\\= \binom n m^2 + \sum_{k \ge 1} \binom {n-k} m ^2 (F_p(k+1)-F_p(k)) \\\\= \binom n m ^2+\sum_{k \ge 1} \binom {n-k}m^2 \binom{k+1}{p+1} \\\\ \text{ËÆæ $a_k = \binom km^2 (n-k+1)!, b_k =k!$} \\\\ c_p = \binom n m ^2+\frac 1 {(p+1)!}\sum_{k \ge 1} \binom {n-k}m^2 \frac{(k+1)!}{(k-p)!} \\\\=\binom n m ^2+\frac 1 {(p+1)!}\sum_{k \ge 1} a_{n-k}b_{k-p} \] ÂêéÈù¢ÁöÑ‰∏úË•øÊòØ‰∏Ä‰∏™Âç∑ÁßØÁöÑÂΩ¢Âºè„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•Áî®‰∏ÄÊ¨° NTT Ê±ÇÂá∫ÊâÄÊúâ \(c_p\)„ÄÇ Êé•‰∏ãÊù•Âè™ÈúÄË¶ÅÊää \(F(x)\) Ë°®Á§∫‰∏∫ \(\sum w_p F_p(x)\) ÁöÑÂΩ¢ÂºèÔºåËøôÊ†∑Á≠îÊ°àÂ∞±ÊòØ \(\sum w_p c_p\) ‰∫Ü„ÄÇ ‰∫åÈ°πÂºèÂèçÊºî‰∏Ä‰∏ã \[ F(i) = \sum_p w_p \binom i p \Leftrightarrow w_p = \sum _i \binom p i (-1)^{p-i}F(i) \] ‰∫éÊòØ‰πüÂèØ‰ª•Áî®‰∏ÄÊ¨° NTT ÂæóÂà∞ \(w\) Êï∞ÁªÑ„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫ÜÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6363] „ÄåÂú∞Â∫ïËî∑Ëñá„Äç]]></title>
    <url>%2F2020%2F05%2F11%2Floj6363%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(A(x) = \sum_k a_k\frac{x^k}{k!}\)ÔºåÁÇπÂèåËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(B(x) = \sum_{k} b_k \frac{x^k}{k!}\) (Âùá‰∏çÂê´Á©∫ÂõæÔºå‰∏Ä‰∏™ÁÇπ‰∏çÁÆóÁÇπÂèåËøûÈÄöÂõæ) Âàô \[ A(x) = x\sum_{k \ge 0} \frac{(\sum_{s \ge 2} A(x)^{s-1}\frac {b_s} {(s-1)!})^k}{k!} = x \exp(B&#39;(A(x))) \\\\ B&#39;(A(x)) = \ln(\frac {A(x)} x) \] Áî®ÊãâÊ†ºÊúóÊó•ÂèçÊºîÊ±Ç \([x^n]B(x)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)Ôºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ \(i \in S\) ‰ª• \(\mathcal O(i \log i)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ËÆ°ÁÆó \([x^i]B(i)\)ÔºåÁÑ∂Âêé‰ªÖ‰øùÁïôËøô‰∫õÈ°πÂæóÂà∞‰∏Ä‰∏™È¢òÁõÆÂÖÅËÆ∏ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁîüÊàêÂáΩÊï∞ \(C(x)\)„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÂ§ßÂ∞èÈÉΩÂú® \(S\) ÂÜÖÁöÑÊúâÊ†πÊó†ÂêëËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ \(D(x)\) (‰∏ãÈù¢Áî® \(D(x)^{-1}\) Ë°®Á§∫ \(D(x)\) ÁöÑÂ§çÂêàÈÄÜ) : \[ C&#39;(D(x)) = \ln(\frac {D(x)} x) \\\\ C&#39;(x) = \ln (\frac {x}{D(x)^{-1}}) \\\\ D(x)^{-1} = \frac x {\exp C&#39;(x)} \] ÊâÄ‰ª• \(D(x)\) ÊòØ \(\frac x {\exp C&#39;(x)}\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O((n + \sum_{x \in S} x) \log n)\) ‰∏•ÈáçÂç°Â∏∏„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wn[100];int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpow(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;int w[maxn * 8];unsigned long long _a[maxn * 8];void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) _a[rev[i]] = a[i]; int _ = 0; for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int _wn = wn[++ _]; w[0] = 1; for (int i = 1; i &lt; len; i++) &#123; w[i] = 1LL * w[i-1] * _wn % mod; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; unsigned long long v1 = _a[i+j], v2 = _a[i+j+(len&gt;&gt;1)]*w[j]%mod; _a[i+j] = v1 + v2; _a[i+j+(len &gt;&gt; 1)] = v1 + mod - v2; &#125; &#125; if (len == (1 &lt;&lt; 15)) &#123; for (int j = 0; j &lt; (1&lt;&lt;l); j++) &#123; _a[j] = _a[j] % mod; &#125; &#125; &#125; for (int i = 0; i &lt; (1&lt;&lt;l); i++) &#123; a[i] = _a[i] % mod; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;poly A, lnA, dlnA;int ok[maxn], fac[maxn], ifac[maxn];void init(int n) &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly tmp(n + 2); for (int i = 0; i &lt;= n + 1; i++) &#123; tmp.a[i] = 1LL * ifac[i] * qpow(2, 1LL * i * (i - 1) / 2) % mod; &#125; poly lnt = polyLn(tmp); A = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; A.a[i] = 1LL * (i + 1) * lnt.a[i + 1] % mod; &#125; lnA = polyLn(A); dlnA = poly(n); for (int i = 0; i &lt; n; i++) &#123; dlnA.a[i] = 1LL * (i + 1) * lnA.a[i + 1] % mod; &#125;&#125;int cal(int n) &#123; poly nA(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nA.a[i] = 1LL * lnA.a[i] * (mod - n) % mod; &#125; poly T = polyExp(nA) * dlnA; return 1LL * qpow(n, mod-2) % mod * T.a[n - 1] % mod;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); ok[x] = 1; &#125; for (int i = 0; i &lt;= 20; i++) wn[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); init(n); poly dC(n + 1); for (int i = 0; i &lt;= n; i++) &#123; if (ok[i + 1]) &#123; dC.a[i] = cal(i); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; dC.a[i] = 1LL * dC.a[i] * n % mod; &#125; poly t = polyExp(dC); int ans = 1LL * t.a[n - 1] * fac[n - 1] % mod * qpow(n, mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÁõ∏ÂÖ≥ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F11%2FLagrange%2F</url>
    <content type="text"><![CDATA[ÊäÄÂ∑ß ÊèèËø∞ÊñπÂºè Â∞ΩÈáè‰ΩøÁî®Â§çÂêàÈÄÜÁöÑÊ¶ÇÂøµÊù•ÊèèËø∞ÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºåËøôÊ†∑ÂèØ‰ª•ÁúÅÂéªÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ ÂÆö‰πâËÆ∞Âè∑ \(F(x)^{-1}\) Ë°®Á§∫ \(F(x)\) ÁöÑÂ§çÂêàÈÄÜ (Ê≥®ÊÑè‰∏çË¶Å‰∏éÂÄíÊï∞Ê∑∑Ê∑Ü)Ôºå‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÊãâÊ†ºÊúóÊó•ÂèçÊºîÂÖ¨ÂºèÂèØ‰ª•Ë°®Á§∫‰∏∫ \[ [x^n]F(x)^{-1} = \frac 1 n[x^{-1}] \frac 1 {F^n(x)} \\\\ [x^n]G(F(x)^{-1}) = \frac 1 n [x^{-1}] \frac{G&#39;(x)}{F^n(x)} \] ÈÄöËøá‰∏éÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÂá†‰πéÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑËØÅÊòéÊñπÊ≥ïÂèØ‰ª•ËØÅÊòéÁ¨¨‰∏Ä‰∏™ÂºèÂ≠êÁöÑ‰∏Ä‰∏™Êâ©Â±ïÔºöËã• \(F(G(x)) = H(x)\)ÔºåÂàô \([x^n]F(x) = \frac 1 n [x^{-1}] \frac{H&#39;(x)}{G^n(x)}\)„ÄÇÁ¨¨‰∫å‰∏™ÂºèÂ≠ê‰∏éËøô‰∏ÄÁªìËÆ∫ÊòØÁ≠â‰ª∑ÁöÑÔºå‰ΩÜÊòØÂª∫ËÆÆÂ∞ΩÂèØËÉΩ‰ΩøÁî®Á¨¨‰∫å‰∏™ÂºèÂ≠êËÄå‰∏çË¶Å‰ΩøÁî®Ëøô‰∏™ÁªìËÆ∫„ÄÇ Êé®ÂØºÊäÄÂ∑ß Èô§‰∫ÜÁßªÈ°πÁ≠âÂèòÂΩ¢‰πãÂ§ñÔºåËøòÂèØ‰ª•Âà©Áî®Â§çÂêàËøõË°åÂåñÁÆÄ„ÄÇÁî®Â§çÂêàÂåñÁÆÄÊó∂Ê≥®ÊÑèË¶ÅÁÅµÊ¥ª‰ΩøÁî®Â∑¶Âè≥ÈÄÜÔºåÂç≥ÁÅµÊ¥ª‰ΩøÁî® \(A(x) = B(x) \Rightarrow F(A(x))= F(B(x))\) Âíå \(A(x) = B(x) \Rightarrow A(F(x)) = B(F(x))\)ÔºåÈÅøÂÖç‰∏ÄÁõ¥Âè™ÊÉ≥Âà∞ÂÖ∂‰∏≠‰∏ÄÁßçÁöÑÊÉÖÂÜµ„ÄÇ ÂØπ‰∫é \(F(G(x)) = H(x)\)ÔºåÁü• \(H(x), F(x)\) Ê±Ç \([x^n] G(x)\) ÁöÑÊÉÖÂÜµÔºåÁõÆÂâçÊöÇ‰∏çÁü•Êúâ‰ªÄ‰πàÂ•ΩÁöÑÂÅöÊ≥ïÔºå‰ΩÜÊòØÂØπ‰∫é‰∏Ä‰∫õ \(H(x)\) ‰∏é \(G(x)\) ÊúâËæÉ‰∏∫ÁÆÄÂçïÁöÑÂÖ≥Á≥ªÁöÑÈóÆÈ¢òÊòØÂèØÂÅöÁöÑ„ÄÇ ‰æãÂ¶Ç \(F(G(x)) = xG(x) \Rightarrow F(G(G(x)^{-1})) = G^{-1}(x)G(G(x)^{-1}) \Rightarrow F(x) = x G(x)^{-1}\)ÔºåÂç≥ \(G\) ÊòØ \(\frac {F(x)} x\) ÁöÑÂ§çÂêàÈÄÜÔºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Á¨îËÆ∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5827] ÁÇπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F11%2FLuogu5827%2F</url>
    <content type="text"><![CDATA[ÂàöÂºÄÂßã‰ª•‰∏∫ÂíåËæπÂèåÊ≤°Âï•Â∑ÆÂà´..ÁªìÊûúÂêéÊù•Êêû‰∫ÜÂ•Ω‰πÖ„ÄÇ UPDÔºöÂ•ΩÂÉèÂ≠òÂú®Êõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ï„ÄÇ ÂÅöÊ≥ï ËÆæ \(n\) ‰∏™ÁÇπÁöÑÁÇπÂèåËøûÈÄöÂõæÊúâ \(f_n\) ‰∏™ÔºåËøûÈÄöÂõæÊúâ \(g_n\) ‰∏™ÔºåÂÆÉ‰ª¨ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÈí¶ÂÆöÊ†π) Êàë‰ª¨ËÆ§‰∏∫‰∏Ä‰∏™ÁÇπÁöÑÂõæ‰∏çÁÇπÂèåËøûÈÄöÔºå‰∏îËøô‰∏Ä‰∏™ÁÇπ‰∏∫Ââ≤ÁÇπ„ÄÇÁî±‰∫éÈ¢òÁõÆÈáå‰∏Ä‰∏™ÁÇπÊòØÁÆóÁÇπÂèåËøûÈÄöÂõæÁöÑÔºåË¶ÅÁâπÂà§‰∏ã„ÄÇ ËÆæ \(n\) ‰∏™ÁÇπÁöÑÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæ‰∏™Êï∞‰∏∫ \(b_n\)ÔºåÂÖ∂ EGF ‰∏∫ \(B(x)\)„ÄÇÊ†πÊçÆÂâ≤ÁÇπÁöÑÂÆö‰πâÔºåÂéªÊéâÊ†π‰πãÂêéÁöÑÁÇπÊûÑÊàê‰∏Ä‰∏™ËøûÈÄöÂõæÔºåÊâÄ‰ª• \(b_n = \frac n {n!}(2^{n-1}-1)(n-1)!g_{n-1}=(2^{n-1}-1)g_{n-1}\ (n \ge 2)\)„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåÂåÖÂê´‰∏çÊòØÂâ≤ÁÇπÁöÑÁÇπÁöÑÁÇπÂèåÊòØÂîØ‰∏ÄÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•Êûö‰∏æÂåÖÂê´Ê†πÁöÑÁÇπÂèåÁöÑÂ§ßÂ∞èÊù•ËÆ°ÁÆó \(B(x)\)„ÄÇËÆæ \(H(x) = G&#39;(x)\) (ÂØπ EGF Ê±ÇÂØºÁõ∏ÂΩì‰∫éÂπ≥Áßª‰∫Ü)ÔºåÂåÖÂê´Ê†πÁöÑÁÇπÂèåÂ§ßÂ∞è‰∏∫ \(n\) ‰∏îÊ†π‰∏çÊòØÂâ≤ÁÇπÁöÑÊúâÊ†πËøûÈÄöÂõæÁöÑ EGF ‰∏∫ \(n\frac{f_n}{n!}x^n H^{n-1}(x)\) (ËÄÉËôëÂÜ≥ÂÆöÊ†πÔºåÁÑ∂ÂêéÂÜ≥ÂÆöËøô‰∏™ÁÇπÂèå‰∏≠Èô§‰∫ÜÊ†π‰ª•Â§ñÊØè‰∏™ÁÇπÊåÇÁöÑËøûÈÄöÂõæ)„ÄÇ ËÆæ \(C(x) = \frac{B(x)}x\)ÔºåÂàô \[ B(x) = \sum_{n \ge 1} n\frac{f_n}{n!} x^n H^{n-1}(x) = xF&#39;(xH(x)) \\\\ xC(x) = xF&#39;(xH(x)) \\\\ C(x) = F&#39;(xH(x)) \] ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \[ [x^n] F(x) = \frac 1 n[x^{n-1}] F&#39;(x)=\frac 1 {n(n-1)}[x^{-1}]\frac{C&#39;(x)}{(xH(x))^{n-1}} \] ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; const int N = 100000; poly tmp(N + 1); for (int i = 0; i &lt;= N; i++) &#123; tmp.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnT = polyLn(tmp); poly G(N + 1); for (int i = 1; i &lt;= N; i++) &#123; // G.a[i] = 1LL * lnT.a[i] * i % mod; G.a[i] = lnT.a[i]; &#125; poly H(N); for (int i = 0; i &lt; N; i++) &#123; H.a[i] = 1LL * (i + 1) * G.a[i+1] % mod; &#125; poly B(N+1); int _ = 1; for (int i = 1; i &lt;= N; i++) &#123; B.a[i] = 1LL * (_ - 1) * G.a[i-1] % mod; _ = 1LL * _ * 2 % mod; &#125; poly C(N); for (int i = 0; i &lt; N; i++) &#123; C.a[i] = B.a[i+1]; &#125; poly lnH = polyLn(H); poly dC(N-1); for (int i = 0; i &lt; N-1; i++) &#123; dC.a[i] = 1LL * C.a[i+1] * (i+1) % mod; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); if (n == 1) &#123; puts("1"); continue; &#125; poly nH = poly(n); for (int i = 0; i &lt; n; i++) &#123; nH.a[i] = 1LL * lnH.a[i] * (mod - (n - 1)) % mod; &#125; poly res = polyExp(nH) * dC; int ans = 1LL * res.a[n - 2] * qpow(n - 1, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5828] ËæπÂèåËøûÈÄöÂõæËÆ°Êï∞]]></title>
    <url>%2F2020%2F05%2F10%2FLuogu5828%2F</url>
    <content type="text"><![CDATA[‰πãÂâçËØïÂõæÈÄöËøáÁî®Ê†ëÁöÑÁîüÊàêÂáΩÊï∞Â§çÂêàËæπÂèåÁöÑÁîüÊàêÂáΩÊï∞Êù•ÂæóÂà∞Á≠îÊ°à...‰ΩÜÊòØÈóÆÈ¢ò‰ºº‰πéÁ≠â‰ª∑‰∫éÂ∑≤Áü• \(F(x), H(x)\)Ôºå\(F(G(x)) = H(x)\)ÔºåÊ±Ç \([x^n] G(x)\)„ÄÇÊàë‰∏çÊòØÂæà‰ºöÔºåÂ¶ÇÊûúÊúâ‰∫∫‰ºöÁöÑËØùÊ±ÇÊïôÊàë‰∏Ä‰∏ã /kel„ÄÇ ‰∏ãÈù¢ÂÜôÁöÑÊòØÈ¢òËß£ÂÅöÊ≥ï„ÄÇ UPDÔºöÊ†ëÁöÑÁîüÊàêÂáΩÊï∞ÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁúãÂÅö‰∏Ä‰∏™ÊãâÊ†ºÊúóÊó•ÂèçÊºîÁöÑÁªìÊûú..ÊâÄ‰ª•ÊÑüÊÄßÁêÜËß£‰∏Ä‰∏ãÂèØ‰ª•ÁªïËøá‰∏äÈù¢ÈÇ£‰∏™ÂºèÂ≠êÊòØ‰∏Ä‰∏™ÂæàËá™ÁÑ∂ÁöÑ‰∏úË•ø„ÄÇ(Á∫ØÂ±ûËÉ°Ë®Ä‰π±ËØ≠) ÂÅöÊ≥ï ËÆæÊúâÊ†πËæπÂèåÂíåÊúâÊ†πËøûÈÄöÂõæ (ÊúâÊ†πÂ∞±ÊòØÈí¶ÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπ‰ΩúÊ†π) ÁöÑ EGF ÂàÜÂà´ÊòØ \(F(x)\) Âíå \(G(x)\)„ÄÇ(Âùá‰∏çÂåÖÂê´Á©∫Âõæ) ‰ºóÊâÄÂë®Áü•ÔºåËÆæÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(H(x)\)ÔºåÂàôËøûÈÄöÊó†ÂêëÂõæÁöÑ EGF ‰∏∫ \(\ln H(x)\)ÔºåÊâÄ‰ª• \(G(x) = \frac {xH&#39;(x)} {H(x)}\) (‰∏çÁî®ÁúüÁöÑÊåâÁÖßËøô‰∏™ÂºèÂ≠êÂéªÁÆóÔºåÂ∞±ÊòØÁ¨¨ \(i\) È°π‰πò‰ª• \(i\) ÁöÑÊÑèÊÄù)„ÄÇ ËÄÉËôëÊ†πÊâÄÂú®ÁöÑËæπÂèåÊÅ∞Â•Ω‰∏∫ \(n\) ÁöÑËøûÈÄöÂõæÊï∞ÔºåËøôÊ†∑ÁöÑËøûÈÄöÂõæÁöÑÁîüÊàêÂáΩÊï∞ÊòØ \(x^n f_n \sum_k n^k \frac{G^k(x)}{k!}=x^nf_n\exp(nG(x))\)„ÄÇ ÊâÄ‰ª•Êúâ \(G(x) = \sum_{n \ge 1} f_n (x\exp G(x))^n=F(x\exp G(x))\)„ÄÇ ‰Ωú (Êâ©Â±ï) ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèØÂæó \([x^n] F(x) = \frac 1 n[x^{-1}]\frac {G&#39;(x)}{(x\exp G(x))^n}\) ÊàëÈÄâÊã©Ë¥¥Êùø üíäüíäüíä ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];inline int mo(int x) &#123; if (x &gt;= mod) return x - mod; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int qpowl(int x, long long y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = mo(v1 + v2); a[i+j+(len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int fac[maxn], ifac[maxn];int main() &#123; int T = 5; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * qpow(i, mod-2) % mod; &#125; poly G, dG; &#123; int n = 100000; poly H(n + 1); for (int i = 0; i &lt;= n; i++) &#123; H.a[i] = 1LL * qpowl(2, 1LL * i * (i - 1) / 2) * ifac[i] % mod; &#125; poly lnH = polyLn(H); G = poly(n + 1); for (int i = 1; i &lt;= n; i++) &#123; G.a[i] = 1LL * lnH.a[i] * i % mod; &#125; dG = poly(n); for (int i = 0; i &lt; n; i++) &#123; dG.a[i] = 1LL * G.a[i+1] * (i+1) % mod; &#125; &#125; while (T --) &#123; int n; scanf("%d", &amp;n); poly nG = poly(n + 1); for (int i = 0; i &lt;= n; i++) &#123; nG.a[i] = 1LL * G.a[i] * (mod - n) % mod; &#125; poly res = polyExp(nG) * dG; int ans = 1LL * res.a[n-1] * qpow(n, mod-2) % mod * fac[n - 1] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3684] Â§ßÊúãÂèãÂíåÂ§öÂèâÊ†ë]]></title>
    <url>%2F2020%2F05%2F10%2Fbzoj3684%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæÁÇπÊùÉ‰∏∫ \(k\) ÁöÑÊ†ëÊúâ \(a_k\) Ê£µÔºåËÆæ \(A(x) = \sum_{i\ge 1} a_i x^i\) ËÆæ \(D(x) = \sum x^{d_i}\) Êúâ \(A(x) = D(A(x)) + x\)„ÄÇËÆæ \(C(x) = x - D(x)\)ÔºåÂàô \(C(A(x)) = x\) ÂÖ∂‰∏≠ \(C\) Âíå \(A\) ÈÉΩÊòØÊ≤°ÊúâÂ∏∏Êï∞È°π‰∏î‰∏ÄÊ¨°È°π‰∏∫ \(1\) ÁöÑÂ§öÈ°πÂºè„ÄÇÊàë‰ª¨Ë¶ÅÊ±ÇÁöÑÊòØ \([x^s] A(x)\)Ôºå‰ΩúÊãâÊ†ºÊúóÊó•ÂèçÊºîÔºö\([x^s] A(x) = \frac 1 s [x^{-1}] \frac 1 {C^s(x)}\) ËÆæ \(C(x) = xP(x)\)ÔºåÂàô \([x^s]A(x) = \frac 1 s [x^{s-1}] \frac 1 {P^s(x)}\) Ê±Ç‰∏™ÈÄÜÁÑ∂ÂêéÂ§öÈ°πÂºèÂø´ÈÄüÂπÇ‰∏Ä‰∏ãÂç≥ÂèØÔºå‰πüÂèØ‰ª•ÂÖà \(\ln\) ÂÜç \(\exp\)„ÄÇ BZOJ ‰∏äÂø´ÈÄüÂπÇ T ‰∫ÜÔºå‰ΩÜÊòØË¥¥‰∫Ü‰∏™ÊùøÂ≠êÊîπÊàê \(\ln\) + \(\exp\) Â∞±Ëøá‰∫ÜÔºåÁúã‰∫ÜÁ°ÆÂÆûÊòØÊØîÂø´ÈÄüÂπÇÂø´ÁöÑ„ÄÇ (BZOJ Á°ÆÂÆûÂ§™ÊÖ¢‰∫Ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 950009857;const int maxn = 100010;int g = 0;int s, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int wl[21];vector&lt;int&gt; vp;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL * ret * x % mod; &#125; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int checkg(int g) &#123; int ok = 1; for (int i = 0; i &lt; vp.size(); i++) &#123; int p = vp[i]; if (qpow(g, (mod - 1) / p) == 1) &#123; ok = 0; &#125; &#125; return ok;&#125;struct poly &#123; int *a, len; poly (int len_=0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;inline int mo(int x) &#123; if (x &gt;= mod) &#123; return x - mod; &#125; else &#123; return x; &#125;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); &#125; for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; int _ = 0; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int _wl = wl[++ _]; for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = mo(v1 + v2); a[s + i + (len &gt;&gt; 1)] = mo(v1 + mod - v2); w = 1LL * w * _wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * inv * a[i] % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l - i]); &#125; &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int _l = 0; while ((1 &lt;&lt; _l) &lt; ret.len) &#123; ++ _l; &#125; int l = (1 &lt;&lt; _l); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, _l, 1), ntt(wb, _l, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, _l, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly qpow(poly p, int x) &#123; int l = p.len; poly ret(1); ret.a[0] = 1; while (x) &#123; if (x &amp; 1) &#123; ret = ret * p; ret.len = l; &#125; x &gt;&gt;= 1; p = p * p; p.len = l; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0 (tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; v0.a[0] = (v0.a[0] + mod - 2) % mod; for (int i = 0; i &lt; p.len; i++) &#123; v0.a[i] = (mod - v0.a[i]) % mod; &#125; v0.len = p.len; poly v1 = v0 * r0; v1.len = p.len; return v1;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;int main() &#123; &#123; int _ = mod - 1; for (int i = 2; i * i &lt;= _; i++) &#123; if (_ % i == 0) &#123; vp.push_back(i); while (_ % i == 0) &#123; _ /= i; &#125; &#125; &#125; if (_ &gt; 1) &#123; vp.push_back(_); &#125; for (int i = 2; i &lt;= mod; i++) &#123; if (checkg(i)) &#123; g = i; break; &#125; &#125; &#125; for (int i = 0; i &lt;= 20; i++) &#123; wl[i] = qpow(g, (mod - 1) / (1 &lt;&lt; i)); &#125; scanf("%d%d", &amp;s, &amp;m); poly P(s); for (int i = 1; i &lt;= m; i++) &#123; int x = 0; scanf("%d", &amp;x); P.a[x - 1] = mod - 1; &#125; P.a[0] = 1; poly lnP = polyLn(P); int t = (mod - s) % mod; for (int i = 0; i &lt; lnP.len; i++) &#123; lnP.a[i] = 1LL * lnP.a[i] * t % mod; &#125; poly res = polyExp(lnP); int ans = 1LL * qpow(s, mod-2) * res.a[s-1] % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces438E] The Child and Binary Tree]]></title>
    <url>%2F2020%2F05%2F09%2FCF438E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(C(x) = \sum x^{c_i}\)Ôºå\(a_i\) ÊòØÊùÉÂÄºÂíå‰∏∫ \(i\) ÁöÑ‰∫åÂèâÊ†ëÊï∞Èáè (ÁâπÂà´Âú∞ÔºåÁ©∫‰∫åÂèâÊ†ëÁÆó‰Ωú‰∏ÄÁßçÊùÉÂÄºÂíå‰∏∫ \(0\) ÁöÑ‰∫åÂèâÊ†ë)Ôºå\(A(x) = \sum_{i \ge 0} a_ix^i\)„ÄÇ Âàô \(A(x) = A^2(x)C(x)+ 1\)Ôºå\(C(x)A^2(x)-A(x)+1=0\)„ÄÇÁî±‰∏ÄÂÖÉ‰∫åÊ¨°ÊñπÁ®ãÊ±ÇÊ†πÂÖ¨ÂºèÂæó \(A(x) = \frac{1 \pm \sqrt {1-4C(x)}}{2C(x)}\)ÔºåÁî±‰∫éÂàÜÊØçÊ≤°ÊúâÂ∏∏Êï∞È°πÔºåËøôÈáåÂ∫îËØ•ÂèñË¥üÂè∑„ÄÇ ‰∫éÊòØÂ§öÈ°πÂºèÂºÄÊ†π‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇ(Âõ†‰∏∫ \([x^0] (1-4C(x)) = 1\)ÔºåÂè™Â≠òÂú®‰∏§‰∏™ÁöÑÂ§öÈ°πÂºè \(F(x)\) Êª°Ë∂≥ \(F^2(x) \equiv 1-4C(x) \pmod {x^n}\)Ôºå‰∏ÄÊ≠£‰∏ÄË¥ü) ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int g = 3;const int i2 = (mod + 1) / 2;const int maxn = 200010;int n, m;int wa[maxn * 8], wb[maxn * 8], wc[maxn * 8], rev[maxn * 8];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void ntt(int *a, int _l, int ty) &#123; int l = (1 &lt;&lt; _l); for (int i = 1; i &lt; l; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(_l-1)); for (int i = 0; i &lt; l; i++) &#123; if (i &lt; rev[i]) &#123; swap(a[i], a[rev[i]]); &#125; &#125; for (int len = 2; len &lt;= l; len &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / len); for (int s = 0; s &lt; l; s += len) &#123; int w = 1; for (int i = 0; i &lt; (len &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * a[s + i + (len &gt;&gt; 1)] * w % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(l, mod-2); for (int i = 0; i &lt; l; i++) &#123; a[i] = 1LL * a[i] * inv % mod; &#125; for (int i = 1; i &lt; l / 2; i++) &#123; swap(a[i], a[l-i]); &#125; &#125; &#125;struct poly &#123; int *a, len; poly (int len_ = 0) &#123; len = len_; a = new int [len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int t = 0; while ((1 &lt;&lt; t) &lt; ret.len) &#123; ++ t; &#125; int l = (1 &lt;&lt; t); for (int i = 0; i &lt; l; i++) &#123; wa[i] = wb[i] = wc[i] = 0; &#125; for (int i = 0; i &lt; p1.len; i++) &#123; wa[i] = p1.a[i]; &#125; for (int i = 0; i &lt; p2.len; i++) &#123; wb[i] = p2.a[i]; &#125; ntt(wa, t, 1), ntt(wb, t, 1); for (int i = 0; i &lt; l; i++) &#123; wc[i] = 1LL * wa[i] * wb[i] % mod; &#125; ntt(wc, t, -1); for (int i = 0; i &lt; ret.len; i++) &#123; ret.a[i] = wc[i]; &#125; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polyInv(p0); poly v0 = r0 * p; poly v1(p.len); v1.a[0] = 2; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = (v1.a[i] + mod - v0.a[i]) % mod; &#125; poly r = r0 * v1; r.len = p.len; return r;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int tl = (p.len + 1) &gt;&gt; 1; poly p0(tl); for (int i = 0; i &lt; tl; i++) &#123; p0.a[i] = p.a[i]; &#125; poly r0 = polySqrt(p0); poly r1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; r1.a[i] = r0.a[i]; &#125; poly v0 = polyInv(r1) * p; poly v1(p.len); for (int i = 0; i &lt; r0.len; i++) &#123; v1.a[i] = r0.a[i]; &#125; for (int i = 0; i &lt; p.len; i++) &#123; v1.a[i] = 1LL * i2 * (v1.a[i] + v0.a[i]) % mod; &#125; return v1;&#125;int _c[maxn];int main() &#123; int k = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int c; scanf("%d", &amp;c); ++ _c[c]; &#125; for (int i = 1; i &lt;= 100000; i++) &#123; if (_c[i]) &#123; k = i; break; &#125; &#125; if (k &gt; m) &#123; for (int i = 1; i &lt;= m; i++) &#123; puts("0"); &#125; return 0; &#125; poly p(2); p.a[0] = p.a[1] = 1; poly q = p * p; poly C(m + k + 1); for (int i = 0; i &lt;= min(100000, m+k); i++) &#123; C.a[i] = _c[i]; &#125; poly v0(m + k + 1); v0.a[0] = 1; for (int i = 0; i &lt; v0.len; i++) &#123; v0.a[i] = (v0.a[i] + mod - 1LL * 4 * C.a[i] % mod) % mod; &#125; poly v1 = polySqrt(v0); v1.a[0] = (v1.a[0] + mod - 1) % mod; for (int i = 0; i &lt; v1.len; i++) &#123; v1.a[i] = (mod - v1.a[i]) % mod; &#125; poly v2(m + k + 1); for (int i = 0; i &lt; C.len; i++) &#123; v2.a[i] = 1LL * 2 * C.a[i] % mod; &#125; poly X(m+1), Y(m+1); for (int i = 0; i &lt;= m; i++) &#123; X.a[i] = v1.a[i + k]; Y.a[i] = v2.a[i + k]; &#125; poly res = X * polyInv(Y); for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", res.a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>NTT</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268J] Jealous Split]]></title>
    <url>%2F2020%2F05%2F09%2Fgym102268J%2F</url>
    <content type="text"><![CDATA[Á•û‰ªôÈ¢òÔºå‰πãÂâçÂê¨‰∫∫ÊèêËøá„ÄÇ‰ΩÜÊòØÂá∏ÊÄßÂÆåÂÖ®‰∏ç‰ºöËØÅÔºå‰ºö‰∫Ü‰πãÂêéË°•‰∏ä QwQ„ÄÇ ÂÅöÊ≥ï ÊòæÁÑ∂‰Ωø \(\sum s_i^2\) ÂèñÂà∞ÊúÄÂ∞èÂÄºÁöÑÂàíÂàÜ‰∏ÄÂÆöÊª°Ë∂≥Êù°‰ª∂„ÄÇ ÊâÄ‰ª•‰∫åÂàÜÊñúÁéáÊ±ÇÂá∫ \(\sum s_i^2\) ÊúÄÂ∞èÁöÑÂ∫èÂàóÂ∞±Ë°å‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 200010;struct line &#123; __int128 k, b; int c; line (__int128 k_=0, __int128 b_=0, int c_=0) &#123; k = k_, b = b_, c = c_; &#125; __int128 cal(__int128 x) &#123; return k * x + b; &#125;&#125; Q[maxn];ld cross(const line &amp;l1, const line &amp;l2) &#123; return (l1.b - l2.b) / (l2.k - l1.k);&#125;int n, k;__int128 a[maxn], dp[maxn], S[maxn];int mn_cnt[maxn], mx_cnt[maxn];int cmp_less(int x, int y) &#123; return x &lt; y;&#125;int cmp_greater(int x, int y) &#123; return x &gt; y;&#125;void caldp(__int128 cur, int* cnt, int (*cmp) (int, int)) &#123; int s = 0, t = 0; Q[t++] = line(0, cur, 0); for (int i = 1; i &lt;= n; i++) &#123; while (s + 1 &lt; t) &#123; __int128 v1 = Q[s].cal(S[i]), v2 = Q[s+1].cal(S[i]); if (v1 &gt; v2 || (v1 == v2 &amp;&amp; cmp(Q[s+1].c, Q[s].c))) &#123; ++ s; &#125; else break; &#125; dp[i] = Q[s].cal(S[i]) + S[i] * S[i]; cnt[i] = Q[s].c + 1; line l(- 2 * S[i], dp[i] + S[i] * S[i] + cur, cnt[i]); if (s &lt; t &amp;&amp; Q[t-1].k == l.k) &#123; if (l.b == Q[t-1].b) &#123; if (!cmp(l.c, Q[t-1].c)) &#123; l = Q[t-1]; &#125; &#125; else &#123; if (l.b &gt; Q[t-1].b) &#123; l = Q[t-1]; &#125; &#125; -- t; &#125; while (s &lt; t-1 &amp;&amp; (Q[t-1].b - Q[t-2].b) * (Q[t-2].k - l.k) &gt;= (l.b - Q[t-2].b) * (Q[t-2].k - Q[t-1].k)) &#123; -- t; &#125; Q[t++] = l; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = x; &#125; for (int i = 1; i &lt;= n; i++) &#123; S[i] = S[i-1] + a[i]; &#125; __int128 L = 0, R = 3e19; while (1) &#123; __int128 mid = (L + R) / 2; caldp(mid, mn_cnt, cmp_less); caldp(mid, mx_cnt, cmp_greater); if (mn_cnt[n] &lt;= k &amp;&amp; mx_cnt[n] &gt;= k) &#123; break; &#125; else if (mn_cnt[n] &gt; k) &#123; L = mid + 1; &#125; else R = mid - 1; &#125; __int128 mid = (L + R) / 2; vector&lt;int&gt; ans; int cur = n; while (cur) &#123; for (int l = cur; l &gt;= 1; l--) &#123; if (mn_cnt[l-1] &lt;= k-1 &amp;&amp; mx_cnt[l-1] &gt;= k-1 &amp;&amp; (dp[l-1] + (S[cur] - S[l-1]) * (S[cur] - S[l-1]) + mid == dp[cur])) &#123; cur = l-1; ans.push_back(cur); -- k; break; &#125; &#125; &#125; puts("Yes"); ans.pop_back(); reverse(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d ", ans[i]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï]]></title>
    <url>%2F2020%2F05%2F09%2F%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Áî±‰∫éÊàëÊ∞¥Âπ≥Â§™‰ΩéÊôÆÂèäÁªÑÁü•ËØÜÁÇπÈÉΩÊ≤°ÊéåÊè°Ôºå‰ªäÂ§©Áªà‰∫éÊêûÊáÇ‰∫Ü‰∏ÄÁÇπÊâÄ‰ª•ÊâìÁÆóËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢ËÆ®ËÆ∫ÁöÑÈÉΩÊòØÊó†ÂêëÂõæÔºåÁî±‰∫éËøûÈÄöÂùóÈó¥Áã¨Á´ãÔºåÊàë‰ª¨Âè™ËÄÉËôëËøûÈÄöÂõæÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûúÁÇπÊï∞‰∏∫ \(1\)ÔºåÂú®Êüê‰∫õÈóÆÈ¢ò‰∏ãÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ‰∏ãÈù¢Êàë‰ª¨Âè™ËÄÉËôëÁÇπÊï∞‰∏ç‰∏∫ \(1\) ÁöÑÊÉÖÂÜµ„ÄÇ ÂÆö‰πâ 1 ÂØπ‰∫é‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\)ÔºåÂ¶ÇÊûú‰ªé \(G\) Âà†ÂéªÁÇπ \(u\) ÂíåÊâÄÊúâ‰∏éÂÆÉÁõ∏ÈÇªÁöÑËæπÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄöÔºåÂ∞±Áß∞ \(u\) ÊòØ \(G\) ÁöÑ‰∏Ä‰∏™Ââ≤ÁÇπ„ÄÇ ÂÆö‰πâ 2 Ëã•ËøûÈÄöÂõæ \(G\) ‰∏≠‰∏çÂ≠òÂú®Ââ≤ÁÇπÔºåÂàôÁß∞ \(G\) ÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂõæ„ÄÇ ÂÆö‰πâ 3 Áß∞ËøûÈÄöÂõæ \(G\) ÁöÑÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂõæÂ≠êÂõæ‰∏∫ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇ ÊÄßË¥® 1 ‰∏§‰∏™‰∏çÂêåÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑ‰∫§Ëá≥Â§öÂåÖÂê´‰∏Ä‰∏™ÁÇπ„ÄÇ ËØÅÊòé ÂÅáËÆæ‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè \(A\) Âíå \(B\) Êúâ‰∫§ÔºåËÆæËøô‰∏§‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂπ∂‰∏∫ \(H\)ÔºåÊ†πÊçÆÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÂÆö‰πâÔºå\(H\) ‰∏ÄÂÆö‰∏çÊòØÁÇπÂèåËøûÈÄöÂõæÔºåÊâÄ‰ª•Â≠òÂú®‰∏Ä‰∏™ÁÇπ \(u\)Ôºå‰ªé \(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂêéÂæóÂà∞ÁöÑÂõæ‰∏çËøûÈÄö„ÄÇ\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæÂç≥‰∏∫ \(A\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) Âíå \(B\) Âà†ÂéªÁÇπ \(u\) (Â¶ÇÊûúÂ≠òÂú®) ÂæóÂà∞ÁöÑÂõæÁöÑÂπ∂„ÄÇÂ¶ÇÊûú \(A\) Âíå \(B\) ÁöÑ‰∫§Â§ß‰∫é \(1\)ÔºåÁî±‰∫é‰∏§‰∏™Êúâ‰∫§ÁöÑËøûÈÄöÂõæÁöÑÂπ∂‰ªç‰∏∫ËøûÈÄöÂõæÔºå\(H\) ‰∏≠Âà†ÂéªÁÇπ \(u\) ÂæóÂà∞ÁöÑÂõæ‰πüÊòØËøûÈÄöÂõæÔºåËøôÂ∞±ÂØºÂá∫‰∫ÜÁüõÁõæ„ÄÇ ÊÄßË¥® 2 Âú®‰∏Ä‰∏™ËøûÈÄöÂõæ \(G\) ‰∏≠ÔºåÂØπ‰∫é‰ªªÊÑè‰∏ÄÊù°Ëæπ \(e\)ÔºåÊÅ∞Êúâ‰∏Ä‰∏™ \(G\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáèÂåÖÂê´Ëæπ \(e\)„ÄÇ ËØÅÊòé Ëæπ \(e\) ÁöÑ‰∏§‰∏™È°∂ÁÇπÁöÑÂØºÂá∫Â≠êÂõæÂ∞±ÊòØ‰∏Ä‰∏™ \(G\) ÁöÑÂ§ßÂ∞è‰∏∫ \(2\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª•‰πü‰∏ÄÂÆöÂ≠òÂú®ÂåÖÂê´Ëæπ \(e\) ÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÁî±ÊÄßË¥® 1 ÂèØÁü•‰∏§‰∏™‰∏çÂêåÁöÑÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏çÂèØËÉΩÂåÖÂê´Âêå‰∏ÄÊù°Ëæπ„ÄÇ Áî±‰∫éÁÇπÂèåËøûÈÄöÂàÜÈáèÊòØËøûÈÄöÁöÑÔºåÂè™Ë¶ÅÁ°ÆÂÆö‰∫Ü‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâËæπÔºåÁÇπ‰πüÂ∞±Á°ÆÂÆö‰∫Ü„ÄÇÂõæ \(G\) ÁöÑÊâÄÊúâÁÇπÂèåËøûÈÄöÂàÜÈáèÊûÑÊàêËæπÈõÜÁöÑ‰∏Ä‰∏™ÂàíÂàÜ„ÄÇ Âú®Âõæ‰∏ä‰Ωú DFSÔºåÂèñ‰∏ÄÊ£µ‰ª• \(r\) ‰∏∫Ê†πÁöÑ DFS Ê†ëÔºåËÆæÁÇπ \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´ËÆøÈóÆÊó∂Èó¥‰∏∫ \(dfn_u\)Ôºå\(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÈÄöËøá‰∏ÄÊù°ËøîÁ•ñËæπËÉΩÂ§üÂà∞ËææÁöÑ dfn ÊúÄÂ∞èÁöÑÁÇπÁöÑ dfn ‰∏é \(dfn_u\) ÁöÑÊúÄÂ∞èÂÄº‰∏∫ \(low_u\) (Ê≥®ÊÑèËøîÁ•ñËæπÊåáÁöÑÊòØÈùûÊ†ëËæπÔºå‰∏çÂåÖÂê´ \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÔºåÂÆûÁé∞Êó∂Ë¶ÅÁâπÂà§)„ÄÇ ËÆæÁÇπ \(u\) Âú®ËøôÊ£µ DFS Ê†ë‰∏äÁöÑÁà∂‰∫≤‰∏∫ \(fa(u)\)„ÄÇ ÂØπ‰∫éÁÇπ \(u \neq r, fa(u) \neq r\)ÔºåÂ¶ÇÊûú \(low_u &lt; dfn_{fa(u)}\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ÁÇπ \(u, fa(u), fa(fa(u))\) ÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºå‰ªéËÄå \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÂíå \(fa(u)\) Âà∞Áà∂‰∫≤ÁöÑËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ Âú® DFS ÁöÑËøáÁ®ã‰∏≠ÔºåÊØèÁªèËøá‰∏ÄÊù°Ê†ëËæπÂ∞±ÊääËøôÊù°Ê†ëËæπÊîæÂÖ•‰∏Ä‰∏™Ê†à‰∏≠„ÄÇÂú®ÁÇπ \(u\) ÂõûÊ∫ØÊó∂ÔºåÊ£ÄÊü•‰∏Ä‰∏ãÊòØÂê¶Êúâ \(low_u \ge dfn_{fa(u)}\) (Â¶ÇÊûúÊòØÊ†πÁöÑËØù‰∏çÁî®Ê£ÄÊü•‰∫Ü)„ÄÇ ËÄÉËôëÁ¨¨‰∏ÄÊ¨°Êª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂõûÊ∫ØÔºåÊ≠§Êó∂ÁÇπ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπÈÉΩÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÔºåÂõ†Ê≠§Â≠òÂú®‰∏Ä‰∏™ÂåÖÂê´ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÁÇπÂèåËøûÈÄöÂ≠êÂõæ„ÄÇÂõ†‰∏∫‰∏çÂ≠òÂú®Ë∑®Ëøá \(u\) Âà∞Áà∂‰∫≤ÁöÑËæπÁöÑÈùûÊ†ëËæπÔºåËøô‰∏™ÁÇπÂèåËøûÈÄöÂ≠êÂõæÊòØ‰∏Ä‰∏™ÊûÅÂ§ßÁÇπÂèåËøûÈÄöÂ≠êÂõæÔºåÊâÄ‰ª• \(u\) ÁöÑÂ≠êÊ†ë‰∏≠ÊâÄÊúâÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊàë‰ª¨ÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑÁÇπ‰øùÂ≠òËµ∑Êù•ÔºåÁÑ∂Âêé‰ªéÊ†à‰∏≠ÂºπÂá∫ \(u\) Â≠êÊ†ë‰∏≠ÊâÄÊúâÊ†ëËæπ„ÄÇ Âú®‰πãÂêéÁöÑÂõûÊ∫Ø‰∏≠ÔºåÂ¶ÇÊûúÊª°Ë∂≥ \(low_u \ge dfn_{fa(u)}\)ÔºåÈÇ£‰πàÊ≠§Êó∂Ê†à‰∏≠ÊâÄÊúâÊ†ëËæπÂú®Âêå‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠Ôºå‰∏îËøô‰∫õËæπÁöÑÊâÄÊúâÁ´ØÁÇπÁöÑÂØºÂá∫Â≠êÂõæÊòØ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè„ÄÇÊääËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰øùÂ≠ò‰∏ãÊù•ÁÑ∂ÂêéÊääÊ†à‰∏≠ÊâÄÊúâ \(u\) Â≠êÊ†ë‰∏≠ÁöÑËæπÂºπÂá∫Âç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n+m)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖÊ±ÇÂá∫‰∫ÜÊØè‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÁöÑÁÇπÈõÜ„ÄÇ‰∏Ä‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÁöÑËæπÂ∞±ÊòØËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáèÂÜÖÈÉ®ÁöÑÊ†ëËæπÂä†‰∏äËøô‰∏™ÁÇπÂèåËøûÈÄöÂàÜÈáè‰∏≠ÊâÄÊúâÁÇπÁöÑËøîÁ•ñËæπÔºåËøôÂæàÂÆπÊòìÂ§ÑÁêÜ„ÄÇÔºàÊ≥®ÊÑèËøôÈáåËøîÁ•ñËæπÁöÑÂÆö‰πâÊòØ‰ªéÊüê‰∏™ÁÇπÂá∫ÂèëÂà∞ÂÆÉÁ•ñÂÖàÁöÑÈùûÊ†ëËæπÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÊØèÊù°ÈùûÊ†ëËæπÊòØÊÅ∞Â•Ω‰∏Ä‰∏™ÁÇπÁöÑËøîÁ•ñËæπÔºâ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268I] Interesting Graph]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268I%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏Ä‰∏™ÂõæÁöÑÊüìËâ≤ÊñπÊ°àÊï∞Á≠â‰∫éÂêÑ‰∏™ÁÇπÂèåÁöÑÊüìËâ≤ÊñπÊ°àÊï∞‰πòÁßØÈô§‰ª•È¢úËâ≤Êï∞ÁöÑ(ÁÇπÂèåÊï∞ - ËøûÈÄöÂùóÊï∞)Ê¨°ÊñπÔºàËÄÉËôëÂØπÊØè‰∏™ËøûÈÄöÂùóÂú®ÂúÜÊñπÊ†ë‰∏ä‰ªé‰∏äÂæÄ‰∏ãÂØπÊØè‰∏™ÁÇπÂèåÊüìËâ≤Ôºâ„ÄÇ Ê†πÊçÆÈ¢òÁõÆ‰∏≠ÁöÑÊù°‰ª∂Ôºå‰∏Ä‰∏™ÁÇπÂèåÁöÑÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøá \(7\)ÔºåÊö¥ÂäõÊûö‰∏æÈõÜÂêàÂàíÂàÜÂèØ‰ª•Ê±ÇÂá∫‰∏Ä‰∏™ÁÇπÂèåÁöÑËâ≤Â§öÈ°πÂºèÔºåÂàÜÊ≤ª fft ‰∏Ä‰∏ãÂç≥ÂèØÂæóÂà∞ÁªôÂÆöÁöÑÂõæÁöÑËâ≤Â§öÈ°πÂºèÔºåÁÑ∂ÂêéÂ§öÁÇπÊ±ÇÂÄº‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ (‰∏∫Âï•‰∏ÄÂÆöË¶ÅÁªôÂêÑÁßçÊüìËâ≤ÊñπÊ°àÊï∞È¢òÂ•ó‰∏™Â§öÁÇπÊ±ÇÂÄº...Â•ΩÊó†ËÅä) ÂÆåÂÖ®‰∏ç‰ºöÂÜôÁÇπÂèå..Ë∞É‰∫Ü‰∏ÄÂ§©„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int maxn = 100010;const int mod = 998244353;const int g = 3;int n, m, C;namespace NTT &#123; int tot, fac[maxn], ifac[maxn], inv[maxn], ans[maxn]; int wa[maxn*16], wb[maxn*16], wc[maxn*16], rev[maxn*16]; int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret; &#125; struct poly &#123; int *a, len; poly(int len_=0) &#123; len = len_; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125; int cal(int x) &#123; int t = 1; int ret = 0; for (int i = 0; i &lt; len; i++) &#123; ret = (ret + 1LL * t * a[i] % mod) % mod; t = 1LL * t * x % mod; &#125; return ret; &#125; &#125; p[maxn], P[maxn &lt;&lt; 2]; void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; if (l) for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125; &#125; poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); /*for (int i = 0; i &lt; p1.len; i++) &#123; for (int j = 0; j &lt; p2.len; j++) &#123; ret.a[i+j] = (ret.a[i+j] + 1LL * p1.a[i] * p2.a[j] % mod) % mod; &#125; &#125;*/ //return ret; int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret; &#125; poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int l = p.len; int tl = (l + 1) / 2; poly p0(tl); for (int i = 0; i &lt; tl; i++) p0.a[i] = p.a[i]; poly q0 = polyInv(p0); poly t0 = q0 * p; t0.a[0] = (t0.a[0] + mod - 2) % mod; t0.len = p.len; for (int i = 0; i &lt; l; i++) t0.a[i] = (mod - t0.a[i]) % mod; poly ret = q0 * t0; ret.len = l; return ret; &#125; poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (q.len &gt; p.len) return p; poly pr(p.len - q.len + 1), qr(p.len - q.len + 1); for (int i = 0; i &lt; pr.len; i++) pr.a[i] = p.a[p.len - 1 - i]; for (int i = 0; i &lt; qr.len; i++) if (q.len - 1 - i &gt;= 0) qr.a[i] = q.a[q.len - 1 - i]; poly dr = polyInv(qr) * pr; dr.len = p.len - q.len + 1; poly d(dr.len); for (int i = 0; i &lt; d.len; i++) d.a[i] = dr.a[dr.len - 1 - i]; poly res = d * q; poly ret(q.len - 1); for (int i = 0; i &lt; ret.len; i++) &#123; if (i &lt; res.len) ret.a[i] = (p.a[i] + mod - res.a[i]) % mod; else ret.a[i] = p.a[i]; &#125; return ret; &#125; void _solve(int l, int r, int rt) &#123; if (l == r) &#123; P[rt] = poly(2); P[rt].a[0] = mod - l, P[rt].a[1] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; _solve(l, m, rt&lt;&lt;1); _solve(m+1, r, rt&lt;&lt;1|1); P[rt] = P[rt&lt;&lt;1] * P[rt&lt;&lt;1|1]; &#125; void calAns(const poly &amp;p, int l, int r, int rt) &#123; if (l == r) &#123; ans[l] = p.a[0]; return; &#125; int m = (l + r) &gt;&gt; 1; calAns(polyMod(p, P[rt&lt;&lt;1]), l, m, rt&lt;&lt;1); calAns(polyMod(p, P[rt&lt;&lt;1|1]), m+1, r, rt&lt;&lt;1|1); &#125; poly cal(int l, int r) &#123; if (l == r) return p[l]; int m = (l + r) &gt;&gt; 1; return cal(l, m) * cal(m+1, r); &#125; void solve() &#123; fac[0] = ifac[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= m; i++) inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; for (int i = 1; i &lt;= m; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; poly _res = cal(1, tot); poly res(n + m + 1); for (int i = 0; i &lt;= n + m; i++) &#123; if (i + C &lt; _res.len) &#123; res.a[i] = _res.a[i + C]; &#125; &#125; // cout &lt;&lt; res.cal(3) &lt;&lt; endl; _solve(1, n, 1); calAns(polyMod(res, P[1]), 1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", ans[i]); &#125; puts(""); &#125;&#125;int l[maxn], vis[maxn], dfn[maxn], low[maxn], tim, e, top;pi sta[maxn];vector&lt;int&gt; son[maxn], va[maxn];vector&lt;int&gt; vertex_set;vector&lt;pi&gt; edge_set;vector&lt;int&gt; G[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;// Á¨¨‰∏ÄÁ±ªÊñØÁâπÊûóÊï∞int S[10][10];// ‰∏ãÈôçÂπÇÁ≥ªÊï∞int _a[10], _b[10], vc[10], col[maxn];void __dfs(int in, int mx) &#123; if (in &gt;= vertex_set.size()) &#123; ++ _a[mx]; return; &#125; for (int i = 0; i &lt;= 7; i++) vc[i] = 0; int u = vertex_set[in]; for (int _ = 0; _ &lt; G[u].size(); _++) &#123; int v = G[u][_]; vc[col[v]] = 1; &#125; vector&lt;int&gt; ok_col; for (int i = 1; i &lt;= mx; i++) &#123; if (!vc[i]) &#123; ok_col.push_back(i); &#125; &#125; for (int _ = 0; _ &lt; ok_col.size(); _++) &#123; int c = ok_col[_]; col[u] = c; __dfs(in + 1, mx); col[u] = 0; &#125; col[u] = mx + 1; __dfs(in + 1, mx + 1); col[u] = 0;&#125;NTT::poly cal() &#123; sort(vertex_set.begin(), vertex_set.end()); vertex_set.erase(unique(vertex_set.begin(), vertex_set.end()), vertex_set.end()); for (int _ = 0; _ &lt; vertex_set.size(); _++) &#123; int u = vertex_set[_]; col[u] = 0; G[u].clear(); for (int i = 0; i &lt; va[u].size(); i++) &#123; edge_set.push_back(pi(u, va[u][i])); &#125; //printf("%d ", u); &#125; //puts(""); for (int _ = 0; _ &lt; edge_set.size(); _++) &#123; int u = edge_set[_].first, v = edge_set[_].second; G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 0; i &lt;= 7; i++) &#123; _a[i] = _b[i] = 0; vc[i] = 0; &#125; int s = vertex_set.size(); if (s &gt; 7) exit(-1); __dfs(0, 0); NTT::poly ret(s + 1); for (int i = 0; i &lt;= s; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; int K = S[i][j]; if ((i + j) &amp; 1) K = (mod - K) % mod; _b[j] = (_b[j] + 1LL * K * _a[i] % mod) % mod; &#125; &#125; for (int i = 0; i &lt;= s; i++) &#123; ret.a[i] = _b[i]; &#125; return ret;&#125;void dfs(int u, int f) &#123; dfn[u] = low[u] = ++ tim, vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; son[u].push_back(v); sta[++ top] = pi(u, v); dfs(v, u); low[u] = min(low[u], low[v]); &#125; else if (v != f) &#123; low[u] = min(low[u], dfn[v]); if (vis[v]) &#123; va[u].push_back(v); &#125; &#125; &#125; if (f &amp;&amp; low[u] &gt;= dfn[f]) &#123; pi t; edge_set.clear(); vertex_set.clear(); do &#123; t = sta[top --]; edge_set.push_back(t); vertex_set.push_back(t.first), vertex_set.push_back(t.second); &#125; while (t != pi(f, u)); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; vis[u] = 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); S[0][0] = 1; for (int i = 1; i &lt;= 7; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; S[i][j] = S[i-1][j-1] + 1LL * (i-1) * S[i-1][j] % mod; &#125; &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; int _tim = tim; -- C; dfs(i, 0); if (tim == _tim + 1) &#123; vertex_set.clear(); edge_set.clear(); vertex_set.push_back(i); ++ C; NTT::p[++ NTT::tot] = cal(); &#125; &#125; &#125; NTT::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268E] Expected Value]]></title>
    <url>%2F2020%2F05%2F08%2Fgym102268E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ \(f_i\) ÊòØÁ¨¨ \(i\) Ê≠•Êó∂ÊÅ∞Â•ΩÂà∞ËææÁÇπ \(n\) ÁöÑÊ¶ÇÁéáÔºåÊòæÁÑ∂Êï∞Âàó \(\{f_i\}\) Êª°Ë∂≥‰∏Ä‰∏™‰∏çË∂ÖËøá \(n\) Èò∂ÁöÑÁ∫øÊÄßÈÄíÊé®„ÄÇ Âõ†‰∏∫ÁªôÂÆöÁöÑÂõæÊòØÂπ≥Èù¢ÂõæÔºåÊâÄ‰ª• \(m = \mathcal O(n)\)ÔºåÊàë‰ª¨ÂèØ‰ª•Êö¥ÂäõÊ±ÇÂá∫ \(f\) ÁöÑÂâç \(2n\) È°πÔºåÁÑ∂Âêé BM Âá∫ÈÄíÊé®Âºè„ÄÇÂæóÂà∞ÈÄíÊé®Âºè‰πãÂêé‰πüÂ∞±ÂæóÂà∞‰∫ÜÁîüÊàêÂáΩÊï∞ÔºåÊ±Ç‰∏™ÂØºÊää \(x=1\) ‰ª£ÂÖ•Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;const int maxm = 3 * maxn;const int mod = 998244353;int n, m, _l[maxn], out[maxn], deg[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = _l[u], _l[u] = e++;&#125;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;namespace BM &#123; int s[maxn * 2], f[maxn], nf[maxn]; int l[maxn * 2], Q[maxn * 2], R[maxn * 2]; int p, pQ[maxn * 2], pR[maxn * 2]; int _Q[maxn * 2], _R[maxn * 2]; void init() &#123; f[1] = 1; for (int T = 1; T &lt;= 2 * n; T++) &#123; for (int u = 1; u &lt;= n; u++) &#123; nf[u] = 0; for (int p = _l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != n) &#123; nf[u] = (nf[u] + 1LL * out[v] * f[v] % mod) % mod; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; f[u] = nf[u]; &#125; s[T] = f[n]; &#125; l[0] = 0, Q[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) R[i] = s[i]; int p = 0; for (int i = 1; i &lt;= 2 * n; i++) &#123; if (!R[i]) &#123; l[i] = l[i-1]; continue; &#125; l[i] = max(l[i-1], i - l[i-1] + 1); if (i - l[i-1] + 1 &gt; l[i-1]) &#123; for (int j = 0; j &lt;= 2 * n; j++) &#123; _Q[j] = Q[j]; _R[j] = R[j]; &#125; &#125; if (p) &#123; int k = (mod - 1LL * qpow(pR[p], mod-2) * R[i] % mod) % mod; int d = i - p; for (int j = 0; j &lt;= 2 * n; j++) &#123; if (j &gt;= d) &#123; Q[j] = (Q[j] + 1LL * k * pQ[j - d] % mod) % mod; R[j] = (R[j] + 1LL * k * pR[j - d] % mod) % mod; &#125; &#125; &#125; if (i - l[i-1] + 1 &gt; l[i-1]) &#123; p = i; for (int j = 0; j &lt;= 2 * n; j++) &#123; pQ[j] = _Q[j]; pR[j] = _R[j]; &#125; &#125; &#125; // (R(x) / Q(x))' = (R'(x)Q(x)-R(x)Q'(x))/Q(x)^2 int r = 0, q = 0, r_ = 0, q_ = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; r = (r + R[i]) % mod; r_ = (r_ + 1LL * i * R[i] % mod) % mod; q = (q + Q[i]) % mod; q_ = (q_ + 1LL * i * Q[i] % mod) % mod; &#125; int X = ((1LL * r_ * q - 1LL * r * q_) % mod + mod) % mod; int Y = 1LL * q * q % mod; printf("%d\n", int (1LL * X * qpow(Y, mod-2) % mod)); &#125;&#125;int main() &#123; memset(_l, -1, sizeof(_l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int useless_x, useless_y; scanf("%d%d", &amp;useless_x, &amp;useless_y); &#125; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; for (int i = 1; i &lt;= n; i++) &#123; out[i] = qpow(deg[i], mod-2); &#125; BM::init(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102268G] Angle Beats]]></title>
    <url>%2F2020%2F05%2F07%2Fgym102268A%2F</url>
    <content type="text"><![CDATA[ÂêêÊßΩÔºöËøôÈ¢òÁõÆÂêçÂèñÁöÑ„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÂÅöÊ≥ï Ë¶ÅÊòØ‰∏çÊòØÈ¢ÑÂÖàÁü•ÈÅìÊòØ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖç‰º∞ËÆ°‰∏ÄÊòüÊúüÈÉΩÊÉ≥‰∏çÂà∞„ÄÇ„ÄÇ ËÄÉËôëÊûÑÈÄ†‰∏Ä‰∏™Êó†ÂêëÂõæÔºåÁÑ∂ÂêéÁî®‰∏ÄËà¨ÂõæÊúÄÂ§ßÂåπÈÖçÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ ÂØπÊØè‰∏™ . Âª∫‰∏Ä‰∏™ÁÇπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ +ÔºåÈÇ£‰πàÂª∫‰∏§‰∏™Êñ∞ÁöÑÁÇπÔºå‰∏§‰∏™Êñ∞ÁöÑÁÇπÈÉΩÂêëÂÆÉÂõõÂë®ÁöÑ . ÂØπÂ∫îÁöÑÁÇπËøûËæπÔºåÁÑ∂Âêé‰∏§‰∏™Êñ∞ÁÇπ‰πãÈó¥Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Ê†ºÂ≠êÊòØ *ÔºåÂª∫‰∏§‰∏™Êñ∞ÁÇπÔºå‰∏Ä‰∏™Âêë‰∏ä‰∏ãÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°ËæπÔºå‰∏Ä‰∏™ÂêëÂ∑¶Âè≥ÁöÑ . ÂØπÂ∫îÁöÑÁÇπÂêÑËøû‰∏ÄÊù°Ëæπ„ÄÇËøôÊ†∑Ëøô‰∏™ÂõæÁöÑÊúÄÂ§ßÂåπÈÖçÂáèÂéª * Âíå + ÁöÑ‰∏™Êï∞Â∞±ÊòØÁ≠îÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ÁêÜËÆ∫ÂèØ‰ª•ÂÅöÂà∞ \(\mathcal O(n^2m^2)\)ÔºåÂèØËøá„ÄÇ ÁÑ∂ËÄåÊàëÂÜôÁöÑËøô‰∏™Â∏¶Ëä±Ê†ë‰ºº‰πéÊòØ‰∏âÊñπÁöÑÔºå‰ΩÜÂÆÉ‰πüËøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const int maxp = 1000010;const int cx[] = &#123;0, 1, 0, -1&#125;;const int cy[] = &#123;1, 0, -1, 0&#125;;typedef pair&lt;int,int&gt; pi;int r, c, id2x[maxp], id2y[maxp];char buf[maxn][maxn], ans[maxn][maxn];int id1[maxn][maxn], id2[maxn][maxn];int match[maxp], tag[maxp], pre[maxp];int _vis[maxp], tim, qs, qt;vector&lt;pi&gt; vans, vc;int n, l[maxp], e, vis[26], Q[maxp], fa[maxp];struct Edge &#123; int v, x;&#125; E[maxp &lt;&lt; 1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++;&#125;int getroot(int x) &#123; if (!x) return 0; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;int lca(int x, int y) &#123; ++ tim; int cur = getroot(x); while (cur) &#123; _vis[cur] = tim; cur = getroot(pre[match[cur]]); &#125; cur = getroot(y);; while (cur) &#123; if (_vis[cur] == tim) return cur; cur = getroot(pre[match[cur]]); &#125; return 0;&#125;void shrink(int u, int v, int r) &#123; while (getroot(u) != r) &#123; pre[u] = v, v = match[u]; if (u == fa[u]) fa[u] = r; if (v == fa[v]) fa[v] = r; if (tag[v] == 2) &#123; tag[v] = 1; Q[qt++] = v; &#125; u = pre[v]; &#125;&#125;void find(int S) &#123; qs = qt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0, pre[i] = 0, fa[i] = i; Q[qt ++] = S, tag[S] = 1; while (qs &lt; qt) &#123; int u = Q[qs++]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (getroot(v) == getroot(u)) continue; if (!match[v]) &#123; pre[v] = u; int cur = v; while (cur) &#123; match[cur] = pre[cur]; int t = match[pre[cur]]; match[pre[cur]] = cur; cur = t; &#125; return; &#125; if (!tag[v]) &#123; tag[v] = 2, tag[match[v]] = 1; pre[v] = u; Q[qt++] = match[v]; &#125; else if (tag[v] != 2) &#123; int r = lca(u, v); shrink(u, v, r); shrink(v, u, r); &#125; &#125; &#125;&#125;void setvis(int p) &#123; int x = id2x[p], y = id2y[p]; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;void setvis(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + cx[i], ty = y + cy[i]; if (ans[tx][ty] &gt;= 'a' &amp;&amp; ans[tx][ty] &lt;= 'z') &#123; vis[ans[tx][ty] - 'a'] = 1; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;r, &amp;c); for (int i = 1; i &lt;= r; i++) &#123; scanf("%s", buf[i] + 1); for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] == '.') &#123; id1[i][j] = ++ n; id2x[n] = i, id2y[n] = j; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (buf[i][j] != '.') &#123; id1[i][j] = ++ n, id2[i][j] = ++ n; addEdge(id1[i][j], id2[i][j]); if (buf[i][j] == '+') &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); addEdge(id2[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); addEdge(id2[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id1[i][j], id1[i][j-1]); addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id1[i][j], id1[i][j+1]); addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; else &#123; if (i - 1 &gt;= 1 &amp;&amp; buf[i-1][j] == '.') &#123; addEdge(id1[i][j], id1[i-1][j]); &#125; if (i + 1 &lt;= r &amp;&amp; buf[i+1][j] == '.') &#123; addEdge(id1[i][j], id1[i+1][j]); &#125; if (j - 1 &gt;= 1 &amp;&amp; buf[i][j-1] == '.') &#123; addEdge(id2[i][j], id1[i][j-1]); &#125; if (j + 1 &lt;= c &amp;&amp; buf[i][j+1] == '.') &#123; addEdge(id2[i][j], id1[i][j+1]); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!match[i]) &#123; find(i); &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; ans[i][j] = buf[i][j]; if (buf[i][j] != '.') &#123; if (match[id1[i][j]] != id2[i][j]) &#123; if (match[id1[i][j]] &amp;&amp; match[id2[i][j]]) &#123; vc.push_back(pi(i, j)); vans.push_back(pi(match[id1[i][j]], match[id2[i][j]])); &#125; &#125; &#125; &#125; &#125; // cout &lt;&lt; vans.size() &lt;&lt; endl; for (int _ = 0; _ &lt; vans.size(); _++) &#123; for (int i = 0; i &lt; 26; i++) vis[i] = 0; setvis(vans[_].first); setvis(vans[_].second); setvis(vc[_].first, vc[_].second); for (int i = 0; i &lt; 26; i++) &#123; if (!vis[i]) &#123; ans[id2x[vans[_].first]][id2y[vans[_].first]] = 'a' + i; ans[id2x[vans[_].second]][id2y[vans[_].second]] = 'a' + i; ans[vc[_].first][vc[_].second] = 'a' + i; break; &#125; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; puts(ans[i] + 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6210]„ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçtree]]></title>
    <url>%2F2020%2F05%2F07%2Floj6210%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫é‰∏ÄÊù°ÈìæÔºåÂÅáËÆæÂÆÉ‰ªéÊüê‰∏ÄÁ´ØÂºÄÂßãÁ¨¨‰∏Ä‰∏™Â§ß‰∫é \(1\) ÁöÑÁÇπÁöÑÁÇπÊùÉ‰∏∫ \(x\)ÔºåËøô‰∏™ÁÇπ(ÂºÄÂßãÁöÑÈÇ£‰∏ÄÁ´ØÂà∞ÂÆÉ)‰πãÂâçÊúâ \(k\) ‰∏™ÁÇπÔºå‰πãÂêéÊúâ \(l\) ‰∏™ÁÇπÔºå‰πãÂêé \(l\) ‰∏™ÁÇπÁÇπÊùÉ‰πòÁßØ‰∏∫ \(s\)„ÄÇ ÂÅáËÆæËøôÊù°ÈìæÁöÑÁ≠îÊ°àÊØîËøô‰∏™ÁÇπÂ∑¶ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÂíåÂè≥ËæπÁöÑÁÇπÊûÑÊàêÁöÑÈìæÁöÑÁ≠îÊ°àÈÉΩË¶Å‰∏•Ê†º‰ºò„ÄÇ ÈÇ£‰πà \[ \frac {sx} {k + l + 1} &lt; \frac 1 k \Rightarrow k(sx-1) &lt; l+1 \\\\ \frac {sx} {k + l + 1} &lt; \frac s l \Rightarrow l(x-1) &lt; k+1 \] ÊâÄ‰ª• \(k = l\)„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰∏ÄÊù°ÈìæÊØîÂÆÉÁöÑÊâÄÊúâÂ≠êÈìæÈÉΩ‰∏•Ê†º‰ºòÔºå‰∏îËøôÊù°Èìæ‰∏äÂ≠òÂú®ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÔºåÈÇ£‰πà‰ªéÂÆÉ‰∏§Á´ØÂºÄÂßãÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπÊùÉÂ§ß‰∫é \(1\) ÁöÑÁÇπÈÉΩÊòØ‰∏≠ÁÇπ„ÄÇ ÊâÄ‰ª•Âè™ÈúÄËÄÉËôëÂÖ® \(1\) ÈìæÂíå‰ª•Êüê‰∏™ÁÇπ‰∏∫‰∏≠ÁÇπÔºåÂÖ∂‰ªñÁÇπÈÉΩÊòØ \(1\) ÁöÑÈìæ„ÄÇ Êç¢Ê†π dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a%b);&#125;struct frac &#123; int x, y; frac (int a = 0, int b = 0) &#123; int d = gcd(b, a); x = a / d, y = b / d; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x;&#125;frac ans;int n, l[maxn], w[maxn], dp[maxn*2], e;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f, int fa_e) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs1(v, u, p^1); dp[fa_e] = max(dp[fa_e], dp[p^1] + 1); &#125; &#125; if (w[u] != 1) dp[fa_e] = -1;&#125;void dfs2(int u, int f) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x == mx) &#123; dp[p] = cx; &#125; else dp[p] = mx; if (w[u] != 1) dp[p] = -1; int v = E[p].v; if (v != f) dfs2(v, u); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; ans.x = 0x3f3f3f3f, ans.y = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w[i]); &#125; dfs1(1, 0, e); dfs2(1, 0); for (int u = 1; u &lt;= n; u++) &#123; int mx = 0, cx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int x = dp[p^1] + 1; if (x &gt;= mx) &#123; cx = mx; mx = x; &#125; else if (x &gt; cx) &#123; cx = x; &#125; &#125; frac f(w[u], mx + cx + 1); if (f &lt; ans) ans = f; &#125; printf("%d/%d\n", ans.x, ans.y); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trick & Idea Êï¥ÁêÜ]]></title>
    <url>%2F2020%2F05%2F06%2Ftrick%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[[AGC040F] Two Pieces]]></title>
    <url>%2F2020%2F04%2F29%2Fagc040_f%2F</url>
    <content type="text"><![CDATA[Â§™Á•û‰ªô‰∫ÜÔºåÁúã sol ‰∫Ü„ÄÇ ÂÅöÊ≥ï ÂÖàËßÑÂÆöÂΩì‰∏§‰∏™Áü≥Â≠êË∑ùÁ¶ª‰∏∫ \(1\) Êó∂Ôºå‰∏çËÉΩÁßªÂä®ÂùêÊ†áÂ∞èÁöÑÁü≥Â≠ê„ÄÇËøôÊ†∑Â∞±Âè™ÈúÄË¶ÅÂØπÊìç‰ΩúÂ∫èÂàóËÆ°Êï∞‰∫Ü„ÄÇ ËÄÉËôëÂØπÊúâ \(K\) ‰∏™ÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÊñπÊ°àËÆ°Êï∞„ÄÇ\(K = N\) ÁöÑÊÉÖÂÜµÂæàÂÆπÊòìÂçïÁã¨ËÄÉËôë„ÄÇ ÂØπ‰∫é \(K &lt; N\) ÁöÑÊÉÖÂÜµÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÁ°ÆÂÆö‰∫ÜÊääÊüê‰∏™Áü≥Â≠êÁöÑÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÔºåËÄÉËôë‰∏Ä‰∏™Â∫èÂàó \(s\)ÔºåËã•Á¨¨ \(i\) ‰∏™ÊääÊüêÁü≥Â≠êÂùêÊ†á \(+1\) Êìç‰ΩúÁßªÂä®ÁöÑÊòØÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÔºå\(s_i = -1\)ÔºåÂê¶Âàô \(s_i = 1\)„ÄÇËøôÊ†∑ÁöÑ‰∏Ä‰∏™Â∫èÂàó \(s\) ÊòæÁÑ∂Êª°Ë∂≥ \(\forall 1 \le i \le K, \sum_{k=1}^i s_i &gt; 0\)„ÄÇÂØπ‰∫é‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂ∫èÂàó \(s\)ÔºåÊàë‰ª¨Êù•ËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊää‚ÄúÂùêÊ†áÂ∞èÁöÑÁü≥Â≠êÁßªÂä®Âà∞ÂùêÊ†áÂ§ßÁöÑÁü≥Â≠êÁöÑ‰ΩçÁΩÆ‚ÄùÁöÑÊìç‰ΩúÊèíÂÖ•Âà∞Ëøô‰∏™ÔºàÂè™ÂåÖÂê´ÊääÊüêÁü≥Â≠êÂùêÊ†áÂ¢ûÂä† \(1\) ÁöÑÊìç‰ΩúÁöÑÔºâÊìç‰ΩúÂ∫èÂàó‰πã‰∏≠ÁöÑÊñπÊ°à„ÄÇÊòæÁÑ∂ \(s\) ‰∏≠Êúâ \(B\) ‰∏™ \(1\)Ôºå\(K-B\) ‰∏™ \(-1\)„ÄÇÂ¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰ΩúÊèíÂú® \(s_i\) ÂØπÂ∫îÁöÑÊìç‰ΩúÂíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥ÔºåÈÇ£‰πà \(\sum_{k \le i} [s_k = 1]+\sum_{k &gt; i} [s_k = -1] = B-(\sum_{k &gt; i} s_k) = A\)„ÄÇËÆæ \(t_i = \sum_{k \le i} s_k\)„ÄÇÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êìç‰ΩúË¢´ÊèíÂÖ•Âú® \(s_i\) Âíå \(s_{i+1}\) ÂØπÂ∫îÁöÑÊìç‰Ωú‰πãÈó¥Ôºå‰∏îÂ≠òÂú® \(j &gt; i\)Ôºå\(t_j \le t_i\)ÔºåÈÇ£‰πàËøô‰∏™Êìç‰ΩúÂ∫èÂàó‰∏ÄÂÆö‰∏çÂêàÊ≥ï„ÄÇÊâÄ‰ª•ÊúÄÂêé‰∏Ä‰∏™ÊèíÂÖ•ÁöÑÊìç‰Ωú‰∏ÄÂÆöÂú® \(t_i = B-(K-B)-(B-A)=B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥ÔºåÂÖ∂‰ªñÊìç‰ΩúÂøÖÈ°ªÊèíÂÖ•ÊúÄÂêé‰∏Ä‰∏™ \(t_i = x, x \le B+A-K\) ÁöÑÊúÄÂêé‰∏Ä‰∏™ \(s_i\) ‰∏é \(s_{i+1}\) ‰πãÈó¥Ôºå‰∏îÂè™Ë¶ÅÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÂæóÂà∞ÁöÑÂ∞±ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ‰∫éÊòØÈóÆÈ¢òÂ∞±ÂèòÊàê‰∫ÜÊ±ÇÊää \(N-K-1\) ÊãÜÊàê \(B+A-K+1\) ‰∏™ÈùûË¥üÊï¥Êï∞‰πãÂíåÁöÑÊñπÊ°àÊï∞ÔºåËøôÂæàÂÆπÊòìÁî®‰∏Ä‰∏™ÁªÑÂêàÊï∞ËÆ°ÁÆó„ÄÇÊ≥®ÊÑèÂà∞ÂØπ‰∫é‰∏çÂêåÁöÑ \(s\)ÔºåÊèíÂÖ•Êìç‰ΩúÁöÑÊñπÊ°à‰πãÂíå \(K\) ÊúâÂÖ≥ÔºåÊâÄ‰ª•Êàë‰ª¨Êûö‰∏æ \(K\) ÁªüËÆ°Á≠îÊ°àÂç≥ÂèØ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂØπÂ∫îÁöÑ \(K\)ÔºåËÆ°ÁÆóÂØπÂ∫îÁöÑ \(s\) ÁöÑ‰∏™Êï∞ÊòØ‰∏Ä‰∏™Á±ª‰ººÂç°ÁâπÂÖ∞Êï∞ÁöÑÈóÆÈ¢òÔºå‰∏ç‰ºöÁöÑËØùÂèØ‰ª•ÂéªÁúãÁúã AGC021E„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000010;const int mod = 998244353;int N, A, B, ans;int fac[maxn &lt;&lt; 1], ifac[maxn &lt;&lt; 1], inv[maxn &lt;&lt; 1];int binom(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) return 0; if (y &gt; x) return 0; return 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;&#125;int cal(int X, int Y) &#123; return 1LL * (X - Y + 1) * inv[X + 1] % mod * binom(X+Y, X) % mod;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); if (!B) &#123; puts("1"); return 0; &#125; fac[0] = ifac[0] = 1, inv[1] = 1; for (int i = 2; i &lt;= N * 2; i++) &#123; inv[i] = mod - 1LL * inv[mod % i] * (mod / i) % mod; &#125; for (int i = 1; i &lt;= N * 2; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = 1LL * ifac[i-1] * inv[i] % mod; &#125; if (A != B &amp;&amp; A + B == N) &#123; ans = cal(B-1, A); &#125; for (int K = B; K &lt; N; K++) &#123; int v1 = 0, v2 = 0; v1 = cal(B-1, K-B); v2 = binom(N-K-1+B+A-K+1-1, B+A-K+1-1); ans = (ans + 1LL * v1 * v2 % mod) % mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC041E] Balancing Network]]></title>
    <url>%2F2020%2F04%2F29%2Fagc041_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ balancer \((x_i,y_i)\)ÔºåÂ∞±Âú®ÁÇπ \(x_i\) ÂíåÁÇπ \(y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Ê†áÂè∑‰∏∫ \(i\) ÁöÑÊó†ÂêëËæπ„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö\(T=1\) ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëÊâÄÊúâË¢´Áî®Ëøá balancerÔºåÂèØ‰ª•ÂèëÁé∞ÂÆÉ‰ª¨ÂØπÂ∫îÁöÑËæπÊûÑÊàêÁöÑÂ≠êÂõæ‰∏ÄÂÆöÊòØ \(G\) ÁöÑ‰∏ÄÊ£µÁîüÊàêÊ†ëÔºå‰∏îÂ¶ÇÊûúÊääÊúÄÂêéÁªàÊ≠¢ÁöÑ wire ‰Ωú‰∏∫Ê†πÔºåÊØè‰∏™ÁÇπÂà∞ÂÆÉÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÈÉΩÂ∞è‰∫éÂÆÉÁà∂‰∫≤Âà∞ÂÆÉÁà∂‰∫≤ÁöÑÁà∂‰∫≤ÁöÑËæπÁöÑÊ†áÂè∑ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ„ÄÇÂèçËøáÊù•ÔºåÂÆπÊòìÈ™åËØÅÂ¶ÇÊûúÂ≠òÂú®‰∏ÄÊ£µËøôÊ†∑ÁöÑÁîüÊàêÊ†ëÔºåÈÇ£‰πà‰πüÂ≠òÂú®‰∏ÄÁßçÂêàÊ≥ïÊñπÊ°à„ÄÇ Êää balancer ‰Ωú‰∏∫ÁÇπÂª∫‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂ¶ÇÊûú balancer \(i,j\) ÈÉΩËøûÊé•‰∫ÜÊüê‰∏™ wireÔºå‰∏î \(i &lt; j\)ÔºåÂ∞±‰ªé \(j\) Âà∞ \(i\) Ëøû‰∏ÄÊù°Ëæπ„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÂêàÊ≥ïÊñπÊ°àÔºå‰∏ÄÂÆöÂèØ‰ª•‰ªéËøô‰∏™Âõæ‰∏äÊüê‰∏™ÁÇπÂá∫ÂèëÔºåÂà∞Ëææ‰∏éÊØè‰∏™ wire Áõ∏ËøûÁöÑËá≥Â∞ë‰∏Ä‰∏™ balancer„ÄÇÂèçËøáÊù•ÔºåÂ¶ÇÊûúÂ≠òÂú®ËøôÊ†∑‰∏Ä‰∏™ÁÇπÔºåÊàë‰ª¨‰ªéËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancer ÂºÄÂßãÔºåÊåâÁºñÂè∑‰ªéÂ§ßÂà∞Â∞èËÄÉËôëÊØè‰∏™ balancer„ÄÇÁª¥Êä§‰∏Ä‰∏™ balancer ÁöÑÈõÜÂêàÔºåÂàùÂßãÊó∂Âè™ÊúâËøô‰∏™ÁÇπÂØπÂ∫îÁöÑ balancerÔºåËÄÉËôëÂà∞‰∏Ä‰∏™ balancer Êó∂ÔºåÂ¶ÇÊûúÂÆÉËøûÊé•ÁöÑ‰∏Ä‰∏™ wire ÊòØÂΩìÂâçÁª¥Êä§ÁöÑÈõÜÂêà‰∏≠Êüê‰∏™ balancer ÁöÑÁ´ØÁÇπÔºåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÂ∞±ÊääËøô‰∏™ balancer Âä†ÂÖ•ÈõÜÂêà„ÄÇÊúÄÂêéÂæóÂà∞ÁöÑÈõÜÂêàÊòæÁÑ∂ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÁîüÊàêÊ†ë„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑ balancerÔºåÁÑ∂ÂêéÁî®‰ª•‰∏äÁÆóÊ≥ïÊûÑÈÄ†Âç≥ÂèØ„ÄÇ‰ºòÂåñ‰∏Ä‰∏ãÂª∫ËæπÔºåÊàë‰ª¨ÂèØ‰ª•ÂØπÊØè‰∏™ wireÔºåÊää‰∏éÂÆÉÁõ∏ÈÇªÁöÑ balancer ÊéíÂ∫èÔºåÂè™ËÄÉËôëÁõ∏ÈÇªÁöÑ balancer ‰πãÈó¥ÁöÑÊúâÂêëËæπ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ DAG ‰∏ä DP ÈóÆÈ¢òÔºåÁõ¥Êé•ÂÅöÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(nm)\)ÔºåÁî® bitset ‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ËÉΩËøá‰∫Ü„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÔºö\(T=2\) ÂΩì \(n \ge 3\) Êó∂Ôºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØèÊù°ËæπÔºåÂèØ‰ª•ÂèëÁé∞ÊÄªÂ≠òÂú®‰∏ÄÁßçÊñπÊ°à‰ΩøÊâÄÊúâ wire ÊúÄÁªà‰∏çÊ±áËÅöÂú®Âêå‰∏Ä‰∏™ÁÇπ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;const int maxm = 100010;int n, m, T;vector&lt;int&gt; vec[maxn], G[maxm];int ex[maxm], ey[maxm];char str[maxm];namespace Subtask1 &#123; int vis[maxn]; bitset&lt;maxn&gt; dp[maxm]; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j + 1 &lt; vec[i].size(); j++) &#123; G[vec[i][j+1]].push_back(vec[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[i][ex[i]] = dp[i][ey[i]] = 1; &#125; int ok = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; int v = G[i][j]; dp[i] |= dp[v]; &#125; if (dp[i].count() == n) &#123; ok = i; &#125; &#125; if (!ok) &#123; puts("-1"); exit(0); &#125; vis[ex[ok]] = vis[ey[ok]] = ok; for (int i = ok - 1; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (vis[x] &amp;&amp; !vis[y]) &#123; vis[y] = i; str[i] = '^'; &#125; else if (vis[y] &amp;&amp; !vis[x]) &#123; vis[x] = i; str[i] = 'v'; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (str[i] == '\0') &#123; if (vis[ex[i]] &lt; vis[ey[i]]) &#123; str[i] = 'v'; &#125; else str[i] = '^'; &#125; &#125; puts(str+1); &#125;&#125;namespace Subtask2 &#123; void solve() &#123; if (n == 2) &#123; puts("-1"); exit(0); &#125; int to[4]; to[1] = 1, to[2] = 2, to[3] = 3; for (int i = m; i &gt;= 1; i--) &#123; int x = ex[i], y = ey[i]; if (x &lt;= 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else if (x &gt; 3 &amp;&amp; y &lt;= 3) &#123; str[i] = 'v'; &#125; else if (x &gt; 3 &amp;&amp; y &gt; 3) &#123; str[i] = '^'; &#125; else &#123; if (to[x] == to[y]) &#123; str[i] = '^'; &#125; else &#123; int z = 0; for (int j = 1; j &lt;= 3; j++) &#123; if (j != x &amp;&amp; j != y) &#123; z = j; &#125; &#125; if (to[x] == to[z]) &#123; str[i] = 'v'; to[x] = to[y]; &#125; else &#123; str[i] = '^'; to[y] = to[x]; &#125; &#125; &#125; puts(str + 1); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;ex[i], &amp;ey[i]); vec[ex[i]].push_back(i), vec[ey[i]].push_back(i); &#125; if (T == 1) Subtask1::solve(); else Subtask2::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC027F] Grafting]]></title>
    <url>%2F2020%2F04%2F24%2Fagc027_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁâπÂà§Êéâ‰∏§Ê£µÊ†ë‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊÉÖÂÜµ„ÄÇ Êûö‰∏æÁ¨¨‰∏Ä‰∏™Êìç‰ΩúÁöÑÁÇπÂèäÂÖ∂Êìç‰ΩúÊñπÂºèÔºåËÆæËøô‰∏™ÁÇπ‰∏∫ \(r\)„ÄÇÊàë‰ª¨ËÄÉËôëËøõË°åÂÆåÁ¨¨‰∏ÄÊ¨°Êìç‰ΩúÂêéÁöÑ‰∏§Ê£µÊ†ë„ÄÇ ËÆæÁ¨¨‰∏ÄÊ£µÊ†ë‰∏∫ \(T_A\)ÔºåÁ¨¨‰∫åÊ£µÊ†ë‰∏∫ \(T_B\)ÔºåÊää \(r\) ‰Ωú‰∏∫‰∏§Ê£µÊ†ëÁöÑÊ†π„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âú®ÊúâÊ†πÊ†ë‰∏äËÄÉËôëÈóÆÈ¢ò„ÄÇ ÂÅáËÆæÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°à‰∏≠Ôºå‰Ω†Âú®Êüê‰∏™Êó∂ÂàªÊääÁÇπ \(u\) ÊüìÈªëÂπ∂Êé•Âà∞ÁÇπ \(v\)ÔºåÈÇ£‰πàÂú®Ëøô‰πãÂêé \(v\) ‰ª•ÂèäÂÖ∂Á•ñÂÖà‰∏ÄÂÆöÈÉΩ‰∏çÂèØËÉΩÊòØÂè∂Â≠êÔºåÊâÄ‰ª•Ê≠§Êó∂ \(T_A\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑÁ≠â‰∫é \(T_B\) ‰∏ä \(u\) Âà∞Ê†πÁöÑË∑ØÂæÑ„ÄÇÂõ†Ê≠§ \(v\) ÂøÖÈ°ªÊòØ \(u\) Âú® \(T_B\) ‰∏äÁöÑÁà∂‰∫≤„ÄÇ Â¶ÇÊûú‰∏Ä‰∏™ÁÇπÂàùÂßãÊó∂Âà∞Ê†πÁöÑË∑ØÂæÑÔºàÁªèËøáÁöÑÁÇπÁöÑÂ∫èÂàóÔºâÂú®‰∏§Ê£µÊ†ë‰∏ä‰∏çÂêåÔºåÊàë‰ª¨Áß∞ÂÆÉ‰∏∫‰∏çÂ•ΩÁöÑÔºåÂê¶ÂàôÊàë‰ª¨Áß∞ÂÆÉ‰∏∫Â•ΩÁöÑ„ÄÇÊòæÁÑ∂Êàë‰ª¨‰∏ç‰ºöÊüìÈªëÂ•ΩÁöÑÁÇπÔºåËÄå‰∏çÂ•ΩÁöÑÁÇπÂøÖÈ°ªË¶ÅË¢´ÊüìÈªë„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËß£ÂÜ≥ÂèØË°åÊÄßÈóÆÈ¢ò„ÄÇ ‰∫ãÂÆû‰∏äÔºåÂ≠òÂú®‰∏Ä‰∏™ÂêàÊ≥ïÊñπÊ°àÁ≠â‰ª∑‰∫éÂ≠òÂú®‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÁöÑÊéíÂàóÔºå‰ΩøÂæóÔºö - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_A\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂâç„ÄÇ - ‰ªªÊÑè‰∏Ä‰∏™‰∏çÂ•ΩÁöÑÁÇπÂú® \(T_B\) ‰∏äÁöÑÊâÄÊúâÂÑøÂ≠êÈÉΩÊéíÂú®ÂÆÉ‰πãÂêé„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÊòØÂê¶Â≠òÂú®ÊãìÊâëÂ∫èÁöÑÈóÆÈ¢òÔºåÂà§‰∏Ä‰∏ã DAG Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(Tn^3)\)„ÄÇÁî±‰∫éÊàëÊáíÂÜô‰∫Ü \(\mathcal O(Tn^4)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int T, n;int E1[maxn][maxn], E2[maxn][maxn], E[maxn][maxn], deg[maxn];int tag[maxn], _deg[maxn], _E1[maxn][maxn], _E2[maxn][maxn];void dfs_tag(int u, int f) &#123; tag[u] = 1; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; E2[u][v] &amp;&amp; v != f) &#123; dfs_tag(v, u); &#125; &#125;&#125;void dfs1(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E1[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[u][v]; ++ deg[v]; &#125; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int v = 1; v &lt;= n; v++) &#123; if (E2[u][v] &amp;&amp; v != f) &#123; if (!tag[u]) &#123; ++ E[v][u]; ++ deg[u]; &#125; dfs2(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); while (T --) &#123; int ans = 0x3f3f3f3f; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; _E1[i][j] = _E2[i][j] = 0; &#125; _deg[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E1[u][v] = _E1[v][u] = 1; ++ _deg[u], ++ _deg[v]; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); _E2[u][v] = _E2[v][u] = 1; &#125; int dif = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (_E1[i][j] != _E2[i][j]) &#123; dif = 1; &#125; &#125; &#125; if (!dif) &#123; puts("0"); continue; &#125; for (int s = 1; s &lt;= n; s++) &#123; if (_deg[s] != 1) continue; int f = 0; for (int i = 1; i &lt;= n; i++) if (_E1[s][i]) f = i; for (int t = 1; t &lt;= n; t++) &#123; if (t == s) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; E[i][j] = 0; E1[i][j] = _E1[i][j]; E2[i][j] = _E2[i][j]; &#125; deg[i] = 0; &#125; E1[s][f] = E1[f][s] = 0, E1[s][t] = E1[t][s] = 1; int cnt = 0; for (int i = 1; i &lt;= n; i++) tag[i] = 0; dfs_tag(s, 0); for (int i = 1; i &lt;= n; i++) if (tag[i]) ++ cnt; dfs1(s, 0), dfs2(s, 0); queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) &#123; if (!tag[i] &amp;&amp; !deg[i]) Q.push(i); &#125; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int v = 1; v &lt;= n; v++) &#123; if (E[u][v]) &#123; deg[v] -= E[u][v]; if (!deg[v]) Q.push(v); &#125; &#125; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (!tag[i] &amp;&amp; deg[i]) ok = 0; if (ok) ans = min(ans, n - cnt); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans + 1); else puts("-1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC040E] Prefix Suffix Addition]]></title>
    <url>%2F2020%2F04%2F24%2Fagc040_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂØπ‰∫éÁªôÂÆöÁöÑÂ∫èÂàó \(a\)ÔºåÊàë‰ª¨ÊääÂÆÉÊãÜÊàê‰∏§‰∏™ÈùûË¥üÂ∫èÂàó \(x\) Âíå \(y\) ÁöÑÂíå„ÄÇÁÑ∂Âêé‰ªÖÁî®‰∏çÂáèÂ∫èÂàóÂéªÂæóÂà∞ \(x\)Ôºå‰ªÖÁî®‰∏çÂ¢ûÂ∫èÂàóÂæóÂà∞ \(y\)„ÄÇ ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫éÈïø‰∏∫ \(k\) Â∫èÂàó \(a\) (ÂÆö‰πâ \(a_0 = a_{k+1} = 0\))ÔºåÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂâçÁºÄ‰∏çÂáèÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=1}^n [a_{i+1} &lt; a_i]\)ÔºõÊääÂÆÉÊãÜÊàêËã•Âπ≤ÂêéÁºÄ‰∏çÂ¢ûÂ∫èÂàóÁöÑÂíåÔºåÊúÄÂ∞è‰∏™Êï∞‰∏∫ \(\sum_{i=0}^{n-1} [a_{i+1} &gt; a_i]\)„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Âà∞‰∏Ä‰∏™Ë¥™ÂøÉÔºåËÄÉËôë \(i\) ‰ªéÂ∞èÂà∞Â§ßÂú∞ÂÜ≥ÂÆö \(x\) Âíå \(y\) ÁöÑÁ¨¨ \(i\) È°πÔºåÁÑ∂Âêé‰ΩøÂæóÂâç \(i\) È°π \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Â∞ΩÂèØËÉΩÂ∞è„ÄÇÁÑ∂ËÄåÁõ¥Êé•Ë¥™ÂøÉÊòØ‰∏çÂØπÁöÑ„ÄÇÊ≥®ÊÑèÂà∞ÔºåÂØπ‰∫é‰∏§Áßç \(\sum_{i=1}^n [x_{i+1} &lt; x_i] + \sum_{i=0}^{n-1} [y_{i+1} &gt; y_i]\) Áõ∏Á≠âÁöÑÊñπÊ°àÔºå\(x_i\) ËæÉÂ∞èÁöÑ‰∏ÄÂÆöÊØîËæÉ‰ºòÔºåËÄå‰∏îÂ¶ÇÊûúÂâç \(i\) È°π‰∏Ä‰∏™ÊñπÊ°àÁöÑ‰ª£‰ª∑ÊØîÂâç \(i\) È°πÊúÄÂ∞è‰ª£‰ª∑ÊñπÊ°àÁöÑ‰ª£‰ª∑ËøòË¶ÅÂ§ßË∂ÖËøá \(2\)ÔºåÂÆÉ‰∏ÄÂÆö‰∏ç‰ºò„ÄÇÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊàë‰ª¨ÂèØ‰ª•Âè™‰øùÁïô‰∏â‰∏™ÊñπÊ°àÔºå‰ΩøÂæóÂÖ∂‰∏≠‰∏ÄÂÆöÊúâ‰∏Ä‰∏™Âú®‰πãÂêéÂèØ‰ª•ÂèòÊàêÊúÄ‰ºòÊñπÊ°à„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, a[maxn];vector&lt;pi&gt; cal(int lasta, int lastb, int s, int _) &#123; vector&lt;pi&gt; ret; // ÂÖàÂà§Êñ≠ÊòØÂê¶ÂèØËÉΩ‰∏çÂ¢ûÂä† // x &gt;= lasta, s - x &lt;= lastb // x &gt;= lasta, x &gt;= s - lastb; if (max(lasta, s - lastb) &lt;= s) ret.push_back(make_pair(_, max(lasta, s - lastb))); // ÂÜçÂà§Êñ≠Âè™Â¢ûÂä†‰∏ÄÈ°πÔºåx ÁöÑÊúÄÂ∞èÂÄºÔºàÊòæÁÑ∂ÂèØ‰ª•Âè™Â¢ûÂä†‰∏ÄÈ°πÔºâ ret.push_back(pi(_ + 1, max(0, min(lasta, s - lastb)))); ret.push_back(pi(_ + 2, 0)); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); pi mn0(0, 0), mn1(0, 0), mn2(0, 0); for (int i = 1; i &lt;= n+1; i++) &#123; vector&lt;pi&gt; v0 = cal(mn0.second, a[i-1] - mn0.second, a[i], mn0.first); vector&lt;pi&gt; v1 = cal(mn1.second, a[i-1] - mn1.second, a[i], mn1.first); vector&lt;pi&gt; v2 = cal(mn2.second, a[i-1] - mn2.second, a[i], mn2.first); vector&lt;pi&gt; ch; ch.insert(ch.end(), v0.begin(), v0.end()); ch.insert(ch.end(), v1.begin(), v1.end()); ch.insert(ch.end(), v2.begin(), v2.end()); sort(ch.begin(), ch.end()); int mn = ch[0].first; pi nmn0(0x3f3f3f3f, 0), nmn1(0x3f3f3f3f, 0), nmn2(0x3f3f3f3f, 0); for (int i = 0; i &lt; ch.size(); i++) &#123; if (ch[i].first == mn) nmn0 = min(nmn0, ch[i]); else if (ch[i].first == mn + 1) nmn1 = min(nmn1, ch[i]); else if (ch[i].first == mn + 2) nmn2 = min(nmn1, ch[i]); &#125; mn0 = nmn0, mn1 = nmn1, mn2 = nmn2; &#125; printf("%d\n", mn0.first); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019F] Yes or No]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏çÂ¶®ÂÅáËÆæ \(n \ge m\)„ÄÇ Âè™‰ºö \(\mathcal O(n \log^2 n)\) Ëá™Èó≠‰∫ÜÔºåÂéªÁúãÈ¢òËß£‰∫Ü„ÄÇ Áî±‰∫é‰Ω†ÁöÑÂÜ≥Á≠ñ‰∏ç‰ºöÂΩ±Âìç‰πãÂêéÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°àÔºåÊâÄ‰ª•ÊòæÁÑ∂ÊØèÊ¨°ÈÄâÊ¶ÇÁéáÂ§ßÁöÑÂ∞±ÊØîËæÉÂ•Ω„ÄÇ ËÆæÁ¨¨ \(k+1\) ‰∏™ÈóÆÈ¢òËÉΩÂ§üÁ≠îÂØπÁöÑÊ¶ÇÁéá‰∏∫ \(p_k\)ÔºåÂÅáËÆæÂâç \(k\) ‰∏™ÈóÆÈ¢ò‰∏≠Á≠îÂØπ‰∫Ü \(a\) ‰∏™ÔºåÈÇ£‰πà \[p_k = \sum_{a \le k} \binom k a \binom{n+m-k}{n-a} \frac{\max\{n-a, m-(k-a)\}}{n+m-k}\] ÂàÜ‰∏∫ \(n - a &lt; m - (k - a)\) Âíå \(n-a \ge m - (k - a)\) ËÆ°ÁÆóË¥°ÁåÆ„ÄÇ ËÆæ \(F(n,m,x,y) = \binom {x+y} x \binom{n+m-x-y}{n-x},G(n,m,s,x) =\sum_{i \le x} F(n,m,i,s-i),H(n,m,s,x) =\sum_{i &gt; x} F(n,m,i,s-i)\)„ÄÇ Á¨¨‰∏ÄÈÉ®ÂàÜÔºö \(n - a &lt; m - (k - a) \Leftrightarrow 2a &gt; n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{n-m+k &lt; 2a \le k} \binom k a \binom {n+m-k}{m-k+a} \frac{m-k+a}{n+m-k} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+m-k-1}{m-k+a-1} \\\\ =\sum_{2a &gt; n-m+k} \binom k a \binom {n+(m-1)-k}{n-a} \\\\ =H(n,m-1,k,\lfloor \frac {n-m+k} 2\rfloor) \] Á¨¨‰∫åÈÉ®ÂàÜ \(n - a \ge m - (k - a) \Leftrightarrow 2a \le n-m+k\) Ëøô‰∏ÄÈÉ®ÂàÜÂØπ \(p_k\) Ë¥°ÁåÆ‰∏∫ \[ \sum_{2a \le n-m+k} \binom k {a} \binom {n+m-k}{n-a} \frac{n-a}{n+m-k} \\\\ =\sum_{2a \le n-m+k} \binom k a \binom {(n-1)+m-k}{n-1-a} \\\\ =G(n-1,m,k,\lfloor \frac {n-m+k}2 \rfloor) \] Âø´ÈÄüËÆ°ÁÆó \(H,G\) ÁöÑÊÑè‰πâÊòØÊúâÂ§öÂ∞ëÊù°‰ªé \((0,0)\) Âà∞ \((n,m)\) ÁöÑÈùûÈôçË∑ØÂæÑ‰∏éÁõ¥Á∫ø \(x+y = s\) ÁöÑ‰∫§ÁÇπÁöÑÊ®™ÂùêÊ†áÂú®Êüê‰∏™ËåÉÂõ¥ÂÜÖ„ÄÇ Áî±Ëøô‰∏™ÁªÑÂêàÊÑè‰πâÂæàÂÆπÊòìÂæóÂá∫ \[ H(n,m,k+1,l) - H(n,m,k,l) = \binom{k}{l}\binom{n+m-k-1}{n-l-1} \] \[ G(n,m,k+1,l) - G(n,m,k,l) = -\binom{k}{l}\binom{n+m-k-1}{n-l-1} \] ÊâÄ‰ª•Êàë‰ª¨‰ªéÂ∞èÂà∞Â§ßÊûö‰∏æ \(k\) Á∫øÊÄßÁª¥Êä§ \(H\) Âíå \(G\) ÈúÄË¶ÅÁî®Âà∞ÁöÑÂÄºÔºåÂ∞±Âú® \(\mathcal O(n)\) ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;const int mod = 998244353;int n, m, s, ans;int fac[maxn&lt;&lt;1], ifac[maxn&lt;&lt;1], inv[maxn&lt;&lt;1], pw[maxn&lt;&lt;1];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;int binom(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int cal(int k) &#123; if (k &gt;= 0) return pw[k]; else return 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); s = n + m; if (n &lt; m) swap(n, m); fac[0] = ifac[0] = inv[1] = pw[0] = 1; for (int i = 2; i &lt;= s; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod; for (int i = 1; i &lt;= s; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * inv[i] * ifac[i-1] % mod, pw[i] = 2 * pw[i-1] % mod; int h = 0, g = binom(n + m - 1, n - 1); for (int k = 0; k &lt; s; k++) &#123; ans = (ans + h) % mod; ans = (ans + g) % mod; int l = (n - m + k) / 2; h = ( h + 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - l - 1 ) % mod ) % mod; g = ( g + mod - 1LL * binom( k, l ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; if ( (n - m + k + 1) / 2 &gt; (n - m + k) / 2 ) &#123; h = (h + mod - 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - l - 1) % mod ) % mod; g = (g + 1LL * binom( k + 1, l + 1 ) * binom( n + m - 1 - k - 1, n - 1 - l - 1 ) % mod ) % mod; &#125; &#125; ans = 1LL * ans * qpow(binom(n + m, n), mod - 2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC019E] Shuffle and Swap]]></title>
    <url>%2F2020%2F04%2F23%2Fagc019_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôë‰∏Ä‰∏™Êó†ÂêëÂõæ \(G\)ÔºåÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∫§Êç¢ÔºåÂ¶ÇÊûú‰∫§Êç¢ÁöÑÊòØ \(a_i\) Âíå \(a_j\)ÔºåÂú®ÁÇπ \(i\) ÂíåÁÇπ \(j\) ‰πãÈó¥Ëøû‰∏ÄÊù°ËæπÔºåÊ†áÂè∑‰∏∫ \(i\)„ÄÇ ËÆæ \(S_1\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_2\) ÊòØÊâÄÊúâ‰∏§‰∏™Â∫èÂàó‰∏≠ÈÉΩÊòØ \(1\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêàÔºå\(S_3\) ÊòØÊâÄÊúâÁ¨¨‰∏Ä‰∏™Â∫èÂàó‰∏≠ÊòØ \(1\) Á¨¨‰∫å‰∏™Â∫èÂàó‰∏≠ÊòØ \(0\) ÁöÑ‰ΩçÁΩÆÁöÑÈõÜÂêà„ÄÇ \(S_1\) Âíå \(S_3\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(1\)Ôºå\(S_2\) ‰∏≠ÁÇπÂ∫¶Êï∞ÈÉΩÊòØ \(2\)„ÄÇ‰∏çÈöæËØÅÊòéÔºåÂ¶ÇÊûúÊúÄÁªà‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ \(G\) ÁöÑ‰∏Ä‰∏™ËøûÈÄöÂùóË¶Å‰πàÊòØ‰∏ÄÊù° \(S_1\) ‰∏≠ÁÇπÂà∞ \(S_3\) ‰∏≠ÁÇπÁöÑË∑ØÂæÑÔºåË¶Å‰πàÊòØ‰∏Ä‰∏™ \(S_2\) ÂÜÖÈÉ®ÁöÑÁéØ„ÄÇ ËÄÉËôëÂØπËÉΩ‰Ωø‰∏§‰∏™Â∫èÂàóÂèòÂæó‰∏ÄÊ†∑ÁöÑÂõæÁöÑÂΩ¢ÊÄÅÂíåËæπÁöÑÊ†áÂè∑ËÆ°Êï∞ÔºåÈÇ£‰πàÔºåÂØπ‰∫é‰∏Ä‰∏™Âõ∫ÂÆöÁöÑÂõæ \(G\)Ôºå‰∏Ä‰∏™ÁéØ‰∏äÁöÑÊ†áÂè∑È°∫Â∫èÊòØÊó†ÊâÄË∞ìÁöÑÔºå‰∏ÄÊù°ÈìæÊ†áÂè∑‰∏ÄÂÆöÊòØ‰ªé \(S_1\) ‰∏Ä‰æßÂà∞ \(S_3\) ‰∏Ä‰æßÈÄíÂ¢û„ÄÇÊâÄ‰ª•Â¶ÇÊûúÂÜ≥ÂÆö‰∫Ü \(G\)ÔºåÂèØ‰ª•ÂÖàÂÜ≥ÂÆöÊØè‰∏™ËøûÈÄöÂùóÁöÑËæπÁî®Âì™‰∫õÊ†áÂè∑ÔºåÁÑ∂ÂêéÂØπ‰∫éÁéØÂèØ‰ª•‰ªªÊÑèÊéíÂàóÔºåÈìæÂè™Êúâ‰∏ÄÁßçÊ†áÂè∑ÊñπÂºè„ÄÇ ËÄÉËôëÂÜ≥ÂÆö \(S_2\) ‰∏≠ÁöÑÂõæÁöÑÁªìÊûÑÔºåÊàë‰ª¨ÂèØ‰ª•ÂÜôÂá∫ÁéØÂíåÈìæÁöÑ EGFÔºå\(C(x)\) Âíå \(P(x)\)„ÄÇ \(C(x) = \exp(\sum_{k \ge 1} (k-1)!k! \frac {x^k}{k!k!})= \exp(-\ln(1-x)) = \frac 1 {1-x}\) \(P(x) = \sum_{k \ge 0} k!\frac{x^k}{k!(k+1)!}=\frac 1 x \sum_{k \ge 0} \frac {x^{k+1}}{(k+1)!}=\frac{e^x-1}x\) È¢òÁõÆ‰∏≠Ë¶ÅÊ±ÇÁöÑÂç≥ÊòØ \(\lvert S_1 \rvert!\lvert S_2 \rvert!(\lvert S_1 \rvert + \lvert S_2 \rvert)![x^{\lvert S_2 \rvert}](P(x)^{\lvert S_1 \rvert}C(x))\)„ÄÇ NTT ‰∏Ä‰∏ãÂç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇÔºàÂÖ∂ÂÆûÁõ¥Êé•ÂÜô‰∏äÁ≥ªÊï∞Â∞±ÊòØ‰∫ÜÔºåÂâçÈù¢Êé®ÁöÑÂÆåÂÖ®Áî®‰∏çÂà∞...Ôºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10010;const int mod = 998244353;const int g = 3;int n, c1, c2, c3, fac[maxn], ifac[maxn];char A[maxn], B[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % mod; x = 1ll * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[len]; for (int i = 0; i &lt; len; i++) &#123; a[i] = 0; &#125; &#125;&#125;;int wa[maxn&lt;&lt;2], wb[maxn&lt;&lt;2], wc[maxn&lt;&lt;2], rev[maxn&lt;&lt;2];void ntt(int *a, int _l, int ty) &#123; int len = (1 &lt;&lt; _l); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (_l - 1)); for (int i = 0; i &lt; len; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wl = qpow(g, (mod - 1) / l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = 0; i &lt; (l &gt;&gt; 1); i++) &#123; int v1 = a[s + i], v2 = 1LL * w * a[s + i + (l &gt;&gt; 1)] % mod; a[s + i] = (v1 + v2) % mod; a[s + i + (l &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL * w * wl % mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL * a[i] * inv % mod; for (int i = 1; i &lt; len - i; i++) swap(a[i], a[len - i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1 &lt;&lt; l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1), ntt(wb, l, 1); for (int i = 0; i &lt; (1 &lt;&lt; l); i++) wc[i] = 1LL * wa[i] * wb[i] % mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; ret.len = min(ret.len, c2+1); return ret;&#125;poly qpow(poly p, int k) &#123; poly ret(1); ret.a[0] = 1; while (k) &#123; if (k &amp; 1) ret = ret * p; p = p * p; k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; scanf("%s", A+1); scanf("%s", B+1); n = int (strlen (A+1)); for (int i = 1; i &lt;= n; i++) &#123; if (A[i] == '1' &amp;&amp; B[i] == '0') ++ c1; if (A[i] == '1' &amp;&amp; B[i] == '1') ++ c2; if (A[i] == '0' &amp;&amp; B[i] == '1') ++ c3; &#125; fac[0] = ifac[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; fac[i] = 1LL * fac[i-1] * i % mod; ifac[i] = qpow(fac[i], mod-2); &#125; poly C(c2+1), P(c2+1); for (int i = 0; i &lt;= c2; i++) C.a[i] = 1; for (int i = 0; i &lt;= c2; i++) P.a[i] = ifac[i+1]; poly res = qpow(P, c1) * C; printf("%d\n", int (1LL * fac[c1] * fac[c2] % mod * fac[c1 + c2] % mod * res.a[c2] % mod)); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016F] Games on DAG]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_f%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂêêÊßΩÔºö‰∏∫Âï•ËøôÁßçÊ≤°Âï•ÊÑèÊÄùÁöÑÈ¢ò‰ºöÊòØ agc ÁöÑ F È¢ò„ÄÇ Ëøô‰∏™Ê∏∏ÊàèÊòØ‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÁöÑÂíåÔºåÊâÄ‰ª•Âè™Ë¶Å‰ªé \(1\) ÂºÄÂßãÁöÑÊ∏∏ÊàèÂíå‰ªé \(2\) ÂºÄÂßãÁöÑÊ∏∏Êàè SG ÂÄº‰∏ç‰∏ÄÊ†∑Â∞±Ë°å„ÄÇ ËÄÉËôëÊåâ \(SG\) ÂÄº \(dp\)Ôºå\(dp_{S}\) Ë°®Á§∫ÈõÜÂêà \(S\) ‰∏≠‰ªª‰ΩïÁöÑÁÇπ SG ÂÄºÈÉΩÊØî \(S\) Â§ñ‰ªª‰ΩïÁÇπÊ∂àÔºåËá≥Â∞ë‰∏ÄÁ´ØÂú® \(S\) ‰∏≠ÁöÑËæπÁöÑÊñπÊ°àÊï∞„ÄÇ ËΩ¨ÁßªÂ∞±ÊòØÊûö‰∏æ SG ‰∏∫ \(S\) ‰∏≠ÊúÄÂ§ß SG ÂÄºÂä†‰∏ÄÁöÑÁÇπÁöÑÈõÜÂêàÔºåÁÑ∂ÂêéËøô‰∏™ÈõÜÂêàÂÜÖÈÉ®ÊâÄÊúâËæπÈÉΩ‰∏çÈÄâÔºåÊâÄÊúâ‰∏çÂú®Ëøô‰∏™ÈõÜÂêàÂÜÖ‰πü‰∏çÂú® \(S\) ÂÜÖÁöÑÁÇπÂà∞Ëøô‰∏™ÈõÜÂêàËá≥Â∞ëÊúâ‰∏ÄÊù°ËæπÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞ÔºõËøô‰∏™ÈõÜÂêàÂà∞‰∏çÂú®Ëøô‰∏™ÈõÜÂêà‰∏≠‰πü‰∏çÂú® \(S\) ‰∏≠ÁöÑÁÇπÁöÑËæπÂèØÈÄâÂèØ‰∏çÈÄâÔºå‰πò‰ª•‰∏Ä‰∏™Á≥ªÊï∞„ÄÇÊ≥®ÊÑè \(1,2\) ‰∏çËÉΩÂêåÊó∂Âú®Ëøô‰∏™ÈõÜÂêà„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n3^n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;const int mod = 1e9+7;int n, m;int out[maxn], in[maxn], sz[1&lt;&lt;maxn];int dp[1&lt;&lt;maxn];int lowbit(int x) &#123;return x &amp; (-x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; (1&lt;&lt;n); i++) sz[i] = sz[i ^ lowbit(i)] + 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); -- x, -- y; out[x] ^= (1&lt;&lt;y), in[y] ^= (1&lt;&lt;x); &#125; dp[0] = 1; for (int mask = 1; mask &lt; (1&lt;&lt;n); ++ mask) &#123; for (int s = mask; s; s = (s - 1) &amp; mask) &#123; if ((s &amp; 1) &amp;&amp; (s &amp; 2)) continue; int t = dp[mask ^ s]; for (int i = 0; i &lt; n; i++) &#123; if (s &amp; (1&lt;&lt;i)) &#123; t = 1LL * t * (1&lt;&lt;(sz[out[i] &amp; (~ mask)])) % mod; &#125; else if (!(mask &amp; (1&lt;&lt;i))) &#123; t = 1LL * t * ((1&lt;&lt;sz[s &amp; out[i]]) - 1) % mod; &#125; &#125; dp[mask] = (dp[mask] + t) % mod; &#125; &#125; printf("%d\n", dp[(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC016E] Poor Turkeys]]></title>
    <url>%2F2020%2F04%2F22%2Fagc016_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊääÈóÆÈ¢òÊîæÂà∞‰∏Ä‰∏™Êó†ÂêëÂõæ‰∏äËÄÉËôëÔºåÂ¶ÇÊûúÁ¨¨ \(i\) ‰∏™‰∫∫ÈÄâ‰∫ÜÁÅ´È∏° \(x_i,y_i\)ÔºåÂ∞±Âú® \(x_i,y_i\) ‰πãÈó¥Ëøû‰∏ÄÊù°Êó†ÂêëËæπÔºåÊàë‰ª¨Áß∞ËøôÊù°ËæπÁöÑÊó∂Èó¥‰∏∫ \(i\)„ÄÇ ËÄÉËôë‰∏Ä‰∏™ÁÅ´È∏° \(s\) Âπ∏Â≠òÁöÑÊù°‰ª∂ÔºöÂ¶ÇÊûú \(s\) Âú®Êó∂Âàª \(t\) Ê≤°Ë¢´ÂêÉÊéâÔºåÂØπ‰∫éÊØè‰∏ÄÊù°Ëæπ \(\{s,v\}\)ÔºåÂ¶ÇÊûúËøôÊù°ËæπÁöÑÊó∂Èó¥Â∞è‰∫éÁ≠â‰∫é \(t\)ÔºåË¢´ÂêÉÊéâÁöÑÈÉΩÊòØÁÅ´È∏° \(v\)Ôºå‰∫éÊòØÁÅ´È∏° \(v\) Ë¶ÅÂú®ËøôÊù°ËæπÁöÑÊó∂Èó¥Âπ∏Â≠òÔºåÂ¶ÇÊ≠§‰º†ÈÄí‰∏ãÂéªÔºåÊúÄÁªà‰ºöÂæóÂà∞Ëã•Âπ≤Êù°Ë¢´ÂêÉÊéâÁöÑÁÅ´È∏°Á°ÆÂÆöËæπÔºåËøô‰∫õËæπ‰ºöÊûÑÊàê‰∏ÄÊ£µÊ†ëÔºàÂ¶ÇÊûú‰∏çÊûÑÊàê‰∏ÄÊ£µÊ†ëÁöÑËØùÁÅ´È∏° \(s\) ‰∏çÂèØËÉΩÂπ∏Â≠òÔºâ„ÄÇÊòæÁÑ∂Âè™Ë¶ÅËøô‰∏™Ê†ë‰∏äÁöÑËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Êª°Ë∂≥‰∫ÜÊù°‰ª∂Ôºå\(s\) ‰πü‰∏ÄÂÆö‰ºöÂπ∏Â≠ò„ÄÇÂõ†Ê≠§ÁÅ´È∏° \(s\) Âíå \(t\) ÂêåÊó∂Âπ∏Â≠òÁöÑÊù°‰ª∂Â∞±ÊòØÂÆÉ‰ª¨ÂØπÂ∫îÁöÑÁ°ÆÂÆöÁöÑËæπÊ≤°ÊúâÂÜ≤Á™Å„ÄÇ Áî±‰∫é‰∏Ä‰∏™ÁÅ´È∏°Âπ∏Â≠òÁöÑÊù°‰ª∂‰∏≠ÊúÄÂ§ö \(n-1\) Êù°ËæπË¢´ÂêÉÊéâÁöÑÁÅ´È∏°Ë¢´Á°ÆÂÆöÔºåÊâÄ‰ª•ÂèØ‰ª•Êö¥ÂäõÊ£ÄÊü•‰∏§‰∏™ÁÅ´È∏°ÊòØÂê¶ÂèØ‰ª•ÂêåÊó∂Âπ∏Â≠òÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 410;const int maxm = 100010;typedef pair&lt;int,int&gt; pi;int n, m, ok;int eu[maxm], ev[maxm], l[maxn], e;int tag[maxm], vis[maxm], a[maxn];vector&lt;pi&gt; vec[maxn];struct Edge &#123; int v, x, t;&#125; E[maxm &lt;&lt; 1];inline void addEdge(int u, int v, int t) &#123; E[e].v = v, E[e].x = l[u], E[e].t = t, l[u] = e++; E[e].v = u, E[e].x = l[v], E[e].t = t, l[v] = e++;&#125;void dfs(int u, int t, vector&lt;pi&gt; &amp;vec) &#123; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; if (E[p].t == t) continue; if (E[p].t &lt;= t) &#123; int v = E[p].v; if (vis[v]) ok = 0; else &#123; vec.push_back(pi(E[p].t, u &lt; v)); dfs(v, E[p].t, vec); &#125; &#125; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); memset(tag, -1, sizeof(tag)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;eu[i], &amp;ev[i]); addEdge(eu[i], ev[i], i); &#125; for (int i = 1; i &lt;= n; i++) &#123; ok = 1; for (int j = 1; j &lt;= n; j++) vis[j] = 0; dfs(i, m+1, vec[i]); a[i] = ok; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = vec[i][j].second; for (int j = i+1; j &lt;= n; j++) &#123; if (!a[i] || !a[j]) continue; int ok = 1; for (int k = 0; k &lt; vec[j].size(); k++) &#123; if (tag[vec[j][k].first] != -1 &amp;&amp; tag[vec[j][k].first] != vec[j][k].second) &#123; ok = 0; &#125; &#125; ans += ok; &#125; for (int j = 0; j &lt; vec[i].size(); j++) tag[vec[i][j].first] = -1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC005E] Sugigma: The Showdown]]></title>
    <url>%2F2020%2F04%2F22%2Fagc005_e%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â¶ÇÊûúÁ∫¢Ê†ë‰∏äÊúâ‰∏ÄÊù°Ëæπ \((u,v)\)Ôºå\(u\) Âíå \(v\) Âú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\)ÔºåÈÇ£‰πà Sigma Ëµ∞Âà∞ \(u\) Êàñ \(v\) Â∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª‰∫Ü„ÄÇ Êàë‰ª¨ÊääÂ≠òÂú®‰∏ÄÊù°Áõ∏ÈÇªÁ∫¢ËæπÂú®ËìùÊ†ë‰∏äË∑ùÁ¶ªÂ§ß‰∫é \(2\) ÁöÑÁÇπÊ†áËÆ∞‰∏Ä‰∏ãÔºåÂè™Ë¶ÅÂà∞ËææËøôÁßçÁÇπÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥ÂæÄ‰∏ãË∑ë„ÄÇ ÂÅáËÆæ Sigma Âú®ÁÇπ \(X\)ÔºåSugim Âú®ÁÇπ \(Y\)ÔºåËÄÉËôëËìùÊ†ëÂéªÊéâÁÇπ \(Y\) ÂêéÂΩ¢ÊàêÁöÑËã•Âπ≤‰∏™ËøûÈÄöÂùóÔºåSigma Êó†Ê≥ï‰ªé‰∏Ä‰∏™ËøûÈÄöÂùóÁöÑÊú™Ê†áËÆ∞ÁÇπÂà∞Âè¶‰∏Ä‰∏™ËøûÈÄöÂùó„ÄÇÊâÄ‰ª•ÊòæÁÑ∂ Sugim ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØÔºåÊØèÊ¨°Âú®ËìùÊ†ë‰∏äÂêë \(X\) ÊâÄÂú®ÁöÑÊñπÂêëËµ∞‰∏ÄÊ≠•„ÄÇSigma ÁöÑÊúÄ‰ºòÁ≠ñÁï•ÊòØ‰∏ç‰ºöÈáçÂ§çÁªèËøáËµ∞ËøáÁöÑÁÇπÁöÑ„ÄÇ ‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂú∞Ê±ÇÂá∫ Sigma ÂèØËÉΩËµ∞Âà∞Âì™‰∫õÁÇπÔºåÂ¶ÇÊûú‰ªñËÉΩËµ∞Âà∞‰∏Ä‰∏™Ê†áËÆ∞ÁÇπÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰∏ÄÁõ¥Ë∑ë‰∏ãÂéª„ÄÇÂê¶ÂàôÁ≠îÊ°àÂ∞±ÊòØËÉΩËµ∞Âà∞ÁöÑÁÇπÂú®ËìùÊ†ë‰∏ä‰∏é \(Y\) ÁöÑÊúÄËøúË∑ùÁ¶ª„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, X, Y;int tag[maxn], vis[maxn];struct Tree &#123; int l[maxn], dep[maxn], fa[maxn][20], e, r; Tree() &#123;memset(l, -1, sizeof(l));&#125; struct Edge &#123; int v, x; &#125; E[maxn&lt;&lt;1]; inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++; E[e].v = u, E[e].x = l[v], l[v] = e++; &#125; void dfs(int u, int f) &#123; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125; &#125; void init(int rt) &#123; r = rt; dfs(r, 0); &#125; int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1 &lt;&lt; i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i], v = fa[v][i]; &#125; &#125; return fa[u][0]; &#125; int dis(int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[lca(u, v)]; &#125;&#125; T1, T2;void dfs_vis(int u, int f) &#123; vis[u] = 1; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (v != f) &#123; // Ê≠§Êó∂ Y ÁöÑÊ∑±Â∫¶‰∏∫ T1.dep[u] if (T2.dep[v] &gt; T1.dep[u] + 1) &#123; dfs_vis(v, u); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;X, &amp;Y); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); T1.addEdge(a, b); &#125; for (int i = 1; i &lt; n; i++) &#123; int c, d; scanf("%d%d", &amp;c, &amp;d); T2.addEdge(c, d); &#125; T1.init(X), T2.init(Y); for (int u = 1; u &lt;= n; u++) &#123; for (int p = T1.l[u]; p &gt;= 0; p = T1.E[p].x) &#123; int v = T1.E[p].v; if (T2.dis(u, v) &gt; 2) &#123; tag[u] = 1; &#125; &#125; &#125; dfs_vis(X, 0); int ans = 0; for (int u = 1; u &lt;= n; u++) &#123; if (vis[u]) &#123; if (tag[u]) ans = 0x3f3f3f3f; else ans = max(ans, T2.dep[u]); &#125; &#125; if (ans &lt; 0x3f3f3f3f) printf("%d\n", ans &lt;&lt; 1); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÖ≥‰∫éÊúÄÈïøÂèçÈìæÊñπÊ°àÁöÑÊûÑÈÄ†]]></title>
    <url>%2F2020%2F04%2F15%2Fdilworth%2F</url>
    <content type="text"><![CDATA[Êúâ‰∏Ä‰∫õÊ±ÇÊúÄÈïøÂèçÈìæÁöÑÈ¢òÁõÆ‰ºöËÆ©‰Ω†ÊûÑÈÄ†ÊñπÊ°àÔºåÊØîÂ¶Ç [CTSC2008] Á•≠Á•Ä Âíå CF590E Birthday„ÄÇ ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÂÜôÁöÑÊØîËæÉÊ∏ÖÊô∞ÁöÑÂÅöÊ≥ïÔºår-64 ÁöÑ uoj blog„ÄÇ Â§ßÊ¶ÇÊòØËØ¥Âª∫Âá∫‰∫åÂàÜÂõæÊ±ÇÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÊâÄÊúâ‰∏§ÈÉ®‰∏≠ÂØπÂ∫îÁöÑÁÇπÈÉΩÂú®Áã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÊûÑÊàêÊúÄÈïøÂèçÈìæ„ÄÇ ÊûÑÊàêÂèçÈìæÊòØÊòæÁÑ∂ÁöÑÔºåÊûÑÊàêÊúÄÈïøÂèçÈìæÁöÑÁêÜÁî±‰ºº‰πé‰∏çÂ§™ÂÆåÊï¥Ôºà‰πüÊúâÂèØËÉΩÊòØ‰ΩúËÄÖËßâÂæóËøôËøá‰∫éÊòæÁÑ∂‰∫ÜÔºâÔºåÂùë‰∫ÜÊàëÂæà‰πÖÔºåËøôÈáåËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇ ËÆæÂéüÂõæÁÇπÊï∞‰∏∫ \(n\)Ôºå‰∫åÂàÜÂõæÁöÑÊúÄÂ§ßÂåπÈÖç‰∏∫ \(m\)ÔºåÈÇ£‰πàÊúÄÂ∞èÈìæË¶ÜÁõñÂ§ßÂ∞è‰∏∫ \(n-m\)ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞è‰∏∫ \(2n - m\)„ÄÇÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºåÂ∑¶Âè≥ÈÉ®‰∏≠ÂØπÂ∫îÁÇπÈÉΩÂú®ÂÖ∂‰∏≠ÁöÑÁÇπÊúâ \(n-m\) ‰∏™„ÄÇÈ¶ñÂÖàÊàë‰ª¨Ë¶ÅËØÅÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁÇπÔºåÂÆÉÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπËá≥Â∞ëÊúâ‰∏Ä‰∏™Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÔºàÈÇ£ÁØá blog ‰∏≠‰ºº‰πéÁº∫Â∞ë‰∫ÜËøô‰∏ÄÊ≠•ÔºâÔºöÂ¶ÇÊûú‰∏Ä‰∏™ÁÇπÂú®Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÈÉΩ‰∏çÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠Ôºå‰∏ÄÂÆöÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Â∑¶ÈÉ®ÂØπÂ∫îÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπÊúâËæπÁöÑ(‰∫åÂàÜÂõæ‰∏äÁöÑ)ÁÇπ \(a\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜÔºå‰πüÊúâ‰∏Ä‰∏™‰∏éÂÆÉÂú®Âè≥ÈÉ®ÂØπÂ∫îÁöÑÁÇπÊúâËæπÁöÑÁÇπ \(b\) Âú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠„ÄÇÁî±ÂÅèÂ∫èÂÖ≥Á≥ªÁöÑ‰º†ÈÄíÊÄßÂèØÁü• \(a\) Âíå \(b\) Âú®‰∫åÂàÜÂõæ‰∏äÊúâ‰∏ÄÊù°ËæπÔºå‰∏éÊúÄÂ§ßÁã¨Á´ãÈõÜÁöÑÂÆö‰πâÁüõÁõæ„ÄÇÂõ†Ê≠§ÔºåÊúÄÂ§ßÁã¨Á´ãÈõÜÂ§ßÂ∞èÁ≠â‰∫é \(n + Â∑¶Âè≥ÈÉ®ÂØπÂ∫îÁÇπÈÉΩÂú®ÊúÄÂ§ßÁã¨Á´ãÈõÜ‰∏≠ÁöÑÁÇπÁöÑÊï∞Èáè\)Ôºå‰πüÂ∞±ËØÅÊòé‰∫ÜÊàë‰ª¨ÊûÑÈÄ†Âá∫ÁöÑÂèçÈìæÊòØÊúÄÈïøÂèçÈìæ„ÄÇ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2390] „ÄåJOISC 2017 Day 1„ÄçÂºÄËçíËÄÖ]]></title>
    <url>%2F2020%2F03%2F31%2FLOJ2390%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÆæ‰∏úË•øÂçóÂåóÊñπÂêëÂêπÁöÑÊ¨°Êï∞ÂàÜÂà´‰∏∫ \(c_E, c_W, c_S, c_N\)„ÄÇ È¢òÊÑèÁõ∏ÂΩì‰∫éÊòØË¶ÅÊ±Ç \(c_E+c_W+c_S+c_N\) ÊúÄÂ∞èÁöÑ \(c_E,c_W,c_S,c_N\)Ôºå‰ΩøÂæóÂú®Âπ≥Èù¢‰∏äÊîæ \(n\) ‰∏™Áü©ÂΩ¢ÔºåÁ¨¨ \(i\) ‰∏™Áü©ÂΩ¢ÁöÑÊ®™ÂùêÊ†áËåÉÂõ¥‰∏∫ \([S_i - c_N, S_i + c_S]\)ÔºåÁ∫µÂùêÊ†áËåÉÂõ¥‰∏∫ \([E_i - c_W, E_i + c_E]\)ÔºåËÉΩÂ§üË¶ÜÁõñ‰ª• \((1,1)\) ‰∏∫Â∑¶‰∏äËßíÁöÑ \(R \times C\) Áü©ÂΩ¢„ÄÇ ÂÅáËÆæÊúâ‰∏Ä‰∏™ÊñπÊ°àÔºåËÄÉËôëË∞ÉÊï¥„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>LOJ</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó]]></title>
    <url>%2F2020%2F03%2F27%2F%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[‰æãÈ¢ò LOJ6440 ÂÅöÊ≥ï ËÄÉËôëËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰Ωú‰∏ÄÊù°Â∞ÑÁ∫ø \(y = \frac{Px+R}Q\)ÔºåÂè™ËÄÉËôë \(x &gt; 0\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(y = i\) Â∞±ÊâßË°åÊìç‰Ωú \(A\)ÔºåÁ¢∞Âà∞‰∏ÄÊù°Áõ¥Á∫ø \(x = i\) Â∞±ÊâßË°åÊìç‰Ωú \(B\)Ôºå\(i\) ÊòØÊ≠£Êï¥Êï∞„ÄÇ ‚ÄúÊìç‰ΩúÂ∫èÂàó‚ÄùÂØπÂ∫îÁöÑ‰ø°ÊÅØË¶ÅÂèØÂêàÂπ∂„ÄÇ ËÄÉËôëÈÄíÂΩíÂú∞Â§ÑÁêÜÈóÆÈ¢òÔºåËÆæ \(A\) Âíå \(B\) ÊòØ‰∏§‰∏™Êìç‰ΩúÂ∫èÂàóÂØπÂ∫îÁöÑ‰ø°ÊÅØ„ÄÇÂÆö‰πâ \(solve(P, Q, R, L, A, B)\) Ë°®Á§∫‰∏Ä‰∏™Âê´Êúâ \(L\) ‰∏™ \(B\)ÔºåÁ¨¨ \(k\) ‰∏™ \(B\) ÂíåÁ¨¨ \(k-1\) ‰∏™ \(B\) ‰πãÈó¥Êúâ \(\lfloor \frac{Pk+R}Q \rfloor - \lfloor \frac{P(k-1)+R}Q \rfloor\) ‰∏™ \(A\) ÁöÑÊìç‰ΩúÂ∫èÂàóÁöÑ‰ø°ÊÅØÔºà\(k = 1\) Êó∂ÊòØÂºÄÂ§¥ \(A\) ÁöÑÊï∞ÈáèÔºâ„ÄÇÊää \(R\) ÂØπ \(Q\) ÂèñÊ®°‰∏ç‰ºöÊîπÂèòÁ≠îÊ°àÔºåÊää \(P\) ÂØπ \(Q\) ÂèñÊ®°Âè™Ë¶ÅÊää \(B\) ÂèòÊàê \(A^{\lfloor \frac P Q \rfloor}B\) Â∞±ÂèØ‰ª•ÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú„ÄÇ ÂÖàÂèñÊ®°Ôºå‰øùËØÅ \(P, R &lt; Q\)„ÄÇ ËÄÉËôë‰∫§Êç¢ \(A\) Âíå \(B\) ÁöÑÂú∞‰ΩçÔºåÂéüÊù•Êàë‰ª¨ÊòØËÄÉËôëÊØè‰∏™ \(B\) ÂâçÈù¢ÊúâÂá†‰∏™ \(A\)ÔºåÁé∞Âú®Êàë‰ª¨ËÄÉËôëÊØè‰∏™ \(A\) ÂâçÈù¢ÊúâÂá†‰∏™ \(B\)ÔºåÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂâçÈù¢ÁöÑÊù°‰ª∂ÊòØ \(i \le \frac{Pj+R}{Q}\)ÔºåÂç≥ \(j \ge \frac{Qi-R}P\)„ÄÇÈÇ£‰πàÁ¨¨ \(i\) ‰∏™ \(A\) Âú®Á¨¨ \(j\) ‰∏™ \(B\) ÂêéÈù¢ÁöÑÊù°‰ª∂ÊòØ \(j &lt; \frac{Qi-R}P\)Ôºå‰ªéÁ¨¨ \(i\) ‰∏™ \(A\) ÂâçÈù¢Êúâ \(\max(0, \lceil \frac {Qi-R}P \rceil-1) = \max(0, \lfloor \frac{Qi-R-1}{P}\rfloor)\) ‰∏™ \(B\)„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÁâπÂà´ÂéªÂ§ÑÁêÜ‰∏Ä‰∏ãÊúÄÂêé‰∏Ä‰∏™ \(B\) Âíå \(Qi-R-1\) Â∞è‰∫é \(0\) ÁöÑÊÉÖÂÜµÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™ÂΩ¢Âºè‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇÁî±‰∫é \(R &lt; Q\)Ôºå\(i &gt; 0\) Êó∂ \(Qi-R-1 \ge 0\)„ÄÇ‰ΩÜÊòØ \(i = 0\) Êó∂Âá∫Áé∞Ë¥üÊï∞Êåâ‰πãÂâçÁöÑÂÆö‰πâ‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•Á¨¨‰∏Ä‰∏™ \(A\) ‰ª•ÂèäÂâçÈù¢ÁöÑÈÉ®ÂàÜÂçïÁã¨Â§ÑÁêÜÔºåË∞ÉÁî® \(solve(Q, P, Q-R-1, \lfloor \frac{PL+R}{Q} \rfloor - 1, B, A)\)ÔºåÂ§ÑÁêÜ‰∏ãÂºÄÂ§¥ÁªìÂ∞æÂç≥ÂèØ„ÄÇË¶ÅÂà§‰∏Ä‰∏ãÊ≤°Êúâ \(A\) ÁöÑÊÉÖÂÜµ„ÄÇ Ê∂âÂèäÂà∞Ê±ÇÁü©ÈòµÂπÇÂèØ‰ª•Áõ¥Êé•Âø´ÈÄüÂπÇÔºåÂèØ‰ª•ËØÅÊòéÂ§çÊùÇÂ∫¶‰ªçÊòØ‰∏Ä‰∏™ \(\log\)„ÄÇ ÂÖ≥‰∫éÂÄºÂüü Êú¨È¢òÁöÑÂÄºÂüüÁâπÂà´Â§ßÔºåË¶ÅÂ∞èÂøÉÁàÜ long long„ÄÇ ‰∏ãÈù¢Êàë‰ª¨Êù•ÂàÜÊûêÂêÑ‰∏™ÂèòÈáèÂÜçÈÄíÂΩíËøáÁ®ã‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeeforces566C] Logistical Questions]]></title>
    <url>%2F2020%2F03%2F27%2FCF566C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces453E] Little Pony and Lord Tirek]]></title>
    <url>%2F2020%2F03%2F27%2FCF453E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Ëøô‰∏™È¢òÊØîËæÉÊ∞¥„ÄÇ ÂÅáËÆæÊ≤°ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôêÔºåÈÇ£‰πàÂÖ∂ÂÆûË¶ÅÁÆó‰∏ÄÂè™ pony ËÉΩÊî∂ÂèñÁöÑ manaÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìËøôÊ¨°Êî∂ÂèñÂíå‰∏äÊ¨°Êî∂ÂèñÁöÑÊó∂Èó¥Èó¥ÈöîÔºå‰πò‰∏ä \(r_i\) Âç≥ÂèØ„ÄÇ Êàë‰ª¨Ë¶ÅÂú®Êìç‰ΩúÊó∂Áª¥Êä§ÊâÄÊúâ pony ÁöÑÊúÄÂêéÊìç‰ΩúÊó∂Èó¥ÔºåËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂå∫Èó¥Ë¶ÜÁõñÈóÆÈ¢òÔºåÂæàÂÆπÊòìÂÜô‰∏Ä‰∏™ÂùáÊëä \(\mathcal O(n \log n)\) ÁöÑÂÆûÁé∞ÔºöÂª∫‰∏Ä‰∏™Á∫øÊÆµÊ†ëÔºå‰øÆÊîπÊó∂ÂÖàÊääËØ¢ÈóÆÂå∫Èó¥Âú®Á∫øÊÆµÊ†ë‰∏äÊãÜÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÔºåÂØπÊØè‰∏™Âå∫Èó¥ÔºåÂÅö‰∏Ä‰∏™ËøôÊ†∑ÁöÑËøáÁ®ãÔºöÂÖàËÄÉËôëÂΩìÂâçÂå∫Èó¥ÊâÄÊúâÁÇπÊòØ‰∏çÊòØÊúÄÁªà‰øÆÊîπÊó∂Èó¥Áõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÔºåÂ∞±Â§ÑÁêÜËøô‰∏™Âå∫Èó¥ÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Âå∫Èó¥‰∏äÊâìÊ†áËÆ∞ÔºåÂê¶ÂàôÂ∞±‰∏§ËæπÈÄíÂΩí‰∏ãÂéª„ÄÇÊØèÊ¨°ÂæÄ‰∏ãÈÄíÂΩíÈÉΩ‰ºö‰ΩøÂæó‰∏Ä‰∏™Á∫øÊÆµÊ†ë‰∏äÂå∫Èó¥‰∏≠‰∏çÂêåÁöÑÊúÄÁªà‰øÆÊîπÊó∂Èó¥Êï∞ÂáèÂ∞ë‰∏ÄÔºå‰ªéËÄåËøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶ÊòØÂùáÊëä \(\mathcal O(n \log n)\)„ÄÇ ÊúâÂàùÂßãÂÄºÂíå‰∏äÈôê‰πüÂèØ‰ª•Á±ª‰ººÁöÑÂ§ÑÁêÜÔºå‰∏çÂêåÁöÑÊòØÔºåÂõ†‰∏∫Êúâ‰∫Ü‰∏äÈôêÔºåÈúÄË¶ÅÂØπÊØè‰∏™Âå∫Èó¥Áª¥Êä§‰∏Ä‰∏™‰ª• \(\lceil \frac {m_i}{r_i}\rceil\) ‰∏∫ÂÖ≥ÈîÆÂ≠óÊéíÂ•ΩÂ∫èÁöÑ‰∏úË•ø„ÄÇËøôÊ†∑‰Ω†ÂèØ‰ª•‰∫åÂàÜ‰∏Ä‰∏ãÂâçÂ§öÂ∞ë‰∏™ÈÉΩÊòØÂú®ËøôÊÆµÊó∂Èó¥ÈáåÈù¢ mana Êª°‰∫ÜÁöÑÔºåÁõ¥Êé•Âä†ËøõÁ≠îÊ°àÔºåÁÑ∂ÂêéÂêéÈù¢ÁöÑÂè™ÈúÄË¶ÅÁªüËÆ°‰∏Ä‰∏ã \(r_i\) ÁöÑÂíå‰πò‰∏äÊó∂Èó¥Â∑ÆÂä†ËøõÁ≠îÊ°àÂç≥ÂèØ„ÄÇËøô‰∏™‰∏úË•øÂæàÂÆπÊòìÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ„ÄÇ ÂàùÂßãÂÄºË¶ÅÁâπÂà´Â§ÑÁêÜÔºåÂú®ÊØè‰∏™ÁÇπÁ¨¨‰∏ÄÊ¨°‰øÆÊîπÊó∂Êö¥ÂäõÁÆó‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÊÑüËßâÂÆûÈôÖ‰∏äÂèØ‰ª•Áî®Á∫øÊÆµÊ†ëÂàÜË£ÇÂíåÂêàÂπ∂ÂÅöÂà∞‰∏Ä‰∏™ \(\log\)„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pi;const int maxn = 262155;int n, m;int ps[maxn], pm[maxn], pr[maxn];int res[maxn];vector&lt;pi&gt; vec[maxn];vector&lt;ll&gt; pre[maxn], suf[maxn];void pushUp(int rt) &#123; if (res[rt&lt;&lt;1] == res[rt&lt;&lt;1|1]) res[rt] = res[rt&lt;&lt;1]; else res[rt] = -1;&#125;void build(int l, int r, int rt) &#123; vec[rt] = vector&lt;pi&gt;(r-l+1); pre[rt] = suf[rt] = vector&lt;ll&gt;(r-l+1); for (int i = l; i &lt;= r; i++) &#123; if (pr[i]) vec[rt][i-l] = (pi((pm[i] + pr[i] - 1) / pr[i], i)); else vec[rt][i-l] = (pi(0x3f3f3f3f, i)); &#125; sort(vec[rt].begin(), vec[rt].end()); ll sp = 0, ss = 0; for (int i = 0; i &lt; vec[rt].size(); i++) &#123; sp += pm[vec[rt][i].second]; pre[rt][i] = sp; &#125; for (int i = int (vec[rt].size()) - 1; i &gt;= 0; i--) &#123; ss += pr[vec[rt][i].second]; suf[rt][i] = ss; &#125; if (l == r) return; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1);&#125;void pushDown(int rt) &#123; if (res[rt] != -1) &#123; res[rt&lt;&lt;1] = res[rt&lt;&lt;1|1] = res[rt]; &#125;&#125;ll _solve(int t, int l, int r, int rt) &#123; if (res[rt] != -1) &#123; if (res[rt] == 0) &#123; ll ret = 0; for (int i = l; i &lt;= r; i++) &#123; ret += min(ps[i] + 1LL * pr[i] * t, 0ll + pm[i]); &#125; res[rt] = t; return ret; &#125; else &#123; ll ret = 0; int ct = t - res[rt]; int p = int (upper_bound(vec[rt].begin(), vec[rt].end(), pi(ct, 0x3f3f3f3f)) - vec[rt].begin()); if (p &gt; 0) ret += pre[rt][p-1]; if (p &lt; vec[rt].size()) ret += 1LL * ct * suf[rt][p]; res[rt] = t; return ret; &#125; &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; ret += _solve(t, l, m, rt&lt;&lt;1); ret += _solve(t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;ll solve(int L, int R, int t, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return _solve(t, l, r, rt); &#125; pushDown(rt); ll ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret += solve(L, R, t, l, m, rt&lt;&lt;1); if (R &gt; m) ret += solve(L, R, t, m+1, r, rt&lt;&lt;1|1); pushUp(rt); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;ps[i], &amp;pm[i], &amp;pr[i]); scanf("%d", &amp;m); build(1, n, 1); for (int i = 1; i &lt;= m; i++) &#123; int t, l, r; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); ll ans = solve(l, r, t, 1, n, 1); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1110G] Tree-Tac-Toe]]></title>
    <url>%2F2020%2F03%2F26%2FCF1110G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊØíÁò§ÂàÜÁ±ªËÆ®ËÆ∫.... Â∞±Êîæ‰∏™‰ª£Á†Å..ÁªìËÆ∫Â§™È∫ªÁÉ¶Â∞±‰∏çÂÜô‰∫Ü TAT„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int T, n;int l[maxn], e;int dep[maxn], fa[maxn], deg[maxn], a[maxn], tot;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u, int f) &#123; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;T); for (int test = 1; test &lt;= T; test++) &#123; scanf("%d", &amp;n); e = 0; for (int i = 1; i &lt;= n; i++) l[i] = -1, deg[i] = 0; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; scanf("%s", str+1); if (n &lt;= 2) &#123; puts("Draw"); continue; &#125; int ok = 1; for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 3) ok = 0; if (!ok) &#123; puts("White"); continue; &#125; dep[1] = 0, fa[1] = 0; dfs(1, 0); int r1 = int (max_element(dep+1, dep+n+1) - dep); dep[r1] = 0, fa[r1] = 0; dfs(r1, 0); int r2 = int (max_element(dep+1, dep+n+1) - dep); tot = 0; int _ = r2; while (_) &#123;a[++ tot] = _; _ = fa[_];&#125; int s = 0; for (int i = 1; i &lt;= tot; i++) &#123; s += deg[a[i]]; if (i+1 &lt;= tot) -- s; if (i-1 &gt;= 1) -- s; ++ s; &#125; if (s &lt; n) &#123; puts("White"); continue; &#125; if (tot &lt;= 3) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; if (n &gt; 3) puts("White"); else if (c == 1) puts("Draw"); else puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else &#123; for (int i = 3; i &lt; tot-1; i++) &#123; if (deg[a[i]] != 2) &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (deg[a[2]] == 2 &amp;&amp; deg[a[tot-1]] == 2) &#123; for (int i = 2; i &lt; tot; i++) &#123; if (str[a[i]] == 'W') &#123; ok = 0; &#125; &#125; if (!ok) &#123; puts("White"); continue; &#125; if (str[a[1]] == 'N' &amp;&amp; str[a[tot]] == 'N') &#123; puts("Draw"); continue; &#125; if ((str[a[1]] == 'N') ^ (str[a[tot]] == 'N')) &#123; puts("Draw"); continue; &#125; if (n &amp; 1) &#123; puts("White"); continue; &#125; else &#123; puts("Draw"); continue; &#125; &#125; else if ((deg[a[2]] == 2) ^ (deg[a[tot-1]] == 2)) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c &gt; 1) &#123; puts("White"); continue; &#125; if (!c) &#123; puts("Draw"); continue; &#125; if (deg[a[2]] == 3) &#123; if (str[a[tot]] == 'W') -- c; &#125; if (deg[a[tot-1]] == 3) &#123; if (str[a[1]] == 'W') -- c; &#125; if (c) puts("White"); else if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; else &#123; int c = 0; for (int i = 1; i &lt;= n; i++) if (str[i] == 'W') ++ c; if (c) &#123; puts("White"); continue; &#125; else &#123; if (tot &amp; 1) puts("White"); else puts("Draw"); continue; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538G] Giant Penguin]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Á•û‰ªôÈ¢òÔºåÁúãÈ¢òËß£‰∫Ü„ÄÇ Âèñ‰ªªÊÑè‰∏Ä‰∏™ÁîüÊàêÊ†ëÔºåÂèñËøô‰∏™Ê†ëÁöÑÈáçÂøÉÂíåÊâÄÊúâË∑®ËøáËøô‰∏™ÈáçÂøÉÁöÑÈùûÊ†ëËæπÁöÑÁ´ØÁÇπÔºàÂÆûÈôÖ‰∏ä‰∏§‰∏™Á´ØÁÇπ‰∏≠Âè™Ë¶Å‰ªªÂèñ‰∏Ä‰∏™Â∞±Ë°åÔºåÂè™Ë¶Å‰øùËØÅÂ≠êÊ†ë‰∏çËøûÈÄöÔºâÔºåËÄÉËôëË∑®ËøáËøô‰∫õÁÇπÁöÑË∑ØÂæÑÔºåÁÑ∂ÂêéÂÜçÂØπÊØè‰∏™Â≠êÊ†ëÁÇπÂàÜ„ÄÇ Ê≥®ÊÑè‰∏çË¶ÅÊääËøô‰∫õÁÇπÂà†ÊéâÂÜçÂØπÊØè‰∏™ËøûÈÄöÂùóÂÅöÁÇπÂàÜÊ≤ªÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØËÉΩ‰∏Ä‰∏™ËøûÈÄöÂùó‰∏çÊòØ‰∏Ä‰∏™Ê†ë‰∏äËøûÈÄöÂùóÔºåÂ∞±‰∏çÊòØÂæàÂ•ΩÂ§ÑÁêÜÔºàÂ∫îËØ•‰πüËÉΩÂ§ÑÁêÜÔºâ„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÉèÂä®ÊÄÅÁÇπÂàÜÊ≤ª‰∏ÄÊ†∑Áª¥Êä§Â∞±Ë°åÔºåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÂà†ÂéªÁöÑÁÇπ‰∏éÂΩìÂâçËøûÈÄöÂùó‰∏≠ÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ª„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(nk\log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int maxm = 200010;typedef long long ll;int n, m, k, q;int l[maxn], e;struct Edge &#123; int v, x;&#125; E[maxm&lt;&lt;1];vector&lt;int&gt; tree[maxn];ll getid(int x, int y) &#123; return 1LL * (n+1) * x + y;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int fT_vis[maxn];void findTree(int u) &#123; fT_vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!fT_vis[v]) &#123; findTree(v); tree[u].push_back(v); tree[v].push_back(u); &#125; &#125;&#125;int par[maxn], ind[maxn], tot, col[maxn]; // ÁÇπÂàÜÊ†ë‰∏äÁà∂‰∫≤Ôºå‰∏Ä‰∏™ÁÇπË¢´Âà†ÊéâÊó∂ÂØπÂ∫îÁÇπÂàÜÊ†ë‰∏äÂì™‰∏™ÁÇπvector&lt;int&gt; vimp[maxn], mn[maxn]; // ÁÇπÂàÜÊ†ë‰∏ä‰∏ÄÊ¨°Âà†ÂéªÁöÑÁÇπÔºå‰ª•ÂèäÂà∞ËøûÈÄöÂùóÂÜÖÊúÄËøëË¢´ mark ÁÇπÁöÑË∑ùÁ¶ªunordered_map&lt;ll, int&gt; mdis; // Ë¢´Âà†ÂéªÁöÑÁÇπÂà∞ÂÜÖÈÉ®‰∏Ä‰∏™ÁÇπÁöÑË∑ùÁ¶ªint vis[maxn], dep[maxn], sz[maxn], mx[maxn], _vis[maxn], _tim, __vis[maxn], __tim; // ÁÇπÂàÜÊ≤ªÁî®ÂèòÈáèvoid dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); __vis[u] = __tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f, int c) &#123; col[u] = c; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; !vis[v]) &#123; dfs2(v, u, c); &#125; &#125;&#125;void dfs3(int u, int f, int &amp;s) &#123; ++ s; _vis[u] = _tim; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f &amp;&amp; _vis[v] &lt; _tim &amp;&amp; !vis[v]) &#123; dfs3(v, u, s); &#125; &#125;&#125;int solve(int u, int s) &#123; int id = ++ tot; ++ __tim; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; mx[x] = max(mx[x], s - sz[x]); if (!c || mx[x] &lt; mx[c]) c = x; &#125; vimp[id].push_back(c); col[c] = c; for (int i = 0; i &lt; tree[c].size(); i++) &#123; int v = tree[c][i]; if (!vis[v]) &#123; dfs2(v, c, v); &#125; &#125; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (x == c) continue; for (int p = l[x]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (col[x] != col[v] &amp;&amp; __vis[v] == __tim) &#123; if (v == c &amp;&amp; col[x] == x) continue; vimp[id].push_back(min(x, v)); &#125; &#125; &#125; sort(vimp[id].begin(), vimp[id].end()); vimp[id].erase(unique(vimp[id].begin(), vimp[id].end()), vimp[id].end()); mn[id] = vector&lt;int&gt;(vimp[id].size(), 0x3f3f3f3f); for (int i = 0; i &lt; vimp[id].size(); i++) &#123; int x = vimp[id][i]; ind[x] = id; ++ _tim; queue&lt;int&gt; q; q.push(x); _vis[x] = _tim; dep[x] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (!mdis.count(getid(x, u))) mdis[getid(x, u)] = 0x3f3f3f3f; mdis[getid(x, u)] = min(mdis[getid(x, u)], dep[u]); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; _vis[v] &lt; _tim &amp;&amp; __vis[v] == __tim) &#123; _vis[v] = _tim; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; &#125; ++ _tim; vis[c] = 1, _vis[c] = _tim; // ÂéüÊú¨ËøôÈáåÊòØÊääÊâÄÊúâÂ§ÑÁêÜÁöÑÁÇπÂà†ÊéâÁöÑÔºåÂÜôÂæóÂèØËÉΩÊúâÁÇπÂ•áÊÄ™ÔºåÊáíÂæóÊîπ‰∫Ü vector&lt;int&gt; vv, vs; for (int i = 0; i &lt; vl.size(); i++) &#123; int x = vl[i]; if (_vis[x] &lt; _tim) &#123; int _s = 0; dfs3(x, 0, _s); vv.push_back(x); vs.push_back(_s); &#125; &#125; for (int i = 0; i &lt; vv.size(); i++) &#123; par[solve(vv[i], vs[i])] = id; &#125; return id;&#125;void mark(int u) &#123; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; mn[x][i] = min(mn[x][i], mdis[getid(v, u)]); &#125; x = par[x]; &#125;&#125;int cal(int u) &#123; int ret = 0x3f3f3f3f; int x = ind[u]; while (x) &#123; for (int i = 0; i &lt; vimp[x].size(); i++) &#123; int v = vimp[x][i]; ret = min(ret, mdis[getid(v, u)] + mn[x][i]); &#125; x = par[x]; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; findTree(1); solve(1, n); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int t, v; scanf("%d%d", &amp;t, &amp;v); if (t == 1) &#123; mark(v); &#125; else printf("%d\n", cal(v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102538B] Best Tree]]></title>
    <url>%2F2020%2F03%2F26%2FGym102538B%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÆπÊòìËØÅÊòéÔºåÂØπ‰∫é‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ∫¶Êï∞Â∫èÂàó \(d\)ÔºåÂ≠òÂú®‰∏ÄÊ£µÂØπÂ∫îÁöÑ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(1 \le d_i &lt; n\) ‰∏î \(\sum {d_i} = 2(n-1)\)Ôºà‰ªéÂè∂Â≠êÂΩíÁ∫≥Ôºâ„ÄÇ ËÄÉËôëÂéªÈí¶ÂÆöËøô‰∏™Ê†ëÁöÑ \(k\) ‰∏™ÂåπÈÖçÔºåÂ¶ÇÊûúËÉΩÈí¶ÂÆöÂá∫Êù•Â∞±ËØ¥ÊòéÁ≠îÊ°à \(\ge k\)„ÄÇÈí¶ÂÆö‰∏§‰∏™ÁÇπÂåπÈÖçÂèØ‰ª•Áúã‰ΩúËøô‰∏§‰∏™ÁÇπË¢´Áº©Âà∞‰∫Ü‰∏ÄËµ∑ÔºåÂèòÊàê‰∫Ü‰∏Ä‰∏™Â∫¶Êï∞Âíå‰∏∫‰∏§‰∏™ÁÇπÁöÑÂ∫¶Êï∞‰πãÂíåÂáèÂéª \(2\) ÁöÑÁÇπ„ÄÇÂè™Ë¶Å‰øùËØÅÊâÄÊúâÂåπÈÖçÁº©Ëµ∑Êù•‰πãÂêéÂæóÂà∞ÁöÑÂ∫¶Êï∞Â∫èÂàó‰æùÁÑ∂Êª°Ë∂≥‰πãÂâçÊâÄËØ¥ÁöÑÊù°‰ª∂Âç≥ÂèØ„ÄÇËøôÊòØ‰∏Ä‰∏™‰ºóÊâÄÂë®Áü•ÁöÑË¥™ÂøÉÈóÆÈ¢òÔºåÊéíÂ∫èÂêéË¥™ÂøÉÁî®Â∞èÁöÑÂåπÈÖçÂ§ßÁöÑÂç≥ÂèØ„ÄÇÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè \(1\) Âíå \(1\) Âú®ÁÇπÊï∞Â§ß‰∫é \(2\) Êó∂‰∏çËÉΩÂåπÈÖçÔºàÂõ†‰∏∫ \(1+1-2=0\)ÔºâÔºå‰ΩÜÊòØÁÇπÊï∞Á≠â‰∫é \(2\) Êó∂ÂèØ‰ª•ÂåπÈÖç„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int T, n, d[maxn];int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); if (n == 2) &#123; puts("1"); continue; &#125; multiset&lt;int&gt; st; int ans = 0; for (int i = 1; i &lt;= n; i++) st.insert(d[i]); while (st.size() &gt;= 2) &#123; int x = * st.begin(), y = * st.rbegin(); if (x + y - 2 &gt;= n) &#123; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); continue; &#125; if (x + y - 2 &lt;= 0) break; set&lt;int&gt;::iterator _ = st.end(); st.erase(-- _); st.erase(st.begin()); ++ ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1088F] Ehab and a weird weight formula]]></title>
    <url>%2F2020%2F03%2F25%2FCF1088F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Â•áÊÄ™ÁöÑÈ¢òÁõÆ... ÂÖàÊääÁÇπÊåâ \(a_i\) ‰ªéÂ∞èÂà∞Â§ßÈáçÊñ∞Ê†á‰∏™Âè∑„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨ÂÅáËÆæ \(a_i &lt; a_{i+1}\)„ÄÇ Êää \(1\) Áúã‰ΩúÊ†πÔºåÊòæÁÑ∂ÂèØ‰ª•ÈÄöËøáË∞ÉÊï¥‰ΩøÊØè‰∏™ÁÇπÁöÑÁà∂‰∫≤ÁºñÂè∑ÈÉΩÊØî‰ªñÂ∞è„ÄÇ Êää‰∏§ÁßçË¥°ÁåÆ‰∏ÄËµ∑ËÄÉËôëÔºåÂÆö‰πâËæπ \(\{u, fa(u)\}\) ÁöÑË¥°ÁåÆ‰∏∫ \(a_u + (\lceil\log_2{dist(u,fa(u))}\rceil+1)a_{fa(u)}\)ÔºåÂØπÊØè‰∏™ \(u\) ÂéªÊâæËÉΩ‰Ωø‰ª£‰ª∑ÊúÄÂ∞èÁöÑ \(fa(u)\)„ÄÇÁî±‰∫éËøô‰∏™Ê†ëÁöÑÁâπÊÆäÊÄßË¥®ÔºåÁÇπ \(u\) ÊúÄ‰ºòÁöÑÁà∂‰∫≤‰∏ÄÂÆöÊòØÂéüÊ†ë‰∏ä \(u\) ÁöÑÁ•ñÂÖàÔºåÊâÄ‰ª•ÂÄçÂ¢û‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;typedef long long ll;int l[maxn], e = 0;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];int n, a[maxn], ind[maxn], ni[maxn], _a[maxn];int fa[maxn][20], mn[maxn][20]; // Ë∑ùÁ¶ª‰∏çË∂ÖËøá 2^k ÁöÑÁÇπint cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;void dfs(int u, int f) &#123; fa[u][0] = f; if (u != 1) mn[u][0] = a[f]; else mn[u][0] = 0x3f3f3f3f; for (int i = 1; i &lt; 20; i++) &#123; fa[u][i] = fa[fa[u][i-1]][i-1]; mn[u][i] = min(mn[u][i-1], mn[fa[u][i-1]][i-1]); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dfs(v, u); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); memset(mn[0], 0x3f, sizeof(mn[0])); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), ind[i] = i; sort(ind+1, ind+n+1, cmp); for (int i = 1; i &lt;= n; i++) _a[i] = a[ind[i]], ni[ind[i]] = i; for (int i = 1; i &lt;= n; i++) a[i] = _a[i]; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u = ni[u], v = ni[v]; addEdge(u, v), addEdge(v, u); &#125; dfs(1, 0); ll ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ll res = 1e18; for (int j = 0; j &lt; 20; j++) &#123; res = min(res, 1LL * (j + 1) * mn[i][j]); &#125; ans += res + a[i]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Áü•ËØÜÁÇπ] ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™ \(n\) ‰∏™ÁÇπ \(m\) Êù°ËæπÁöÑÂ∏¶ÊùÉÁÆÄÂçïÊúâÂêëÂõæÔºåÊ±Ç‰∏Ä‰∏™ÊúÄÂ∞èËæπÊùÉÂíåÁöÑÊòØ‰ª• \(r\) ‰∏∫Ê†πÁöÑÂÜÖÂêëÁîüÊàêÊ†ë„ÄÇ Â§ñÂêëÊ†ëÁöÑÊÉÖÂÜµÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´ÔºåËæπÂèç‰∏ÄÂèçÂ∞±Â•Ω„ÄÇ Êó†Ê†πÁöÑÊÉÖÂÜµÂèØ‰ª•Âä†‰∏Ä‰∏™ÁÇπËΩ¨Âåñ‰∏∫ÊúâÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ÁÆóÊ≥ï Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæÊòØ DAGÔºå‰∏Ä‰∏™ÊòæÁÑ∂ÁöÑË¥™ÂøÉÊòØÔºåÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ„ÄÇÊòæÁÑ∂ËøôÊ†∑‰ºöÊûÑÊàê‰∏ÄÊ£µÂÜÖÂêëÊ†ëÔºå‰∏î‰∏çÂèØËÉΩÊúâÊùÉÂÄºÂíåÊõ¥Â∞èÁöÑÂÜÖÂêëÊ†ë„ÄÇ Â¶ÇÊûúÁªôÂÆöÁöÑÊúâÂêëÂõæ‰∏çÊòØ DAGÔºåÁõ¥Êé•ÂèñÈô§‰∫Ü \(r\) ‰ª•Â§ñÁöÑÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂá∫Ëæπ‰∏ç‰∏ÄÂÆö‰ºöÂæóÂà∞‰∏ÄÊ£µÊ†ëÔºåÊ≠§Êó∂ÂèØËÉΩ‰ºöÊúâÂ§ö‰∏™Âº±ËøûÈÄöÂùóÔºåÊØè‰∏™ËøûÈÄöÂùóÊòØ‰∏ÄÊù°ÈìæÔºàÂåÖÂê´ \(r\) ÁöÑÔºâÊàñËÄÖ‰∏ÄÊ£µÂü∫ÁéØÂÜÖÂêëÊ†ë„ÄÇÂ¶ÇÊûú‰Ω†ÂæóÂà∞‰∫Ü‰∏Ä‰∏™ÂÜÖÂêëÁîüÊàêÊ†ëÂ∞±Ê±ÇÂá∫‰∫ÜÁ≠îÊ°àÔºå‰∏ãÈù¢Êàë‰ª¨ËÄÉËôëËá≥Â∞ëÊúâ‰∏Ä‰∏™ÁéØÁöÑÊÉÖÂÜµ„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂØπ‰∫é‰∏Ä‰∏™ÔºàÊüê‰∏™Âü∫ÁéØÊ†ëËøûÈÄöÂùó‰∏≠ÁöÑÔºâÁéØÔºå‰∏ÄÂÆöÂ≠òÂú®‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÊÅ∞Â•ΩÂè™Êúâ‰∏ÄÊù°ÁéØ‰∏äËæπ‰∏çÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºåÊàë‰ª¨ÂÖàÂÅáËÆæËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºà‰Ω†ÂèØ‰ª•Âä†ÂÖ•‰∏Ä‰∏™ÂÖÖÂàÜÂ∞èÁöÑÂÅèÁßªÈáèÔºåÂú®‰∏çÂΩ±ÂìçÁ≠îÊ°àÁöÑÂâçÊèê‰∏ã‰ΩøËæπÊùÉ‰∫í‰∏çÁõ∏ÂêåÔºâÔºåËÆæÁÇπ \(u\) ÁöÑÊúÄÂ§ßÂá∫ËæπËøûÂêëÁÇπ \(f(u)\)ÔºåËÄÉËôë‰∏Ä‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÁÇπ \(u \neq r\)Ôºå\(f(u)\) ‰∏çÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠Ôºå‰∏î \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÊàë‰ª¨ÂèØ‰ª•Êää \(u\) ÁöÑÁà∂‰∫≤Êîπ‰∏∫ \(f(u)\)ÔºåÂæóÂà∞‰∏Ä‰∏™Êõ¥Â∞èÁöÑÂÜÖÂêëÁîüÊàêÊ†ëÔºåËøô‰∏éËøô‰∏™Ê†ëÊòØÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ëÁüõÁõæ„ÄÇËøôËØ¥ÊòéÔºåÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™ÁéØ‰∏äÁöÑÁÇπ \(u\)Ôºå‰ΩøÂæó \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ (ÁéØ‰∏äÁÇπËÇØÂÆö‰∏çÊòØ \(r\))Ôºå\(f(u)\) Ë¶Å‰πàÊòØ \(u\) ÁöÑÁà∂‰∫≤Ë¶Å‰πàÂú® \(u\) ÁöÑÂ≠êÊ†ë‰∏≠„ÄÇËÄÉËôë‰ªé \(u\) Âá∫ÂèëÔºåÊØèÊ¨°‰ªé \(u\) Ëµ∞Âêë \(f(u)\)ÔºåÂú®Ëµ∞Âõû \(u\) ‰πãÂâçÔºå‰∏ÄÂÆö‰∏ç‰ºöÁªèËøá‰∏Ä‰∏™ÁÇπ‰∏§Ê¨°Ôºå‰ªéËÄåË∑ØÂæÑ‰∏äÂè™ÊúâÁ¨¨‰∏ÄÊ¨°Ëµ∞ÁöÑÊó∂ÂÄô \(f(u)\) ‰∏çÊòØ \(u\) ÁöÑÁà∂‰∫≤ÔºåÂõ†Ê≠§ÁéØ‰∏äÂè™Êúâ‰∏ÄÊù°ËæπÊ≤°ÊúâÂú®Ëøô‰∏™ÊúÄÂ∞èÂÜÖÂêëÁîüÊàêÊ†ë‰∏≠Âá∫Áé∞„ÄÇ Âõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁéØ‰∏äÂì™‰∏ÄÊù°ËæπÊ≤°ÊúâÂá∫Áé∞„ÄÇËÄÉËôëÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÂæóÂà∞‰∏Ä‰∏™‰∏éÂéüÂõæÁ≠â‰ª∑ÁöÑÂõæ„ÄÇ ‰æãÂõæ ÂÖ∂‰∏≠ \(e\) ÊòØ‰∏çÂú®ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ‰∏≠ÁöÑËæπÔºå‰ªéÂõæ‰∏≠ÂèØ‰ª•ÂæàÊòéÊòæÂú∞ÁúãÂà∞ÔºåÊääÁéØÁº©Êàê‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÊääÁº©ÂÆåÂêéÁöÑÁöÑÁÇπÁöÑÂá∫ËæπËæπÊùÉÂáèÂéªÂéüÊù•ËøôÊù°Âá∫ËæπÂØπÂ∫îÁöÑ \(e\) ÁöÑÊùÉÂÄºÂç≥ÂèØÂæóÂà∞‰∏Ä‰∏™Á≠â‰ª∑ÁöÑÂõæ„ÄÇ Êö¥ÂäõÁº©ÁÇπÂèØ‰ª•Áî® \(\mathcal O(nm)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ê±ÇÂá∫ÊúÄÂ∞èÊ†ëÂΩ¢Âõæ„ÄÇ Â§çÊùÇÂ∫¶‰ºòÂåñ Áî®Âπ∂Êü•ÈõÜÁª¥Êä§Âº±ËøûÈÄöÂùóÔºåÂÜçÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ÂΩìÂâçÂì™‰∫õÁÇπË¢´Áº©Êàê‰∫Ü‰∏Ä‰∏™ÁÇπ„ÄÇÁî®ÂèØÂπ∂Â†ÜÁª¥Êä§ÂΩìÂâçÊØè‰∏™ÁÇπÁöÑÂá∫ËæπÔºåÁº©ÁÇπÊó∂Â∏¶ tag ÂêàÂπ∂‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÂá∫ËæπÔºåÂ¶ÇÊûúÂú®Âêå‰∏ÄÂº±ËøûÈÄöÂùóÂèàÂèØ‰ª•Áº©ÁÇπ‰∫ÜÔºåÂê¶ÂàôÁöÑËØùÂ∞±ÂíåÂÖ∂‰ªñÂº±ËøûÈÄöÂùóÂêàÂπ∂Âú®‰∫Ü‰∏ÄËµ∑„ÄÇ Áº©‰∏ÄÊ¨°Ëá≥Â∞ëÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºåÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O((n+m) \log n)\)„ÄÇ ÂÆûÁé∞ ÂíïÂíïÂíï„ÄÇ Áî±‰∫éÂÆûÁé∞Âíï‰∫ÜÊâÄ‰ª•‰πü‰∏çËÉΩ‰øùËØÅ‰∏äÈù¢ËØ¥ÁöÑÊòØÂØπÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces626G] Raffles]]></title>
    <url>%2F2020%2F03%2F19%2FCF626G%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Áåú‰∫Ü‰∏™ÁªìËÆ∫Ôºå‰∏ç‰ºöËØÅ‰ΩÜÊòØÂèàÊÉ≥‰∏çÂà∞ÂÖ∂‰ªñÂÅöÊ≥ï..Áúã‰∫ÜÁúºÈ¢òËß£ÂèëÁé∞ÊòØÂØπÁöÑ„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñÔºåÂÅáËÆæ‰Ω†‰π∞‰∫Ü \(x\) Ê¨°Ôºå‰Ω†‰ªéËøô‰∏™ÊäΩÂ•ñ‰∏≠Ëé∑ÂæóÁöÑÈí±Êï∞ÁöÑÊúüÊúõÊòØ \(p_i\frac {x} {x + l_i}\)„ÄÇÂÅáËÆæ‰Ω†Â∑≤Áªè‰π∞‰∫ÜÁ¨¨ \(i\) ‰∏™ÊäΩÂ•ñ \(x\) Ê¨°ÔºåÂÜç‰π∞‰∏ÄÊ¨°ÔºåÊúüÊúõÁöÑÂ¢ûÂä†ÈáèÊòØ \(p_i(\frac{x+1}{x+l_i+1} - \frac{x}{x+l_i}) = p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\)„ÄÇÂÆπÊòìÂèëÁé∞Ëøô‰∏™Â¢ûÂä†ÈáèÂÖ≥‰∫é \(x\) ÂçïË∞ÉÈÄíÂáèÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶ÅÂØπ‰∫éÊâÄÊúâÁöÑ \(i\) Âíå \(x \le i\)ÔºåÊää \(p_i \frac{l_i}{(x+l_i)(x+l_i+1)}\) ‰∏¢Ëøõ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ªéÂ§ßÂà∞Â∞èÊéí‰∏™Â∫èÔºåÂâç \(t\) ‰∏™Êï∞‰πãÂíåÂç≥ÊòØÁ≠îÊ°à„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ§çÊùÇÂ∫¶‰∏çËÉΩÊé•Âèó„ÄÇ Êàë‰ª¨ÂÖàÁÆóÂá∫ÂàùÂßãÊ∏ÖÁ©∫ÁöÑÊúÄ‰ºòÊñπÊ°àÔºåÁªôÁ¨¨ \(k\) ‰∏™ÊäΩÂ•ñÂéüÊúâÁöÑÁ•®Êï∞Âä†‰∏ÄÂáè‰∏Ä‰πãÂêéÔºåËÄÉËôë‰∏§ÁßçÊìç‰ΩúÔºö‰∏ÄÔºåÂ∞ë‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ§ö‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñÔºõ‰∫åÔºåÂ§ö‰π∞‰∏Ä‰∏™ÊäΩÂ•ñ \(k\)ÔºåÂ∞ë‰π∞‰∏Ä‰∏™Âè¶‰∏Ä‰∏™ÊäΩÂ•ñ„ÄÇÊàë‰ª¨ÊâæÂà∞ËÉΩ‰ΩøÊúüÊúõÂ¢ûÂä†ÈáèÊúÄÂ§ßÁöÑÊìç‰ΩúÔºåËøôÂæàÂÆπÊòìÁî®Â†ÜÊù•Áª¥Êä§„ÄÇÂè™ÈúÄË¶ÅÁªèËøá‰∏ÄÊ¨°ËøôÊ†∑ÁöÑÊìç‰ΩúÂç≥ÂèØÂæóÂà∞ÊúÄ‰ºòÊñπÊ°àÔºåËØÅÊòéÂ∞±‰∏çÂÖ∑‰ΩìÂÜôÂá∫‰∫Ü„ÄÇÔºàÊØîÂ¶ÇËØ¥Â¶ÇÊûúÊòØËøõË°åÊìç‰Ωú‰∫åÔºå‰ªéËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÂêéÔºåÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÊØîÂú®‰øÆÊîπÁ•®Êï∞‰πãÂâçËøõË°å‰∏ÄÊ¨°Êìç‰Ωú‰∫åÁöÑÂáèÂ∞èÈáèË¶ÅÂ§ßÊù•ËÄÉËôëÂç≥ÂèØÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;typedef long long ll;const int maxn = 200010;const ld eps = 1e-10;ld ans = 0;int n, t, q;int p[maxn], l[maxn], cur[maxn];int gcd(int x, int y) &#123; if (!y) return x; return gcd(y, x%y);&#125;struct frac &#123; ll x, y; int i; frac(ll x_=0, ll y_=0, int i_=0) &#123; x = x_, y = y_; int d = gcd(x, y); x /= d, y /= d; i = i_; &#125;&#125;;bool operator&lt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &lt; 1LL * f1.y * f2.x; return f1.i &lt; f2.i;&#125;bool operator&gt;(const frac &amp;f1, const frac &amp;f2) &#123; if (1LL * f1.x * f2.y != 1LL * f1.y * f2.x) return 1LL * f1.x * f2.y &gt; 1LL * f1.y * f2.x; return f1.i &gt; f2.i;&#125;bool operator==(const frac &amp;f1, const frac &amp;f2) &#123; return f1.x == f2.x &amp;&amp; f1.y == f2.y &amp;&amp; f1.i == f2.i;&#125;priority_queue&lt;frac, vector&lt;frac&gt;, less&lt;frac&gt; &gt; pq1, d1;priority_queue&lt;frac, vector&lt;frac&gt;, greater&lt;frac&gt; &gt; pq2, d2;void upd1() &#123; while (!d1.empty() &amp;&amp; d1.top() == pq1.top()) &#123; d1.pop(); pq1.pop(); &#125;&#125;void upd2() &#123; while (!d2.empty() &amp;&amp; d2.top() == pq2.top()) &#123; d2.pop(); pq2.pop(); &#125;&#125;void del(int i) &#123; if (cur[i] &lt; l[i]) &#123; d1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; d2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;void add(int i) &#123; if (cur[i] &lt; l[i]) &#123; pq1.push(frac(p[i] * l[i], 1LL * (cur[i] + l[i]) * (cur[i] + l[i] + 1), i)); &#125; if (cur[i]) &#123; pq2.push(frac(p[i] * l[i], 1LL * (cur[i] - 1 + l[i]) * (cur[i] - 1 + l[i] + 1), i)); &#125;&#125;ld cal(int i) &#123; return ld (p[i]) * ld(cur[i]) / ld(cur[i] + l[i]);&#125;void mt() &#123; while (t) &#123; upd1(); if (pq1.empty()) break; frac f = pq1.top(); int i = f.i; del(i); ans -= cal(i); // cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur[i] &lt;&lt; endl; ++ cur[i]; ans += cal(i); add(i); t --; &#125; while (1) &#123; upd1(); upd2(); if (pq1.empty() || pq2.empty()) return; frac f1 = pq1.top(), f2 = pq2.top(); if (ld (f1.x) / ld (f1.y) - ld (f2.x) / ld (f2.y) &lt; eps) return; del(f1.i); del(f2.i); ans -= cal(f1.i); ans -= cal(f2.i); ++ cur[f1.i], -- cur[f2.i]; ans += cal(f1.i); ans += cal(f2.i); add(f1.i); add(f2.i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;l[i]); for (int i = 1; i &lt;= n; i++) add(i); for (int i = 1; i &lt;= q; i++) &#123; int ty, r; scanf("%d%d", &amp;ty, &amp;r); if (ty == 1) &#123; // + 1 del(r); ans -= cal(r); ++ l[r]; ans += cal(r); add(r); mt(); &#125; else &#123; // - 1 del(r); ans -= cal(r); if (cur[r] == l[r]) &#123; -- cur[r], ++ t; &#125; -- l[r]; ans += cal(r); add(r); mt(); &#125; printf("%.10lf\n", double (ans)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1063F] String Journey]]></title>
    <url>%2F2020%2F03%2F19%2FCF1063F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÔºåÂÖàÊääÈ¢òÁõÆ‰∏≠ÁªôÂÆö‰∏≤ÁøªËΩ¨‰∏Ä‰∏ãÔºåÂèòÊàêË¶ÅÊâæ‰∏Ä‰∏™ÊØè‰∏™‰∏≤ÊòØÂêé‰∏Ä‰∏™‰∏≤Â≠ê‰∏≤ÁöÑÂ∫èÂàó„ÄÇ ‰∏ãÈù¢Êàë‰ª¨ËÆ§‰∏∫ÔºåËøô‰∏™Â∫èÂàó‰∏≠ÁöÑÂÖÉÁ¥†ÊòØ‰∏Ä‰∏™(ÂåÖÂê´‰ΩçÁΩÆÁöÑ)Â≠ê‰∏≤„ÄÇÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤Âá∫Áé∞Âú®‰∏çÂêå‰ΩçÁΩÆË¢´ËÆ§‰∏∫ÊòØ‰∏çÂêåÁöÑ„ÄÇ ÂÅáËÆæ‰Ω†Êúâ‰∏Ä‰∏™Â∫èÂàóÔºå‰Ω†‰∏ÄÂÆöÂèØ‰ª•Âú®‰∏çÊîπÂèòÈïøÂ∫¶ÁöÑÊÉÖÂÜµ‰∏ãÊääÂÆÉË∞ÉÊï¥ÊàêÁ¨¨ \(i\) ‰∏™Â≠ê‰∏≤Èïø‰∏∫ \(i\)„ÄÇÊâÄ‰ª•Êàë‰ª¨Âè™ËÄÉËôëËøôÁ±ªÂ∫èÂàó„ÄÇ Áß∞‰∏Ä‰∏™Â≠ê‰∏≤ \(s[l..r]\) ÊòØÂèØËææÁöÑÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏Ä‰∏™ËøôÁ±ªÂ∫èÂàó‰ª• \(s[l..r]\) ÁªìÂ∞æ„ÄÇÈ¢òÁõÆÂ∞±ÊòØË¶ÅÊ±ÇÊúÄÈïøÂèØËææÁöÑÂ≠ê‰∏≤„ÄÇ Ê≥®ÊÑèÂà∞Â¶ÇÊûú \(l &lt; r\)Ôºå\(s[l..r]\) ÂèØËææÔºåÈÇ£‰πà \(s[l..r-1]\) Âíå \(s[l+1..r]\) ‰∏ÄÂÆöÂèØËææ„ÄÇÂõ†Ê≠§Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(l\) Ê±ÇÂá∫ÊúÄÂ§ßÁöÑ \(r\) ‰ΩøÂæó \(s[l..r]\) ÂèØËææÔºåËÆæÂØπ‰∫é \(l=i\) ÊúÄÂ§ßÁöÑ \(r\) ÊòØ \(f_i\)„ÄÇÂØπ \(f\) ‰Ωú dpÔºåÊòæÁÑ∂ \(f_i \ge f_{i-1}\)ÔºåÊâÄ‰ª•ÊØèÊ¨°ÂÖà‰ª§ \(f_i = f_{i-1}\)ÔºåÁÑ∂ÂêéÊ£ÄÊü•‰∏Ä‰∏ã \(f_i\) ËÉΩ‰∏çËÉΩÂ¢ûÂ§ßÔºåÂ¶ÇÊûúËÉΩÂ¢ûÂ§ßÂ∞±‰∏ÄÁõ¥Â¢ûÂ§ßÂà∞‰∏çËÉΩÂ¢ûÂ§ßÂ∞±Ë°å‰∫Ü„ÄÇÊ£ÄÈ™åÂè™ÈúÄË¶ÅÂú® SAM ‰∏äÊâæÂà∞Ë¶ÅÊ£ÄÈ™åÁöÑ‰∏≤Âú®Êüê‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÊúÄÂêéÂá∫Áé∞‰ΩçÁΩÆÂ∞±Â•ΩÔºåËøôÂæàÂÆπÊòìÁî® SAM + Á∫øÊÆµÊ†ëÂÆûÁé∞Ôºà‰πüÂèØ‰ª•Áî®ÂÖ∂‰ªñÊñπÂºèÔºâ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™‰ºöÂ¢ûÂ§ß \(\mathcal O(n)\) Ê¨°ÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500010;int n, ans, f[maxn];char s[maxn];int last, tot, ch[maxn*2][26], par[maxn*2], len[maxn*2], ind[maxn];int tag[maxn*2], fa[maxn*2][20];int T_tot;int ls[maxn*40], rs[maxn*40], sum[maxn*40], trt[maxn*2];vector&lt;int&gt; son[maxn*2];void upd(int p, int l, int r, int &amp;rt) &#123; if (!rt) rt = ++ T_tot; ++ sum[rt]; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, l, m, ls[rt]); else upd(p, m+1, r, rs[rt]);&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; int ret = ++ T_tot; sum[ret] = sum[x] + sum[y]; ls[ret] = Merge(ls[x], ls[y]); rs[ret] = Merge(rs[x], rs[y]); return ret;&#125;void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) &#123;ch[last][c] = np; last = par[last];&#125; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; par[nq] = par[q], len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) &#123;ch[last][c] = nq; last = par[last];&#125; &#125; &#125; tag[np] = l; last = np;&#125;int qrys(int p, int l, int r, int rt) &#123; if (!rt || p &lt;= 0) return 0; if (r &lt;= p) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; ret += qrys(p, l, m, ls[rt]); if (p &gt; m) ret += qrys(p, m+1, r, rs[rt]); return ret;&#125;int qryk(int k, int l, int r, int rt) &#123; if (!rt || k &lt;= 0 || k &gt; sum[rt]) return 0; if (l == r) return l; int m = (l + r) &gt;&gt; 1; if (sum[ls[rt]] &gt;= k) return qryk(k, l, m, ls[rt]); else return qryk(k-sum[ls[rt]], m+1, r, rs[rt]);&#125;void dfs(int u) &#123; fa[u][0] = par[u]; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; if (tag[u]) upd(tag[u], 1, n, trt[u]); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); trt[u] = Merge(trt[u], trt[v]); &#125;&#125;// ÊúâÊ≤°ÊúâÂè≥Á´ØÁÇπÂú® x Êàñ‰πãÂâçÁöÑint check(int l, int r, int x) &#123; int u = ind[r]; for (int i = 19; i &gt;= 0; i--) &#123; if (len[fa[u][i]] &gt;= r-l+1) &#123; u = fa[u][i]; &#125; &#125; int s = qrys(x, 1, n, trt[u]); int p = qryk(s, 1, n, trt[u]); if (!p) return 0; int t = p - (r-l+1) + 1; return f[t] &gt;= p;&#125;int main() &#123; scanf("%d", &amp;n); scanf("%s", s+1); reverse(s + 1, s + n + 1); last = tot = 1; for (int i = 1; i &lt;= n; i++) &#123;addchar(s[i] - 'a', i); ind[i] = last;&#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); dfs(1); for (int l = 1; l &lt;= n; l++) &#123; f[l] = max(l, f[l-1]); while (f[l] + 1 &lt;= n) &#123; if (check(l+1, f[l]+1, l-1) || check(l, f[l], l-1)) &#123; ++ f[l]; &#125; else break; &#125; ans = max(ans, f[l] - l + 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces375E] Red and Black Tree]]></title>
    <url>%2F2020%2F03%2F18%2F375E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Êàë‰ª¨ÂÖà‰∏çË¶ÅËÄÉËôëËæπÊùÉ„ÄÇ ËÄÉËôëÁõ¥Êé• dpÔºå\(dp[u][i][j]\) Ë°®Á§∫ \(u\) ÁöÑÂ≠êÊ†ë‰∏≠‰øÆÊîπÂêéÊúâ \(i\) ‰∏™ÈªëÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøúÁöÑ‰∏éÂ≠êÊ†ë‰∏≠ÊâÄÊúâÈªëÁÇπË∑ùÁ¶ªÈÉΩÂ§ß‰∫é \(x\) ÁöÑÁ∫¢ÁÇπ‰∏éÊ†πÁöÑË∑ùÁ¶ª‰∏∫ \(j\)ÔºåÊúÄÂ∞èË¶Å‰øÆÊîπÂá†Ê¨°„ÄÇËΩ¨ÁßªÁöÑÊó∂ÂÄôÈúÄË¶ÅÂÜ≥ÂÆöË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÁ∫¢ÁÇπÔºåÊâÄ‰ª•ÈúÄË¶ÅÁü•ÈÅìË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÁöÑË∑ùÁ¶ªÔºå‰ΩÜÊòØÂ¶ÇÊûúÊàë‰ª¨ÂÜçËÆ∞‰∏Ä‰∏™ÊúÄËøëÈªëÁÇπÁöÑËØùÂ§çÊùÇÂ∫¶Â∞±ÁÇ∏‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞‰∏Ä‰∏™ÊÄßË¥®ÔºöÂ¶ÇÊûúÊ†πÊòØÁ∫¢ÁÇπÔºåË∑ùÁ¶ªÊ†πÊúÄËøëÁöÑÈªëÁÇπÊâÄÂú®ÁöÑ(Ê†πÁöÑÂÑøÂ≠êÁöÑ)Â≠êÊ†ë‰∏≠‰∏ÄÂÆöÊâÄÊúâÁ∫¢ÁÇπÈÉΩÂèØ‰ª•Âú®Ëøô‰∏™Â≠êÊ†ë‰∏≠ÊâæÂà∞Ë∑ùÁ¶ª‰∏çË∂ÖËøá \(x\) ÁöÑÈªëÁÇπ„ÄÇÊâÄ‰ª•Âè™Ë¶ÅÂØπ \(j = 0\) ÁöÑÊÉÖÂÜµÈ¢ùÂ§ñËÆ∞ÂΩï‰∏ãÊúÄËøëÁöÑÈªëÁÇπ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª• dp ‰∫Ü„ÄÇ Áé∞Âú®Êù•ËÄÉËôë‰∏Ä‰∏ãËæπÊùÉÔºåÊ≥®ÊÑèÂà∞Êàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÊääÊØè‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ùÁ¶ªÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåËøôÊ†∑Â∞±ËÉΩÂÅöÂ∏¶ÊùÉÁöÑÊÉÖÂÜµ‰∫Ü„ÄÇ ÂÜÖÂ≠òÈúÄË¶ÅÂç°‰∏Ä‰∏ã„ÄÇ È¢òËß£Á´üÁÑ∂ÊòØÂØπ \(500\) Á∫ßÂà´ÁöÑ‰∏úË•øË∑ëÂçïÁ∫ØÂΩ¢Ôºå‰∏çÂ§™ËÉΩÁêÜËß£Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n^3)\)„ÄÇÁªèËøáËâ∞ÈöæÁöÑË∞ÉËØïÂíåÂç°Â∏∏Áªà‰∫é A ‰∫Ü„ÄÇÔºàÊó∂Èôê 1000 msÔºåÂºÄ Ofast 982 msÔºå‰∏çÂºÄ Ofast 998 msÔºåTATÔºâ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 510;const int inf = 0x3f3f3f3f;vector&lt;ll&gt; vt;vector&lt;int&gt; lst[maxn];int n, x, l[maxn], sz[maxn], col[maxn], e, cb, cr, ty;ll dis[maxn];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;struct dat &#123; vector&lt;vector&lt;int&gt; &gt; f, g; int s; // f : Êúâ i ‰∏™ÈªëÁÇπÔºåÊâÄÊúâÁ∫¢ÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j // g : Êúâ i ‰∏™ÈªëÁÇπÔºåÊ≤°ÊúâÊú™ÂåπÈÖçÁ∫¢ÁÇπÔºåËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÈªëÁÇπÊ∑±Â∫¶‰∏çË∂ÖËøá j dat(int s_) &#123; s = s_; f = g = vector&lt;vector&lt;int&gt; &gt;(s + 1, vector&lt;int&gt;(n+2, inf)); &#125;&#125;;int getIndex(ll x) &#123; return int (lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;int upb(ll x) &#123; return int (upper_bound(vt.begin(), vt.end(), x) - vt.begin() + 1);&#125;inline int Min(int x, int y) &#123; return x &lt; y ? x : y;&#125;dat Merge(const dat &amp;d1, const dat &amp;d2, ll d, int u, int v) &#123; dat ret(d1.s + d2.s); for (int i = 0; i &lt; lst[v].size(); i++) lst[u].push_back(lst[v][i]); lst[u].push_back(1); for (int _ = 0; _ &lt;= lst[u].size(); _++) &#123; int i = n+1; if (_ &lt; lst[u].size()) i = lst[u][_]; int rb = upb(x + 2 * d - vt[i-1]) - 1; for (int s1 = 0; s1 &lt;= d1.s; s1++) &#123; for (int s2 = 0; s2 &lt;= d2.s; s2++) &#123; int s = s1 + s2; ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.f[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.g[s2][n+1]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][n+1] + d2.g[s2][i]); // ret.f[s][i] = Min(ret.f[s][i], d1.f[s1][i] + d2.g[s2][n+1]); // ret.f[s][i] = Min(ret.f[s][i], d1.g[s1][n+1] + d2.f[s2][i]); if (rb &gt;= 0) &#123; ret.g[s][i] = Min(ret.g[s][i], d1.f[s1][rb] + d2.g[s2][i]); ret.g[s][i] = Min(ret.g[s][i], d1.g[s1][i] + d2.f[s2][rb]); &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; lst[u].pop_back(); if (ty == 0) ret.s = min(ret.s, cb); else ret.s = min(ret.s, cr); return ret;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dfs1(v, u); sz[u] += sz[v]; &#125; &#125;&#125;dat dfs2(int u, int f) &#123; dat ret(1); int t = getIndex(dis[u]); lst[u].push_back(t); if (ty == 0) &#123; for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[1][i] = (col[u] != 1); &#125; else &#123; for (int i = t; i &lt;= n+1; i++) ret.f[1][i] = (col[u] != 0); for (int i = t; i &lt;= n+1; i++) ret.f[0][i] = (col[u] != 1); for (int i = t; i &lt;= n+1; i++) ret.g[0][i] = (col[u] != 1); &#125; for (int i = 0; i &lt;= ret.s; i++) &#123; for (int j = 1; j &lt;= n+1; j++) &#123; ret.g[i][j] = Min(ret.g[i][j], ret.g[i][j-1]); &#125; ret.f[i][1] = Min(ret.f[i][1], ret.g[i][n+1]); for (int j = 1; j &lt;= n+1; j++) &#123; ret.f[i][j] = Min(ret.f[i][j], ret.f[i][j-1]); &#125; &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; ret = Merge(ret, dfs2(v, u), dis[u], u, v); &#125; &#125; return ret;&#125;int main() &#123; // freopen("data.in", "r", stdin); memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); if (col[i]) ++ cb; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); cr = n - cb; if (cr &lt; cb) ty = 1; for (int i = 1; i &lt;= n; i++) vt.push_back(dis[i]); vt.push_back(ll(1e18)); sort(vt.begin(), vt.end()); dat res = dfs2(1, 0); int ans = inf; if (ty == 0) for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cb][i]); else for (int i = 0; i &lt;= n+1; i++) ans = min(ans, res.g[cr][i]); if (ans &lt; inf) printf("%d\n", ans / 2); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Âä®ÊÄÅËßÑÂàí</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces975E] Hag's Khashba]]></title>
    <url>%2F2020%2F03%2F18%2F975E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÂÖàÊ±ÇÈáçÂøÉÔºöÈöè‰æøÊâæ‰∏™ÁÇπÔºåÊääÂ§öËæπÂΩ¢ÂàíÂàÜÊàêËã•Âπ≤‰∏™‰∏âËßíÂΩ¢ÔºåÊ±ÇÂá∫ÊØè‰∏™‰∏âËßíÂΩ¢ÈáçÂøÉÔºåÊåâÊúâÂêëÈù¢ÁßØÂä†ÊùÉÂπ≥Âùá„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÁÇπ \((x_p,y_p)\)ÔºåËÆæ \(p = \begin{bmatrix} x_p \\ y_p \\ 1 \end{bmatrix}\)„ÄÇÊääÂÆÉÁªï \((x_0,y_0)\) ÈÄÜÊó∂ÈíàÊóãËΩ¨ \(c\) ÂºßÂ∫¶ÔºåÁõ∏ÂΩì‰∫éÊää \(p\) Â∑¶‰πò‰∏Ä‰∏™Áü©Èòµ \(\begin{bmatrix} \cos c &amp; -\sin c &amp; x_0+\sin c y_0 - \cos c x_0 \\ \sin c &amp; \cos c &amp; y_0 - \cos c y_0-\sin c x_0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)„ÄÇÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™ \(3 \times 3\) Áü©ÈòµÂ∞±ËÉΩÂø´ÈÄüËé∑ÂæóÊØè‰∏™ÁÇπÁöÑ‰ΩçÁΩÆ„ÄÇÊóãËΩ¨Êó∂ËÄÉËôë‰∏Ä‰∏ãÂõ∫ÂÆöÁöÑÁÇπÂíåÈáçÂøÉÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ Âê¨ÔºàÈ¢òËß£‰∏äÔºâËØ¥ÈúÄË¶ÅÊää‰∏Ä‰∏™ÁÇπÁßªÂà∞ \((0,0)\) ÈÅøÂÖçÁ≤æÂ∫¶ËØØÂ∑Æ„ÄÇ‰∏çÁü•ÈÅì‰∏çËøôÊ†∑ËÉΩ‰∏çËÉΩËøá„ÄÇ ÔºàÊ†∑‰æã 2 ÁúüÁöÑ‰ºöËΩ¨ÂêóÔºüÔºâ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n+m)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double ld;const int maxn = 10010;const ld eps = 1e-9;int n, q, p1, p2;struct Point &#123; ld x, y; Point (ld x_=0, ld y_=0) : x(x_), y(y_) &#123;&#125; ld abs() &#123; return sqrt(x * x + y * y); &#125;&#125; p[maxn], c;Point operator*(const ld &amp;k, const Point &amp;p) &#123; return Point(k * p.x, k * p.y);&#125;Point operator+(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x + b.x, a.y + b.y);&#125;Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;ld operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;struct Matrix &#123; ld a[3][3];&#125; cur;Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) &#123; Matrix ret; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ret.a[i][j] = 0; for (int k = 0; k &lt; 3; k++) &#123; ret.a[i][j] += m1.a[i][k] * m2.a[k][j]; &#125; &#125; &#125; return ret;&#125;Point cal(Point s) &#123; return Point(cur.a[0][0] * s.x + cur.a[0][1] * s.y + cur.a[0][2], cur.a[1][0] * s.x + cur.a[1][1] * s.y + cur.a[1][2]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;q); cur.a[0][0] = cur.a[1][1] = cur.a[2][2] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); p[i].x = x, p[i].y = y; &#125; Point _ = p[1]; for (int i = 1; i &lt;= n; i++) p[i] = p[i] - _; p1 = 1, p2 = 2; ld S = 0; p[n+1] = p[1]; for (int i = 1; i &lt;= n; i++) S += p[i] * p[i+1]; for (int i = 1; i &lt;= n; i++) &#123; Point cc((p[i].x + p[i+1].x) / 3, (p[i].y + p[i+1].y) / 3); c = c + p[i] * p[i+1] / S * cc; &#125; for (int i = 1; i &lt;= q; i++) &#123; int o; scanf("%d", &amp;o); if (o == 1) &#123; int f, t; scanf("%d%d", &amp;f, &amp;t); if (f == p2) swap(p1, p2); // Áé∞Âú®Áî® p2 ÊóãËΩ¨ Point nc = cal(c), np = cal(p[p2]); Point d = nc - np; /* if (d.x &lt; eps &amp;&amp; d.x &gt; -eps) &#123; p1 = t; continue; &#125; */ d = ld(1) / d.abs() * d; ld co = - d.y, si = - d.x; Matrix m; m.a[0][0] = co, m.a[0][1] = -si, m.a[0][2] = np.x + si * np.y - co * np.x; m.a[1][0] = si, m.a[1][1] = co, m.a[1][2] = np.y - co * np.y - si * np.x; m.a[2][0] = 0, m.a[2][1] = 0, m.a[2][2] = 1; cur = m * cur; p1 = t; &#125; else &#123; int v; scanf("%d", &amp;v); Point res = cal(p[v]); printf("%.10lf %.10lf\n", double (res.x + _.x), double (res.y + _.y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces235D] Graph Game]]></title>
    <url>%2F2020%2F03%2F17%2FCF235D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁúãÊàêÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™ÁÇπÊó∂‰ºöÁªôÂÆÉÊâÄÂú®ÁöÑËøûÈÄöÂùóÊØè‰∏™ÁÇπ‰∏Ä‰∏™Ë¥°ÁåÆ„ÄÇ ÂØπÊØè‰∏™ÁÇπÂØπ \((u,v)\) ËÆ°ÁÆó \(v\) ‰ºöÁªô \(u\) ‰∏Ä‰∏™Ë¥°ÁåÆÁöÑÊ¶ÇÁéáÔºå Âä†Ëµ∑Êù•Â∞±ÊòØÁ≠îÊ°à„ÄÇ È¢òÁõÆ‰∏≠ÁªôÂÆöÁöÑÂõæÊòØ‰∏ÄÊ£µÂü∫ÁéØÊ†ë„ÄÇ ÂØπ‰∫é \(u = v\)ÔºåËøô‰∏™Ê¶ÇÁéáÊòØ \(1\)„ÄÇÂØπ \(u \neq v\)ÔºåÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö ‰∏ÄÔºå \(u,v\) Âú®Âêå‰∏Ä‰∏™Â≠êÊ†ë‰∏≠„ÄÇÊää \(u\) Áúã‰ΩúÊ†πÔºåÈÇ£‰πàËøô‰∏™Ê¶ÇÁéáÂ∞±ÊòØÔºåÊØèÊ¨°‰ªéËøòÊú™Ë¢´Âà†Èô§ÁöÑÁÇπ‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÁÇπÔºåÂ∞ÜÂÖ∂Â≠êÊ†ëÂà†Èô§ÔºåÂΩì \(v\) Ë¢´Âà†Èô§Êó∂Ôºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÈô§‰∫Ü \(v\) ‰ª•Â§ñÁöÑÁÇπÈÉΩËøòÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéá„ÄÇËÆæÊÄªÂÖ±Êúâ \(n\) ‰∏™ÁÇπÔºå\(u\) Âà∞ \(v\) Ë∑ØÂæÑ‰∏äÊúâ \(k\) ‰∏™ÁÇπÔºåÁ±ª‰ººÁåé‰∫∫ÊùÄ‰∏ÄÈ¢ò‰∏≠ÁöÑÊäÄÂ∑ßÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìËøô‰∏™Ê¶ÇÁéáÁ≠â‰∫é‰∏çÊñ≠‰ªé \([1,n]\) ‰∏≠Á≠âÊ¶ÇÁéáÈöèÊú∫Âèñ‰∏Ä‰∏™Êï¥Êï∞Ôºå‰∏ÄÊó¶Âá∫Áé∞ \(v\) Êàñ \(v\) ÁöÑÁ•ñÂÖàÂ∞±ÂÅúÊ≠¢ÔºåÂÅúÊ≠¢Êó∂Èô§ \(v\) ‰ª•Â§ñ \(v\) ÁöÑÊâÄÊúâÁ•ñÂÖàÈÉΩÊú™Ë¢´Âà†Èô§ÁöÑÊ¶ÇÁéáÔºåÂç≥ \(\frac 1 n \sum_{i=0}^{\infty} (\frac{n-k}n) ^i = \frac 1 k\)„ÄÇ ‰∫åÔºå\(u,v\) ‰∏çÂú®Âêå‰∏ÄÂ≠êÊ†ë‰∏≠Ôºå‰∏éÊÉÖÂÜµ‰∏ÄÁ±ª‰ººÔºå‰ΩÜÊòØ‰∏çÂêåÁöÑÊòØÊ≠§Êó∂ \(u\) Âà∞ \(v\) Êúâ‰∏§Êù°Ë∑ØÂæÑÔºåÂè™Ë¶ÅÂÖ∂‰∏≠‰∏ÄÊù°Â≠òÂú®Â∞±ÊúâË¥°ÁåÆ„ÄÇÂèØ‰ª•ÂÆπÊñ•ÊàêÁ¨¨‰∏ÄÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂä†‰∏äÁ¨¨‰∫åÊù°Â≠òÂú®ÁöÑÊ¶ÇÁéáÂáèÂéª‰∏§Êù°ÈÉΩÂ≠òÂú®ÁöÑÊ¶ÇÁéá„ÄÇËøô‰∏â‰∏™ÈóÆÈ¢òÈÉΩÂèØ‰ª•Á±ª‰ººÊÉÖÂÜµ‰∏ÄÂú∞Ëß£ÂÜ≥„ÄÇ ËøôÊ†∑Â∞±Âú® \(\mathcal O(n^2)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥‰∫ÜÊú¨È¢ò„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;double ans = 0;int n, l[maxn], e = 0;int deg[maxn], dep[maxn], a[maxn], tot;vector&lt;int&gt; sub[maxn], son[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs(int u) &#123; sub[u].push_back(u); for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dep[v] = dep[u] + 1; dfs(v); for (int _1 = 0; _1 &lt; sub[u].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[v].size(); _2++) &#123; int x = sub[u][_1], y = sub[v][_2]; int d = dep[x] + dep[y] - 2 * dep[u] + 1; ans += double (1) / d; &#125; &#125; for (int _ = 0; _ &lt; sub[v].size(); _++) sub[u].push_back(sub[v][_]); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ++ u, ++ v; addEdge(u, v), addEdge(v, u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; Q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 1) Q.push(i); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2) &#123; -- deg[v]; if (deg[v] == 1) Q.push(v); son[v].push_back(u); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; int u = i, last = 0; do &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (deg[v] &gt;= 2 &amp;&amp; v != last) &#123; last = u; u = v; break; &#125; &#125; a[++ tot] = u; &#125; while (u != i); break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt;= 2) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i+1; j &lt;= tot; j++) &#123; for (int _1 = 0; _1 &lt; sub[a[i]].size(); _1++) &#123; for (int _2 = 0; _2 &lt; sub[a[j]].size(); _2++) &#123; int u = sub[a[i]][_1], v = sub[a[j]][_2]; ans += double (1) / (dep[u] + dep[v] + j - i + 1); ans += double (1) / (dep[u] + dep[v] + tot - j + i + 1); ans -= double (1) / (dep[u] + dep[v] + tot); &#125; &#125; &#125; &#125; ans = ans * 2 + n; printf("%.10lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞Â≠¶</tag>
        <tag>Ê¶ÇÁéá</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces700D] Huffman Coding on Segment]]></title>
    <url>%2F2020%2F03%2F17%2FCF700D%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊÉ≥‰∫ÜÊå∫‰πÖÂè™‰ºöËÉ°‰∏™ \(\mathcal O(n \sqrt n \log n)\) ÁöÑËé´Èòü + Áª¥Êä§ huffman Ê†ëÔºåÂéªÁúã‰∫ÜÁúºÂà´‰∫∫ÁöÑÈ¢òËß£ÂèëÁé∞‰πüÊúâÊòØËøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ.....‰∏çËøáÊØîÊàëËÉ°ÁöÑÂ¶ôÂ§ö‰∫ÜÔºå‰∏ãÈù¢ÂÜôÁöÑÊòØÁúãÂà∞ÁöÑÂà´‰∫∫ÁöÑÂÅöÊ≥ï„ÄÇ Áî®Ëé´ÈòüÂ§ÑÁêÜËØ¢ÈóÆÔºåÁª¥Êä§‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÔºåÂπ∂ËÆ∞ÂΩï‰∏ãÂΩìÂâçÂá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞„ÄÇÂØπÊ¨°Êï∞‰∏çË∂ÖËøá \(x\) ÁöÑÊï∞ÔºåËÆ∞‰∏Ä‰∏ãÊØè‰∏™Êï∞Âá∫Áé∞Âá†Ê¨°ÁÑ∂Âêé \(\mathcal O(x)\) ÁÆóÂá∫ÂêàÂπ∂‰ª£‰ª∑„ÄÇËΩ¨Âåñ‰∏∫Âè™ÊúâÂá∫Áé∞Ê¨°Êï∞Ë∂ÖËøá \(x\) ÁöÑÊï∞ÁöÑÊÉÖÂÜµÔºåËøôÊó∂ÊúÄÂ§öÂè™Êúâ \(\frac n x\) ‰∏™Êï∞ÔºåË¥™ÂøÉÂêàÂπ∂Âç≥ÂèØ„ÄÇËØ¢ÈóÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(x + \frac n x \log n)\)ÔºåÂèñ \(x = \sqrt {n \log n}\)ÔºåÂàô‰∏ÄÊ¨°ËØ¢ÈóÆÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\sqrt {n \log n}\)„ÄÇ Ëé´ÈòüÁª¥Êä§Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é \(x\) ÁöÑÊï∞Êó∂ÂèØ‰ª•‰ΩøÁî®ÈìæË°®ÔºåËøôÊ†∑ÁöÑËØùËé´ÈòüÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int sqr = int (sqrt(maxn) * 20);const int _sqr = int (sqrt(maxn));int n, q;int a[maxn], ql[maxn], qr[maxn];int ind[maxn], ans[maxn], cnt[maxn], cc[maxn], ncnt[maxn];list&lt;int&gt; st;list&lt;int&gt;::iterator p[maxn];int cmp(int x, int y) &#123; if (ql[x] / _sqr == ql[y] / _sqr) return qr[x] &lt; qr[y]; return ql[x] &lt; ql[y];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d", &amp;ql[i], &amp;qr[i]); for (int i = 1; i &lt;= q; i++) ind[i] = i; sort(ind + 1, ind + q + 1, cmp); int curl = 1, curr = 0; cc[0] = 100000; for (int _ = 1; _ &lt;= q; _++) &#123; int x = ind[_]; int l = ql[x], r = qr[x]; while (curl &gt; l) &#123; -- curl; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); ++ cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; &#125; while (curr &lt; r) &#123; ++ curr; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); ++ cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; &#125; while (curl &lt; l) &#123; -- cc[cnt[a[curl]]]; if (cnt[a[curl]] &gt;= sqr) st.erase(p[a[curl]]); -- cnt[a[curl]]; if (cnt[a[curl]] &gt;= sqr) p[a[curl]] = st.insert(st.end(), cnt[a[curl]]); ++ cc[cnt[a[curl]]]; ++ curl; &#125; while (curr &gt; r) &#123; -- cc[cnt[a[curr]]]; if (cnt[a[curr]] &gt;= sqr) st.erase(p[a[curr]]); -- cnt[a[curr]]; if (cnt[a[curr]] &gt;= sqr) p[a[curr]] = st.insert(st.end(), cnt[a[curr]]); ++ cc[cnt[a[curr]]]; -- curr; &#125; // cal ans[x] priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; nst; for (list&lt;int&gt;::iterator iter = st.begin(); iter != st.end(); ++ iter) nst.push(* iter); for (int i = 1; i &lt; sqr; i++) ncnt[i] = cc[i]; for (int i = 1; i &lt; sqr; i++) &#123; if (ncnt[i]) &#123; if (2*i &lt; sqr) &#123; ncnt[2*i] += ncnt[i] / 2; &#125; else &#123; int T = ncnt[i] / 2; while (T--) nst.push(2*i); &#125; ans[x] += 2 * i * (ncnt[i] / 2); ncnt[i] &amp;= 1; if (ncnt[i]) &#123; int f = 0; for (int j = i+1; j &lt; sqr; j++) &#123; if (ncnt[j]) &#123; f = j; break; &#125; &#125; if (!f) nst.push(i); else &#123; -- ncnt[f]; ans[x] += i + f; if (i + f &lt; sqr) ++ ncnt[i + f]; else nst.push(i + f); &#125; &#125; &#125; &#125; while (nst.size() &gt;= 2) &#123; int a = nst.top(); nst.pop(); int b = nst.top(); nst.pop(); ans[x] += a + b; nst.push(a + b); &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ë¥™ÂøÉ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces319E] Ping-Pong]]></title>
    <url>%2F2020%2F03%2F17%2FCF319E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï È¢òÁõÆ‰∏≠ÁöÑËøûËæπÊñπÂºèÂèØ‰ª•Ê¶ÇÊã¨‰∏∫ÔºåÂ¶ÇÊûú(ÂºÄ)Âå∫Èó¥ \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∫§‰∏ç‰∏∫Á©∫Ôºå‰∏î \((l_1,r_1)\) ‰∏é \((l_2,r_2)\) ‰∏çÊòØ‰∏ÄÂØπÂ≠òÂú®ÂåÖÂê´ÂÖ≥Á≥ªÁöÑÂå∫Èó¥ÔºåÈÇ£‰πàËøô‰∏§‰∏™Âå∫Èó¥‰πãÈó¥Êúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇÂê¶ÂàôÔºåÂ¶ÇÊûú \((l_1,r_1)\) Ë¢´ \((l_2,r_2)\) ÂåÖÂê´Ôºå\((l_1,r_1)\) Âà∞ \((l_2,r_2)\) Êúâ‰∏ÄÊù°ÊúâÂêëËæπ„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™‰ªÖÁî±ÂèåÂêëËæπÊûÑÊàêÁöÑËøûÈÄöÂùóÔºåËÆæËøô‰∏™ËøûÈÄöÂùó‰∏≠ÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂‰∏∫ \((L,R)\)ÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ§‰∏∫Áé∞Âú®Â∞±Â≠òÂú®ËøôÊ†∑‰∏Ä‰∏™Âå∫Èó¥ \((L,R)\)„ÄÇÂõ†‰∏∫ÈïøÂ∫¶ÊòØÈÄíÂ¢ûÁöÑÔºåÂ¶ÇÊûú‰πãÂêéÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ \((a,b)\)Ôºå\(a\) Ë¢´ \((L,R)\) ÂåÖÂê´ÊàñËÄÖ \(b\) Ë¢´ \((L,R)\) ÂåÖÂê´ÔºåÈÇ£‰πà \((a,b)\) ‰∏éËøô‰∏™ËøûÈÄöÂùó‰∏≠ÁöÑÊüê‰∏™ÁÇπÊúâ‰∏ÄÊù°ÂèåÂêëËæπ„ÄÇ‰∏çÈöæÂèëÁé∞Ôºå‰∏Ä‰∏™Âå∫Èó¥ \(a\) ËÉΩÂà∞ËææÂå∫Èó¥ \(b\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØ \(a\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Ë¢´ \(b\) ÊâÄÂú®ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂ÂåÖÂê´„ÄÇËøôÊ†∑Êàë‰ª¨Âè™Ë¶ÅÁî®Âπ∂Êü•ÈõÜÁª¥Êä§ËøûÈÄöÂùóÔºåÂπ∂ËÆ∞ÂΩï‰∏Ä‰∏ãËøûÈÄöÂùóÁöÑÂπ∂ÁöÑÂ∑¶Âè≥Á´ØÁÇπÔºåÂ∞±ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ËÉΩÂê¶Âà∞Ëææ‰∫Ü„ÄÇ update : ‰ªîÁªÜËØÅ‰∫Ü‰∏Ä‰∏ã‰πãÂêé‰ºº‰πéËøô‰∏ÄÁªìËÆ∫ÂÜç‰∏§‰∏™ËøûÈÄöÂùóÊâÄÊúâÂå∫Èó¥ÁöÑÂπ∂Áõ∏ÂêåÊó∂‰∏çÊàêÁ´ãÔºåÈúÄË¶ÅÁâπÂà´Âà§‰∏Ä‰∏ã‰ºö‰∏ç‰ºöÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂè™Êúâ‰∏Ä‰∏™ÁÇπ„ÄÇ Êàë‰ª¨Áî®Á∫øÊÆµÊ†ëÁª¥Êä§ÔºåÂØπ‰∫éÊØè‰∏™ÁÇπÊúâÂì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´Ëøô‰∏™ÁÇπ„ÄÇËøôÂèØ‰ª•ÈÄöËøáÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™ÁÇπÂºÄ‰∏Ä‰∏™ vector Êù•ÂÆûÁé∞ÔºåÊü•ËØ¢Âì™‰∫õËøûÈÄöÂùóÁöÑÂπ∂ÂåÖÂê´‰∏Ä‰∏™ÁÇπÊó∂ÔºåÂè™ÈúÄÂèñËøô‰∏™ÁÇπÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÊâÄÊúâ vector ÁöÑÂπ∂Âç≥ÂèØ„ÄÇÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÔºåÂ∞±ÂØπÂ∑¶Âè≥Á´ØÁÇπÊü•‰∏Ä‰∏ãÔºåÊääÂæóÂà∞ÁöÑËøûÈÄöÂùóÂêàÂπ∂ÔºåÁÑ∂ÂêéÂÜçÊääÊñ∞ÁöÑËøûÈÄöÂùóÂä†ÂÖ•Á∫øÊÆµÊ†ë„ÄÇÁî±‰∫éÊâÄÊúâË¢´‰Ω†Êü•ËøáÁöÑÁÇπ vector ‰∏≠ÊâÄÊúâÁÇπÈÉΩ‰ºöË¢´‰Ω†ÂêàÂπ∂ÔºåÊâÄ‰ª•‰Ω†ÊØèÊü•ËØ¢‰∏Ä‰∏™ÁÇπÁöÑ vector Â∞±ÂèØ‰ª•ÊääÂÆÉÁöÑ vector Ê∏ÖÁ©∫ÔºåËÄåÊØèÂä†ÂÖ•‰∏Ä‰∏™Âå∫Èó¥ÊúÄÂ§öÂ¢ûÂä†‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†Âè™‰ºöÁªô \(\mathcal O(\log n)\) ‰∏™ÁÇπÁöÑ vector Ê∑ªÂä†ÂÖÉÁ¥†„ÄÇÊâÄ‰ª•Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n \alpha (n))\)„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010*2;const int maxw = 1e9;vector&lt;int&gt; tmp;int n, c;int L[maxn], R[maxn], fa[maxn];int qo[maxn], qx[maxn], qy[maxn];vector&lt;int&gt; T[maxn&lt;&lt;2];vector&lt;int&gt; vres;int getroot(int x) &#123; if (x == fa[x]) return x; return fa[x] = getroot(fa[x]);&#125;void upd(int L, int R, int x, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; T[rt].push_back(x); return; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) upd(L, R, x, l, m, rt&lt;&lt;1); if (R &gt; m) upd(L, R, x, m+1, r, rt&lt;&lt;1|1);&#125;void qry(int p, int l, int r, int rt) &#123; vres.insert(vres.end(), T[rt].begin(), T[rt].end()); T[rt].clear(); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) qry(p, l, m, rt&lt;&lt;1); else qry(p, m+1, r, rt&lt;&lt;1|1);&#125;// x ÊòØÊ†πÔºåÊää y Âä†ÂÖ• xvoid Union(int x, int y) &#123; int ry = getroot(y); fa[ry] = x; L[x] = min(L[x], L[ry]); R[x] = max(R[x], R[ry]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;qo[i], &amp;qx[i], &amp;qy[i]); if (qo[i] == 1) &#123; tmp.push_back(qx[i]), tmp.push_back(qy[i]); &#125; &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; qx[i] = int (lower_bound(tmp.begin(), tmp.end(), qx[i]) - tmp.begin() + 1); qy[i] = int (lower_bound(tmp.begin(), tmp.end(), qy[i]) - tmp.begin() + 1); ++ c; L[c] = qx[i], R[c] = qy[i]; fa[c] = c; &#125; &#125; int _c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (qo[i] == 1) &#123; ++ _c; vres.clear(); int l = qx[i], r = qy[i]; qry(l, 1, 2*n, 1), qry(r, 1, 2*n, 1); for (int i = 0; i &lt; vres.size(); i++) Union(_c, vres[i]); upd(L[_c]+1, R[_c]-1, _c, 1, 2*n, 1); &#125; else &#123; int rx = getroot(qx[i]), ry = getroot(qy[i]); if (L[rx] &gt;= L[ry] &amp;&amp; R[rx] &lt;= R[ry]) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces504E] Misha and LCP on Tree]]></title>
    <url>%2F2020%2F03%2F16%2FCF504E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ‰ΩúÈáçÈìæÂâñÂàÜÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÈáçÈìæÂâñÂàÜÂêéÁöÑ dfs Â∫è„ÄÇ ‰∏ÄÊù°ÈìæÂèØ‰ª•ÊãÜÊàê dfs Â∫è‰∏ä \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥„ÄÇ Êåâ dfs Â∫èÊääÊØè‰∏™ÁÇπÁöÑÂ≠óÁ¨¶ÊéíÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\)ÔºåÈ¢ÑÂÖàÂª∫‰∏Ä‰∏™ËÉΩ \(\mathcal O(1)\) ËØ¢ÈóÆ \(s\) ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcpÔºåËØ¢ÈóÆ \(s^R\) ‰ªªÊÑè‰∏§‰∏™ÂêéÁºÄ lcp ÂíåËØ¢ÈóÆ‰∏Ä‰∏™ \(s\) ÁöÑÂêéÁºÄÂíå \(s^R\) ÁöÑ‰∏Ä‰∏™ÂêéÁºÄÁöÑ lcp ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂèØ‰ª•ÂØπ \(ss^R\) Âª∫Ê†ëÁä∂Êï∞ÁªÑÔºåÂõ†‰∏∫Êàë‰∏çÊìÖÈïøÂÜôÊ†ëÁä∂Êï∞ÁªÑÔºåÊâÄ‰ª•ÊàëÂØπÂÆÉ‰ª¨Áî® SAM Ê±ÇÂá∫‰∫ÜÂêéÁºÄÊ†ëÔºåÁÑ∂ÂêéÂÜô‰∫Ü‰∏Ä‰∏™ \(\mathcal O(n\log n) - \mathcal O(1)\) lca„ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ËØ¢ÈóÆÔºå‰∏ÄÊù°ÈìæÔºåÂèØ‰ª•ÁúãÊàê \(\mathcal O(\log n)\) ‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÔºåÊâÄ‰ª•Â∞±ÂèòÊàê‰∫Ü‰∏§ÁªÑËã•Âπ≤‰∏™Âå∫Èó¥ÊãºËµ∑Êù•ÁöÑ‰∏≤Ë¶ÅÊ±Ç lcpÔºåÂà©Áî®È¢ÑÂ§ÑÁêÜÁöÑ‰ø°ÊÅØ‰ªéÂâçÂæÄÂêé‰æùÊ¨°Ê±ÇÂ∞±Ë°å‰∫Ü„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, q, l[maxn], e;int son[maxn], sz[maxn], top[maxn], dep[maxn];int dfn[maxn], idfn[maxn], fa[maxn], tim;char str[maxn];struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;void dfs1(int u, int f) &#123; sz[u] = 1; fa[u] = f; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); sz[u] += sz[v]; if (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++ tim; idfn[tim] = u; if (son[u]) dfs2(son[u], t); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa[u] &amp;&amp; v != son[u]) &#123; dfs2(v, v); &#125; &#125;&#125;struct LCP &#123; // ÂÜô‰∏Ä‰∏™Áªô‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊîØÊåÅËØ¢ÈóÆ LCP ÁöÑ‰∏úË•ø int tot, last, tim, n; int ch[maxn*4][26], par[maxn*4], len[maxn*4], dfn[maxn*4], idfn[maxn*4], a[maxn*4], ind[maxn], rind[maxn]; int mnl[maxn*4][22], mnr[maxn*4][22], lg[maxn*4], mn; vector&lt;int&gt; son[maxn*4]; void addchar(int c, int l) &#123; int np = ++ tot; len[np] = l; while (last &amp;&amp; !ch[last][c]) ch[last][c] = np, last = par[last]; if (!last) par[np] = 1; else &#123; int q = ch[last][c]; if (len[q] == len[last] + 1) par[np] = q; else &#123; int nq = ++ tot; len[nq] = len[last] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while (last &amp;&amp; ch[last][c] == q) ch[last][c] = nq, last = par[last]; &#125; &#125; last = np; &#125; void dfs(int u) &#123; dfn[u] = ++ tim; idfn[tim] = u; a[tim] = min(mn, len[u]); mn = len[u]; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); mn = min(mn, len[u]); &#125; &#125; int _lcp(int p1, int p2) &#123; if (p1 == p2) return 2*n - p1 + 1; p1 = dfn[p1], p2 = dfn[p2]; if (p1 &gt; p2) swap(p1, p2); int l = p1 + 1, r = p2; int len = r - l + 1; int t = lg[len]; return min(mnr[l][t], mnl[r][t]); &#125; int lcp(int l1, int r1, int l2, int r2) &#123; int len1 = abs(r1 - l1) + 1, len2 = abs(r2 - l2) + 1; int res = min(len1, len2); if (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(ind[l1], ind[l2])); if (l1 &lt;= r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(ind[l1], rind[n - l2 + 1])); if (l1 &gt; r1 &amp;&amp; l2 &lt;= r2) res = min(res, _lcp(rind[n - l1 + 1], ind[l2])); if (l1 &gt; r1 &amp;&amp; l2 &gt; r2) res = min(res, _lcp(rind[n - l1 + 1], rind[n - l2 + 1])); return res; &#125; void init(string s) &#123; n = int (s.size()); tot = last = 1; string rs = s; reverse(rs.begin(), rs.end()); // ind ÊòØÊ≠£‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ // rind ÊòØÂèç‰∏≤ÂêéÁºÄÂØπÂ∫îÁÇπ for (int i = 0; i &lt; rs.size(); i++) &#123; addchar(rs[i] - 'a', i+1); ind[n - i] = last; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; addchar(s[i] - 'a', i + 1 + n); rind[n - i] = last; &#125; for (int i = 2; i &lt;= tot; i++) son[par[i]].push_back(i); for (int i = 0; (1&lt;&lt;i) &lt;= tot; i++) lg[1&lt;&lt;i] = i; for (int i = 1; i &lt;= tot; i++) if (!lg[i]) lg[i] = lg[i-1]; mn = 0x3f3f3f3f; dfs(1); // cal mnl, mnr for (int i = 1; i &lt;= tot; i++) &#123; mnl[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i - (1&lt;&lt;j) + 1 &gt;= 1; j++) &#123; mnl[i][j] = min(mnl[i][j-1], mnl[i-(1&lt;&lt;(j-1))][j-1]); &#125; &#125; for (int i = tot; i &gt;= 1; i--) &#123; mnr[i][0] = a[i]; for (int j = 1; j &lt;= 21 &amp;&amp; i + (1&lt;&lt;j) - 1 &lt;= tot; j++) &#123; mnr[i][j] = min(mnr[i][j-1], mnr[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125; &#125;&#125; L;struct Seg &#123; int l, r; Seg(int l_=0, int r_=0) : l(l_), r(r_) &#123;&#125;&#125;;vector&lt;Seg&gt; cal(int u, int v) &#123; vector&lt;Seg&gt; ret1, ret2; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) &#123; ret1.push_back(Seg(dfn[u], dfn[top[u]])); u = fa[top[u]]; &#125; else &#123; ret2.push_back(Seg(dfn[top[v]], dfn[v])); v = fa[top[v]]; &#125; &#125; if (dep[u] &gt; dep[v]) &#123; ret1.push_back(Seg(dfn[u], dfn[v])); &#125; else &#123; ret2.push_back(Seg(dfn[u], dfn[v])); &#125; reverse(ret2.begin(), ret2.end()); vector&lt;Seg&gt; ret = ret1; for (int i = 0; i &lt; ret2.size(); i++) ret.push_back(ret2[i]); return ret;&#125;int lcp(vector&lt;Seg&gt; v1, vector&lt;Seg&gt; v2) &#123; int ret = 0; int i1 = 0, i2 = 0; while (i1 &lt; v1.size() &amp;&amp; i2 &lt; v2.size()) &#123; int t = L.lcp(v1[i1].l, v1[i1].r, v2[i2].l, v2[i2].r); if (!t) break; // cout &lt;&lt; t &lt;&lt; endl; // exit(0); ret += t; if (v1[i1].l &lt;= v1[i1].r) &#123; v1[i1].l += t; if (v1[i1].l &gt; v1[i1].r) ++ i1; &#125; else &#123; v1[i1].l -= t; if (v1[i1].l &lt; v1[i1].r) ++ i1; &#125; if (v2[i2].l &lt;= v2[i2].r) &#123; v2[i2].l += t; if (v2[i2].l &gt; v2[i2].r) ++ i2; &#125; else &#123; v2[i2].l -= t; if (v2[i2].l &lt; v2[i2].r) ++ i2; &#125; &#125; return ret;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", str+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); string s; for (int i = 1; i &lt;= n; i++) s.push_back(str[idfn[i]]); L.init(s); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", lcp(cal(a, b), cal(c, d))); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces587F] Duff is Mad]]></title>
    <url>%2F2020%2F03%2F16%2FCF587F%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ËÄÉËôëÊåâ‰∏≤ÈïøÊ†πÂè∑ÂàÜÁ±ª„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ§ß‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåËøôÊ†∑ÁöÑ‰∏≤‰∏ç‰ºöÂæàÂ§öÔºåÊûö‰∏æÊØè‰∏™ËøôÊ†∑ÁöÑ‰∏≤ÔºåÁî® AC Ëá™Âä®Êú∫ÁªüËÆ°ÂÖ∂‰ªñÊØè‰∏™‰∏≤‰Ωú‰∏∫Ëøô‰∏™‰∏≤Â≠ê‰∏≤Âá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÆó‰∏Ä‰∏ãÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÂõûÁ≠î‰∏Ä‰∏ãÂÖ≥‰∫éËøô‰∏™‰∏≤ÁöÑÊâÄÊúâËØ¢ÈóÆ„ÄÇ ÂØπ‰∫é‰∏≤ÈïøÂ∞è‰∫éÁ≠â‰∫é \(\sqrt n\) ÁöÑ‰∏≤ÔºåÊääËØ¢ÈóÆ \([l,r]\) ÊãÜÊàê \([1,r]\) Âíå \([1,l-1]\) Áõ∏ÂáèÔºåÁÑ∂Âêé‰ªéÂâçÂæÄÂêéÊâ´ÊØè‰∏™ÂâçÁºÄÔºåÂõûÁ≠î‰∏éÊØè‰∏™ÂâçÁºÄÁõ∏ÂÖ≥ÁöÑÊâÄÊúâÂõûÁ≠î„ÄÇÂú®Êâ´ÂâçÁºÄÁöÑËøáÁ®ã‰∏≠ÔºåÁî®‰∏Ä‰∏™ AC Ëá™Âä®Êú∫ \(\mathcal O(‰∏≤Èïø)\) ËØ¢ÈóÆËøô‰∏™ÂâçÁºÄ‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êüê‰∏™‰∏≤ÁöÑÂ≠ê‰∏≤Âç≥ÂèØ„ÄÇÈÇ£‰πàÂè™ÈúÄË¶ÅÂú® AC Ëá™Âä®Êú∫‰∏äÂÆûÁé∞‰∏Ä‰∏™ fail Ê†ë‰∏äÁöÑÂ≠êÊ†ëÂä†ÔºàÂä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑ‰∏≤ÔºâÔºåÂú® dfs Â∫è‰∏äËΩ¨‰∏∫Âå∫Èó¥Âä†ÔºåÁî®ÂàÜÂùóÂÅöÂà∞ \(\mathcal O(\sqrt n)\) Âå∫Èó¥Âä†Ôºå \(\mathcal O(1)\) ÂçïÁÇπËØ¢ÈóÆÂ∞±Ë°å‰∫Ü„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\sqrt n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100010;const int sqr = int (sqrt(maxn));char buf[maxn];int n, q, ql[maxn], qr[maxn], qk[maxn];ll ans[maxn];string s[maxn];vector&lt;int&gt; vq1[maxn], vq2[maxn];namespace FQ &#123; // Block i : (i-1)*sqr + 1, i*sqr int a[maxn], ba[maxn]; void add(int l, int r, int v) &#123; if (r-l+1 &lt;= sqr) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] += v; &#125; return; &#125; while (l % sqr != 1) a[l] += v, ++ l; while (r % sqr != 0) a[r] += v, -- r; int lb = (l-1)/sqr+1, rb = (r-1)/sqr+1; for (int i = lb; i &lt;= rb; i++) ba[i] += v; &#125; int ask(int p) &#123; return a[p] + ba[(p-1)/sqr+1]; &#125;&#125;;struct ACAuto &#123; vector&lt;int&gt; son[maxn]; int ch[maxn][26], fail[maxn], Q[maxn], tim; int dfn[maxn], sz[maxn], ind[maxn], tot; int sum[maxn]; ACAuto() &#123;tot = 1, tim = 0;&#125; int addStr(string s) &#123; int cur = 1; for (int i = 0; i &lt; s.size(); i++) &#123; int x = s[i] - 'a'; if (!ch[cur][x]) ch[cur][x] = ++ tot; cur = ch[cur][x]; &#125; return cur; &#125; void dfs(int u) &#123; sz[u] = 1, dfn[u] = ++ tim; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs(v); sz[u] += sz[v]; &#125; &#125; void build() &#123; int s = 0, t = 0; fail[1] = 1; for (int i = 0; i &lt; 26; i++) &#123; if (ch[1][i]) &#123; fail[ch[1][i]] = 1; Q[t++] = ch[1][i]; &#125; else ch[1][i] = 1; &#125; while (s &lt; t) &#123; int u = Q[s++]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; Q[t++] = ch[u][i]; &#125; else ch[u][i] = ch[fail[u]][i]; &#125; &#125; for (int i = 2; i &lt;= tot; i++) son[fail[i]].push_back(i); dfs(1); &#125; void dfs_sum(int u) &#123; for (int i = 0; i &lt; son[u].size(); i++) &#123; int v = son[u][i]; dfs_sum(v); sum[u] += sum[v]; &#125; &#125;&#125; A;ll cnt[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", buf); s[i] = buf; &#125; for (int i = 1; i &lt;= q; i++) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); ql[i] = l, qr[i] = r, qk[i] = k; if (s[k].size() &gt; sqr) &#123; vq1[k].push_back(i); &#125; else &#123; vq2[l-1].push_back(-i); vq2[r].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) A.ind[i] = A.addStr(s[i]); A.build(); for (int i = 1; i &lt;= n; i++) &#123; FQ::add(A.dfn[A.ind[i]], A.dfn[A.ind[i]] + A.sz[A.ind[i]] - 1, 1); for (int _ = 0; _ &lt; vq2[i].size(); _++) &#123; int x = vq2[i][_], K = 1; if (x &lt; 0) K = -K, x = -x; int cur = 1; for (int j = 0; j &lt; s[qk[x]].size(); j++) &#123; cur = A.ch[cur][s[qk[x]][j]-'a']; ans[x] += K * FQ::ask(A.dfn[cur]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i].size() &gt; sqr) &#123; for (int j = 0; j &lt;= n; j++) cnt[j] = 0; for (int j = 1; j &lt;= A.tot; j++) A.sum[j] = 0; int cur = 1; for (int j = 0; j &lt; s[i].size(); j++) &#123; cur = A.ch[cur][s[i][j]-'a']; ++ A.sum[cur]; &#125; A.dfs_sum(1); for (int j = 1; j &lt;= n; j++) cnt[j] = A.sum[A.ind[j]]; for (int j = 1; j &lt;= n; j++) cnt[j] += cnt[j-1]; for (int j = 0; j &lt; vq1[i].size(); j++) &#123; int x = vq1[i][j]; ans[x] += cnt[qr[x]] - cnt[ql[x]-1]; &#125; &#125; &#125; for (int i = 1; i &lt;= q; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces150E] Freezing with Style!]]></title>
    <url>%2F2020%2F03%2F16%2FCF150E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÊòæÁÑ∂ÂèØ‰ª•‰∫åÂàÜÁ≠îÊ°àÔºåËΩ¨Âåñ‰∏∫ËøôÊ†∑‰∏Ä‰∏™ÈóÆÈ¢òÔºöÊØè‰∏™ËæπÁöÑËæπÊùÉÊòØÊ≠£Ë¥ü‰∏ÄÔºåÂà§Êñ≠ÊòØÂê¶ÊúâÈïøÂ∫¶Âú® \(l\) Âà∞ \(r\) ‰πãÈó¥ÁöÑË∑ØÂæÑÔºåÊùÉÂÄº‰πãÂíåÈùûË¥ü„ÄÇ ‰ªé‰∏ãÂæÄ‰∏äÂêàÂπ∂ÔºåÊØèÊ¨°ËÄÉËôëÂΩìÂâçÁÇπ‰Ωú‰∏∫ lca ÁöÑÊÉÖÂÜµÔºåÁÑ∂ÂêéÊääÂ≠êÊ†ëÂêàÂπ∂ÔºåÁî±‰∫é‰Ω†ÂêàÂπ∂Êó∂Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™ÁÇπÂ≠êÊ†ë‰∏≠ÊØè‰∏™Ê∑±Â∫¶Âà∞Ê†πÊùÉÂÄºÂíåÊúÄÂ§ßÁöÑÁÇπÔºåÂèØ‰ª•Áî®ÈïøÈìæÂâñÂàÜÊù•Áª¥Êä§Ê∑±Â∫¶‰ø°ÊÅØ„ÄÇÂêàÂπ∂ÁöÑÊó∂ÂÄôÈ°∫‰æøËØ¢ÈóÆ‰∏Ä‰∏ãÁ≠îÊ°àÔºåÈïøÈìæÂâñÂàÜ + Á∫øÊÆµÊ†ëÂç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;const int inf = 0x3f3f3f3f;typedef pair&lt;int,int&gt; pi;int n, L, R, ca, ru, rv;int l[maxn], dep[maxn], dis[maxn], mx[maxn], son[maxn], e = 0;int tot, ls[maxn*20], rs[maxn*20], trt[maxn];pi T[maxn*20];struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;void dfs1(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dep[v] = dep[u] + 1; dfs1(v, u); if (!son[u] || mx[v] &gt; mx[son[u]]) son[u] = v, mx[u] = mx[v] + 1; &#125; &#125;&#125;void dfs2(int u, int f) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; if (E[p].w &gt;= ca) dis[v] = dis[u] + 1; else dis[v] = dis[u] - 1; dfs2(v, u); &#125; &#125;&#125;void upd(int p, pi v, int l, int r, int &amp;rt) &#123; if (!rt) &#123; rt = ++ tot; ls[rt] = rs[rt] = 0; T[rt] = pi(-inf, 0); &#125; T[rt] = max(T[rt], v); if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, ls[rt]); else upd(p, v, m+1, r, rs[rt]);&#125;pi qry(int L, int R, int l, int r, int rt) &#123; if (!rt) return pi(-inf, 0); if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt]; int m = (l + r) &gt;&gt; 1; pi ret(-inf, 0); if (L &lt;= m) ret = max(ret, qry(L, R, l, m, ls[rt])); if (R &gt; m) ret = max(ret, qry(L, R, m+1, r, rs[rt])); return ret;&#125;int _dis, _dep;// rt2 -&gt; rt1void _dfs1(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; int lb = max(0, L + 2 * _dep - l), rb = min(n, R + 2 * _dep - l); if (lb &lt;= rb) &#123; pi res = qry(lb, rb, 0, n, t); if (res.first + T[rt].first - 2 * _dis &gt;= 0) &#123; ru = res.second, rv = T[rt].second; &#125; &#125; return; &#125; int m = (l + r) &gt;&gt; 1; _dfs1(t, l, m, ls[rt]); _dfs1(t, m+1, r, rs[rt]);&#125;void _dfs2(int t, int l, int r, int rt) &#123; if (!rt) return; if (l == r) &#123; upd(l, T[rt], 0, n, t); return; &#125; int m = (l + r) &gt;&gt; 1; _dfs2(t, l, m, ls[rt]); _dfs2(t, m+1, r, rs[rt]);&#125;void Merge(int rt1, int rt2) &#123; _dfs1(rt1, 0, n, rt2); _dfs2(rt1, 0, n, rt2);&#125;void dfs3(int u, int f) &#123; trt[u] = 0; upd(dep[u], pi(dis[u], u), 0, n, trt[u]); if (son[u]) dfs3(son[u], u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f &amp;&amp; v != son[u]) &#123; dfs3(v, u); _dis = dis[u], _dep = dep[u]; Merge(trt[son[u]], trt[v]); &#125; &#125; _dis = dis[u], _dep = dep[u]; if (son[u]) &#123; Merge(trt[son[u]], trt[u]); trt[u] = trt[son[u]]; &#125;&#125;// check caint check() &#123; dfs2(1, 0); tot = ru = rv = 0; dfs3(1, 0); if (ru + rv) return 1; return 0;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d%d", &amp;n, &amp;L, &amp;R); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs1(1, 0); int l = 0, r = int (1e9), ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ca = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; ca = ans; check(); printf("%d %d\n", ru, rv); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÈïøÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces809E] Surprise me!]]></title>
    <url>%2F2020%2F03%2F15%2FCF809E%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï ÁÇπÂàÜÊ≤ª‰∏Ä‰∏ãÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãÈóÆÈ¢òÔºö Êúâ‰∏§‰∏™Èïø‰∏∫ \(n\) ÁöÑÊï∞ÁªÑ \(a_1\) Âíå \(d_1\)Ôºå‰∏§‰∏™Èïø‰∏∫ \(m\) ÁöÑÊï∞ÁªÑ \(a_2\) Âíå \(d_2\)ÔºåÊ±ÇÔºö \[ \sum_{i=1}^n \sum_{j=1}^m \phi(a_1[i]a_2[j])(d_1[i]+d_2[j]) \] Êûö‰∏æ‰∏Ä‰∏ã \(i\)ÔºåÂÖ≥ÈîÆÂ∞±ÊòØÂ¶Ç‰ΩïÊ±ÇÂΩ¢Â¶Ç \(\sum_j \phi(a_1[i]a_2[j]) d_2[j]\) ÁöÑ‰∏úË•ø„ÄÇ Ê≥®ÊÑèÂà∞ \(\phi(ab) = \gcd(a,b) \frac{\phi(a)\phi(b)}{\phi(\gcd(a,b))}\) ËÆæ \(s_i = \sum_{i|k} d_2[k]\phi(a_2[k])\) \[ \sum_j \phi(a_1[i]a_2[j]) d_2[j] \\=\phi(a_1[i])\sum_{d\mid a_1[i]} [\gcd(a_1[i],a_2[j])=d]\frac{dd_2[j]\phi(a_2[j])}{\phi(d)} \\=\phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \] \(s_i\) ÊòØÂæàÂÆπÊòìÂ§ÑÁêÜÁöÑÔºåÂè™ÈúÄË¶ÅÂØπÊØè‰∏™ \(1\ldots m\) ‰∏≠ÁöÑÊï∞ \(i\) ËÄÉËôë \(d_2[i]\phi(a_2[i])\) ÂØπÊØè‰∏™ \(s\) ‰∏≠ \(i\) ÁöÑÁ∫¶Êï∞‰∏ãÊ†á‰ΩçÁΩÆÁöÑË¥°ÁåÆÂç≥ÂèØ„ÄÇ Â¶ÇÊûúÊö¥ÂäõËÆ°ÁÆó‰∏äÂºèÔºåÂ§çÊùÇÂ∫¶‰∏∫ \(1 \ldots n\) ‰∏≠ÊØè‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞ÁöÑÁ∫¶Êï∞‰∏™Êï∞‰πãÂíå‰πò‰ª•ÁÇπÂàÜÊ≤ªÁöÑ‰∏Ä‰∏™ \(\log\)„ÄÇÂâçÈù¢ÁöÑÈÉ®ÂàÜÂ§çÊùÇÂ∫¶ÊòØ \(\log^2\) ÁöÑÔºàËÄÉËôë \((\sum \frac 1 i )^2\)ÔºâÔºå‰ªéËÄåÊÄªÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n\log^3 n)\)„ÄÇ ÁªßÁª≠ÂØπ‰∏äÂºèÂèòÂΩ¢Ôºö ËÆæ \(t_k = \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d)\)Ôºå\(t_k\) ÊòØ‰∏Ä‰∏™Â∏∏Êï∞„ÄÇ \[ \phi(a_1[i])\sum_{d\mid a_1[i]} \frac d {\phi(d)} \sum_{d \mid k, k \mid a_1[i]} \mu(\frac k d) s_k \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k \sum_{d \mid k} \frac d {\phi(d)} \mu(\frac k d) \\=\phi(a_1[i])\sum_{k \mid a_1[i]} s_k t_k \] ËÄÉËôëÂØπ \(t\) ËøõË°åÈ¢ÑÂ§ÑÁêÜ„ÄÇ\(t\) ÊòØ‰∏Ä‰∏™ÁßØÊÄßÂáΩÊï∞ÔºàÂõ†‰∏∫ÂÆÉÊòØ‰∏§‰∏™ÁßØÊÄßÂáΩÊï∞ÁöÑÁãÑÂà©ÂÖãÈõ∑Âç∑ÁßØÔºâÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•ÊääÂÆÉÁ≠õÂá∫Êù•„ÄÇ ‰ΩÜÊòØÂõ†‰∏∫ÊàëÊáíÔºåÊàëÈÄâÊã©Áõ¥Êé•Êö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(t\)ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log n)\)„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂ§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2n)\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int mod = 1e9+7;vector&lt;int&gt; vd[maxn];int n, a[maxn], l[maxn], K[maxn], e, ans;int phi[maxn], iphi[maxn], mu[maxn], isnp[maxn], prm[maxn], pcnt;int sum1[maxn], sum2[maxn], dep[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct Edge &#123; int v, x;&#125; E[maxn&lt;&lt;1];inline void addEdge(int u, int v) &#123; E[e].v = v, E[e].x = l[u], l[u] = e++;&#125;int vis[maxn], sz[maxn], mx[maxn], sum[maxn];void dfs1(int u, int f, vector&lt;int&gt; &amp;vl) &#123; sz[u] = 1, mx[u] = 0; vl.push_back(u); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs1(v, u, vl); sz[u] += sz[v]; mx[u] = max(mx[u], sz[v]); &#125; &#125;&#125;void dfs2(int u, int f) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dep[v] = dep[u] + 1; dfs2(v, u); sz[u] += sz[v]; &#125; &#125;&#125;int mo(int x) &#123; if (x &gt;= mod) return x - mod; if (x &lt; 0) return x + mod; return x;&#125;void dfs3_inc(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] + phi[w]); sum2[d] = mo(sum2[d] + 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_inc(v, u); &#125; &#125;&#125;void dfs3_dec(int u, int f) &#123; int w = a[u]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; sum1[d] = mo(sum1[d] - phi[w]); sum2[d] = mo(sum2[d] - 1LL * phi[w] % mod * dep[u] % mod); &#125; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs3_dec(v, u); &#125; &#125;&#125;void dfs4(int u, int f) &#123; int w = a[u]; int s1 = 0, s2 = 0, cur_sum1 = 0, cur_sum2 = 0; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; cur_sum1 = mo(cur_sum1 + 1LL * K[d] * sum1[d] % mod); cur_sum2 = mo(cur_sum2 + 1LL * K[d] * sum2[d] % mod); &#125; ans = mo(ans + 1LL * cur_sum1 * dep[u] % mod * phi[w] % mod); ans = mo(ans + 1LL * cur_sum2 * phi[w] % mod); for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v] &amp;&amp; v != f) &#123; dfs4(v, u); &#125; &#125;&#125;void solve(int u, int s) &#123; vector&lt;int&gt; vl; dfs1(u, 0, vl); int c = 0; for (int i = 0; i &lt; vl.size(); i++) &#123; int u = vl[i]; mx[u] = max(mx[u], s - sz[u]); if (!c || mx[u] &lt; mx[c]) c = u; &#125; dep[c] = 0; dfs2(c, 0); vector&lt;int&gt; nv, ns; for (int p = l[c]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!vis[v]) &#123; nv.push_back(v), ns.push_back(sz[v]); &#125; &#125; dfs3_inc(c, 0); for (int i = 0; i &lt; nv.size(); i++) &#123; int v = nv[i]; dfs3_dec(v, c); dfs4(v, c); dfs3_inc(v, c); &#125; &#123; int w = a[c]; for (int i = 0; i &lt; vd[w].size(); i++) &#123; int d = vd[w][i]; ans = (ans + 1LL * K[d] * sum2[d] % mod * phi[w] % mod) % mod; &#125; &#125; dfs3_dec(c, 0); vis[c] = 1; for (int i = 0; i &lt; nv.size(); i++) solve(nv[i], ns[i]);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i]) &#123; phi[i] = i-1; mu[i] = mod - 1; prm[++ pcnt] = i; &#125; for (int j = 1; j &lt;= pcnt &amp;&amp; prm[j] * i &lt;= n; j++) &#123; isnp[prm[j] * i] = 1; if (i % prm[j] == 0) &#123; mu[i * prm[j]] = 0; phi[i * prm[j]] = phi[i] * prm[j]; break;„ÄÇÔºå &#125; else &#123; mu[i * prm[j]] = (mod - mu[i]) % mod; phi[i * prm[j]] = phi[i] * (prm[j] - 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) iphi[i] = qpow(phi[i], mod-2); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * i &lt;= n; j++) &#123; vd[j*i].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; vd[i].size(); j++) &#123; int d = vd[i][j]; K[i] = (K[i] + 1LL * mu[i/d] * d % mod * iphi[d] % mod) % mod; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; solve(1, n); ans = 1LL * ans * qpow(1LL * n * (n-1) % mod, mod-2) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Êï∞ËÆ∫</tag>
        <tag>ÁÇπÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces176E] Archaeology]]></title>
    <url>%2F2020%2F03%2F10%2F%5B%5D1%2F</url>
    <content type="text"><![CDATA[ÂÅöÊ≥ï Èöè‰æøÂèñ‰∏Ä‰∏™ÁÇπ‰ΩúÊ†πÔºåÁî®Á∫øÊÆµÊ†ëÊåâ dfs Â∫èÁª¥Êä§Â≠òÂú®ÁöÑÁÇπÔºåÁª¥Êä§‰∏Ä‰∏ãÊâÄÊúâÂ≠òÂú®ÁöÑÁÇπÁöÑ lca ÂíåÂà∞Ê†πÁöÑË∑ØÂæÑÁöÑÂπ∂ÁöÑÈïøÂ∫¶Âç≥ÂèØ„ÄÇ ËØØ‰ª•‰∏∫Ë¶ÅÂáèÂéªÁÇπÊï∞ * lca ÁöÑÊ∑±Â∫¶ÔºåË∞É‰∫ÜÂ•Ω‰πÖ... ‰∏ÄÁõ¥Ë∞É‰∏çÂá∫Êù•ÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•‰∏Ä‰∏ãÊòØ‰∏çÊòØÂì™ÈáåÊÉ≥Èîô‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;char opt[10];ll dis[maxn];int n, l[maxn], fa[maxn][20], e, q;int dfn[maxn], dep[maxn], tim;struct Edge &#123; int v, w, x;&#125; E[maxn&lt;&lt;1];void dfs(int u, int f) &#123; dfn[u] = ++ tim; fa[u][0] = f; for (int i = 1; i &lt; 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != f) &#123; dis[v] = dis[u] + E[p].w; dep[v] = dep[u] + 1; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); if (dep[u] &gt; dep[v]) &#123; int c = dep[u] - dep[v]; for (int i = 0; i &lt; 20; i++) &#123; if (c &amp; (1&lt;&lt;i)) &#123; u = fa[u][i]; &#125; &#125; &#125; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) &#123; if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;struct dat &#123; int s, t, l; ll sum;&#125; T[maxn&lt;&lt;2];inline void addEdge(int u, int v, int w) &#123; E[e].v = v, E[e].x = l[u], E[e].w = w, l[u] = e++;&#125;dat operator+(const dat &amp;d1, const dat &amp;d2) &#123; if (!d1.l) return d2; if (!d2.l) return d1; dat ret; ret.s = d1.s, ret.t = d2.t; ret.l = lca(d1.l, d2.l); ret.sum = d1.sum + d2.sum - dis[lca(d1.t, d2.s)]; return ret;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; T[rt].l = T[rt].s = T[rt].t = v; T[rt].sum = dis[v]; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); &#125; dfs(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%s", opt); if (opt[0] == '+') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], x, 1, n, 1); &#125; else if (opt[0] == '-') &#123; int x; scanf("%d", &amp;x); upd(dfn[x], 0, 1, n, 1); &#125; else &#123; printf("%lld\n", T[1].sum - dis[T[1].l]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈúÄË¶ÅÁªèÂ∏∏Â§ç‰π†ÁöÑ‰∏úË•ø]]></title>
    <url>%2F2020%2F03%2F09%2Fxu'yao%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∫õÊÑüËßâËá™Â∑±ËÄÉËØïÁöÑÊó∂ÂÄôÂæàÈöæÁã¨Á´ãÊÉ≥Âá∫Êù•‰ΩÜÊòØÂèàÁªèÂ∏∏‰ºöÂøòÁöÑ‰∏úË•ø„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπËßÅ ËøôÁØá blogÔºåËÄÉÂâçÂ§ç‰π†Áî®„ÄÇ Ê•ºÊàøÈáçÂª∫ÁöÑÂÅöÊ≥ï (2020.03.09) ÊîØÈÖçÊ†ë ‰ºØÂä™Âà©Êï∞‰∏éËá™ÁÑ∂Êï∞ÂπÇÂíå Ëá™ÁÑ∂Êï∞ÁöÑÔºàÂèØÈáç / ‰∏çÂèØÈáçÔºâÊó†Â∫èÊãÜÂàÜÔºöÊ†πÂè∑ÂÅöÊ≥ï‰∏é \(\log\) ÂÅöÊ≥ï jlsÁ∫øÊÆµÊ†ë ‰∏áËÉΩÊ¨ßÂá†ÈáåÂæó‰∏éÁ±ªÊ¨ßÂá†ÈáåÂæó Â§ÑÁêÜÂàÜÊØçÁ≠âÂ∑ÆÁîüÊàêÂáΩÊï∞ÁöÑÊñπÊ≥ï ‰Ω†ÁöÑÂêçÂ≠ó ÈÇ£‰∏™È¢òÁöÑÂÅöÊ≥ï ÊúÄÂ∞èÂ≠óÂÖ∏Â∫èÊãìÊâëÂ∫è(ÊåáÊåâÁºñÂè∑‰ªéÂ∞èÂà∞Â§ßÊääÊØè‰∏™ÁÇπÂú®ÊãìÊâëÂ∫è‰∏äÁöÑ‰ΩçÁΩÆÂÜô‰∏ãÊù•ÁöÑÂ∫èÂàó)ÔºåËßÅ agc001_f Âà©Áî®Êó∂Èó¥Êà≥Á∫øÊÄßÂü∫ (ÊåâÊØè‰∏™ÂÖÉÁ¥†Ë¢´Âà†Èô§ÁöÑÊó∂Èó¥) ÂÆûÁé∞Á¶ªÁ∫øËøõË°å‰∏çÂ∏¶ log ÁöÑÁ∫øÊÄßÂü∫ÊèíÂÖ•Âà†Èô§ Âà§Á∫øÊÄßÊó†ÂÖ≥Êó∂ÊääÂÆûÊï∞ÊîπÊàêÂèñÊ®°Âπ∂‰∏ç‰ºöÊúâÂ§™Â§ßÊçüÂ§±ÔºåÁ±ª‰ººÂìàÂ∏åÔºàÈÄêÊ≠•ËÄÉËôëÁü©ÈòµÁöÑÂèòÂåñ~ÔºåÂÖ∂ÂÆûÂè™Ë¶Å‰∏çÂá∫Áé∞Ê®°Êï∞ÂÄçÊï∞Â∞±Ë°å Èìæ‰∏äËØ¢ÈóÆ / Âå∫Èó¥ËØ¢ÈóÆÂ∞è‰∫éÁ≠â‰∫é \(k\) (k ÊØèÊ¨°ÁªôÂÆö) ÁöÑÂÖÉÁ¥†ÁöÑ‰ø°ÊÅØ (‰∏çÂèØÂáè)ÔºåÊúâÂäûÊ≥ï‰∏Ä‰∏™ \(\log\) ÁÇπÂèåËÅîÈÄöÂàÜÈáèÁöÑÊ±ÇÊ≥ï (ÂÜô‰∫ÜÁØáÂÖ¨ÂºÄ blog) ‰∏ÄÁ±ª‰∫åÂàÜÂá∏‰ºòÂåñËæìÂá∫ÊñπÊ°àÁöÑÊñπÊ≥ï ÊãâÊ†ºÊúóÊó•ÂèçÊºîÂèäÂÖ∂Êâ©Â±ï ËÆ∞ÂæóÂç∑ÁßØÂΩ¢ÂºèÁöÑ dp ÂèØ‰ª•ÂàÜÊ≤ª fft ‰ºòÂåñ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÊäÄÂ∑ßÊï¥ÁêÜ]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éÂõûÊªöÊìç‰ΩúÁöÑÊäÄÂ∑ßÂú®ÈúÄË¶ÅÂõûÊªöÁöÑÊï∞ÁªÑÊØîËæÉÂ§öÁöÑÊó∂ÂÄô‰∏Ä‰∏™‰∏Ä‰∏™ÂºÄÊ†àÂõûÊªö‰ºöÊØîËæÉÈ∫ªÁÉ¶ÔºåÂèØ‰ª•ËØïÁùÄ‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö 123int *sta_p[maxn*k], sta_v[maxn*k], top;void modify(int &amp;x) &#123;++ top; sta_p[top] = &amp;x; sta_v[top] = x;&#125; ËøôÊ†∑ËøòÂéüÁöÑÊó∂ÂÄô‰πüÂè™ÈúÄË¶ÅÊ†πÊçÆÊåáÈíàÊêû‰∏ÄÊêûÂ∞±Â•ΩÔºåÂè™ÈúÄË¶ÅÂºÄ‰∏Ä‰∏™Ê†àÂ∞±Ë°å‰∫ÜÔºåÊ≥®ÊÑè \(k\) ‰∏çË¶ÅÂºÄÂ∞è„ÄÇ ÊúâÊó∂ÂÄô‰Ω†ÈúÄË¶ÅËÆ∞ÂΩï‰∏Ä‰∏™ÊîØÊåÅÈöèÊó∂Ê∏ÖÁ©∫ÁöÑ \(01\) Êï∞ÁªÑÔºåËøôÊó∂ÂèØ‰ª•‰∏çÈ¢ùÂ§ñÂºÄÊ†áËÆ∞Êï∞ÁªÑ„ÄÇËÆ∞‰∏Ä‰∏™ÂèòÈáè \(tim\)ÔºåËµã \(1\) ÁöÑÊó∂ÂÄôÂ∞±ËÆæ‰∏∫ \(tim\)ÔºåÂà§Êñ≠ÊòØ \(0\) ËøòÊòØ \(1\) Â∞±ÁúãÊòØÂê¶Á≠â‰∫é \(tim\)ÔºåÊ∏ÖÁ©∫Â∞± \(tim \leftarrow tim + 1\)„ÄÇ ‰∏ä‰∏ãÁïåË¥πÁî®ÊµÅÔºåÂØπÊØèÊù°ÂøÖÈ°ªËæπ‰∏çË¶ÅÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂØπÊØè‰∏Ä‰∏™ÁÇπËÆ∞‰∏Ä‰∏™Â∫¶Êï∞ÔºåÂÖ®ÈÉ®Ê∑ªÂä†‰πãÂêéÂÜçÊ†πÊçÆÂ∫¶Êï∞ÂÜ≥ÂÆöÊØè‰∏™ÁÇπÂà∞Ë∂ÖÁ∫ßÊ∫êËøòÊòØË∂ÖÁ∫ßÊ±áÔºåËøûÂ§öÂ§ßÊµÅÈáèÁöÑËæπÔºåËøôÊ†∑ÂèØ‰ª•Â§ßÂ§ßÂáèÂ∞ëËæπÊï∞„ÄÇ Âú®ÂÅö dinic Êó∂‰ª•‰∏ã‰∏§‰ªΩ‰ª£Á†ÅÊúâÂ∑®Â§ßÂ∏∏Êï∞Â∑ÆË∑ùÔºå‰∏ãÈù¢ÁöÑÊúâÊó∂ÁîöËá≥ÂèØ‰ª•ÊØî‰∏äÈù¢ÁöÑÂø´ÂçÅÂÄçÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà„ÄÇ 12345678910111213141516171819202122232425262728293031323334int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0 &amp;&amp; w &lt; in; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;int _find(int u, int in) &#123; if (u == cur_sink) return in; int w = 0, t; for (int &amp;p = cur[u]; p &gt;= 0; p = E[p].x) &#123; if (p &gt;= e) continue; if (E[p].c &amp;&amp; L[E[p].v] == L[u] + 1) &#123; if ((t = _find(E[p].v, min(E[p].c, in - w)))) &#123; w += t; E[p].c -= t; E[p^1].c += t; if (w == in) break; &#125; &#125; &#125; if (w &lt; in) L[u] = -1; return w;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces938G] Shortest Path Queries]]></title>
    <url>%2F2020%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊääÊìç‰ΩúÁ¶ªÁ∫øÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºåÊääÈóÆÈ¢òÂèòÊàêÂè™ÈúÄË¶ÅÊîØÊåÅÂä†ËæπÔºåÂõûÊªöÔºåÁª¥Êä§‰∏§ÁÇπÈó¥ÊúÄÂ∞è \(xor\) Ë∑ØÂæÑ„ÄÇ Âú®ËØ¢ÈóÆ \(u,v\) ‰∏≠Ôºå‰Ω†ÂèØ‰ª•‰ªé \(u\) Ëµ∞Âà∞ \(t\) ÁÑ∂ÂêéËµ∞Âõû \(u\)ÔºåË∑ØÂæÑ‰∏äÊØèÊù°ËæπÈÉΩË¢´ÁªèËøá‰∏§Ê¨°ÔºåÊâÄ‰ª•Ë∑ØÂæÑ‰∏äÁöÑËæπË¥°ÁåÆ‰∏∫ \(0\)„ÄÇÂõ†Ê≠§Â¶ÇÊûúÊúâ‰∏ÄÊù° \(xor\) ‰∏∫ \(x\) ÁöÑ \(u,v\) Ë∑ØÂæÑÔºåÊúâ‰∏Ä‰∏™ \(xor\) ‰∏∫ \(c\) ÁöÑÁéØÔºåÂ∞±Â≠òÂú®‰∏ÄÊù° \(xor\) ‰∏∫ \(x\oplus c\) ÁöÑË∑ØÂæÑ„ÄÇ ‰ªªÊÑèËÄÉËôë‰∏ÄÊ£µÁîüÊàêÊ†ëÔºåÂØπ‰∫é‰∏Ä‰∏™ÈùûÊ†ëËæπ \(u,v,w\)ÔºåËÆæ \(u\) Âà∞ \(v\) ÁöÑÊ†ë‰∏äË∑ØÂæÑ \(xor\) ‰∏∫ \(x\)ÔºåÈÇ£‰πàÂ≠òÂú®‰∏Ä‰∏™ \(xor\) ‰∏∫ \(x \oplus w\) ÁöÑÁéØÔºåÂõ†Ê≠§Â¶ÇÊûúÁªèËøá‰∫ÜËøôÊù°ÈùûÊ†ëËæπÔºåÊàë‰ª¨‰∏çÂ¶®ÊääÂÆÉÁúãÊàêÊòØÊ≤øÁùÄÊ†ë‰∏äË∑ØÂæÑ‰ªé \(u\) Ëµ∞Âà∞ \(v\)„ÄÇ‰πãÂêéÂÜçÂºÇÊàñ‰∏äËøô‰∏™Êç¢ÁöÑÊùÉÂÄº„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅËÄÉËôëÊää \(u\) Âà∞ \(v\) ‰πãÈó¥ÁöÑÊ†ë‰∏äË∑ØÂæÑÂºÇÊàñ‰∏ä‰∏Ä‰∫õÁî±‰∏ÄÊù°ÈùûÊ†ëËæπ‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\)ÔºåÁ≠îÊ°àÊúÄÂ∞èÊòØ‰ªÄ‰πà„ÄÇ Áª¥Êä§ÊâÄÊúâÈùûÊ†ëËæπÂä†‰∏ä‰∏ÄÊù°Ê†ëÈìæÊûÑÊàêÁöÑÁéØÁöÑ \(xor\) ÁöÑÁ∫øÊÄßÂü∫Âç≥ÂèØ„ÄÇ ÁÑ∂ÂêéËÄÉËôëÊÄé‰πàÂä†ËæπÁª¥Êä§Ëøô‰∏™‰∏úË•ø„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂõûÊªöÔºåÂùáÊëäÁÆóÊ≥ïÔºàÂ¶Ç LCTÔºåË∑ØÂæÑÂéãÁº©ÁöÑÂπ∂Êü•ÈõÜÔºâÊó†Ê≥ï‰ΩøÁî®„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊîØÊåÅËØ¢ÈóÆ‰∏§ÁÇπÊòØÂê¶ËøûÈÄöÔºåËØ¢ÈóÆ‰∏§ÁÇπ‰πãÈó¥ÁöÑ \(xor\)ÔºåÂä†ËæπÂíåÂõûÊªöÂç≥ÂèØ„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁªôÁÇπ \(i\) Áª¥Êä§‰∏Ä‰∏™ÂÄº \(v_i\)ÔºåÂàùÂßãÊó∂ÊâÄÊúâÁÇπÁöÑÂÄº \(=0\)ÔºåÁî®ÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÊù•Áª¥Êä§ËøûÈÄöÊÄß„ÄÇÊàë‰ª¨ÂßãÁªàË¶Å‰øùËØÅÂØπ‰∫é‰ªªÊÑèÁöÑ \(u,v\)ÔºåÂ¶ÇÊûú \(u,v\) ËøûÈÄöÔºåÈÇ£‰πà \(u,v\) ‰πãÈó¥Ê†ë‰∏äË∑ØÂæÑÁöÑ \(xor\) Á≠â‰∫é \(v_u \oplus v_v\)„ÄÇÊØèÊ¨°Âä†ËæπÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú‰∏§‰∏™ËøûÈÄöÂùóÂπ∂Êàê‰∫Ü‰∏Ä‰∏™ËøûÈÄöÂùóÔºå‰Ω†ÂèØ‰ª•ÈÄöËøáÊääÂÖ∂‰∏≠‰∏Ä‰∏™ËøûÈÄöÂùóÂÜÖÁöÑÊâÄÊúâÁÇπÁöÑ \(v_i\) ÂºÇÊàñ‰∏ä‰∏Ä‰∏™Êï∞Êù•‰øùÊåÅËøô‰∏ÄÊÄßË¥®„ÄÇÊåâÁß©ÂêàÂπ∂Êó∂Êâì‰∏™ tag Âç≥ÂèØ„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(\mathcal O(n \log^2 n)\)„ÄÇ ‰ª£Á†Å ËøôÊ¨°Â∞ùËØï‰∫Ü‰∏ÄÁßçÊñ∞ÁöÑÁ†ÅÈ£é„ÄÇÁúã‰∏äÂéªÂ≠óÁ¨¶ÈáèÂ∞ë‰∫Ü‰∏çÂ∞ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef pair&lt;int,int&gt; pi;int n, m, q;int eu[maxn*2], ev[maxn*2];vector&lt;pi&gt; tmp;int bu[maxn], bv[maxn], bd[maxn], be[maxn];int qo[maxn], qx[maxn], qy[maxn], qd[maxn], qe[maxn];int ans[maxn];namespace DSU &#123; int f[maxn], d[maxn], w[maxn], e[maxn], top; int *sta_p[maxn*10], sta_v[maxn*10]; int a[30]; void modify(int &amp;x) &#123; ++ top; sta_p[top] = &amp;x, sta_v[top] = x; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) f[i] = i; &#125; int gr(int x) &#123; if (f[x] == x) return x; return gr(f[x]); &#125; int ge(int x) &#123; if (f[x] == x) return 0; return e[x] ^ ge(f[x]); &#125; int gw(int x) &#123; return w[x] ^ ge(x); &#125; void ins(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (!a[i]) &#123; modify(a[i]); a[i] = x; break; &#125; else x ^= a[i]; &#125; &#125; &#125; int ask(int x) &#123; for (int i = 29; i &gt;= 0; i--) &#123; if (x &amp; (1&lt;&lt;i)) &#123; if (a[i]) &#123; x ^= a[i]; &#125; &#125; &#125; return x; &#125; void adde(int u, int v, int x) &#123; int ru = gr(u), rv = gr(v); if (ru == rv) &#123; ins(gw(u) ^ gw(v) ^ x); &#125; else if (ru != rv) &#123; if (d[ru] &lt; d[rv]) swap(ru, rv); modify(f[rv]); f[rv] = ru; modify(d[ru]); d[ru] = max(d[ru], d[rv] + 1); modify(e[rv]); e[rv] ^= x ^ gw(u) ^ gw(v); &#125; &#125; void rollb(int t) &#123; while (top &gt; t) &#123; (*sta_p[top]) = sta_v[top]; -- top; &#125; &#125;&#125;int tim = 0;int vis_l[maxn&lt;&lt;1], vis_r[maxn&lt;&lt;1], _vis[maxn&lt;&lt;1];int cur_ext[maxn&lt;&lt;1], cur_d[maxn&lt;&lt;1];void solve(int l, int r) &#123; int t = DSU::top; if (l == r) &#123; if (qo[l] == 3) &#123; ans[l] = DSU::ask(DSU::gw(qx[l]) ^ DSU::gw(qy[l])); &#125; else cur_ext[qe[l]] ^= 1; if (qo[l] == 1) cur_d[qe[l]] = qd[l]; return; &#125; int m = (l + r) &gt;&gt; 1; ++ tim; for (int i = l; i &lt;= m; i++) if (qo[i] != 3) vis_l[qe[i]] = tim; &#123; // ÂáÜÂ§áÂ∑¶Âå∫Èó¥ for (int i = m+1; i &lt;= r; i++) &#123; if (qo[i] != 3) &#123; if (vis_l[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(l, m); DSU::rollb(t); &#125; ++ tim; for (int i = m+1; i &lt;= r; i++) if (qo[i] != 3) vis_r[qe[i]] = tim; &#123; // ÂáÜÂ§áÂè≥Âå∫Èó¥ for (int i = l; i &lt;= m; i++) &#123; if (qo[i] != 3) &#123; if (vis_r[qe[i]] != tim) &#123; if (cur_ext[qe[i]]) &#123; DSU::adde(eu[qe[i]], ev[qe[i]], cur_d[qe[i]]); &#125; &#125; &#125; &#125; solve(m+1, r); DSU::rollb(t); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;bu[i], &amp;bv[i], &amp;bd[i]); if (bu[i] &gt; bv[i]) swap(bu[i], bv[i]); tmp.push_back(pi(bu[i], bv[i])); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;qo[i]); if (qo[i] == 1) &#123; scanf("%d%d%d", &amp;qx[i], &amp;qy[i], &amp;qd[i]); &#125; else &#123; scanf("%d%d", &amp;qx[i], &amp;qy[i]); &#125; if (qx[i] &gt; qy[i]) swap(qx[i], qy[i]); if (qo[i] != 3) tmp.push_back(pi(qx[i], qy[i])); &#125; sort(tmp.begin(), tmp.end()); for (int i = 1; i &lt;= m; i++) &#123; be[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(bu[i], bv[i])) - tmp.begin() + 1); &#125; for (int i = 1; i &lt;= q; i++) &#123; if (qo[i] != 3) qe[i] = int (lower_bound(tmp.begin(), tmp.end(), pi(qx[i], qy[i])) - tmp.begin() + 1); &#125; for (int i = 0; i &lt; tmp.size(); i++) eu[i+1] = tmp[i].first, ev[i+1] = tmp[i].second; for (int i = 1; i &lt;= m; i++) cur_ext[be[i]] = 1, cur_d[be[i]] = bd[i]; DSU::init(); for (int i = 1; i &lt;= q; i++) if (qo[i] != 3) _vis[qe[i]] = 1; for (int i = 1; i &lt;= m; i++) if (!_vis[be[i]]) DSU::adde(bu[i], bv[i], bd[i]); solve(1, q); for (int i = 1; i &lt;= q; i++) if (qo[i] == 3) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034E] Complete Compress]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÊÑüËßâÊØî E È¢òÈöæ‰ΩÜÊòØËøáÁöÑ‰∫∫ËøúÊØî E È¢òÂ§ö... ‰∏çÁü•ÈÅì piece ÊÄé‰πàÁøªËØëÔºåÂêéÈù¢Áî®Áü≥Â≠ê‰ª£Êåá piece„ÄÇ ÂÖàÊûö‰∏æ‰∏Ä‰∏™ÁÇπ \(r\)ÔºåÁÑ∂ÂêéËÄÉËôëÊääÊâÄÊúâÁü≥Â≠êÈÉΩÁßªÂä®Âà∞ÁÇπ \(r\) ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÊää \(r\) ‰Ωú‰∏∫Ê†πÔºåËÄÉËôëÊØè‰∏™Áü≥Â≠êÂà∞ \(r\) ÁöÑË∑ùÁ¶ª‰πãÂíå \(s\)ÔºåÊòæÁÑ∂Êìç‰Ωú‰∏ç‰ºöÊîπÂèò \(s\) ÁöÑÂ•áÂÅ∂ÊÄßÔºåÊâÄ‰ª•Â¶ÇÊûú \(s\) ÊòØÂÅ∂Êï∞Ôºå‰∏çÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°à„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÊääÊâÄÊúâÁü≥Â≠êÁßªÂä®Âà∞ \(r\) ÁöÑÊñπÊ°àÔºåÈÇ£‰πàÊúÄÂ∞ëÊ≠•Êï∞ÂøÖÁÑ∂ÊòØ \(\frac s 2\)ÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰∏™ÊñπÊ°à‰∏≠Êúâ‰∏ÄÊ¨°‰Ωø‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ∞èÔºåÂè¶‰∏Ä‰∏™Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ªÂèòÂ§ßÔºå‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏Ä‰∏™Ê≠•Êï∞Êõ¥Â∞ëÁöÑÁöÑÊñπÊ°à„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨Âè™ÈúÄËÄÉËôëÂ¶Ç‰ΩïÊ£ÄÈ™åÊñπÊ°àÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™ËÄÉËôë‰∏Ä‰∏™Â≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºå‰∏çÈöæÂèëÁé∞ÊúÄ‰ºòÊñπÊ°à‰∏ÄÂÆöÂèØ‰ª•Ë∞ÉÊï¥‰∏∫‰∏ÄÁßçÂÖàËøõË°åÂÆåÂÖ®Âú®Êüê‰∏™ÂÑøÂ≠êÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÔºåÂÜçËøõË°å‰∏§‰∏™Áü≥Â≠êÂú®‰∏çÂêåÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÊìç‰ΩúÁöÑÊñπÊ°à„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂÅöÊ†ëÂΩ¢ dpÔºåËÆæ \(f_{ij}\) Ë°®Á§∫ÊòØÂê¶ÂèØ‰ª•ÂØπ \(i\) ÁöÑÂ≠êÊ†ëÂÜÖÈÉ®ÁöÑÁü≥Â≠êËøõË°åÊìç‰ΩúÔºå‰ΩøÂæó \(i\) Â≠êÊ†ëÂÜÖÈÉ®Áü≥Â≠êÂà∞Ê†πÁöÑË∑ùÁ¶ª‰πãÂíå‰∏∫ \(j\)„ÄÇËÄÉËôëÊÄé‰πàËΩ¨ÁßªÔºåÂÅáËÆæÊàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∫ÜÁÇπ \(u\) ÊØè‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÊìç‰ΩúÔºåÁªèËøáËøô‰∫õÊìç‰ΩúÊó∂ÂÄôÁ¨¨ \(i\) ‰∏™ÂÑøÂ≠êÂ≠êÊ†ëÂÜÖÁöÑÁü≥Â≠êÂà∞ \(u\) Ë∑ùÁ¶ª‰πãÂíå‰∏∫ \(s_i\)ÔºåÂÖ±Êúâ \(c\) ‰∏™ÂÑøÂ≠êÔºåËÆæ \(\max s_i = t\)ÔºåÂèØ‰ª•ËØÅÊòéÔºå\(f_{uj} = 1\)ÔºåÂΩì‰∏î‰ªÖÂΩì \(j\) ‰∏é \(\sum s_i\) Â•áÂÅ∂ÊÄßÁõ∏ÂêåÔºå‰∏î \(j \ge 2t - \sum s_i\)„ÄÇËøôÊ†∑ÁöÑÂ§çÊùÇÂ∫¶Â§™Â§ß‰∫ÜÔºå‰∏çÈöæÂΩíÁ∫≥ËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(f_{ij} = 1\) ÁöÑ \(j\) ÂøÖÁÑ∂ÊòØÊüê‰∏™Âå∫Èó¥ÂÜÖÁöÑÊâÄÊúâÂ•áÊï∞ / ÂÅ∂Êï∞„ÄÇÂà©Áî®Ëøô‰∏™ÊÄßË¥®ÔºåÊàë‰ª¨ dp ‰ΩøÂè™ÈúÄË¶ÅËÆ∞‰∏Ä‰∏™Âå∫Èó¥Âç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóËøô‰∏™Âå∫Èó¥ÁöÑÂè≥ËæπÁïåÊó∂ÔºåÂè™ÈúÄÊääÊâÄÊúâÂÑøÂ≠êÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁü≥Â≠êÂà∞Ëøô‰∏™ÂÑøÂ≠êÁöÑË∑ùÁ¶ª‰πãÂíåÈÉΩÂèñÂà∞ÊúÄÂ§ßÂç≥ÂèØ„ÄÇÂú®ËÆ°ÁÆóÂ∑¶ËæπÁïåÊó∂ÔºåÊûö‰∏æÂèñÂà∞Â∑¶ËæπÁïåÁöÑÊñπÊ°à‰∏≠Âì™‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) ÊúÄÂ§ßÔºåËÆ©ÂÖ∂‰ªñÂÑøÂ≠êÁöÑ \(s_i\) ÈÉΩÂ∞ΩÈáèÂ∞èÔºåËøô‰∏™ÂÑøÂ≠êÁöÑ \(s_i\) Âú®Â§ß‰∫éÁ≠â‰∫éÂÖ∂‰ªñÂÑøÂ≠êÁöÑÂâçÊèê‰∏ãÂ∞ΩÈáèÂ∞èÔºåÊõ¥Êñ∞‰∏Ä‰∏ãÂ∑¶ËæπÁïåÂç≥ÂèØ„ÄÇÂÖ∑‰ΩìÂÆûÁé∞ÂèØ‰ª•Áúã‰ª£Á†Å„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;const int inf = 0x3f3f3f3f;int ans = inf;int n, l[maxn], sz[maxn], lb[maxn], rb[maxn], dep[maxn], e;char S[maxn];struct Edge &#123; int v, x;&#125; E[maxn &lt;&lt; 1];int Max(int u, int v) &#123; if ((u ^ v) &amp; 1) ++ v; return max(u, v);&#125;void dfs(int u, int fa) &#123; sz[u] = (S[u] == '1'); lb[u] = inf; rb[u] = 0; int sum = 0, mx = 0, cmx = 0; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u); sz[u] += sz[v]; rb[u] += sz[v] + rb[v]; sum += sz[v] + lb[v]; if (sz[v] + lb[v] &gt;= mx) &#123; cmx = mx; mx = sz[v] + lb[v]; &#125; else if (sz[v] + lb[v] &gt; cmx) &#123; cmx = sz[v] + lb[v]; &#125; &#125; &#125; lb[u] = sum; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (v != fa) &#123; int t = mx; if (sz[v] + lb[v] == mx) t = cmx; int w = Max(sz[v] + lb[v], t); if (w &gt; sz[v] + rb[v]) continue; int s = sum - sz[v] - lb[v] + w; lb[u] = min(lb[u], max(s &amp; 1, s - 2 * (s - w))); &#125; &#125;&#125;inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); scanf("%s", S+1); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; dep[i] = 0; dfs(i, 0); int sum = 0; for (int j = 1; j &lt;= n; j++) &#123; if (S[j] == '1') &#123; sum += dep[j]; &#125; &#125; if (!lb[i]) ans = min(ans, sum / 2); &#125; if (ans == inf) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC034F] RNG and XOR]]></title>
    <url>%2F2019%2F11%2F02%2F%5BAGC034F%5D-RNG-and-XOR%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂæàÊúâÂêØÂèëÊÄßÁöÑÈóÆÈ¢ò...ÂÅö‰∫Ü‰∏ÄÈÅçÊääÂØπ FWT ÁêÜËß£ÁöÑ‰∏çÂΩªÂ∫ïÁöÑÂú∞ÊñπÈÉΩÊêûÊ∏ÖÊ•ö‰∫Ü„ÄÇ ÂÄíËøáÊù•ÁúãÔºåËÆ°ÁÆóÊØè‰∏™Êï∞ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞ÔºåÊòæÁÑ∂Á≠îÊ°àÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ È¶ñÂÖàËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Âàó \(2^n\) ÂÖÉÁ∫øÊÄßÊñπÁ®ãÁªÑÂéªËß£Ôºå‰ΩÜÊòØÊö¥ÂäõÈ´òÊñØÊ∂àÂÖÉÁöÑÂ§çÊùÇÂ∫¶Â§™È´ò‰∫Ü„ÄÇ Êàë‰ª¨ËÆæ \(f_i\) Ë°®Á§∫ \(i\) ÂèòÊàê \(0\) ÁöÑÊúüÊúõÊ≠•Êï∞Ôºå\(p_i\) Ë°®Á§∫ÈöèÊú∫Êï∞ÁîüÊàêÂô®ÁîüÊàê \(i\) ÁöÑÊ¶ÇÁéá„ÄÇÈÇ£‰πàÂèØ‰ª•ÂèëÁé∞ \(f\) Êï∞ÁªÑÊª°Ë∂≥ÊñπÁ®ã \(f = f\cdot p + w x^0 + \sum x^S\)„ÄÇÂÖ∂‰∏≠‰πòÊ≥ïË°®Á§∫ÈõÜÂêàÂºÇÊàñÂç∑ÁßØ„ÄÇ ÁßªÈ°πÂæóÂà∞ \((x^0-p)f = w x^0 + \sum x^S\)ÔºåÂØπ‰∏§ËæπÂêåÊó∂ FWTÔºåÂæó \((\sum x^S-\hat {p})\hat{f} = w \sum x^S + 2^nx^0\)„ÄÇÊòæÁÑ∂ \(\hat{p}_{0} = \sum p_S= 1\)Ôºå‰ªéËÄå \(((w\sum x^S) + 2^n x^0)[x^0] = 0\)ÔºåËøôÂ∞±Êé®Âá∫‰∫Ü \(w = -2^n\)„ÄÇÊòæÁÑ∂ \(\forall S, \lvert \hat{p}_S \rvert &lt; 1\)Ôºå‰ªéËÄåÂèØ‰ª•Êé®Âá∫ \(\hat{f}_S\) ÁöÑÂÄº„ÄÇÊé•‰∏ãÊù•ÔºåÂè™Ë¶ÅÁü•ÈÅì \(\hat f_0\) Â∞±ÂèØ‰ª• IFWT Âá∫ \(f\) ‰∫Ü„ÄÇÊ≥®ÊÑèÂà∞Ôºå\(IFWT(\hat f + kx^0) = f + \frac k {2^n} \sum x^S\)ÔºåÂè™ÈúÄÈöè‰æøÁªô \(\hat f_0\) ËÆæ‰∏Ä‰∏™ÂÄºÔºåÁÑ∂Âêé IFWT Âá∫‰∏Ä‰∏™Êï∞ÁªÑ \(f\)ÔºåÂØπÊØè‰∏™ \(i\) Êää \(f_i\) ÂáèÂéª \(f_0\) Âç≥ÂèØ„ÄÇÔºàËøôÈáåÁî®Âà∞‰∫Ü \(f_0 = 0\) ÁöÑÊù°‰ª∂Ôºâ Ê®°Êï∞ÂÜôÊàê \(10^9+7\) ËøòË∞É‰∫ÜÂ•Ω‰πÖ...ÊàëÁúüÁöÑÊòØ zz„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 18;const int mod = 998244353;const int inv = (mod + 1) / 2;int n, a[1&lt;&lt;maxn], b[1&lt;&lt;maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void fwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; fwt(a, l, m); fwt(a, m+1, r); for (int i = l; i &lt;= m; i++) &#123; int v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125;&#125;void ifwt(int *a, int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1, t = (r-l+1) &gt;&gt; 1; for (int i = l; i &lt;= m; i++) &#123; int v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod; a[i] = v0; a[i+t] = v1; &#125; ifwt(a, l, m); ifwt(a, m+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf("%d", &amp;a[i]); int s = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) s = (s + a[i]) % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod; for (int i = 0; i &lt; (1&lt;&lt;n); i++) a[i] = (mod - a[i]) % mod; a[0] = (a[0] + 1) % mod; fwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1&lt;&lt;n)) % mod; ifwt(a, 0, (1&lt;&lt;n)-1); for (int i = 1; i &lt; (1&lt;&lt;n); i++) a[i] = (a[i] + mod - a[0]) % mod; a[0] = 0; for (int i = 0; i &lt; (1&lt;&lt;n); i++) printf("%d\n", a[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC103D] Distance Sums]]></title>
    <url>%2F2019%2F11%2F01%2F%5BARC103D%5D-%2F</url>
    <content type="text"><![CDATA[arc È¢òÂè∑ÂæàÁ•ûÂ•á...‰ª•ÈìæÊé•‰∏≠ÁöÑ‰∏∫ÂáÜ„ÄÇ È¢òËß£ ÁªôÁÇπ \(i\) ‰∏Ä‰∏™ÊùÉÈáç \(w_i\)ÔºåÈáçÊñ∞ÂÆö‰πâ \(D_i = \sum_k w_k dis(i,k)\)„ÄÇÂàùÂßãÊó∂ÂØπ‰∫éÊâÄÊúâÁöÑ \(i\)Ôºå\(w_i = 1\)„ÄÇ‰ªªÊÑèÊó∂ÂàªÔºå\(\sum_i w_i = n\)„ÄÇ ÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁÇπ \(v\) ‰∏éÁÇπ \(u\) Áõ∏ÈÇªÔºå‰ª•ÁÇπ \(u\) ‰∏∫Ê†πÊó∂ÁÇπ \(v\) ÁöÑÂ≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáç‰πãÂíå‰∏∫ \(s\)ÔºåÂàô \(D_v - D_u = n - 2s\)„ÄÇ ÊâæÂà∞ \(D_u\) ÊúÄÂ§ßÁöÑÁÇπ \(u\)ÔºåÁî±‰∫é‰ªª‰Ωï‰∏é \(v\) Áõ∏ÈÇªÁöÑÁÇπÈÉΩÊª°Ë∂≥ \(D_v - D_u \le 0\)ÔºåÊâÄ‰ª•‰ª• \(u\) ‰∏∫Ê†π \(v\) Â≠êÊ†ë‰∏≠ÁöÑÁÇπÊùÉÈáçÂíåËá≥Â∞ë‰∏∫ \(\frac n 2\)ÔºåÊâÄ‰ª• \(u\) Ëá≥Â§öÊúâ‰∏Ä‰∏™Áõ∏ÈÇªÁÇπ„ÄÇÊàë‰ª¨‰∏çËÄÉËôë \(n = 1\) ÁöÑÊÉÖÂÜµ„ÄÇ\(u\) ÊòØ‰∏Ä‰∏™Âè∂Â≠ê„ÄÇ ÂÅáËÆæ‰∏é \(u\) Áõ∏ÈÇªÁöÑÁÇπÊòØ \(f\)ÔºåÈÇ£‰πà \(D_f-D_u = 2w_u - n\)ÔºåÁî±‰∫é \(D_i\) ‰∫í‰∏çÁõ∏ÂêåÔºåËøôÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü \(u\) ÁöÑÁà∂‰∫≤ \(f\)„ÄÇÊàë‰ª¨ËÆ∞ÂΩï‰∏Ä‰∏ãÁÇπ \(u\) ÂíåÁÇπ \(f\) Ëøû‰∏ÄÊù°ËæπÔºåÊääÁÇπ \(f\) ÁöÑÊùÉÈáçÂä†‰∏äÁÇπ \(u\) ÁöÑÊùÉÈáçÔºåÁÑ∂ÂêéÊääÁÇπ \(u\) Âà†Âéª„ÄÇËøôÊ†∑ÂØπËøòÂú®Ê†ë‰∏äÁöÑ‰ªª‰Ωï‰∏Ä‰∏™ÁÇπ \(i\)ÔºåÁªèËøáËøôÊ¨°Êìç‰Ωú \(D_i\) ÊÅ∞Â•ΩÂáèÂ∞ë‰∫Ü \(w_u\)„ÄÇÊõ¥Êñ∞‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰∏ÄÁõ¥ËøôÊ†∑Êìç‰Ωú‰∏ãÂéªÂ∞±ÂîØ‰∏ÄÁ°ÆÂÆö‰∫Ü‰∏ÄÊ£µÊ†ëÔºåÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÔºàÊáíÂæóÂà§ÁâπÊÆäÊÉÖÂÜµÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõÈ™åËØÅ‰∫ÜÔºâ ÂÆûÈôÖ‰∏ä‰∏çÈúÄË¶ÅÊõ¥Êñ∞ \(D_i\)ÔºåÂõ†‰∏∫ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØÊï¥‰ΩìÂä†ÔºåËÄåÊàë‰ª¨ÂßãÁªàÂè™‰ºöÁî®Âà∞ \(D_i\) ÁöÑÁõ∏ÂØπÂ§ßÂ∞èÂÖ≥Á≥ªÂíå \(D_f-D_u\) ÁöÑÂÄº„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;priority_queue&lt;ll&gt; pq;map&lt;ll, int&gt; mp;int n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;ll D[maxn], S[maxn];struct Edge &#123; int v, x;&#125; E[maxn];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs1(int u) &#123; sz[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; dep[v] = dep[u] + 1; dfs1(v); sz[u] += sz[v]; &#125;&#125;void dfs2(int u) &#123; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; S[v] = S[u] + n - 2 * sz[v]; dfs2(v); &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;D[i]); for (int i = 1; i &lt;= n; i++) &#123; mp[D[i]] = i; pq.push(D[i]); w[i] = 1; &#125; vis[0] = 1; while (pq.size() &gt; 1) &#123; ll v = pq.top(); pq.pop(); int u = mp[v]; vis[u] = 1; if (!vis[mp[v + 2 * w[u] - n]]) &#123; int t = mp[v + 2 * w[u] - n]; w[t] += w[u]; addEdge(t, u); ++ tot; e_u[tot] = t; e_v[tot] = u; &#125; else &#123; puts("-1"); return 0; &#125; &#125; int r = mp[pq.top()]; dfs1(r); for (int i = 1; i &lt;= n; i++) S[r] += dep[i]; dfs2(r); for (int i = 1; i &lt;= n; i++) &#123; if (S[i] != D[i]) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d %d\n", e_u[i], e_v[i]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC030D] Inversion Sum]]></title>
    <url>%2F2019%2F11%2F01%2F%5BAGC030D%5D-Inversion-Sum%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ËÆæ \(f_{ij}\) Ë°®Á§∫ \(A_i &lt; A_j\) ÁöÑÊ¶ÇÁéá„ÄÇ ÊØèÊ¨°‰øÆÊîπ \(\mathcal O(n)\) Êõ¥Êñ∞‰∏Ä‰∏ãÂ∞±Ë°å„ÄÇ ÊúÄÂêéÊ±ÇÂá∫ÈÄÜÂ∫èÂØπ‰∏™Êï∞ÁöÑÊúüÊúõÔºå‰πò‰ª• \(2^q\) Â∞±ÊòØÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;const int mod = 1e9+7;int A[maxn], f[maxn][maxn];int n, q;int main() &#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;A[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = (A[i] &lt; A[j]); &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); int inv = (mod + 1) / 2; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[j][x] + f[j][y]) * inv % mod; f[j][x] = f[j][y] = s; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (j != x &amp;&amp; j != y) &#123; int s = 1LL * (f[x][j] + f[y][j]) * inv % mod; f[x][j] = f[y][j] = s; &#125; &#125; int s = 1LL * (f[x][y] + f[y][x]) * inv % mod; f[x][y] = f[y][x] = s; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; ans = (ans + f[i][j]) % mod; &#125; &#125; for (int i = 1; i &lt;= q; i++) ans = 1LL * ans * 2 % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC026F] Manju Game]]></title>
    <url>%2F2019%2F11%2F01%2FAGC026F%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ‰∏∫‰∫ÜÊñπ‰æøÊèèËø∞ÁªìËÆ∫ÔºåÊääËæìÂÖ•ÁöÑÊï∞ÁªÑÁúã‰Ωú \(n\) ‰∏™Ê†ºÂ≠êÔºåÊØè‰∏™Ê†ºÂ≠êÈáåÂ°´‰∫Ü‰∏Ä‰∏™Êï∞Â≠ó„ÄÇÂØπÊ†ºÂ≠êÈªëÁôΩÊüìËâ≤ÔºåÁ¨¨‰∏Ä‰∏™Ê†ºÂ≠êÊòØÈªëËâ≤ÔºåÁõ∏ÈÇª‰∏§‰∏™Ê†ºÂ≠êÈ¢úËâ≤‰∏çÂêå„ÄÇ ‰∏çÈöæÂèëÁé∞ÁªìËÆ∫ÔºöÂ¶ÇÊûú \(n\) ‰∏∫ÂÅ∂Êï∞ÔºåÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÂæóÂà∞ÁöÑÊî∂ÁõäÊòØÈªëÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏éÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíåÁöÑÊúÄÂ§ßÂÄº„ÄÇÂ¶ÇÊûú \(n\) ‰∏∫Â•áÊï∞ÔºåËÆæÁôΩÊ†ºÂ≠ê‰∏äÊï∞Â≠óÁöÑÂíå‰∏∫ \(s\)ÔºåÂÖàÊâãËÉΩÂ§üËé∑ÂæóËá≥Â∞ë \(x\) ÁöÑÊî∂ÁõäÔºåÂΩì‰∏î‰ªÖÂΩìÂ≠òÂú®‰∏ÄÁßçÈÄâÂá∫Ëã•Âπ≤‰∏™ÁôΩÊ†ºÂ≠êÁöÑÊñπÊ°àÔºåÁî®Ëøô‰∫õÁôΩÊ†ºÂ≠êÊää \(n\) ‰∏™Ê†ºÂ≠êÂàÜÊàêËã•Âπ≤‰∏™ËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÂÜÖÈªëÊ†ºÂ≠êÁöÑÂíåÂáèÂéªÁôΩÊ†ºÂ≠êÁöÑÂíåÈÉΩÂ§ß‰∫éÁ≠â‰∫é \(x-s\)„ÄÇ ËØÅÊòéÊØîËæÉÊòæÁÑ∂ÔºåÂÖ∑‰ΩìËøáÁ®ã‰∏çÂÜôÂá∫‰∫Ü„ÄÇÂ§ßÊ¶ÇÊÄùË∑ØÂ∞±ÊòØË¶ÅËØÅÊòéÂÖàÊâãÊúÄ‰ºòÁ≠ñÁï•ÁöÑÊî∂ÁõäÊòØ \(x\)ÔºåÂè™ÈúÄÂÖàÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•ÔºåÊó†ËÆ∫ÂêéÊâãÊÄé‰πàÊìç‰ΩúËá≥Â∞ëËÉΩÂ§ü \(x\) ÁöÑÊî∂ÁõäÔºåÂêéÊâãÂ≠òÂú®‰∏ÄÁßçÁ≠ñÁï•Êó†ËÆ∫ÂÖàÊâãÊÄé‰πàÊìç‰Ωú‰∏ÄÂÆöËÉΩ‰ΩøÂÖàÊâãËé∑ÂæóËá≥Â§ö \(x\) ÁöÑÊî∂Áõä„ÄÇ\(n\) ‰∏∫Â•áÊï∞Áõ¥Êé•ÂÅöÔºå\(n\) ‰∏∫ÂÅ∂Êï∞‰∫åÂàÜ dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;int n, a[maxn], sum[maxn];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); if (n &amp; 1) &#123; int L = -1e9, R = 1e9, ans = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i]; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int mns = 0; for (int i = 1; i &lt; n; i += 2) &#123; if (sum[i] - mns &gt;= mid) &#123; mns = min(mns, sum[i+1]); &#125; &#125; if (sum[n] - mns &gt;= mid) &#123; L = mid + 1; ans = mid; &#125; else R = mid-1; &#125; for (int i = 2; i &lt;= n; i += 2) ans += a[i]; for (int i = 1; i &lt;= n; i++) s += a[i]; printf("%d %d\n", ans, s - ans); &#125; else &#123; int s0 = 0, s1 = 0; for (int i = 1; i &lt;= n; i++) if (i &amp; 1) s1 += a[i]; else s0 += a[i]; if (s0 &lt; s1) swap(s0, s1); printf("%d %d\n", s0, s1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC022E] Median Replace]]></title>
    <url>%2F2019%2F10%2F26%2F%5BAGC%5D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂèØ‰ª•ÂèëÁé∞ÔºåÂÅáËÆæÊúÄÁªàËÉΩÂèòÊàê 0ÔºåÂ¶ÇÊûúÊúâ 000ÔºåÁ¨¨‰∏ÄÊ≠•Êìç‰ΩúÊääÂÆÉÂèòÊàê 0 ‰∏ÄÂÆöÊúÄÁªà‰ªçÁÑ∂ËÉΩÂèòÊàê 0„ÄÇËøôÊòØÂõ†‰∏∫ÔºåÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™Á¨¨‰∏ÄÊ≠•‰∏çÊòØÂØπËøô‰∏â‰∏™Êï∞Êìç‰ΩúÔºåËÄÉËôëÁ¨¨‰∏ÄÊ¨°ÂΩ±ÂìçÂà∞Ëøô‰∏â‰∏™Êï∞‰∏≠Êüê‰∏™Êï∞ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøô‰∏™Êìç‰ΩúÂ∞±ÊòØÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0ÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ÊääËøôÊ¨°Êìç‰ΩúÁßªÂä®Âà∞Á¨¨‰∏ÄÊ¨°Êìç‰Ωú„ÄÇÂê¶ÂàôÁöÑËØùÔºåÈÇ£‰πàÊääËøôÊ¨°Êìç‰ΩúÊîπ‰∏∫ÊääËøô‰∏â‰∏™ 0 ÂèòÊàê‰∏Ä‰∏™ 0 ËÇØÂÆö‰∏ç‰ºöÊõ¥Âä£„ÄÇÔºàÂõ†‰∏∫ÊääÂ∫èÂàó‰∏äÁöÑ‰∏Ä‰∏™ 0 Êîπ‰∏∫ 1 ÂæóÂà∞ÁöÑÂ∫èÂàó‰∏ÄÂÆö‰∏ç‰ºöÊõ¥Âä£ÔºâÁî®Á±ª‰ººÁöÑÊÄùË∑ØÂèØ‰ª•ËØÅÊòéÔºåÂ¶ÇÊûúÊúâ 010ÔºåÁ¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 0 ‰πü‰∏ç‰ºöÊõ¥Âä£ÔºåÂ¶ÇÊûúÊúâ 101 Á¨¨‰∏ÄÊ≠•ÊääÂÆÉÂèòÊàê 1 ‰πü‰∏ç‰ºöÊõ¥Âä£„ÄÇ ËÄÉËôë‰∏Ä‰∏™Â∫èÂàóÔºåÂèçÂ§çËøõË°å‰ª•‰∏ä‰∏âÁßçÊìç‰ΩúÁõ¥Âà∞‰∏çËÉΩÊìç‰ΩúÔºåÊääÂæóÂà∞ÁöÑÂ∫èÂàóÂàíÂàÜ‰∏∫Ëã•Âπ≤‰∏™ 0 / 1 ÁöÑËøûÁª≠ÊÆµÔºåÈô§‰∫ÜÂºÄÂ§¥ÂíåÁªìÂ∞æÁöÑËøûÁª≠ÊÆµÔºåÊØè‰∏™ËøûÁª≠ÊÆµÈïøÂ∫¶Ëá≥Â∞ë‰∏∫ \(2\)Ôºå‰∏î 0 ÁöÑËøûÁª≠ÊÆµÈïøÂ∫¶‰∏ç‰ºöË∂ÖËøá \(2\)„ÄÇÊòæÁÑ∂Êää 111 ÂèòÊàê 1 ÊòØ‰∏ç‰ºòÁöÑ„ÄÇ‰∏çÈöæÁî®ÂΩíÁ∫≥Ê≥ïËØÅÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÔºåÈÉΩ‰∏ç‰ºöÂá∫Áé∞ 000„ÄÇÔºàËÄÉËôëÂú®ËøõË°å‰∏ÄÊ≠•Êìç‰Ωú‰πãÂêéÔºåÂà©Áî® 010 Âèò‰∏∫ 0 ÁöÑÁªìËÆ∫ÂÜçËøõË°å‰∏ÄÊ¨°Êìç‰ΩúÔºåËøôÊ†∑Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™Êõ¥Áü≠ÁöÑÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºâËÄåÂÖ∂‰ªñÊìç‰ΩúÈÉΩ‰ºö‰Ωø 0 ÁöÑ‰∏™Êï∞Âíå 1 ÁöÑ‰∏™Êï∞ÂêåÊó∂ÂáèÂ∞ë 1„ÄÇËøôÂ∞±ËØ¥ÊòéÊª°Ë∂≥Ëøô‰∏™Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÊúÄÁªàËÉΩÂèòÊàê 1ÔºåÂΩì‰∏î‰ªÖÂΩì 1 ÁöÑ‰∏™Êï∞Â§ß‰∫é 0 ÁöÑ‰∏™Êï∞„ÄÇÔºàÈïøÂ∫¶ÂøÖ‰∏∫Â•áÊï∞Ôºâ ÂØπËøô‰∏™‰∏úË•ø dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂâçÁºÄ 1 ÁöÑ‰∏™Êï∞ÂáèÂéª 0 ÁöÑ‰∏™Êï∞Â§ß‰∫éÁ≠â‰∫é \(2\)ÔºåËøô‰∏™Â∫èÂàóÂøÖÁÑ∂ÂèØ‰ª•ÂèòÊàê 0„ÄÇÊâÄ‰ª•ÂÆûÈôÖÈúÄË¶ÅËÆ∞ÁöÑÁä∂ÊÄÅÊï∞ÂæàÂ∞ë„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC023E] Inversions]]></title>
    <url>%2F2019%2F10%2F24%2F%5BAGC023E%5D-Inversions%2F</url>
    <content type="text"><![CDATA[È¢òËß£ ÂØπ‰∫é \(i, j\)ÔºåËÄÉËôë \(P_i &gt; P_j\) ÁöÑÊñπÊ°àÊï∞„ÄÇÂè™ÈúÄËÄÉËôë \(A_i \le A_j\) ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇËøôÁõ∏ÂΩì‰∫éÊòØÊää \(A_j\) Êîπ‰∏∫ \(A_i\) ‰πãÂêéÊª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÈôêÂà∂ÁöÑÊéíÂàóÊï∞Èô§‰ª• \(2\)„ÄÇ Êää \(1 \ldots n\) Êåâ \(A_i\) ‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåËÆæÊéíÂ∫èÂêéÁ¨¨ \(i\) ‰∏™Êï∞ÊòØ \(p_i\)„ÄÇÊòæÁÑ∂Êª°Ë∂≥ \(\forall i, P_i \le A_i\) ÁöÑÊéíÂàóÊÄªÊï∞‰∏∫ \(\prod_i A_{p_i}-i+1\)„ÄÇËÆæÊÄªÊï∞‰∏∫ \(C\)„ÄÇ ËÆæ \(B_i = \frac{A_{p_i}-i}{A_{p_i}-i+1}\) ÂØπÊâÄÊúâÊª°Ë∂≥ \(p_i &lt; p_j\) ÁöÑ \((i,j)\) ËÆ°ÁÆó \(P_{p_i} &gt; P_{p_j}\) ÁöÑÊéíÂàóÊï∞„ÄÇÂØπ‰∫éÊØè‰∏ÄÂØπ \(i &lt; j\)ÔºåÂ¶ÇÊûú \(p_i &lt; p_j\)ÔºåÈÇ£‰πàÂÆÉÁöÑË¥°ÁåÆÊòØ \(\frac 1 2 C\frac{A_{p_i}-i}{A_{p_j}-j+1}\prod_{k=i+1}^{j-1} B_k\)„ÄÇ\(p_i &gt; p_j\) ÁöÑÊÉÖÂÜµÊ≤°ÊúâÂæàÂ§ßÂå∫Âà´ÔºåÂÖ∑‰ΩìÂºèÂ≠êÂ∞±‰∏çÂÜôÂá∫Êù•‰∫Ü„ÄÇÊûö‰∏æ \(j\)ÔºåÁî®Á∫øÊÆµÊ†ëÂØπÊØè‰∏™ \(p_i\) Áª¥Êä§‰∏ãËøô‰∏™ÂºèÂ≠êÔºåÊØèÊ¨°ÁßªÂä® \(j\) ÁöÑÊó∂ÂÄôÂå∫Èó¥‰πòÊõ¥Êñ∞ÔºåÁªüËÆ°Á≠îÊ°àÊó∂Âå∫Èó¥Ê±ÇÂíåÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pi;const int mod = 1e9+7;const int maxn = 200010;int n, C = 1, ans = 0;pi a[maxn];int b[maxn], sum[maxn&lt;&lt;2], cnt[maxn&lt;&lt;2], K[maxn&lt;&lt;2];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL * ret * x % mod; x = 1LL * x * x % mod; y &gt;&gt;= 1; &#125; return ret;&#125;void pushUp(int rt) &#123; sum[rt] = (sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]) % mod; cnt[rt] = cnt[rt&lt;&lt;1] + cnt[rt&lt;&lt;1|1];&#125;void modify(int rt, int k) &#123; sum[rt] = 1LL * sum[rt] * k % mod; K[rt] = 1LL * K[rt] * k % mod;&#125;void pushDown(int rt) &#123; if (K[rt] != 1) &#123; modify(rt&lt;&lt;1, K[rt]); modify(rt&lt;&lt;1|1, K[rt]); K[rt] = 1; &#125;&#125;void update(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (sum[rt] + v) % mod; cnt[rt] ++; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, v, l, m, rt&lt;&lt;1); else update(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int ret = 0; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = (ret + query(L, R, l, m, rt&lt;&lt;1)) % mod; if (R &gt; m) ret = (ret + query(L, R, m+1, r, rt&lt;&lt;1|1)) % mod; return ret;&#125;int query_cnt(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cnt[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) ret = ret + query_cnt(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + query_cnt(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a+1, a+n+1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].first-i+1 &lt;= 0) &#123; puts("0"); return 0; &#125; b[i] = 1LL*(a[i].first-i)*qpow(a[i].first-i+1, mod-2)%mod; &#125; for (int i = 1; i &lt;= n; i++) C = 1LL * C * (a[i].first-i+1) % mod; for (int i = 1; i &lt;= n; i++) &#123; int v = 1LL*(mod+1)/2*C%mod*qpow(a[i].first-i+1, mod-2)%mod; ans = (ans + 1LL*v*query(1, a[i].second-1, 1, n, 1)%mod)%mod; ans = ((ans + 1LL*C*query_cnt(a[i].second+1, n, 1, n, 1)%mod)%mod+mod-1LL*v*query(a[i].second+1, n, 1, n, 1)%mod)%mod; K[1] = 1LL * K[1] * b[i] % mod; sum[1] = 1LL * sum[1] * b[i] % mod; update(a[i].second, a[i].first-i, 1, n, 1); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Atcoder</tag>
        <tag>ËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1204D] Kirk and a Binary String]]></title>
    <url>%2F2019%2F09%2F21%2FCF1204D%2F</url>
    <content type="text"><![CDATA[È¢òËß£ update: ÊÑüËßâÊàëÂÅöÈ∫ªÁÉ¶‰∫ÜÔºåÈ¢òËß£ÂÅöÊ≥ïÂ•ΩÁÆÄÂçï„ÄÇËøôÁØá blog Â∞±‰∏¢ËøôÂêß‚Ä¶..ÊÑüËßâÊ≤°‰ªÄ‰πàÈîôËØØ„ÄÇ Â¶ÇÊûúÂè™Êää \(0\) ÂèòÊàê \(1\) ËÄå‰∏çÊää \(1\) ÂèòÊàê \(0\)Ôºå‰ºöÂØºËá¥ \(0\) ÁöÑ‰∏™Êï∞ÂáèÂ∞ëÔºåËøò‰∏çÂ¶Ç‰∏çÊîπÂèòÂéüÂ∫èÂàó„ÄÇ Â¶ÇÊûúÊó¢Âá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ‰πüÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\)ÔºåËÆæÊüê‰∏Ä‰∏™Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_1\)ÔºåÊüê‰∏Ä‰∏™Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆ‰∏∫ \(p_2\)„ÄÇ ‰∏çÂ¶®ËÆæ \(p_1 &lt; p_2\)„ÄÇÔºàÂ¶ÇÊûú \(p_1 &gt; p_2\)Ôºå‰∫§Êç¢ÂéüÂ∫èÂàóÂíåÊñ∞Â∫èÂàóÂ∞±Âíå‰∏ÄÁßç \(p_1 &lt; p_2\) ÁöÑÊÉÖÂÜµÁ≠â‰ª∑‰∫ÜÔºâ ËÆæ \(f[l,r]\) Ë°®Á§∫ÂéüÂ∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶Ôºå\(g[l,r]\) Ë°®Á§∫Êñ∞Â∫èÂàó‰∏ä \([l,r]\) ‰∏≠ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ ÂÆö‰πâ \(f[l,r] = g[l,r] = 0(l &gt; r)\)„ÄÇ ÈÇ£‰πà \(f[p_1,p_2] = f[p_1+1, p_2-1]+2 \Rightarrow g[p_1,p_2] = g[p_1+1,p_2-1]+2\)„ÄÇ Âõ†Ê≠§Êñ∞Â∫èÂàó‰∏ä \([p_1,p_2]\) ‰∏≠ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂøÖÁÑ∂Ë¶ÅÂåÖÂê´ \(p_1\) Âíå \(p_2\)Ôºå‰ΩÜÊòØÊñ∞Â∫èÂàó‰∏ä \(p_1\) ‰ΩçÁΩÆ‰∏∫ \(1\)Ôºå\(p_2\) ‰ΩçÁΩÆ‰∏∫ \(0\)ÔºåËøôÊòØ‰∏çÂèØËÉΩÁöÑ„ÄÇ Âõ†Ê≠§ÔºåÂè™‰ºöÂá∫Áé∞Êää \(1\) ÂèòÊàê \(0\) ÁöÑ‰ΩçÁΩÆÔºå‰∏ç‰ºöÂá∫Áé∞Êää \(0\) ÂèòÊàê \(1\) ÁöÑ‰ΩçÁΩÆ„ÄÇ ËÄÉËôëÊää‰∏Ä‰∏™‰ΩçÁΩÆÂú®ÂéüÂ∫èÂàóÂ∑¶Á´ØÊàñÂ∑¶Ëæπ‰∏ç‰∏∫ \(1\) ÁöÑ \(1\) ÂèòÊàê \(0\)Ôºå‰∏çÂØπ‰ªªÊÑèÂå∫Èó¥ÂÜÖÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàó‰∫ßÁîüÂΩ±ÂìçÁöÑÊù°‰ª∂„ÄÇ ÂÅáËÆæËøô‰∏™‰ΩçÁΩÆÊòØ \(p\)„ÄÇÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫Ôºö \(p &lt; n\) ‰∏î‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(1\). \(p = n\) Êàñ‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\). ÂÖàÁúãÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ„ÄÇÊää‰ΩçÁΩÆ \(p\) ‰∏äÁöÑ \(1\) ÂèòÊàê \(0\) Áúã‰ΩúÊñ∞Â∫èÂàóÔºàÁî® \(g[l,r]\) ÊèèËø∞Êñ∞Â∫èÂàó‰∏äÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºâ„ÄÇÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\(f[i,p] = f[i,p-1] + 1 \Rightarrow g[i,p] = g[i,p-1] + 1\)ÔºåËÄåÊñ∞Â∫èÂàó‰∏ä‰ΩçÁΩÆ \(p\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøôËØ¥Êòé \([i,p-1]\) Â≠òÂú®ÁªìÂ∞æ‰∏∫ \(0\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂç≥ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÁ≠â‰∫é \([i, p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞„ÄÇÂèØ‰ª•ËØÅÊòéËøô‰∏™Êù°‰ª∂ÂØπ‰ªªÊÑèÁöÑ \(i &lt; p\) ÈÉΩÊàêÁ´ãÁöÑÂÖÖË¶ÅÊù°‰ª∂‰∏∫ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; p\)Ôºå\([i,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºöÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑÔºåÂè™ÈúÄËØÅÂÖÖÂàÜÊÄßÔºåÂÅáËÆæ \([i, p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÂ§ß‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºå‰ªªÂèñ‰∏Ä‰∏™ \([i,p-1]\) ÁöÑÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÔºåÂÆÉÂøÖÁÑ∂ÂåÖÂê´‰∏Ä‰∏™ \(1\)ÔºåËÆæÁ¨¨‰∏Ä‰∏™ \(1\) ‰ΩçÁΩÆ‰∏∫ \(k\)ÔºåÈÇ£‰πàËøô‰∏™Â≠êÂ∫èÂàó \(k\) ‰πãÂâçÁöÑÂÖÉÁ¥†ÂÜçÊãº‰∏ä \([k,p-1]\) ‰∏≠ÊâÄÊúâÁöÑ \(0\) ÂøÖÁÑ∂ÊòØ‰∏Ä‰∏™ÂÖ® \(0\) ÁöÑ‰∏ç‰ºöÊõ¥Áü≠ÁöÑÂ≠êÂ∫èÂàóÔºàÂõ†‰∏∫ \([k,p-1]\) ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºâÔºåËøô‰∏é‰∏çÂ≠òÂú®ÂÖ®‰∏∫ \(0\) ÁöÑ‰∏çÈôçÂ≠êÂ∫èÂàóÁüõÁõæ„ÄÇ‰∏çÈöæÈ™åËØÅËøô‰πüÊòØÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏≠ËÉΩÊää \(p\) ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂„ÄÇ Á¨¨‰∫åÁßçÊÉÖÂÜµÊòæÁÑ∂‰πüÂøÖÈ°ªË¶ÅÊª°Ë∂≥Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑÊù°‰ª∂„ÄÇÈô§Ê≠§‰πãÂ§ñÔºåÁî±‰∫é‰ΩçÁΩÆ \(p+1\) ‰∏äÁöÑÊòØ \(0\)ÔºåËøòÈúÄÊª°Ë∂≥ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &gt; p\)Ôºå\([p+1,i]\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏çÂ∞ë‰∫é \(0\) ÁöÑ‰∏™Êï∞Ôºà‰∏éÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑËØÅÊòéÁ±ª‰ººÔºåËØ¶ÁªÜËøáÁ®ãÂ∞±‰∏çÂÜô‰∫ÜÔºâ„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ë¥™ÂøÉÔºåÂØπ‰∫é‰∏Ä‰∏™‰ΩçÁΩÆÔºåÂ¶ÇÊûúÂÆÉÊòØ \(1\)Ôºå‰∏îËÉΩÂ§ü‰øùÊåÅ‰ªªÊÑèÂå∫Èó¥ÊúÄÈïø‰∏çÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏çÂèòÂú∞Âèò‰∏∫ \(0\)ÔºåÂ∞±ÊääÂÆÉÂèòÊàê \(0\)„ÄÇ‰∏çÈöæËØÅÊòéËøôÁßçË¥™ÂøÉÊòØÊ≠£Á°ÆÁöÑÔºåËØ¶ÁªÜËØÅÊòéËøôÈáå‰∏çÂÜô‰∫Ü„ÄÇÔºàÊèêÁ§∫ÔºöËÄÉËôëÊúÄ‰ºòËß£‰∏≠ \(1\rightarrow0\) ÁöÑÊúÄÂ∞è‰ΩçÁΩÆÔºâ Âà§Êñ≠ÊòØÂê¶Â≠òÂú®ÂâçÁºÄ / ÂêéÁºÄ \(0\) ÁöÑ‰∏™Êï∞Â§ö‰∫é / Â∞ë‰∫é \(1\) ÁöÑ‰∏™Êï∞ÔºåÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÊØè‰∏™ÂâçÁºÄ‰∏≠ \(0\) ÁöÑ‰∏™Êï∞Âáè \(1\) ÁöÑ‰∏™Êï∞ÂæàÂÆπÊòìÂú∞Â§ÑÁêÜ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1188E] Problem from Red Panda]]></title>
    <url>%2F2019%2F09%2F18%2FCF1188E%2F</url>
    <content type="text"><![CDATA[ËøòÊ≤°ÂÜôËøá„ÄÇÂ¶ÇÊûúÊúâÈîôËØØÂèØ‰ª• QQ / ËØÑËÆ∫ÂëäËØâÊàë„ÄÇ È¢òËß£ ËøôÊ†∑ÁêÜËß£Ëøô‰∏™ÈóÆÈ¢òÔºöÂàùÂßãÊó∂Êó∂Èó¥‰∏∫Á¨¨ \(0\) Áßí„ÄÇÊØèÁßí‰Ω†ÂèØ‰ª•ÈÄâÊã©‰∏Ä‰∏™ \(i\)ÔºåÁÑ∂ÂêéÊää \(a_i\) Âä†‰∏ä \(k\)ÔºåÊé•‰∏ãÊù•ÂÜçÊääÊâÄÊúâ \(a_i\) ÂáèÂéª \(1\)„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÂÅúÊ≠¢Ëøô‰∏™ËøáÁ®ãÔºåÂπ∂ÊääÂΩìÂâçÁöÑ \(a\) Êï∞ÁªÑ‰Ωú‰∏∫ÁªìÊûú„ÄÇÈóÆÂú®‰∏çÁªèËøá‰ªª‰ΩïÂ≠òÂú® \(a_i &lt; 0\) ÁöÑÁä∂ÊÄÅÁöÑÂâçÊèê‰∏ãÔºåËÉΩÂ§üÂæóÂà∞Â§öÂ∞ëÁßç‰∏çÂêåÁöÑÁªìÊûú„ÄÇ ‰ªéËøô‰∏™ËßíÂ∫¶Êù•ÁúãÔºåÂ¶ÇÊûú‰∏çËÄÉËôë \(+k\) Êìç‰ΩúÔºåÊØèÁßíÊØè‰∏™ \(a_i\)ÈÉΩ‰ºöÂáèÂ∞ë \(1\)„ÄÇ ËÆæ \(c_{t,i}\) Ë°®Á§∫Ââç \(t\) Áßí \(a_i\) Ë¢´ÊâßË°å \(+k\) Êìç‰ΩúÁöÑÊ¨°Êï∞„ÄÇÈÇ£‰πàÔºåÂ¶ÇÊûúËøô‰∏™ËøáÁ®ãÂú®ËøõË°å‰∫Ü \(T\) Áßí‰πãÂêéÁªìÊùüÔºå\(\forall t \le T, 1 \le i \le n, a_i-t+kc_{t,i} \ge 0\)Ôºå‰πüÂ∞±ÊòØËØ¥ \(\forall 1 \le i \le n, 0 \le p \le \lfloor \frac {T-a_i-1} k \rfloor,c_{a_i+kp+1,i} \ge p+1\)„ÄÇ ‰∏çÈöæËØÅÊòéÂ≠òÂú®ÁªèËøá \(T\) ÁßíÊ≤°ÊúâÂá∫Áé∞ËøáË¥üÊï∞ÁöÑÊñπÊ°àÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºö \[ \forall t \le T, \sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t \] ÂØπ‰∫é \(t \in \mathbb{N}\)Ôºå\(\sum_i \lceil \frac{\max(t-a_i, 0)} k \rceil \le t\) ÊòØÂê¶ÊàêÁ´ãÊòØ‰∏é \(T\) Êó†ÂÖ≥ÁöÑ„ÄÇÊâÄ‰ª•ÔºåË¶Å‰πàÂØπÊâÄÊúâÁöÑ \(T\) ÈÉΩÂ≠òÂú®‰∏çÁªèËøáË¥üÊï∞ÁöÑÊñπÊ°àÔºåË¶Å‰πàÂ≠òÂú®‰∏Ä‰∏™ÈùûË¥üÊï¥Êï∞ \(T_0\)ÔºåÂΩì \(T \le T_0\) Êó∂Â≠òÂú®ÊñπÊ°àÔºå\(T &gt; T_0\) Êó∂‰∏çÂ≠òÂú®ÊñπÊ°à„ÄÇ Â§™Êôö‰∫ÜÂÖàÁù°‰∫Ü„ÄÇÂùëÂæÖÂ°´„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàËÆ°Êï∞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces571E] Geometric Progressions]]></title>
    <url>%2F2019%2F09%2F18%2FCF571E%2F</url>
    <content type="text"><![CDATA[Âè£ËÉ°ÁöÑÊ≤°ÂÆûÁé∞ËøáÔºåÂ¶ÇÊúâÈîôËØØËØ∑ QQ ÊàñËØÑËÆ∫ÂëäËØâÊàëÔºÅ È¢òËß£ ËÄÉËôëÂè™Êúâ‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÁöÑÊÉÖÂÜµ„ÄÇ Á¨¨‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_1, a_1b_1, a_1b_1^2, \ldots\) Á¨¨‰∫å‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(a_2,a_2b_2,a_2b_2^2,\ldots\) ÂÅáËÆæ \(v\) ÂêåÊó∂Âá∫Áé∞Âú®‰∏§‰∏™Á≠âÊØîÊï∞Âàó‰∏≠ÔºåÈÇ£‰πà \(\exists k_1, k_2 \in \mathbb{N}, v = a_1b_1^{k_1} = a_2b_2^{k_2}\)„ÄÇ ËÆæ \(p_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™Á¥†Êï∞„ÄÇ \(b_1 = \prod p_i^{c_{1i}}, b_2 = \prod p_i^{c_{2i}}\) ËÄÉËôë‰ªªÊÑè‰∏§‰∏™‰∏çÂêåÁ¥†Êï∞ \(p_i\) Âíå \(p_j\)ÔºåÂÅáËÆæ \(p_i\) Âú® \(a_1,a_2\) ‰∏≠Âá∫Áé∞Ê¨°Êï∞ÂàÜÂà´ÊòØ \(w_{1i},w_{2i}\)„ÄÇ ÈÇ£‰πàÊúâ \[ \begin{cases} k_1 c_{1i}+w_{1i} = k_2{c_{2i}} + w_{2i}\\ k_1 c_{1j}+w_{1j} = k_2{c_{2j}} + w_{2j} \end{cases} \] ËøôÊòØ‰∏Ä‰∏™‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ãÁªÑ„ÄÇÂÅáËÆæ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåËøô‰∏™ÊñπÁ®ãÁªÑÊúâÂîØ‰∏ÄËß£„ÄÇ ÂÅáËÆæÂ≠òÂú® \(i &lt; j\)Ôºå \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÊó†ÂÖ≥ÔºåÈÇ£‰πàËß£Âá∫Ëøô‰∏™ÊñπÁ®ã„ÄÇËøôÊ†∑Â∞±ÂæóÂà∞‰∫ÜÂîØ‰∏Ä‰∏Ä‰∏™ÂèØËÉΩÊòØÊâÄÊúâÁ≠âÊØîÊï∞ÂàóÂÖ±ÊúâÂÖÉÁ¥†ÁöÑÊï∞ÔºàÁöÑÁ¥†Âõ†Êï∞ÂàÜËß£ÔºâÔºåÁÑ∂ÂêéÊ£ÄÈ™å‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âê¶ÂàôÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i &lt; j\) ÈÉΩÊúâ \((c_{1i},-c_{2i})\) Âíå \((c_{1j}, -c_{2j})\) Á∫øÊÄßÁõ∏ÂÖ≥„ÄÇ ÈÇ£‰πàÂ≠òÂú®Ê≠£Êï¥Êï∞ \(w\)Ôºå\(b_1 = w^{i_1}, b_2 = w^{i_2}((i_1,i_2) = 1)\)„ÄÇ \[ a_1b_1^{k_1} = a_2b_2^{k_2} \Leftrightarrow w^{k_1i_1-k_2i_2}=\frac {a_2} {a_1} \] ‰∏çÂ¶®ËÆæ \(a_1 \le a_2\)„ÄÇÈÇ£‰πà‰∏ÄÂÆöÊúâ \(a_1 \mid a_2\)„ÄÇ ËÆæ \(\frac {a_2} {a_1} = x\)ÔºåÂ¶ÇÊûúÊúâËß£ÔºåÂøÖÊúâ \(x = w^n, n \in \mathbb{N}\)„ÄÇ ÊñπÁ®ãÂèò‰∏∫ \(k_1i_1-k_2i_2 = n\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰∏çÂÆöÊñπÁ®ã„ÄÇ‰∏çÈöæÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑ‰∏ÄÁªÑËß£ \(k_1= x, k_2 = y\)„ÄÇÔºàÂÖ∑‰ΩìÊù•ËØ¥ÂÖàÊâæÂà∞ \(k_1i_1-k_2i_2=1\) ÁöÑËß£ÔºåÁÑ∂ÂêéÂú®‰∏§Ëæπ‰πò‰ª• \(n\)Ôºâ ÈÇ£‰πàËøô‰∏™ÊñπÁ®ãÁöÑÈÄöËß£‰∏∫ \(k_1 = x + pi_2, k_2 = y + pi_1, p \in \mathbb{Z}\)„ÄÇ ‰∏çÈöæÊâæÂà∞ \(k_1\) ÊúÄÂ∞èÁöÑÈùûË¥üÊï¥Êï∞Ëß£ÔºåÂÅáËÆæËøôÊó∂ \(a_1w^{k_1c_1}=t\)„ÄÇËøôÊ†∑‰∏§‰∏™Á≠âÊØîÊï∞ÂàóÂ∞±Ë¢´ÂêàÂπ∂‰∏∫‰∫Ü‰∏Ä‰∏™Á≠âÊØîÊï∞ÂàóÔºö\(t, w^{i_1i_2}t,w^{wi_1i_2}t,\ldots\)„ÄÇ ÁªßÁª≠ÊääÂêàÂπ∂ÂæóÂà∞ÁöÑÁ≠âÊØîÊï∞ÂàóÂíåÂÖ∂‰ªñÁ≠âÊØîÊï∞ÂàóËøõË°åÁõ∏ÂêåÁöÑÊìç‰ΩúÂç≥ÂèØ„ÄÇ]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÊîØÈÖçÊ†ë]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÊîØÈÖçÊ†ëÁöÑÁÆóÊ≥ïÂæàÂ¶ô„ÄÇÂÆÉÁöÑËØÅÊòéÂÆûÂú®Â§™Èïø‰∫Ü‚Ä¶.ÂÆåÊï¥ÂÜô‰∏ÄÈÅçÊØîËæÉË¥πÊó∂Èó¥ÔºåËøôÈáåÂ∞±Âè™ÂÜôÁªìËÆ∫‰∫Ü„ÄÇ ÊòæÁÑ∂ÊîØÈÖçÂÖ≥Á≥ªÊûÑÊàê‰∏ÄÊ£µÊ†ë„ÄÇ ÂÆö‰πâ \(sdom(u)\) ÊòØËÉΩÂ§ü‰ªé \(v\) Âá∫ÂèëÂè™ÁªèËøá \(dfn\) ÊØî \(u\) Â§ßÁöÑÂà∞Ëææ \(u\)Ôºà\(u\) Âíå \(v\) ‰∏çÁÆóÂú®ÈáåÈù¢ÔºâÁöÑ \(dfn\) ÊúÄÂ∞èÁöÑ \(v\)„ÄÇ \(sdom(u)\) Ë¶Å‰πàÊòØËÉΩÂ§üÈÄöËøá‰∏ÄÊù°ÂâçÂêëËæπ / Ê†ëËæπÁõ¥Êé•Âà∞Ëææ \(u\) ÁöÑÁÇπÔºåË¶Å‰πàÊòØÊª°Ë∂≥Â≠êÊ†ë‰∏≠Â≠òÂú®Ëá≥Â∞ë‰∏Ä‰∏™ÁÇπËÉΩÂ§üÁõ¥Êé•Ëµ∞Âà∞ \(u\) ‰∏î \(dfn\) ÊØî \(u\) Â§ßÁöÑÁÇπÁöÑ \(sdom\)„ÄÇÊ†πÊçÆËøô‰∏ÄÁÇπÂèØ‰ª•Âπ∂Êü•ÈõÜËÆ°ÁÆó \(sdom\)„ÄÇÂπ∂Êü•ÈõÜÁª¥Êä§ÁöÑÊòØÈìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇ ËÆæ \(v\) ÊòØ \(u\) Âà∞ \(sdom(u)\) ÁöÑÈìæ‰∏äÔºà‰∏çÂê´ \(sdom(u)\)Ôºâ\(sdom\) ÊúÄÂ∞èÁöÑÁÇπ ÔºåÈÇ£‰πàÂ¶ÇÊûú \(sdom(v) = sdom(u)\)Ôºå\(idom(u) = sdom(u)\)ÔºåÂê¶Âàô \(idom(u) = idom(v)\)„ÄÇËøô‰∏™‰∏úË•ø‰πüÊòØË¶ÅÊ±Ç‰∏Ä‰∏™Èìæ sdom ÁöÑÊúÄÂ∞èÂÄº„ÄÇÂèØ‰ª•Ê±Ç \(sdom\) ÁöÑÊó∂ÂÄôÈ°∫‰æøÁª¥Êä§‰∏Ä‰∏ã„ÄÇ Âú®Ëøô‰ªΩ‰ª£Á†Å‰∏≠ \(sdom\) Â≠òÁöÑÊòØ \(dfn\) ÊúÄÂ∞èÁöÑÁÇπÁöÑ \(dfn\) ËÄå‰∏çÊòØÁºñÂè∑ÔºåÈúÄË¶ÅÁâπÂà´Ê≥®ÊÑè„ÄÇ ÔºàÂê¨ËØ¥ËøôÈ¢òÊï∞ÊçÆÂæàÊ∞¥‚Ä¶ËØ¥‰∏çÂÆöÊúâÈîôÊ≤°Ë¢´Êü•Âá∫Êù•Ôºâ Ëøô‰ªΩ‰ª£Á†ÅË¢´Êèê‰∫§Âà∞ „ÄêÊ®°Êùø„ÄëÊîØÈÖçÊ†ë„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;const int maxm = 300010;int n, m, tot;int l[maxn], dfn[maxn], vis[maxn], a[maxn], sdom[maxn], idom[maxn], e;int fa[maxn], mn[maxn], mnp[maxn], sz[maxn];vector&lt;int&gt; vec[maxn], b[maxn], son[maxn], tree[maxn];struct Edge &#123; int v, x;&#125; E[maxm];inline void addEdge(int u, int v) &#123; E[e].v = v; E[e].x = l[u]; l[u] = e++;&#125;void dfs(int u) &#123; dfn[u] = ++ tot; a[tot] = u; vis[u] = 1; for (int p = l[u]; p &gt;= 0; p = E[p].x) &#123; int v = E[p].v; if (!dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); son[u].push_back(v); dfs(v); &#125; else if (!vis[v] &amp;&amp; dfn[u] &lt; dfn[v]) &#123; sdom[v] = min(sdom[v], dfn[u]); &#125; if (dfn[u] &gt; dfn[v]) vec[v].push_back(u); &#125; vis[u] = 0;&#125;int Min(int x, int y) &#123; return sdom[x] &lt; sdom[y] ? x : y;&#125;int getroot(int x) &#123; if (x == fa[x]) return x; int f = getroot(fa[x]); mn[x] = Min(mn[x], mn[fa[x]]); fa[x] = f; return f;&#125;void calsize(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; calsize(v); sz[u] += sz[v]; &#125;&#125;int main() &#123; memset(l, -1, sizeof(l)); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; i++) sdom[i] = n+1; dfs(1); for (int i = 1; i &lt;= n; i++) fa[i] = i, mn[i] = i; for (int _ = n; _ &gt;= 1; _--) &#123; int i = a[_]; for (int j = 0; j &lt; vec[i].size(); j++) &#123; int u = vec[i][j]; getroot(u); sdom[i] = min(sdom[i], sdom[mn[u]]); &#125; b[a[sdom[i]]].push_back(i); for (int j = 0; j &lt; b[i].size(); j++) &#123; int u = b[i][j]; getroot(u); mnp[u] = mn[u]; &#125; for (int j = 0; j &lt; son[i].size(); j++) &#123; int u = son[i][j]; fa[u] = i; &#125; &#125; for (int _ = 2; _ &lt;= n; _++) &#123; int i = a[_]; if (sdom[mnp[i]] &lt; sdom[i]) idom[i] = idom[mnp[i]]; else idom[i] = a[sdom[i]]; &#125; for (int i = 2; i &lt;= n; i++) tree[idom[i]].push_back(i); calsize(1); for (int i = 1; i &lt;= n; i++) printf("%d ", sz[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT ÈóÆÈ¢òÊÄªÁªì]]></title>
    <url>%2F2019%2F09%2F17%2F2-SAT%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥‰ª•Êù•ÂØπ 2-SAT ÁöÑÁêÜËß£ÊØîËæÉÊ®°Á≥äÔºåÊâÄ‰ª•ÂÜôËøôÊ†∑‰∏Ä‰∏™Â∞ΩÂèØËÉΩÊ∏ÖÊô∞ÁöÑÊÄªÁªìÊù•ÁêÜÊ∏ÖÊÄùË∑Ø„ÄÇ 2-SAT ÈóÆÈ¢òÁöÑÂÆö‰πâÔºöÊúâ \(n\) ‰∏™ÈÄªËæëÂèòÈáèÔºåÁî® \(b_i\) Ë°®Á§∫Á¨¨ \(i\) ‰∏™ÈÄªËæëÂèòÈáè„ÄÇ\(m\) ‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÊØè‰∏Ä‰∏™ÈôêÂà∂Êù°‰ª∂ÂΩ¢Â¶ÇÔºö\((\neg)b_i \to (\neg) b_j\)„ÄÇÈóÆÊòØÂê¶Â≠òÂú®Êª°Ë∂≥ÈôêÂà∂ÁöÑ \(b\)„ÄÇ Áî®ÂõæÊù•ÊèèËø∞ÈôêÂà∂Êù°‰ª∂„ÄÇÂØπÊØè‰∏™ÈÄªËæëÂèòÈáèÂª∫‰∏§‰∏™ÁÇπÔºåÂàÜÂà´‰ª£Ë°®ÂèñÂÄº‰∏∫ \(0\) ÂíåÂèñÂÄº‰∏∫ \(1\)„ÄÇ‰ª£Ë°® \(b_i=0\) ÁöÑÁÇπ‰∏∫ \(p_i\)Ôºå‰ª£Ë°® \(b_i = 1\) ÁöÑÁÇπ‰∏∫ \(q_i\)„ÄÇÂØπÊØè‰∏™ÈôêÂà∂Êù°‰ª∂ÔºåÂú®Âõæ‰∏äËøû‰∏ÄÊù°ÊúâÂêëËæπÔºåË°®Á§∫‰∏Ä‰∏™ÂëΩÈ¢òÊé®Âá∫Âè¶‰∏Ä‰∏™ÂëΩÈ¢òÔºåÁÑ∂ÂêéÂÜçÂä†‰∏ÄÊù°ËæπË°®Á§∫ËØ•ÈôêÂà∂Êù°‰ª∂ÁöÑÈÄÜÂê¶ÂëΩÈ¢ò„ÄÇ‰∏æ‰æãÊù•ËØ¥ÔºåÂ¶ÇÊûúÊúâÈôêÂà∂Êù°‰ª∂ \(\neg b_i \rightarrow b_j\)ÔºåÂ∞±Âä†ÂÖ• \((p_i, q_j)\) Âíå \((p_j, q_i)\) Ëøô‰∏§Êù°ÊúâÂêëËæπ„ÄÇÈóÆÈ¢òÂ∞±Âèò‰∏∫Âà§ÂÆöÊòØÂê¶Â≠òÂú®ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)ÔºåÊÅ∞Â•ΩÂåÖÂê´ \(p_i\) Âíå \(q_i\) ‰∏≠ÁöÑ‰∏Ä‰∏™ÁÇπÁöÑÈó≠ÂêàÂ≠êÂõæ„ÄÇ ÂÆöÁêÜÔºö2-SAT ÊúâËß£ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºåÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂú®Âêå‰∏ÄÂº∫ËøûÈÄöÂàÜÈáè‰∏≠„ÄÇ ÂøÖË¶ÅÊÄßÊòØÊòæÁÑ∂ÁöÑ„ÄÇ ‰∏ãÈù¢Áî®ÊûÑÈÄ†ËØÅÊòéÂÖÖÂàÜÊÄßÔºö ÂÖà tarjan Ê±ÇÂá∫Âº∫ËøûÈÄöÂàÜÈáèÔºåÊääÊØè‰∏™Âº∫ËÅîÈÄöÂàÜÈáèÁº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÁî±‰∫é‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÁöÑÁÇπÂØπÂ∫îÁõ∏ÂèçÂèñÂÄºÁöÑÁÇπ‰πüÊûÑÊàê‰∏Ä‰∏™Âº∫ËøûÈÄöÂàÜÈáèÔºåÊâÄ‰ª•Áº©ÁÇπÂêéÔºåËøô‰∏™ÈóÆÈ¢òÂèò‰∏∫‰∫Ü‰∏Ä‰∏™Êõ¥Â∞èÁöÑ 2-SAT ÈóÆÈ¢ò„ÄÇÂè™ÈúÄË¶ÅËß£ÂÜ≥ÂõæÊòØ DAG Êó∂ÁöÑÈóÆÈ¢òÂç≥ÂèØ„ÄÇ ÊääÊâÄÊúâÁöÑËæπÊñπÂêëÂèçËøáÊù•„ÄÇ‰∏ãÈù¢ÊâÄÊúâÁöÑËÆ®ËÆ∫ÈÉΩÊòØÂú®ÂèçÂõæ‰∏äÁöÑ„ÄÇ Áî®Á¨¶Âè∑ \(v^r\) Ë°®Á§∫‰∏éÁÇπ \(v\) ÂØπÂ∫îÁöÑÁÇπÔºö\(p_i^r = q_i, q_i^r = p_i\)„ÄÇ Ê±ÇÂá∫ÊãìÊâëÂ∫èÔºåÊåâÊãìÊâëÂ∫è‰æùÊ¨°Â§ÑÁêÜÊØè‰∏™ÁÇπÔºöÂ¶ÇÊûúÂΩìÂâçÁÇπ \(u\) Ë¢´Êâì‰∫ÜÊ†áËÆ∞ÔºåÈÇ£‰πà‰∏çÈÄâÔºõÂê¶ÂàôÈÄâÊã© \(u\)ÔºåÂπ∂Êää \(u^r\) ‰ª•Âèä \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÊâÄÊúâÁÇπÊâì‰∏äÊ†áËÆ∞ÔºàÈÄíÂΩíËøõË°åÔºåÂ¶ÇÊûúÂ∑≤ÁªèË¢´ÊâìËøáÊ†áËÆ∞Â∞±Ë∑≥ËøáÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºöË¢´Ê†áËÆ∞‰∏ÄÊ¨°Ôºâ„ÄÇ ËøôÊ†∑ÂØπ‰∫é‰ªªÊÑèÁöÑ \(i\)Ôºå\(p_i\) Âíå \(q_i\) ‰∏çÂèØËÉΩÂêåÊó∂Ë¢´ÈÄâÔºåÂ∑≤ÈÄâÁöÑÁÇπ‰πü‰∏ç‰∏éÈôêÂà∂ÁüõÁõæÔºåÂè™ÈúÄË¶ÅËØÅÊòéÂØπ‰∫é‰ªªÊÑèÁöÑ \(u\)Ôºå\(u\) Âíå \(u^r\) ‰∏≠Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÈÄâÂç≥ÂèØ„ÄÇ Â¶ÇÊûú \(u\) Á¨¨‰∏ÄÊ¨°Ë¢´Ê†áËÆ∞ÁöÑÂéüÂõ†ÊòØ \(v\) Ë¢´ÈÄâÊã©Ôºå ÈÇ£‰πà \(u\) ÊòØ \(v^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºåÁî± 2-SAT ÁöÑÊÄßË¥®ÂèØÂæó \(v\) ÊòØ \(u^r\) Âá∫ÂèëËÉΩÂà∞ËææÁöÑÁÇπÔºå‰ªéËÄå \(v\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†Âêé„ÄÇ ÂÅáËÆæÂ≠òÂú®‰∏Ä‰∏™ \(u\)Ôºå\(u\) Âíå \(u^r\) ÈÉΩË¢´Ê†áËÆ∞‰∫ÜÔºåÊ†áËÆ∞ \(u\) ÁöÑÂéüÂõ†ÊòØ \(v_1\) ÊòØË¢´ÈÄâÊã©ÔºåÊ†áËÆ∞ \(u^r\) ÁöÑÂéüÂõ†ÊòØ \(v_2\) Ë¢´ÈÄâÊã©„ÄÇÈÇ£‰πà \(v_1\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºå\(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u\) Èù†Âêé„ÄÇ‰∏çÂ¶®ËÆæ \(u\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÈÇ£‰πà \(v_2\) Âú®ÊãìÊâëÂ∫è‰∏äÊØî \(u^r\) Èù†ÂêéÔºåÂú®Â§ÑÁêÜ \(v_2\) ‰πãÂâçÂ∞±‰ºöÂÖàÂ§ÑÁêÜ \(u^r\)ÔºåÁüõÁõæ„ÄÇ ÊâÄ‰ª•ËØ•ÁÆóÊ≥ï‰ºöÂæóÂà∞‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊñπÊ°à„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢ò]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Áî®Êù•ËÆ∞ÂΩïÂè£ËÉ°ÁöÑÈ¢òÁõÆ„ÄÇ Â¶ÇÊúâÈîôËØØËØ∑Âä°ÂøÖ qq ÊàñËÄÖËØÑËÆ∫ÂëäËØâÊàëÔºåË∞¢Ë∞¢ÔºÅ JOISC 2018 Day4 T1 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Â¶ÇÊûúËÆ§‰∏∫Áõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥Êúâ‰∏ÄÊù°ËæπÔºåÊú¨È¢òÂ∞±ÂèØ‰ª•ÁúãÊàêÊ±ÇÊúÄÂ§ßÊùÉÁÇπÁã¨Á´ãÈõÜ„ÄÇ ÊòæÁÑ∂‰∏ÄÊù°ÈìæÊòØ‰∫åÂàÜÂõæÔºåÈÇ£‰πàÈóÆÈ¢òÂèØ‰ª•ËΩ¨Âåñ‰∏∫Áî®Ë¥πÁî®ÊµÅÊ±ÇÊúÄÂ∞èÊùÉÁÇπË¶ÜÁõñÈõÜ„ÄÇ ËÆ∞ÂΩïÁõ∏ÈÇª‰∏§ÁÇπ‰πãÈó¥ËæπÁöÑÊñπÂêëÔºåÊääËøûÁª≠‰∏ÄÊÆµÊñπÂêëÁõ∏ÂêåÁöÑËßÜ‰Ωú‰∏Ä‰∏™ÊÆµ„ÄÇÁî®Á∫øÊÆµÊ†ëÁª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÊØèÊ¨°ÊúâÊÆµÂèëÁîüÂèòÊõ¥Êó∂Â∞±ËØ¢ÈóÆËøô‰∏™ÊÆµÔºåÁÑ∂Âêé‰øÆÊîπÁ∫øÊÆµÊ†ë‰∏äÁöÑ‰ø°ÊÅØ„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Áª¥Êä§ÊúÄÁü≠Â¢ûÂπøË∑ØÔºåÂ∞±Âú® \(\mathcal O(n \log n)\) ÁöÑÊó∂Èó¥Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ JOISC 2018 Day4 T2 ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Áúã‰ΩúÊòØËØ¢ÈóÆ‰∏ÄÊù°Èìæ‰∏ä‰∏ÄÈÉ®ÂàÜÁÇπÁöÑÂØºÂá∫Â≠êÂõæÁöÑËøûÈÄöÂùóÊï∞„ÄÇ‰æùÊ¨°Âä†ÁÇπÔºåÈÄöËøá‰∫åÂàÜÊ±ÇÂá∫Êñ∞Âä†ÁöÑÁÇπÂíåÂ∑≤ÊúâÁÇπÊûÑÊàêÁöÑËøûÈÄöÂùó‰πãÈó¥ÁöÑËøûËæπ„ÄÇÁî±‰∫éÊÄªÂÖ±Âè™Êúâ \(n-1\) Êù°ËæπÔºåËØ¢ÈóÆÊ¨°Êï∞‰∏ç‰ºöË∂ÖËøá \(\lceil \log n\rceil (n-1)\)„ÄÇ LOJ 6191 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÈÖçÂØπÊ∏∏Êàè ÁÇπÂáªÊü•ÁúãÈ¢òËß£ ÊúÄÂêé‰∏ÄÂÆö‰ºöÂèòÊàê &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;„ÄÇ \(f_{i,j}\) Ë°®Á§∫Ââç \(i\) ‰∏™Ê∂àÂÆåÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶ÊúÄÂêéÊúâËøûÁª≠ \(j\) ‰∏™ &gt;ÔºåÁïô‰∏ãÁöÑÂ≠óÁ¨¶‰∏≠ &lt; ÁöÑÊï∞ÈáèÁöÑÊúüÊúõ„ÄÇ ÊúÄÂêéÂæàÂÆπÊòìÁªüËÆ°Á≠îÊ°à„ÄÇ LOJ 6192 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÂüéÂ∏ÇÁΩëÁªú Ê≤°Âï•Â•ΩËØ¥ÁöÑÔºåÂ∞±ÊòØÂÄçÂ¢û‰∏Ä‰∏ã„ÄÇ LOJ 6194 „ÄåÁæéÂõ¢ CodeM Â§çËµõ„ÄçÊéíÂàó ÁÇπÂáªÊü•ÁúãÈ¢òËß£ Êåâ \(a_i\) ‰∏∫Á¨¨‰∏ÄÂÖ≥ÈîÆÂ≠óÔºå\(b_i\) ‰∏∫Á¨¨‰∫åÂÖ≥ÈîÆÂ≠óÊéíÂ∫è„ÄÇÈáçÊñ∞ÁªôÁÇπÁºñÂè∑„ÄÇ ÂÅáËÆæ‰Ωø saved ÂèòÂä®ÁöÑÁÇπÁöÑÁºñÂè∑ÂàÜÂà´ÊòØ \(c_1, \ldots, c_k\)ÔºåÊúâ \(\forall 1 \le i &lt; k, a_{c_i} \le a_{c_{i+1}}, b_{c_i} \le b_{c_{i+1}}\)„ÄÇ ËÄÉËôëÂØπ‰∫éÁªôÂÆöÁöÑ \(c_i\) Âíå \(k\)ÔºåÂ¶Ç‰ΩïËÆ°ÁÆó \(p\) ÁöÑÊï∞Èáè„ÄÇ ËÆæ \(d_i = card \{1 \le x \le n, a_x \ge c_i, b_x \ge c_i\}\)ÔºåÂÆö‰πâ \(d_0 = n\)„ÄÇ Â¶ÇÊûú \(d_k &gt; 1\)Ôºå\(p\) ÁöÑÊï∞Èáè‰∏∫ \(0\)„ÄÇ Âê¶Âàô \(p\) ÁöÑÊï∞Èáè‰∏∫ \(\prod_{0 \le i &lt; k} \binom{d_i}{d_{i+1}}(d_i-d_{i+1})!\)„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÂÆπÊòì \(dp\) Â§ÑÁêÜÁöÑÂºèÂ≠ê„ÄÇÂàÜÊ≤ª‰ºòÂåñ‰∏Ä‰∏ãÂ∞±ÂÅöÂÆå‰∫Ü„ÄÇ LOJ 6212 „ÄåÁæéÂõ¢ CodeM ÂÜ≥Ëµõ„Äçmelon ÁÇπÂáªÊü•ÁúãÈ¢òËß£ \(n \le L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(n\)Ôºå\(L &lt; n \le 2L\) Êó∂Á≠îÊ°àÊòæÁÑ∂ÊòØ \(L\)Ôºå‰∏ãÈù¢ËÆ®ËÆ∫ \(n &gt; 2L\) ÁöÑÊÉÖÂÜµ„ÄÇ Â¶ÇÊûú Alice ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæÁìúÁöÑÊï∞ÈáèÂ§ß‰∫é \(2L\)ÔºåÂèñËµ∞‰∏Ä‰∏™ÁìúÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÁìúÔºåÂ∞±ËÉΩ‰øùËØÅËá≥Â∞ëÊãøÂà∞ \(\lceil \frac {n} 2\rceil\) ‰∏™Áìú„ÄÇÔºàÂõ†‰∏∫ËøôÊ†∑ Alice ÊãøÂà∞ÁöÑÁìú‰∏ÄÂÆö‰∏ç‰ºöÊØî Bob Â∞ëÔºâ Â¶ÇÊûú Bob ÈááÂèñÂ¶Ç‰∏ãÁ≠ñÁï•ÔºöÂÅáËÆæ Alice ÂàöÂàöÊãøËµ∞‰∫Ü \(x\) ‰∏™ÁìúÔºåÁé∞Âú®ËøòÂâ©‰∏ã \(c\) ‰∏™ÁìúÔºåÂ¶ÇÊûú \(c-x \ge 2L\)ÔºåÈÇ£‰πàÂèñËµ∞ \(x\) ‰∏™ÁìúÔºõÂê¶ÂàôÂÖàÂèñËµ∞ \(x-1\) ‰∏™ÁìúÔºåÂêÉÂÆåÂêéÔºåÂâ©‰ΩôÁìúÊï∞‰∏∫ \(c-(x-1)\)ÔºåÂõ†‰∏∫ \(c-x &lt; 2L\)ÔºåÊâÄ‰ª• \(c-x+1 \le 2L\)ÔºåÂ¶ÇÊûú \(c-x+1 \le L\)ÔºåÁõ¥Êé•ÂèñËµ∞Ââ©‰ΩôÂÖ®ÈÉ®ÁìúÔºåËøôÁßçÊÉÖÂÜµ‰∏ã Bob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåÂê¶ÂàôÂèñËµ∞ \(L\) ‰∏™ÔºåÂõ†‰∏∫ \(c-x+1 \le 2L\)ÔºåÂú®Ââ©‰ΩôÁöÑ \(c-x+1\) ‰∏™Áìú‰∏≠ÔºåBob ÊãøÁöÑÁìú‰∏ç‰ºöÊØî Alice Â∞ëÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÊúÄÂùè‰πüÂè™ÊòØÁî±‰∫é‰∏ä‰∏ÄÊ¨° Alice Êìç‰ΩúÁöÑÊó∂ÂàªÔºåAlice ÂèñËµ∞‰∫Ü \(x\) ‰∏™ËÄå Bob ÂèñËµ∞‰∫Ü \(x-1\) ‰∏™ÔºåBob ÊØî Alice ÊãøÁöÑÁìúÂ∞ë‰∫Ü‰∏Ä‰∏™„ÄÇÊâÄ‰ª• Bob ÊãøÁöÑÁìúÁöÑÊï∞ÈáèÊúÄÂùèÊØî Alice Â∞ë \(1\)„ÄÇ Âõ†Ê≠§ÔºåÂú®ÂèåÊñπÈÉΩÈááÂèñÊúÄ‰ºòÁ≠ñÁï•Êó∂ÔºåAlice ËÉΩËé∑ÂæóÊÅ∞Â•Ω \(\lceil \frac{n} 2\rceil\) ‰∏™Áìú„ÄÇ Áªº‰∏äÊâÄËø∞ÔºåÂΩì \(n \le L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(n\)ÔºõÂΩì \(L &lt; n \le 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(L\)ÔºõÂΩì \(n &gt; 2L\) Êó∂ÔºåÁ≠îÊ°à‰∏∫ \(\lceil \frac {n} 2\rceil\)„ÄÇ CF 1215F Radio Stations ÈùûÂ∏∏Â¶ôÁöÑ 2SAT È¢òÔºåÊ≤°ÊÉ≥Âá∫Êù•„ÄÇÁúã‰∫ÜÈ¢òËß£ËßâÂæóÂæà nb„ÄÇÂÖ∑‰ΩìÂÅöÊ≥ïÂ∞±‰∏çÂÜô‰∫Ü„ÄÇÂèØ‰ª•ÁúãÂÆòÊñπÈ¢òËß£„ÄÇ CF 1188E Problem from Red Panda ÂæÖÂ°´Âùë„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á±ªÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁõ¥Áî®‰∏ÄÁõ¥Êã∑Êùø...ÈúÄË¶ÅË°•‰∏ÄË°•‰∫Ü„ÄÇ ÈóÆÈ¢ò Ê±Ç \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \] Âç≥Âú®‰∏ÄÊù°Áõ¥Á∫ø‰∏ãÁöÑÊï¥ÁÇπÊï∞. ÂÅöÊ≥ï Â¶ÇÊûú \(a \ge c\) Êàñ \(b \ge c\)ÔºåÂàô \(f(a,b,c,n) = \frac {n(n+1)}2\lfloor \frac a c \rfloor + (n+1) \lfloor \frac {b} {c}\rfloor + f(a\bmod c,b\bmod c,c,n)\) Âê¶Âàô \[ f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac {ai+b} c \rfloor \\ =\sum_{x \ge 0} \sum_{i=0}^n [x &lt; \lceil \frac{ai+b} c \rceil]\\ =\sum_{x \ge 0} \sum_{i=0}^n [xc &lt; ai+b+c-1]\\ =\sum_{x \ge 0} \sum_{i \le n} [i &gt; \lfloor \frac{xc-b-c+1} a\rfloor]\\ =\sum_{0 \le x &lt; \frac{an+b} c} [n-\lfloor \frac{xc-b-c+1}a \rfloor]\\ =\lceil \frac {an+b} {c} \rceil n-f(c,1-b-c,a,\lceil \frac {an+b} {c}\rceil-1) \] ÔºàÂõ†‰∏∫ \(i\) ‰ªé \(0\) ÂºÄÂßãÔºåÊâÄ‰ª•Ë¶ÅÁî®Â∞è‰∫éÂè∑Ôºâ ËøôÊ†∑ÊØèÈÄíÂΩí‰∏§Ê¨°Ôºå\((a,c)\) Â∞±ÂèòÊàê \((c, a\bmod c)\)ÔºåÂõ†Ê≠§Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ \(O(\log (a+c))\). Áî±‰∫é \(a &lt; c, b &lt; c\)ÔºåÊâÄ‰ª• \(n\) ÁöÑÂÄº‰∏ç‰ºöÂ¢ûÂ§ßÔºåÊó†ÈúÄÊãÖÂøÉÁàÜ long long.]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2461] ÂÆåÁæéÁöÑÈòüÂàó]]></title>
    <url>%2F2019%2F08%2F10%2F%5BLOJ2461%5D%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• È¢òËß£ Â§çÊùÇÂ∫¶ËÆ®ËÆ∫‰∏≠ÈªòËÆ§ \(n,m\) ÂêåÈò∂„ÄÇ ÂÆö‰πâÁ¨¨ \(i\) ‰∏™Êìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥‰∏∫ \(i\)„ÄÇ Ê±ÇÂá∫ÊØèÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÊñ∞ÁöÑ \(x\) ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥ÔºåÂ∞±ÂæàÂ•ΩÊ±ÇÁ≠îÊ°à‰∫Ü„ÄÇ ‰ªéÂêéÂæÄÂâçËÄÉËôëÊØè‰∏™Êìç‰ΩúÔºåËÆ°ÁÆóËøôÊ¨°Êìç‰ΩúÂä†ÂÖ•ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉ®Ë¢´ÂºπÂá∫ÁöÑÊúÄÊó©Êó∂Èó¥„ÄÇ ÂÆö‰πâ‰∏Ä‰∏™ÈòüÂàó \(i\) ÁöÑÂºπÂá∫Êó∂Èó¥‰∏∫‰ªéÂΩìÂâçÊìç‰ΩúÂºÄÂßãÔºåÂæÄÂêéÁ¨¨ \(a_i\) ‰∏™ÂΩ±ÂìçÈòüÂàó \(i\) ÁöÑÊìç‰ΩúÁöÑÂèëÁîüÊó∂Èó¥„ÄÇ ÂàÜÂùóÔºå‰ªéÂêéÂæÄÂâç‰æùÊ¨°Âä†ÂÖ•ÊØè‰∏™Êìç‰ΩúÔºåÂàÜÂà´Áª¥Êä§ÊØè‰∏ÄÂùó‰∏≠ÁöÑÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄº„ÄÇÊàë‰ª¨Êää‰∏ÄÂùó‰∏≠ÊâÄÊúâÈòüÂàóÂºπÂá∫Êó∂Èó¥ÁöÑÊúÄÂ§ßÂÄºÁß∞‰∏∫Ëøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Âú®Âä†ÂÖ•Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂêéÔºåÁ¨¨ \(i\) ‰∏™Âùó \([a_i,b_i]\) Áª¥Êä§ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t_i\)ÔºåËÆæ \(c_p\) ‰∏∫Á¨¨ \(k\) ‰∏™Êìç‰ΩúÂà∞Á¨¨ \(t_i-1\) ‰∏™Êìç‰Ωú‰∏≠Á¨¨ \(p\) ‰∏™ÈòüÂàóË¢´ push ÁöÑÊ¨°Êï∞ÔºåÁª¥Êä§ \(mn_k = \min_{a_i \le p \le b_i} c_p-a_p\)„ÄÇÂêåÊó∂Áª¥Êä§ \(c_p\) ÁöÑÂÄº„ÄÇÔºàÈÄöËøáÊâìÊ†áËÆ∞Ôºâ ËÄÉËôëÂú®Âä†ÂÖ•Êìç‰Ωú \(i\) ÂêéÔºåÂ¶Ç‰ΩïÊõ¥Êñ∞ÊØèÂùóÁª¥Êä§ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÅáËÆæËøô‰∏™ÂùóÊòØÁ¨¨ \(k\) ‰∏™Âùó„ÄÇ ÂØπ‰∫éËøô‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â§ß‰∫éÁ≠â‰∫é \(m\) ÁöÑÊÉÖÂÜµÈ¢ÑÂÖàÂ§ÑÁêÜÂ•Ω„ÄÇ‰∏ãÈù¢Âè™ËÆ®ËÆ∫ÊúÄÊó©ÂºπÂá∫Êó∂Èó¥Â∞è‰∫é \(m\) ÁöÑÊÉÖÂÜµ„ÄÇ Êõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ Â¶ÇÊûúËøô‰∏™ÂùóË¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êõ¥Êñ∞ \(mn_k \leftarrow mn_k+1\)„ÄÇÊõ¥Êñ∞ \(c_p\) ÁöÑÂÄºÔºåÂç≥Êâì‰∏Ä‰∏™Êï¥ÂùóÂä† \(1\) Ê†áËÆ∞„ÄÇ Â¶ÇÊûúËøô‰∏™ÂùóÊú™Ë¢´Á¨¨ \(i\) Ê¨°‰øÆÊîπÁöÑÂå∫Èó¥ÂÆåÊï¥ÂåÖÂê´Ôºö Êö¥ÂäõÈáçÊûÑÔºåÊõ¥Êñ∞ \(mn_k\) Âíå \(c\) Êï∞ÁªÑ„ÄÇ Êõ¥Êñ∞ \(t_k\) Êåâ‰ª•‰∏ãÊ≠•È™§ËøõË°åÔºö Â¶ÇÊûú \(mn_k \ge 0\)ÔºåËØ¥Êòé \(t_k\) ÂèØ‰ª•ÂáèÂ∞èÔºåÈÇ£‰πà \(t_k \leftarrow t_k-1\)„ÄÇÂê¶Âàô‰∏çÁî®Êõ¥Êñ∞ÔºåÁªìÊùüÊìç‰Ωú„ÄÇ Â¶ÇÊûúÁ¨¨ \(t_k\) Ê¨°Êìç‰ΩúÂåÖÂê´Êï¥‰∏™ÂùóÔºåÈÇ£‰πà \(mn_k \leftarrow mn_k-1\)ÔºåÊâì \(-1\) Ê†áËÆ∞Êõ¥Êñ∞ \(c_p\) ÁöÑÂÄº„ÄÇÂê¶ÂàôÊö¥ÂäõÈáçÊûÑÊõ¥Êñ∞ \(mn_k\) Âíå \(c_p\) ÁöÑÂÄº„ÄÇ ËΩ¨Âà∞Êìç‰Ωú 1„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂà∞‰∫ÜÂú® \(O(n \sqrt n)\) Êó∂Èó¥ÂÜÖÁª¥Êä§ÊØè‰∏™ÂùóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Ââ©‰ΩôÁöÑÈóÆÈ¢òÊòØ: Â¶Ç‰ΩïÂú®‰ªéÂè≥ÂæÄÂ∑¶Âä†ÂÖ•Êìç‰ΩúÁöÑËøáÁ®ã‰∏≠ÔºåÊîØÊåÅÊü•ËØ¢‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇÊääÂå∫Èó¥ÊãÜÊàêËã•Âπ≤‰∏™ÂùóÂíå‰∏çË∂ÖËøá \(2 \sqrt n\) ‰∏™Â§öÂá∫Êù•ÁöÑÁÇπ„ÄÇÂØπ‰∫éËøô‰∫õÂùóÔºåÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ÔºåÂèñ \(\max\) Âç≥ÂèØ„ÄÇÂØπ‰∫éËøô‰∫õÂ§öÂá∫Êù•ÁöÑÁÇπÔºåÈúÄË¶ÅÂä®ÊÄÅËØ¢ÈóÆ‰ªñ‰ª¨ÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ Â§ÑÁêÜÂçïÁÇπ‰ø°ÊÅØ Ë¶ÅÊîØÊåÅ‰ªéÂêéÂæÄÂâçÊ∑ªÂä†Êìç‰ΩúÔºåËØ¢ÈóÆÂçï‰∏™ÈòüÂàóÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥„ÄÇ ÂêåÊ†∑ÂàÜÂùóÁª¥Êä§„ÄÇÂØπÊØè‰∏™ÂùóÂºÄ‰∏Ä‰∏™ vectorÔºåÂØπÊØè‰∏™ÈòüÂàóÂºÄ‰∏Ä‰∏™ vector„ÄÇÂú®ËøõË°å‰øÆÊîπÊó∂ÔºåÂØπÂÆåÊï¥ÂåÖÂê´ÁöÑÊØè‰∏™ÂùóÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑ÔºåÂÜçÂØπ‰∏§ËæπÂ§öÂá∫ÁöÑ \(O (\sqrt n)\) ‰∏™ÈòüÂàóÂØπÂ∫îÁöÑ vector Âä†ÂÖ•ÂΩìÂâç‰øÆÊîπÁöÑÁºñÂè∑„ÄÇ ÈÇ£‰πà‰∏Ä‰∏™ÈòüÂàóÁöÑÊìç‰ΩúÂ∫èÂàóÂ∞±ÊòØÂÆÉÁöÑ vector ÂíåÂÆÉÊâÄÂú®ÁöÑÂùóÁöÑ vector ÂΩíÂπ∂ÂêéÁöÑÁªìÊûú„ÄÇÂØπÊØè‰∏™ÁÇπËÆ∞ÂΩïÂÆÉÁöÑÊúÄÊó©ÂºπÂá∫Êó∂Èó¥ \(t\) (ÊØèÊ¨°ËØ¢ÈóÆÊó∂Êõ¥Êñ∞Ôºå‰øÆÊîπÊó∂‰∏ç‰∏ÄÂÆöÊòØÊúÄÊñ∞ÁöÑ)ÔºåÂÆÉÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâçÁöÑ‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_1\)ÔºåÂÆÉÊâÄÂú®ÂùóÁöÑ vector ‰∏≠Á¨¨‰∏Ä‰∏™Âú® \(t\) ‰πãÂâç‰øÆÊîπÁöÑ‰ΩçÁΩÆ \(p_2\)„ÄÇÂØπÊØè‰∏™ÂùóËÆ∞ÂΩïËøô‰∏™Âùó‰∏≠ÁöÑÈòüÂàóÂú®‰∏ä‰∏ÄÊ¨°Êõ¥Êñ∞‰ø°ÊÅØ‰πãÂêé‰øÆÊîπÁöÑÊ¨°Êï∞ \(c\)„ÄÇÈÇ£‰πà‰øÆÊîπÁöÑÊó∂ÂÄôÂØπÊï¥ÂùóÂè™ÈúÄË¶Å \(c \leftarrow c+1\)ÔºåÂØπ‰∏§Á´ØÁöÑÂùóÊõ¥Êñ∞ÂÖ∂‰∏≠ÊØè‰∏Ä‰∏™ÈòüÂàóÁöÑ \(t, p_1, p_2\)ÔºåÂπ∂Êää \(c\) ËÆæ‰∏∫ \(0\)„ÄÇÊõ¥Êñ∞ÊñπÊ≥ïÂ§ßËá¥‰∏∫ÔºöÂØπ‰∫é‰∏Ä‰∏™ÈòüÂàóÔºåÂÖàÂà§Êñ≠ \(t\) ÊòØÂú®ÂÆÉ vector ‰∏≠ËøòÊòØÂú®ÂùóÁöÑ vector ‰∏≠ÔºàÈÄöËøá \(p_1, p_2\) ÂèØ‰ª•Áõ¥Êé•Âà§Êñ≠ÔºâÔºåËøô‰∏§ÁßçÊÉÖÂÜµÂå∫Âà´‰∏çÂ§ßÔºåÊâÄ‰ª•ËøôÈáåÂè™ÂÜôÂú®Âùó vector ‰∏äÁöÑÊÉÖÂÜµ„ÄÇÂÆö‰πâ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáè \(t = c\)ÔºåÂ¶ÇÊûúÂÆÉÁöÑÂùóÁöÑ vector ‰∏≠ÁöÑÁ¨¨ \(p_2+t\) È°πÁöÑÂ∞è‰∫éËøô‰∏™ÈòüÂàóÁöÑ vector ‰∏≠ÁöÑ \(p_1\) È°πÔºåÈÇ£‰πà \(p_1 \leftarrow p_1+1\)ÔºåÁÑ∂Âêé \(t \leftarrow t-1\)ÔºåÁÑ∂ÂêéÂÜçÊ¨°Ê£ÄÊü•ÔºåËøôÊ†∑Âæ™ÁéØÁõ¥Âà∞ÂèØ‰ª•Áõ¥Êé•Êää \(p_2\) Êîπ‰∏∫ \(p_2+t\) ÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ \(p_2\) Â∞±ÂÆåÊàê‰∫ÜÊõ¥Êñ∞„ÄÇ ‰∏Ä‰∏™ÈòüÂàóË¢´Êõ¥Êñ∞Êó∂ËøõË°åÁöÑÂà§Êñ≠ÁöÑÊÄªÊ¨°Êï∞‰∏éÂÆÉÁöÑ vector ‰∏≠ÂÖÉÁ¥†‰∏™Êï∞ÂêåÁ∫ßÔºåÊâÄ‰ª•Êõ¥Êñ∞ÁöÑÊÄªÂ§çÊùÇÂ∫¶ÊòØ \(O(n)\) ÁöÑ„ÄÇÔºà‰ΩÜÊòØÁª¥Êä§ vector ÂíåËøõË°åÊìç‰ΩúÊòØ \(O(\sqrt n)\) ÁöÑÔºâ„ÄÇ ËøôÊ†∑Â∞±‰ª• \(O(n \sqrt n)\) ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò„ÄÇ ÂÆûÁé∞ 1ÂæÖÂ°´]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊìç‰ΩúÊ®°Êùø]]></title>
    <url>%2F2019%2F07%2F12%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[NOI ÂâçÂ§ç‰π†„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100010; //ÊúÄÂ§ßÂ§öÈ°πÂºèÈïøÂ∫¶ÔºåÂÄçÊï∞ÈóÆÈ¢òÂ∑≤ÁªèËÄÉËôëconst int mod = 998244353;const int g = 3;int wa[8*maxn], wb[8*maxn], wc[8*maxn], rev[8*maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[l_]; for (int i = 0; i &lt; l_; i++) a[i] = 0; &#125;&#125;;void ntt(int *a, int l, int ty) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int i = 0; i &lt; (1&lt;&lt;l); i += len) &#123; int w = 1; for (int j = 0; j &lt; (len&gt;&gt;1); j++) &#123; int v1 = a[i+j], v2 = 1LL*w*a[i+j+(len&gt;&gt;1)]%mod; a[i+j] = (v1 + v2) % mod; a[i+j+(len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow(1&lt;&lt;l, mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyInv(tmp); poly ret(p.len); for (int i = 0; i &lt; G.len; i++) ret.a[i] = 1LL*2*G.a[i]%mod; poly t = p*G*G; for (int i = 0; i &lt; p.len; i++) ret.a[i] = (ret.a[i] + mod - t.a[i]) % mod; return ret;&#125;poly polyLn(const poly &amp;p) &#123; if (p.len == 1) return poly(1); poly inv = polyInv(p); poly d(p.len); for (int i = 0; i+1 &lt; p.len; i++) &#123; d.a[i] = 1LL*p.a[i+1]*(i+1)%mod; &#125; inv = inv * d; poly ret(p.len); for (int i = 1; i &lt; ret.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*inv.a[i-1]%mod; &#125; return ret;&#125;poly polyExp(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly tmp(nlen); for (int i = 0; i &lt; nlen; i++) tmp.a[i] = p.a[i]; poly G = polyExp(tmp); poly t(p.len), v(p.len); for (int i = 0; i &lt; nlen; i++) v.a[i] = G.a[i]; v = polyLn(v); for (int i = 0; i &lt; p.len; i++) &#123; t.a[i] = (mod - v.a[i] + p.a[i]) % mod; &#125; t.a[0] = (t.a[0] + 1) % mod; t = t*G; poly ret(p.len); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = t.a[i]; return ret;&#125;void polyDiv(const poly &amp;F, const poly &amp;Q, poly &amp;P, poly &amp;R) &#123; poly rF(F.len-Q.len+1), rQ(F.len-Q.len+1); for (int i = 0; i &lt; rF.len; i++) rF.a[i] = F.a[F.len-1-i]; for (int i = 0; i &lt; rQ.len; i++) if (Q.len-1-i &gt;= 0) rQ.a[i] = Q.a[Q.len-1-i]; poly v = rF*polyInv(rQ); for (int i = 0; i &lt; P.len; i++) P.a[i] = v.a[F.len-Q.len-i]; poly t = P*Q; for (int i = 0; i &lt; R.len; i++) R.a[i] = (F.a[i] + mod - t.a[i]) % mod;&#125;poly polySqrt(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = 1; return ret; &#125; int nlen = (p.len+1)/2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly F0 = polySqrt(np); poly exF0(p.len); for (int i = 0; i &lt; F0.len; i++) exF0.a[i] = F0.a[i]; poly tmp = F0*F0; poly extmp(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; tmp.len) extmp.a[i] = tmp.a[i]; extmp.a[i] = (extmp.a[i] + mod - p.a[i]) % mod; &#125; poly Q(p.len); for (int i = 0; i &lt; p.len; i++) Q.a[i] = 1LL*exF0.a[i]*2%mod; poly tt = extmp*polyInv(Q); poly res(p.len); for (int i = 0; i &lt; res.len; i++) &#123; res.a[i] = (exF0.a[i] + mod - tt.a[i]) % mod; &#125; return res;&#125;int main() &#123; int n; scanf("%d", &amp;n); poly P(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;P.a[i]); poly res = polySqrt(P); for (int i = 0; i &lt; res.len; i++) printf("%d ", res.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé®]]></title>
    <url>%2F2019%2F07%2F08%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0-NTT%2F</url>
    <content type="text"><![CDATA[Â§öÈ°πÂºèÂèñÊ®°‰ºòÂåñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 32010;const int mod = 998244353;const int g = 3;int n, k;int f[maxn], a[maxn];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;struct poly &#123; int *a, len; poly(int l_ = 0) &#123; len = l_; a = new int[len]; for (int i = 0; i &lt; len; i++) a[i] = 0; &#125;&#125; P; // ÁâπÂæÅÂ§öÈ°πÂºèint wa[maxn*8], wb[maxn*8], wc[maxn*8], rev[maxn*8];void ntt(int *a, int l, int ty) &#123; for (int i = 1; i &lt; (1&lt;&lt;l); i++) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1))); for (int i = 0; i &lt; (1&lt;&lt;l); i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int len = 2; len &lt;= (1&lt;&lt;l); len &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/len); for (int s = 0; s &lt; (1&lt;&lt;l); s += len) &#123; int w = 1; for (int i = s; i &lt; s + (len&gt;&gt;1); ++ i) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(len&gt;&gt;1)]%mod; a[i] = (v1 + v2) % mod; a[i + (len &gt;&gt; 1)] = (v1 + mod - v2) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; int inv = qpow((1&lt;&lt;l), mod-2); for (int i = 0; i &lt; (1&lt;&lt;l); i++) a[i] = 1LL*a[i]*inv%mod; for (int i = 1; i &lt; (1&lt;&lt;(l-1)); i++) swap(a[i], a[(1&lt;&lt;l)-i]); &#125;&#125;poly operator*(const poly &amp;p1, const poly &amp;p2) &#123; poly ret(p1.len + p2.len - 1); int l = 0; while ((1&lt;&lt;l) &lt; ret.len) ++ l; for (int i = 0; i &lt; (1&lt;&lt;l); i++) wa[i] = wb[i] = 0; for (int i = 0; i &lt; p1.len; i++) wa[i] = p1.a[i]; for (int i = 0; i &lt; p2.len; i++) wb[i] = p2.a[i]; ntt(wa, l, 1); ntt(wb, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) wc[i] = 1LL*wa[i]*wb[i]%mod; ntt(wc, l, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = wc[i]; return ret;&#125;poly polyInv(const poly &amp;p) &#123; if (p.len == 1) &#123; poly ret(1); ret.a[0] = qpow(p.a[0], mod-2); return ret; &#125; int nlen = (p.len + 1) / 2; poly np(nlen); for (int i = 0; i &lt; nlen; i++) np.a[i] = p.a[i]; poly f0 = polyInv(np); poly t1 = p*f0; poly t2(p.len); for (int i = 0; i &lt; p.len; i++) &#123; if (i &lt; t1.len) &#123; t2.a[i] = (mod - t1.a[i]) % mod; &#125; &#125; t2.a[0] = (t2.a[0] + 2) % mod; poly res = f0*t2; poly ret(p.len); for (int i = 0; i &lt; p.len; i++) ret.a[i] = res.a[i]; return ret;&#125;poly polyMod(const poly &amp;p, const poly &amp;q) &#123; if (p.len &lt; q.len) return p; poly rp(p.len-q.len+1), rq(p.len-q.len+1); for (int i = 0; i &lt; p.len; i++) if (q.len-1-i &lt; rp.len) rp.a[p.len-1-i] = p.a[i]; for (int i = 0; i &lt; q.len; i++) if (q.len-1-i &lt; rq.len) rq.a[q.len-1-i] = q.a[i]; poly t1 = rp*polyInv(rq); poly t2(p.len-q.len+1); for (int i = 0; i &lt; t2.len; i++) &#123; t2.a[i] = t1.a[p.len-q.len-i]; &#125; poly t3 = t2*q; poly ret(q.len-1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = (p.a[i] + mod - t3.a[i]) % mod; return ret;&#125;poly calMod(int y) &#123; poly ret(1); ret.a[0] = 1; poly x(2); x.a[1] = 1; while (y) &#123; if (y &amp; 1) ret = polyMod(ret * x, P); x = polyMod(x * x, P); y &gt;&gt;= 1; &#125; return ret;&#125;void polyPrint(const poly &amp;p) &#123; printf("%d :\n", p.len); for (int i = 0; i &lt; p.len; i++) &#123; printf("%d ", p.a[i]); &#125; printf("\n");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123;scanf("%d", &amp;a[i]); a[i] = (a[i] + mod) % mod;&#125; for (int i = 0; i &lt; k; i++) &#123;scanf("%d", &amp;f[i]); f[i] = (f[i] + mod) % mod;&#125; //‰πò‰ª• A^n int ans = 0; P = poly(k+1); for (int i = 1; i &lt;= k; i++) P.a[k-i] = (mod-a[i])%mod; P.a[k] = 1; //polyPrint(P); poly pol = calMod(n); //polyPrint(pol); for (int i = 0; i &lt; pol.len; i++) &#123; ans = (ans + 1LL*pol.a[i]*f[i]%mod)%mod; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆûÁé∞ÈîôËØØËÆ∞ÂΩï]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E7%8E%B0%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ÊØîËæÉÂáΩÊï∞ÂÆö‰πâ‰∏ç‰∏•Ê†ºÔºåÂ≠òÂú®ËøîÂõûÁõ∏Á≠â‰ΩÜÊòØÂÆûÈôÖ‰∏äÊúâÂå∫Âà´ÁöÑÊÉÖÂÜµ„ÄÇËøôÂèØËÉΩÂØºËá¥ÂèåÂ†ÜÁª¥Êä§Âà†Èô§Êìç‰ΩúÊó∂Âá∫Áé∞ÈóÆÈ¢ò„ÄÇÔºàÂ∫îÂΩìÂêåÊó∂ÂºπÊ†à‰ΩÜÊòØÊ†àÈ°∂ÂÖÉÁ¥†‰∏çÁõ∏Á≠âÔºâ for (int i = 1; i &lt;= n; i++) a[n] = inf„ÄÇ Âú®‰∏Ä‰∫õÂõûÊ∫ØÊó∂ÈúÄË¶ÅÊí§ÈîÄÊìç‰ΩúÁöÑ dfs ‰∏≠ÔºåÂõ†‰∏∫ÂÖ∂‰ªñÂéüÂõ† return ÁöÑÊó∂ÂÄôÊ≤°ÊúâÊí§ÈîÄÊìç‰Ωú„ÄÇ Âæ™ÁéØ/if ÈáåÂ±ÇÂ§ñÂ±ÇÂèòÈáèÂêçÊ∑∑Ê∑Ü„ÄÇ ËøõË°å dfs / ÈÄíÂΩíÊó∂ÔºåÂõ†‰∏∫‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè‰∏ãÂ±Ç dfs Êó∂Á†¥Âùè‰∫Ü‰∏äÂ±Ç‰πãÂêéË¶ÅÁî®Âà∞ÁöÑ‰ø°ÊÅØ„ÄÇ ÂÆπÊñ•Êó∂ÔºåÂè™Êûö‰∏æ‰∫ÜÈõÜÂêàÂ§ßÂ∞èÂøòËÆ∞‰∫Ü‰πòÁªÑÂêàÊï∞„ÄÇ ÊèíÂ§¥ dp ‰∏çË¶ÅÂøòËÆ∞ËøûÊé•‰∏§‰∏™Â∑¶Êã¨Âè∑ÊàñËÄÖËøûÊé•‰∏§‰∏™Âè≥Êã¨Âè∑ÁöÑÊÉÖÂÜµ„ÄÇ Ê†ëÈìæÂâñÂàÜÊó∂ÔºåËØ¢ÈóÆÈìæÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ≥®ÊÑèÊòØÊØîËæÉÈáçÈìæÈ°∂Á´ØÊ∑±Â∫¶Â§ßÂ∞èÔºå‰∏çËÉΩÁõ¥Êé•ÊØîËæÉ‰∏§‰∏™ÁÇπÊ∑±Â∫¶Â§ßÂ∞è„ÄÇ sort Êó∂ÂøòËÆ∞Âä†ÊØîËæÉÂáΩÊï∞„ÄÇ Áª¥Êä§Áü©Èòµ‰πòÊ≥ïÊó∂Â∑¶‰πòÂè≥‰πòÊêûÈîô„ÄÇ Á∫øÊÆµÊ†ëÂêàÂπ∂Êó∂ÔºåÂ¶ÇÊûúË¶ÅÂèØÊåÅ‰πÖÂåñÔºåÁ©∫Èó¥Ë¶ÅÂºÄ‰∏§ÂÄç„ÄÇ Âú®Â§ÑÁêÜÊ∂âÂèä‰∏çÂêåÈïøÂ∫¶Â≠óÁ¨¶‰∏≤ÁöÑÂ≠óÁ¨¶‰∏≤ÂìàÂ∏åÊó∂Ôºå‰∏ÄÂÆöË¶ÅÁî® str[i] - 'a' + 1 ËÄå‰∏çÊòØ str[i] - 'a' Âú®Â§ÑÁêÜÂ≠êÊ†ëÊúÄÈïø‰ªéÊ†πÂºÄÂßãË∑ØÂæÑ‰πãÁ±ªÁöÑÈóÆÈ¢òÊó∂ÔºåÂ¶ÇÊûúËøô‰∏™Â≠êÊ†ë‰∏çËÉΩÈÄâÔºådp ÂÄºËÆæ‰∏∫ \(0\) ‰ªç‰ºö +1 Âêë‰∏äË¥°ÁåÆ Âú®Áî® new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Âá∫Áé∞Ë∂äÁïå„ÄÇËøôÊó∂‰∏ç‰ºöÊä•ÈîôÔºåÂá∫Áé∞ new Âá∫Êù•ÁöÑÊï∞ÁªÑÊó∂Ôºå‰∏ÄÂÆöË¶ÅË∞®ÊÖéËÆ°ÁÆóÊØèÊ¨°Ë∞ÉÁî®ÁöÑÂ§ßÂ∞è„ÄÇÔºàÂ∞§ÂÖ∂ÊòØÂÜôÂ§öÈ°πÂºèÊó∂Ôºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Gym102201E] Eat Economically]]></title>
    <url>%2F2019%2F06%2F26%2F%5BGym102201E%5D-%2F</url>
    <content type="text"><![CDATA[ÂèëËøôÁØáÂçöÂÆ¢‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆ∞ÂΩï‰∏Ä‰∏™ÊûÅ‰∏∫ÈöêËîΩÁöÑÈîôËØØ„ÄÇ ÂÜôÊØîËæÉÂáΩÊï∞‰∏ÄÂÆöË¶Å‰øùËØÅÊòØ‰∏•Ê†ºÁöÑÂ∞è‰∫éÂè∑„ÄÇË¶ÅÁâπÂà´Â§ÑÁêÜÁ≠â‰∫é„ÄÇÂê¶ÂàôÂú®ÈÅáÂà∞Â†ÜÊâìÊ†áËÆ∞Âà†Èô§ËøôÁßçÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÂÖÉÁ¥†Âú®Â†Ü‰∏≠ÁöÑÈ°∫Â∫è‰ºöÂΩ±ÂìçÁ≠îÊ°à„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 250010;ll ans[maxn];int L[maxn&lt;&lt;1], D[maxn&lt;&lt;1], a[maxn&lt;&lt;1], n;struct C1 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x] == L[y]) return x &lt; y; return L[x] &gt; L[y]; &#125;&#125;;struct C2 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (D[x] == D[y]) return x &lt; y; return D[x] &gt; D[y]; &#125;&#125;;struct C3 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; if (L[x]-D[x] == L[y]-D[y]) return x &lt; y; return L[x]-D[x] &gt; L[y]-D[y]; &#125;&#125;;struct C4 &#123; bool operator()(const int &amp;x, const int &amp;y) &#123; return D[x]-L[x] &gt; D[y]-L[y]; &#125;&#125;;template&lt;typename T1, typename T2&gt;struct Heap &#123; priority_queue&lt;T1, vector&lt;T1&gt;, T2&gt; q, d; void _c() &#123; while (!d.empty() &amp;&amp; q.top() == d.top()) &#123; q.pop(); d.pop(); &#125; &#125; T1 getTop() &#123; _c(); if (!q.empty()) return q.top(); else return 0; &#125; void del(T1 x) &#123; d.push(x); &#125; void add(T1 x) &#123; q.push(x); &#125; int size() &#123;return int(q.size())-int(d.size());&#125;&#125;;Heap&lt;int, C3&gt; h1;Heap&lt;int, C4&gt; h2;Heap&lt;int, C1&gt; h3;Heap&lt;int, C2&gt; h4;int vis[maxn&lt;&lt;1];int main() &#123; L[0] = D[0] = 0x7fffffff; scanf("%d", &amp;n); for (int i = 1; i &lt;= 2*n; i++) scanf("%d%d", &amp;L[i], &amp;D[i]); for (int i = 1; i &lt;= 2*n; i++) h3.add(i), h4.add(i); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i-1]; &#123; int v1 = h3.getTop(), v2 = h4.getTop(), v3 = h1.getTop(); if (!v3 || L[v1] &lt; L[v3]-D[v3]+D[v2]) &#123; ans[i] += L[v1]; h2.add(v1); h3.del(v1); h4.del(v1); &#125; else &#123; ans[i] += L[v3]-D[v3]+D[v2]; h1.del(v3); h2.add(v3); h1.add(v2); h3.del(v2); h4.del(v2); &#125; &#125; &#123; int v1 = h4.getTop(), v2 = h3.getTop(), v3 = h2.getTop(); if (!v3 || D[v1] &lt; D[v3]-L[v3]+L[v2]) &#123; ans[i] += D[v1]; h1.add(v1); h4.del(v1); h3.del(v1); &#125; else &#123; ans[i] += D[v3]-L[v3]+L[v2]; h2.del(v3); h1.add(v3); h2.add(v2); h4.del(v2); h3.del(v2); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2572] „ÄåZJOI2017„ÄçÂ≠óÁ¨¶‰∏≤]]></title>
    <url>%2F2019%2F06%2F23%2FLOJ2572%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÂÅöÊ≥ï ‰∏çÈöæËØÅÊòéÂ¶ÇÊûú‰∏Ä‰∏™Â≠ê‰∏≤ \(s\) Êúâ‰∏§‰∏™ÂêéÁºÄ \(s_1, s_2\)Ôºå\(s_2\) ÊòØ \(s_1\) ÁöÑ border ‰∏î \(2\lvert s_2 \rvert &gt; \lvert s_1 \rvert\)ÔºåÈÇ£‰πàÂØπ‰∫é‰ªªÊÑèÁöÑÂ≠óÁ¨¶‰∏≤ \(t\)Ôºå\(s_2\) ‰∏çÂèØËÉΩÊòØ \(st\) ÁöÑÊúÄÂ∞èÂêéÁºÄ„ÄÇ Áî®‰∏Ä‰∏™Á∫øÊÆµÊ†ëÁª¥Êä§ÊØè‰∏™Âå∫Èó¥ÂÜÖÂèØËÉΩÊàê‰∏∫ÊúÄÂ∞èÂêéÁºÄÁöÑÁÇπÔºåËøôÊ†∑ÁöÑÁÇπÂè™Êúâ \(\mathcal O (\log n)\) ‰∏™„ÄÇpush up ÁöÑÊó∂ÂÄôÊö¥ÂäõÂêàÂπ∂Âç≥ÂèØ„ÄÇ ÊØîËæÉÂ§ßÂ∞èÁöÑÊó∂ÂÄôÈúÄË¶ÅÊü• lcpÔºåÂàÜÂùóÁª¥Êä§ÂâçÁºÄÂìàÂ∏åÂç≥ÂèØÂÅöÂà∞ \(\mathcal O(\sqrt n)\) ‰øÆÊîπÔºå\(\mathcal O(\log n)\) ËØ¢ÈóÆÔºàË∞ÉÊï¥ÂùóÂ§ßÂ∞èÂ∫îËØ•ÂèØ‰ª•ÂÅöÂà∞Êõ¥‰ºòÁöÑÂ§çÊùÇÂ∫¶Ôºâ„ÄÇ ÊÄªÂ§çÊùÇÂ∫¶ \(\mathcal O(n\log^2n+m \log ^3 n+m\sqrt n)\)„ÄÇ ÔºàÁúüÁöÑÊØíÁò§Ôºâ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym102222I] Bubble Sort]]></title>
    <url>%2F2019%2F06%2F19%2F%5BGym102222I%5D-Bubble-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø]-Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï]]></title>
    <url>%2F2019%2F06%2F04%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E8%B2%8C%E4%BC%BC%E6%98%AF%E6%B4%B2%E9%98%81%E7%AD%9B%E7%9A%84%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ ÁÆÄÂçïÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1000010;const int mod = 1e9+7;ll n;ll val[maxn];int f[maxn], g[maxn], h[maxn], mx_p[maxn];int p[maxn], isnp[maxn], cnt, tot, sqr;int in1[maxn], in2[maxn], s1[maxn], s2[maxn];inline int mo(const int &amp;x) &#123; if (x &gt;= mod) return x-mod; if (x &lt; 0) return x+mod; return x;&#125;int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;ll calp(ll n) &#123; if (n == 1) return 0; return mo(f[getin(n)]-g[getin(n)]+2);&#125;ll calh(int n, int i) &#123; if (val[n] == 1) return 0; if (val[n] &lt; p[i-1]) return mo(calp(val[n])-s1[mx_p[val[n]]]); else return mo(calp(val[n])-s1[i-1]); &#125;int main() &#123; isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123;p[++ cnt] = i; mx_p[i] = cnt;&#125; for (int j = 1; j &lt;= cnt &amp;&amp; p[j]*i &lt;= 1000000; j++) &#123; isnp[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125; for (int i = 2; i &lt;= 1000000; i++) if (!mx_p[i]) mx_p[i] = mx_p[i-1]; scanf("%lld", &amp;n); sqr = int(sqrt(n)); for (ll i = 1; i &lt;= n; i = n/(n/i)+1) &#123; val[getin(n/i)] = n/i; &#125; for (int i = 1; i &lt;= tot; i++) &#123;f[i] = (1LL*(val[i]%mod)*(val[i]%mod+1)%mod*((mod+1)/2)%mod-1)%mod; g[i] = mo(val[i]%mod-1);&#125; for (int i = 1; i &lt;= cnt; i++) s1[i] = mo(s1[i-1] + (p[i] ^ 1)); for (int i = 1; i &lt;= cnt; i++) s2[i] = mo(s2[i-1] + p[i]); for (int i = 1; i &lt;= cnt &amp;&amp; 1ll*p[i]*p[i] &lt;= n; i++) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; f[j] = mo(f[j]-1LL*p[i]*mo(f[getin(val[j]/p[i])]-s2[i-1])%mod); g[j] = mo(g[j]-mo(g[getin(val[j]/p[i])]-(i-1))); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= cnt; i++) if (1ll*p[i]*p[i] &lt;= n) mx = i; for (int i = mx; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1ll*p[i]*p[i]; j++) &#123; int e = 1; ll v = p[i]; if (1ll*p[i+1]*p[i+1] &gt; val[j]) h[j] = calh(j, i+1); while (v &lt;= val[j]) &#123; int t = 0; if (1LL*p[i+1]*p[i+1] &gt; val[j]/v) &#123; t = mo(calh(getin(val[j]/v), i+1)+1); &#125; else t = mo(h[getin(val[j]/v)]+1); h[j] = mo(h[j]+1LL*(p[i]^e)*t%mod); ++ e; v *= p[i]; &#125; &#125; &#125; printf("%d\n", mo(h[getin(n)]+1)); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ6235] Âå∫Èó¥Á¥†Êï∞‰∏™Êï∞]]></title>
    <url>%2F2019%2F05%2F12%2F%5BLOJ6235%5D-%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ËØïÁùÄÂÆûÁé∞‰∏ã min_25 Á≠õÁöÑÁ¨¨‰∏ÄÊ≠•„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn = 1000010;ll n;int prm[maxn], isnp[maxn], cnt, tot, sqr;ll val[maxn];int in1[maxn], in2[maxn];ll f[maxn];int getin(ll x) &#123; if (x &gt;= sqr) &#123; if (!in1[n/x]) in1[n/x] = ++ tot; return in1[n/x]; &#125; else &#123; if (!in2[x]) in2[x] = ++ tot; return in2[x]; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); sqr = int(sqrt(n)); isnp[1] = 1; for (int i = 2; i &lt;= 1000000; i++) &#123; if (!isnp[i]) &#123; prm[++ cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prm[j]*i &lt;= 1000000; j++) &#123; isnp[i*prm[j]] = 1; if (i % prm[j] == 0) break; &#125; &#125; int mx = 0; for (ll i = 1; i &lt;= n;) &#123; ll nxt = n/(n/i)+1; val[getin(n/i)] = n/i; i = nxt; &#125; for (int i = 1; i &lt;= tot; i++) f[i] = val[i]-1; int last = 0; for (int i = 1; i &lt;= cnt &amp;&amp; 1LL*prm[i]*prm[i] &lt;= n; ++ i) &#123; last = i; for (int j = 1; j &lt;= tot &amp;&amp; val[j] &gt;= 1LL*prm[i]*prm[i]; j++) &#123; f[j] -= (f[getin(val[j]/prm[i])]-(i-1)); &#125; &#125; printf("%lld\n", f[getin(n)]); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces715E] Complete the Permutations]]></title>
    <url>%2F2019%2F05%2F08%2F%5BCodeforces715E%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/problemset/problem/715/E È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏§‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàó \(p_1\) Âíå \(p_2\)ÔºåÂÖ∂‰∏≠Êúâ‰∏Ä‰∫õ‰ΩçÁΩÆË¢´ÊåñÁ©∫ÔºåËÆ©‰Ω†Ëá™Â∑±Â°´Êï∞Â≠ó„ÄÇ ËØ∑‰Ω†ÂØπÊØè‰∏™ \(k\) ËæìÂá∫ÔºåÊúâÂ§öÂ∞ëÁßçÂ°´Êï∞Â≠óÊñπÊ°àÔºå‰ΩøÂæó \(p_1\) ÊúÄÂ∞ë‰∫§Êç¢ \(k\) Ê¨°ÂèØ‰ª•ÂèòÊàê \(p_2\)„ÄÇ \(n \le 250\)„ÄÇ Ëß£Ê≥ï È¶ñÂÖàÈ¢òÁõÆ‰øùËØÅËá≥Â∞ëÂ≠òÂú®‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°à‰ΩøÂæó \(p_1\) Âíå \(p_2\) ÊòØÊéíÂàóÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊï∞‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµ„ÄÇ ÂÆπÊòìÁúãÂá∫‰∫§Êç¢Ê¨°Êï∞ \(n-(p_1p_2^{-1}\) ÁöÑËΩÆÊç¢Êï∞\()\)„ÄÇ ÈóÆÈ¢òÂèòÊàê‰∫ÜÊ±ÇÊª°Ë∂≥ \(p_1p_2^{-1}\) ÊÅ∞Â•ΩÂèØ‰ª•ÂàÜËß£‰∏∫ \(k\) ‰∏™‰∏çÁõ∏‰∫§ËΩÆÊç¢ÁöÑÊñπÊ°àÊï∞„ÄÇ ËÆæ \(p_1p_2^{-1}=w\)ÔºåÂàô \(p_1=wp_2\)ÔºåÂç≥ \(p_1[i]=w[p_2[i]]\)„ÄÇ ËÆæÊâÄÊúâ \(p_1\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_1\)ÔºåÊâÄÊúâ \(p_2\) ‰∏≠Â∑≤ÁªèÁ°ÆÂÆöÁöÑ‰ΩçÁΩÆÁöÑ‰∏ãÊ†áÊûÑÊàêÁöÑÈõÜÂêà‰∏∫ \(S_2\)„ÄÇ ÂÅáËÆæ \(w\) ÊòØÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÊéíÂàó„ÄÇÈÇ£‰πàÂØπ‰∫é \(i \in S_1\)ÔºåÊúâ \(p_2[i]=w^{-1}[p_1[i]]\)ÔºõÂØπ‰∫é \(i \in S_2\)ÔºåÊúâ \(p_1[i]=w[p_2[i]]\)„ÄÇÊâÄ‰ª• \(\forall i \in S_1 \cap S_2\)Ôºå\(p_1[i]\) Âíå \(p_2[i]\) ÈÉΩÊòØÁ°ÆÂÆöÁöÑ„ÄÇÂØπ‰∫é \(p_1\) Êù•ËØ¥ÔºåËøòÊúâ \(n-\lvert S_1\cup S_2 \rvert\) ‰∏™‰ΩçÁΩÆË¶ÅÂ°´ÁöÑÊï∞Ê≤°ÊúâÁ°ÆÂÆö„ÄÇÈÇ£‰πàÂ¶ÇÊûúÂ≠òÂú®Ëá≥Â∞ë‰∏ÄÁßçÂ°´Êï∞ÊñπÊ°àÔºåÂ∞±ÊÅ∞Â•ΩÊúâ \((n-\lvert S_1\cup S_2 \rvert)!\) Áßç‰ΩøÂæó \(p_1p_2^{-1}=w\) ÁöÑÂ°´Êï∞ÊñπÊ°à„ÄÇ ÂÜçËÄÉËôëÊúâÂ§öÂ∞ëÁßçÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÂêàÊ≥ïÁöÑ \(w\)„ÄÇÂØπ‰∫é \(i \in S_1\cap S_2\)Ôºå\(w[p_2[i]]=p_1[i]\)„ÄÇÊâÄ‰ª• \(w\) ÁöÑ‰∏Ä‰∫õ‰ΩçÁΩÆÂ∑≤ÁªèÁ°ÆÂÆö‰∫Ü„ÄÇÂêåÊó∂ \(\forall i \in S_2\setminus S_1, j \in S_1, w[p_2[i]] \notin p_1[j]\)„ÄÇ\(w\) ‰∏≠Á°ÆÂÆöÁöÑ‰ΩçÁΩÆÂ∑≤ÁªèÊûÑÊàê‰∫Ü‰∏Ä‰∫õÈìæÂíå‰∏Ä‰∫õÁéØ„ÄÇÊûÑÊàêÁéØÂêé‰∏çÂèØËÉΩ‰∏éÂÖ∂‰ªñÁÇπËøûËæπÔºåÂèØ‰ª•Áõ¥Êé•ÂøΩÁï•„ÄÇÈìæÂèØ‰ª•Áº©Êàê‰∏Ä‰∏™ÁÇπ„ÄÇÈÇ£‰πàÈóÆÈ¢òËΩ¨Âåñ‰∏∫ÔºåÁªôÂÆö‰∏§‰∏™ÈõÜÂêà \(A\) Âíå \(B\)ÔºåÊ±ÇÊúâÂ§öÂ∞ë‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÊéíÂàóÔºåÊÅ∞Êúâ \(k\) ‰∏™ÁéØÁöÑÊéíÂàóÔºåÊª°Ë∂≥ \(\forall i \in A, w[i] \notin B\)„ÄÇÊòæÁÑ∂Ëøô‰∏™ÈóÆÈ¢òÂè™‰∏é \(n, k, \lvert A \rvert, \lvert B \rvert, \lvert A\cap B\rvert\) ÊúâÂÖ≥„ÄÇ ÂÖàËÄÉËôë \(A\cap B =\emptyset\)„ÄÇÂÆπÊñ•‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ \[F(n,\lvert A \rvert, \lvert B \rvert,k)=\sum_{x\le\lvert A \rvert} (-1)^x\binom{\lvert A \rvert}{x}\binom{\lvert B \rvert}{x}S(n-x,k)\] ÂÜçËÄÉËôë \(A\cap B \neq \emptyset\)„ÄÇÊääÈôêÂà∂Êù°‰ª∂Áúã‰Ωú \(\forall i \in A\setminus B,w[i]\notin B\) Âíå \(\forall i \in A \cap B, w[i] \notin B\)„ÄÇÂØπÁ¨¨‰∫å‰∏™Êù°‰ª∂ÂÆπÊñ•„ÄÇËÆæ \(G(n, c, i)\) ‰∏∫ \(n\) ‰∏™Êï∞ÁöÑÊéíÂàóÔºåÂÜ≥ÂÆö \(c\) ‰∏™‰ΩçÁΩÆÂ°´‰ªÄ‰πàÔºå‰ΩøÂ∑≤ÁªèÂÜ≥ÂÆöÁöÑËæπÊûÑÊàê \(i\) ‰∏™ÁéØÊñπÊ°àÊï∞ÔºàÊòæÁÑ∂Ê≠§Êó∂Êúâ \(n-c\) Êù°ÈìæÔºâ„ÄÇ \[\sum_{x\le{\lvert A \cap B \rvert}} (-1)^x\binom{\lvert A \cap B \rvert}{x} \sum_{i} G(\lvert B \rvert,x,i) F(n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\] \((n-x,\lvert A\setminus B \rvert, \lvert B\rvert-x,k-i)\) ÂÆûÈôÖÂè™Êúâ \(n^2\) ÁßçÔºåÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜ \(F\) Âç≥ÂèØÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ \(\mathcal O(n^3)\)„ÄÇ ÂÜçËÄÉËôë \(G\) ÊÄé‰πàËÆ°ÁÆó„ÄÇ\(G(n,c,i)=(n-1)G(n-1,c-1,i)+G(n-1,c-1,i-1)\). \(\mathcal O(n^3)\) ËÆ°ÁÆóÈùûÂ∏∏Êñπ‰æø„ÄÇ ËøôÊ†∑Â∞±ÂÅöÂÆå‰∫Ü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 255;const int mod = 998244353;int C[maxn][maxn], S[maxn][maxn], inv[maxn];int tot_n, base;int n = 0, X = 0, A = 0, B = 0, T = 0, p1[maxn], p2[maxn], vis[maxn], w[maxn], jc[maxn], ans[maxn];int vis1[maxn], vis2[maxn];int F[maxn][maxn], deg[maxn];int val_F[maxn][maxn];int G[maxn][maxn][maxn];int calF(int n, int a, int b, int c) &#123; int ret = 0; for (int x = 0; x &lt;= a; ++ x) &#123; int tmp = 1LL*C[a][x]*C[b][x]%mod*jc[x]%mod*S[n-x][c]%mod; if (x &amp; 1) tmp = (mod-tmp)%mod; ret = (ret + tmp) % mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); jc[0] = 1; S[0][0] = 1; inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; inv[i] = mod-1LL*(mod/i)*inv[mod%i]%mod; &#125; for (int i = 0; i &lt;= n; i++) C[i][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; &#125; jc[i] = 1LL*jc[i-1]*i%mod; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; for (int k = 1; k &lt;= i; k++) &#123; S[i][j] = (S[i][j] + 1LL*C[i-1][k-1]*S[i-k][j-1]%mod*jc[k]%mod*inv[k]%mod)%mod; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p1[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p2[i]); for (int i = 1; i &lt;= n; i++) &#123; if (p1[i] &amp;&amp; !p2[i]) vis1[p1[i]] = 1; vis2[p2[i]] = 1; if (p1[i] &amp;&amp; p2[i]) &#123; w[p1[i]] = p2[i]; deg[p2[i]] ++; &#125; else if (!p1[i] &amp;&amp; !p2[i]) ++ X; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; int t = i, last = 0; while (t &amp;&amp; !vis[t]) &#123; vis[t] = 1; last = t; t = w[t]; &#125; if (!t) &#123; ++ tot_n; if (vis1[last]) ++ A; if (vis2[i]) ++ B; if (vis1[last] &amp;&amp; vis2[i]) ++ T; &#125; else ++ base; &#125; &#125; A -= T; B -= T; for (int x = 0; x &lt;= T; x++) &#123; for (int j = 0; j &lt;= n; j++) &#123; F[x][j] = calF(tot_n-x, A, B+T-x, j); &#125; &#125; G[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; G[i][0][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; G[i][j][0] = 1LL*(i-1)*G[i-1][j-1][0]%mod; for (int k = 1; k &lt;= j; k++) &#123; G[i][j][k] = (1LL*(i-1)*G[i-1][j-1][k]%mod+G[i-1][j-1][k-1])%mod; &#125; &#125; &#125; for (int k = 0; k &lt;= tot_n; k++) &#123; int tans = 0; for (int x = 0; x &lt;= T; x++) &#123; int K = C[T][x]; int sum = 0; if (x &amp; 1) K = (mod - K) % mod; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + 1LL*G[B+T][x][i]*F[x][k-i]%mod)%mod; &#125; tans = (tans + 1LL*K*sum%mod)%mod; &#125; ans[n-(k+base)] = tans; &#125; for (int i = 0; i &lt; n; i++) printf("%d ", int(1LL*ans[i]*jc[X]%mod)); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>ÁªÑÂêàÊï∞Â≠¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC031C] Differ by 1 Bit]]></title>
    <url>%2F2019%2F04%2F25%2F%5BAGC031C%5D-Differ-by-1-Bit%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï È¶ñÂÖàÔºå‰∏Ä‰∏™‰ª• \(A\) ‰∏∫ÂºÄÂ§¥‰ª• \(B\) ‰∏∫ÁªìÂ∞æÁöÑÂ∫èÂàóÊòØÂê¶Â≠òÂú®Ôºå‰ªÖ‰∏é \(A\oplus B\) ÊúâÂÖ≥„ÄÇ Â¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàóÔºåÈÇ£‰πà \(A\oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞‰∏ÄÂÆöÊòØÂ•áÊï∞„ÄÇ ‰∏Ä‰∏™ÁªìËÆ∫ÊòØÔºåÂ¶ÇÊûú \(A \oplus B\) ‰∏≠ \(1\) ÁöÑ‰∏™Êï∞ÊòØÂ•áÊï∞ÔºåÈÇ£‰πàÊª°Ë∂≥Êù°‰ª∂ÁöÑÂ∫èÂàó‰∏ÄÂÆöÂ≠òÂú®„ÄÇ ‰∏ãÈù¢ÈÄíÂΩíÂú∞ÁªôÂá∫ÊûÑÈÄ†„ÄÇ ÂÆö‰πâ \(build(n,A,B)\) ËøîÂõû‰∏Ä‰∏™ \(0 \ldots 2^n-1\) ÁöÑ‰ª• \(A\) ‰∏∫ÂºÄÂ§¥Ôºå\(B\) ‰∏∫ÁªìÂ∞æÁöÑÊéíÂàó„ÄÇÔºà\(A\oplus B\) ‰∏≠ÊúâÂ•áÊï∞‰∏™ \(1\)Ôºâ Ëã• \(n=1\)ÔºåÂ¶ÇÊûú \(A = 0\)ÔºåËøîÂõû \(A, B\)„ÄÇ Ëã• \(A \oplus B\) ‰∏≠ÊÅ∞Êúâ‰∏Ä‰∏™ \(1\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^{n-1}\)ÔºàÂÖ∂‰ªñÊÉÖÂÜµÂè™ÈúÄË¶ÅÊääÊâÄÊúâÊï∞ÂºÇÊàñ‰∏ä \(A\) Âπ∂Êää \(1\) ÊâÄÂú®Âú®‰ΩçÂíåÊúÄÈ´ò‰Ωç‰∫§Êç¢Âç≥ÂèØÔºâ„ÄÇ ËÆæ \(a=build(n-1, 0, 1)\)ÔºåÈÇ£‰πà \(0a_1,\ldots,0a_{2^{n-1}},1a_{2^{n-1}},\ldots,1a_1\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠Â≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæÂÖ∂‰∏≠ \(0\) Âú®ÊúÄ‰Ωé‰Ωç‰∏ä‰∏î \(A\) ÁöÑÊúÄ‰Ωé‰Ωç‰∏∫ \(0\)„ÄÇ ËÆæ \(a = build(n-1, \frac A 2, \frac B 2)\)Ôºå\(b = build(n-1, a_1, a_2)\)„ÄÇ ÈÇ£‰πà \(a_10,b_11,\ldots,b_{2^{n-1}}1,a_20,\ldots,a_{2^{n-1}}0\) ÊòØ‰∏Ä‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÊéíÂàó„ÄÇ Ëã• \(A\oplus B\) ‰∏≠‰∏çÂ≠òÂú® \(0\)Ôºå‰∏çÂ¶®ËÆæ \(A = 0, B = 2^n-1\)„ÄÇ ËÆæ \(a=build(n-1, 0, 1), b = build(n-1, 1, 2^{n-1}-1)\)„ÄÇ Âàô \(0a_1, \ldots, 0a_{2^{n-1}}, 1b_1,\ldots,1b_{2^{n-1}}\) ÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊéíÂàó„ÄÇ Áî®‰∏ªÂÆöÁêÜÂèØ‰ª•ÂàÜÊûêÂá∫Áõ¥Êé•ÈÄíÂΩíÁöÑÂ§çÊùÇÂ∫¶Âπ∂‰∏çÈ´ò„ÄÇÊâÄ‰ª•Áõ¥Êé•ÈÄíÂΩí‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 17;int swap(int v, int p1, int p2) &#123; if (((v &gt;&gt; p1)&amp;1) != ((v&gt;&gt;p2)&amp;1)) &#123; return v ^ (1&lt;&lt;p1) ^ (1&lt;&lt;p2); &#125; else return v;&#125;vector&lt;int&gt; build(int n, int A, int B) &#123; if (n == 1) &#123; vector&lt;int&gt; ret; ret.push_back(A); ret.push_back(B); return ret; &#125; else &#123; vector&lt;int&gt; ret; int cnt = 0, t = A^B; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt == 1) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; p = i; break; &#125; &#125; A = swap(A, p, n-1); B = swap(B, p, n-1); vector&lt;int&gt; a = build(n-1, 0, 1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = int(a.size()-1); i &gt;= 0; i--) ret.push_back((1&lt;&lt;(n-1))|a[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, n-1); return ret; &#125; else if (cnt &lt; n) &#123; int p = 0; for (int i = 0; i &lt; n; i++) &#123; if (!(t &amp; (1&lt;&lt;i))) &#123; p = i; break; &#125; &#125; A = swap(A, p, 0); B = swap(B, p, 0); int q = 0; if (A &amp; 1) &#123; q = 1; A ^= q; B ^= q; &#125; vector&lt;int&gt; a = build(n-1, A&gt;&gt;1, B&gt;&gt;1); vector&lt;int&gt; b = build(n-1, a[0], a[1]); vector&lt;int&gt; ret; ret.push_back(a[0]&lt;&lt;1); for (int i = 0; i &lt; b.size(); i++) ret.push_back(b[i]&lt;&lt;1|1); for (int i = 1; i &lt; a.size(); i++) ret.push_back(a[i]&lt;&lt;1); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= q; for (int i = 0; i &lt; ret.size(); i++) ret[i] = swap(ret[i], p, 0); return ret; &#125; else &#123; vector&lt;int&gt; ret; vector&lt;int&gt; a = build(n-1, 0, 1); vector&lt;int&gt; b = build(n-1, 1, (1&lt;&lt;(n-1))-1); for (int i = 0; i &lt; a.size(); i++) ret.push_back(a[i]); for (int i = 0; i &lt; b.size(); i++) ret.push_back((1&lt;&lt;(n-1)) | b[i]); for (int i = 0; i &lt; ret.size(); i++) ret[i] ^= A; return ret; &#125; &#125;&#125;int n, A, B;int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); int t = A^B, cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (t &amp; (1&lt;&lt;i)) &#123; ++ cnt; &#125; &#125; if (cnt &amp; 1) &#123; puts("YES"); vector&lt;int&gt; ans = build(n, A, B); for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; printf("%d ", ans[i]); &#125; printf("\n"); &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC032D] Rotation Sort]]></title>
    <url>%2F2019%2F04%2F23%2F%5BAGC032D%5D-Rotation-Sort%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ ÂÅöÊ≥ï ËÆæ \(f_{i,j}\) Ë°®Á§∫Êää \(p_i \ldots p_n\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÊéíÂ∫èÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇ ËÆæ \(k\) ÊòØ \(p_i \ldots p_n\) ‰∏≠Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÁöÑ‰ΩçÁΩÆÔºå\(p_i\ldots p_k\) ‰∏≠Â§ß‰∫éÁ≠â‰∫é \(j\) ÁöÑÊï∞ÂÖ±Êúâ \(c\) ‰∏™„ÄÇ \[f_{i,j}=\min\{A(c-1)+f_{k+1, p_k+1},B+f_{i, p_k+1}\}\] È¢ÑÂ§ÑÁêÜÂá∫ \(p\) Âíå \(c\)Ôºå\(n^2\) dp ‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5010;typedef long long ll;int n, A, B, p[maxn], rp[maxn];ll f[maxn][maxn];int sum[maxn], K[maxn][maxn], C[maxn][maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;p[i]); rp[p[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; K[i][j] = K[i][j+1]; if (rp[j] &gt;= i) K[i][j] = rp[j]; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (p[i] &gt;= j) sum[i] = sum[i-1] + 1; else sum[i] = sum[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = K[i][j]; if (k) &#123; C[i][j] = sum[k]-sum[i-1]; &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (!K[i][j]) f[i][j] = 0; else &#123; ll c = C[i][j], k = K[i][j]; f[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]); &#125; &#125; &#125; printf("%lld\n", f[1][1]); return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces917E] Upside Down]]></title>
    <url>%2F2019%2F04%2F20%2FCF917E%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•„ÄÇ È¢òÁõÆÂ§ßÊÑè Áªô‰Ω†‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÁöÑÊ†ëÔºåËæπ‰∏äÊúâÂ≠óÁ¨¶„ÄÇÂÆö‰πâË∑ØÂæÑ \(u\) Âà∞ \(v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Â∞±ÊòØÊääË∑ØÂæÑ‰∏äÁöÑÂ≠óÁ¨¶‰æùÊ¨°Êé•Ëµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁªôÂÆö \(m\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s_1,s_2\ldots s_m\)„ÄÇ\(q\) Ê¨°ËØ¢ÈóÆÔºåÊØèÊ¨°ËØ¢ÈóÆÁªôÂá∫‰∏â‰∏™Êï∞ \(i, j, k\)ÔºåËØ¢ÈóÆÂú®Ë∑ØÂæÑ \(i\) Âà∞ \(j\) ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠Ôºå\(s_k\) Âá∫Áé∞‰∫ÜÂá†Ê¨°„ÄÇ Ëß£Ê≥ï Á¨¶Âè∑ËØ¥ÊòéÔºö\(s^R\) Ë°®Á§∫ \(s\) ÁöÑÂèç‰∏≤„ÄÇ\(pre(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂâçÁºÄÔºå\(suf(s,i)\) Ë°®Á§∫ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(i\) ÁöÑÂêéÁºÄ„ÄÇ\(s+t\) Ë°®Á§∫ÊääÂ≠óÁ¨¶‰∏≤ \(s\) ÂíåÂ≠óÁ¨¶‰∏≤ \(t\) ÊãºËµ∑Êù•ÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇ ÂÖàÂÅö‰∏ÄÊ¨°ÁÇπÂàÜÊ≤ªÂ∞±ÂèØ‰ª•ÊääÈóÆÈ¢òËΩ¨Âåñ‰∏∫ \(u \rightarrow v\) ÁªèËøáÊ†πÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•Âè™ËÆ®ËÆ∫ÁªèËøáÊ†πÁöÑÊÉÖÂÜµ„ÄÇ ËÆæÊ†π‰∏∫ \(r\)ÔºåËØ¢ÈóÆÁöÑË∑ØÂæÑ‰∏∫ \(u \rightarrow v\)ÔºåËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(s_k\)„ÄÇ ÂèØ‰ª•Êää \(s_k\) Âú®Ë∑ØÂæÑ \(u \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÂàÜÊàê‰∏âÈÉ®ÂàÜËÆ°ÁÆóÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØÂú® \(u\rightarrow r\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∫åÈÉ®ÂàÜÊòØÂú® \(r \rightarrow v\) ‰∏äÁöÑÂåπÈÖçÔºåÁ¨¨‰∏âÈÉ®ÂàÜÊòØÂú®Ë∑®Ëøá \(r\) ÁöÑÂåπÈÖç„ÄÇ Ââç‰∏§ÈÉ®ÂàÜÊòØÊØîËæÉÂ•ΩËÆ°ÁÆóÁöÑ„ÄÇÁ¶ªÁ∫ø‰∏Ä‰∏ãÔºåÂØπÊâÄÊúâÁöÑ \(s_i\) Âª∫ACËá™Âä®Êú∫ÔºåÂú®Ê†ë‰∏ädfsÔºåÊØèÊ¨°Âú®ACËá™Âä®Êú∫‰∏äËµ∞‰∏ÄÊù°ËΩ¨ÁßªËæπÔºåÁî® BIT Áª¥Êä§‰∏Ä‰∏ãÊØè‰∏™ÁÇπË¢´Ëµ∞‰∫ÜÂá†Ê¨°ÔºåÂú® dfs Âà∞ÁÇπ \(x\) Êó∂ÔºåÂè™ÈúÄ‰Ωú‰∏ÄÊ¨°Â≠êÊ†ëËØ¢ÈóÆÂç≥ÂèØÂø´ÈÄüÂæóÂà∞ \(s_k\) Âú® \(r\rightarrow x\) ‰∏äÂá∫Áé∞‰∫ÜÂá†Ê¨°ÔºàÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØ¢ÈóÆ \(s_k\) ÁöÑÂèç‰∏≤Âá∫Áé∞‰∫ÜÂá†Ê¨°Ôºâ„ÄÇ ÊØîËæÉÁÆÄÂçïÂ∞±‰∏çËØ¶ÁªÜÊèèËø∞‰∫Ü„ÄÇ Á¨¨‰∏âÈÉ®ÂàÜÊØîËæÉÂ§çÊùÇ„ÄÇËÆæË∑ØÂæÑ \(u\rightarrow r\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(x\)ÔºåË∑ØÂæÑ \(r \rightarrow v\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤‰∏∫ \(y\)„ÄÇËÆæ \(p\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(pre(s_k,p)=suf(x,p)\) ÁöÑÊï¥Êï∞Ôºå\(q\) ÊòØÊúÄÂ§ßÁöÑÊª°Ë∂≥ \(suf(s_k,q)=pre(y,q)\) ÁöÑÊï¥Êï∞„ÄÇÈÇ£‰πàËÆ°ÁÆóÁ¨¨‰∏âÈÉ®ÂàÜÂèØ‰ª•ËΩ¨Âåñ‰∏∫ËÆ°ÁÆó \(s_k\) Âú® \(suf(x,p)+pre(y,q)\) ‰∏≠ÁöÑÂá∫Áé∞Ê¨°Êï∞„ÄÇ ËÆæ \(t_i\) Ë∑ØÂæÑË°®Á§∫ \(r\rightarrow i\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂàô \(suf(x,p)+pre(y,q)\) ÂèØ‰ª•Ë°®Á§∫‰∏∫ \(pre(s_k,p)+suf(s_k,q)\)ÔºåËøôÊ†∑Â∞±ËΩ¨Âåñ‰∏∫‰∫ÜÂè™‰∏é \(s_k\) Áõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ\(p\)„ÄÅ\(q\) ÁöÑÂÖ∑‰ΩìÊ±ÇÊ≥ïÂêéÈù¢‰ºöËØ¶ÁªÜÊèèËø∞„ÄÇÂÅáËÆæÂ∑≤ÁªèÊ±ÇÂæó‰∫Ü \(p\)„ÄÅ\(q\)ÔºåËÄÉËôëÊÄé‰πàÂø´ÈÄüÂæóÂà∞Á¨¨‰∏âÈÉ®ÂàÜÁöÑÂåπÈÖçÊ¨°Êï∞„ÄÇ ÊääËØ¢ÈóÆÁ¶ªÁ∫ø„ÄÇÂØπÊØè‰∏™ \(i\)ÔºåÂª∫‰∏ÄÊ£µ \(s_i\) ÁöÑÂêéÁºÄÊ†ëÂíå \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë„ÄÇÂú® \(s_i^R\) ÁöÑÂêéÁºÄÊ†ë‰∏ä \(dfs\)Ôºå\(dfs\) ÁöÑËøáÁ®ã‰∏≠ÔºåÁª¥Êä§‰∏ÄÊ£µÁ∫øÊÆµÊ†ë„ÄÇÂ¶ÇÊûú \(dfs\) Âà∞‰∏Ä‰∏™‰ª£Ë°® \(s_i^R\) ÂêéÁºÄÁöÑÁÇπÔºåËÆæËøô‰∏™ÁÇπÂØπÂ∫îÁöÑÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ \(l\)ÔºåÈÇ£‰πàÂ∞±Âú®Á∫øÊÆµÊ†ë‰∏äÊää \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÂØπÂ∫î \(s_i[l+1\ldots \lvert s_i \rvert]\) ÁöÑÁÇπÁöÑÂ≠êÊ†ë \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂä†‰∏Ä„ÄÇÔºàÂèØËÉΩÊèèËø∞ÁöÑ‰∏çÊòØÂæàÊ∏ÖÊ•ö...Êàë‰πü‰∏çÁü•ÈÅìÊÄé‰πàÊèèËø∞‰∫ÜÔºâÂõûÊ∫ØÊó∂Êí§ÈîÄÊìç‰Ωú„ÄÇÁÑ∂ÂêéÂØπÊØè‰∏™ËØ¢ÈóÆ \(p, q\)ÔºåÂè™Ë¶ÅÂú® \(dfs\) Âà∞ \(s_i^R\) ÈïøÂ∫¶‰∏∫ \(p\) ÁöÑÂêéÁºÄÊó∂ÔºåËØ¢ÈóÆ‰∏Ä‰∏ã \(s_i\) ÈïøÂ∫¶‰∏∫ \(q\) ÁöÑÂêéÁºÄÂú® \(s_i\) ÁöÑÂêéÁºÄÊ†ë‰∏äÁöÑ \(dfs\) Â∫è‰∏ä‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÁöÑÂÄºÂç≥ÂèØ„ÄÇ ËÄÉËôëÂ¶Ç‰ΩïÊ±Ç \(p\)„ÄÅ\(q\)„ÄÇÁî±‰∫éÊ±Ç \(q\) ÁöÑËøáÁ®ãÂíåÊ±Ç \(p\) Á±ª‰ººÔºåËøôÈáåÂè™ËØ¶ÁªÜÊèèËø∞Ê±Ç \(p\) ÁöÑËøáÁ®ã„ÄÇÂØπÊâÄÊúâ \(s_i\) ‰ª•Âèä \(s_i^R\) Âª∫Âá∫‰∏Ä‰∏™Âπø‰πâSAM„ÄÇÁÑ∂ÂêéÁ±ª‰ººACËá™Âä®Êú∫+BITÁöÑËøáÁ®ãÂú∞ÔºåÁª¥Êä§‰∏Ä‰∏™‰ª•parentÊ†ë \(dfs\) Â∫è‰∏∫‰∏ãÊ†áÁöÑÁ∫øÊÆµÊ†ë„ÄÇÁÑ∂ÂêéÂú®ÁÇπÂàÜÊ≤ªÂêéÂæóÂà∞ÁöÑËøûÈÄöÂùó‰∏ä \(dfs\)Ôºå\(dfs\) Âà∞ \(u\) Êó∂Áª¥Êä§ \(r\rightarrow u\) ‰∏äÁöÑÂ≠óÁ¨¶‰∏≤Âú®SAM‰∏äÁöÑ‰ΩçÁΩÆÔºåÂπ∂ÊääÂÆÉÁöÑÂ≠êÊ†ëÂú® \(dfs\) Â∫è‰∏äÁöÑ‰ΩçÁΩÆÂú®Á∫øÊÆµÊ†ë‰∏äÂ≠êÊ†ëÂØπÈïøÂ∫¶Âèñ \(max\)„ÄÇÁÑ∂ÂêéÊ±Ç \(p\) Êó∂Âè™ÈúÄË¶ÅËØ¢ÈóÆ‰∏Ä‰∏ã \(s_k^R\) Âú® \(SAM\) ‰∏äÁöÑ‰ΩçÁΩÆÂú®parent tree‰∏≠ÁöÑ \(dfs\) Âú®Á∫øÊÆµÊ†ë‰∏äÁöÑ‰ΩçÁΩÆÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537] PKUWC2018 Minimax]]></title>
    <url>%2F2019%2F04%2F17%2F%5BLOJ2537%5D-PKUWC2018-Minimax%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• „ÄåPKUWC2018„ÄçMinimax„ÄÇ Â§ßËá¥ÊÄùË∑Ø&amp;&amp;ÂêêÊßΩ Á∫øÊÆµÊ†ëÂêàÂπ∂ÔºåÁª¥Êä§Êüê‰∏™ÁÇπÊúÄÂêéÁöÑÂÄºÂú®Á∫øÊÆµÊ†ë‰∏äÊØè‰∏™Âå∫Èó¥ÁöÑÊ¶ÇÁéá„ÄÇ merge ÁöÑÊó∂ÂÄôËÆ∞‰∏Ä‰∏ãÂâçÂêéÁºÄÊ¶ÇÁéáÂ∞±ËÉΩËΩ¨Áßª‰∫Ü„ÄÇ ‰ª£Á†ÅËÉΩÂäõÁúüÊòØË∂äÊù•Ë∂äÂ∑Æ‰∫Ü..Á∫øÊÆµÊ†ëÂêàÂπ∂ÈÉΩÂÜô‰∏çÁÜü„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 300010;const int mod = 998244353;typedef long long ll;const int maxw = 1e9;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;vector&lt;int&gt; tree[maxn];int n, tot;int ls[maxn*20], rs[maxn*20], sum[maxn*20], tag[maxn*20], p[maxn], _, ans = 0;inline void addEdge(int u, int v) &#123; tree[u].push_back(v);&#125;void modify(int rt, int v) &#123; if (rt) &#123; tag[rt] = 1LL*tag[rt]*v%mod; sum[rt] = 1LL*sum[rt]*v%mod; &#125;&#125;void pushDown(int rt) &#123; if (tag[rt] != 1) &#123; modify(ls[rt], tag[rt]); modify(rs[rt], tag[rt]); tag[rt] = 1; &#125;&#125;int Merge(int l, int r, int rt1, int rt2, int p, int Lp1, int Rp1, int Lp2, int Rp2) &#123; int pmax = p, pmin = (mod+1-p)%mod; int a = sum[rt1], b = sum[rt2]; int sa = (Rp1+a)%mod, pa = (Lp1+a)%mod; int sb = (Rp2+b)%mod, pb = (Lp2+b)%mod; if (!rt1 || !rt2) &#123; if (!rt1 &amp;&amp; !rt2) return 0; if (rt1 &amp;&amp; !rt2) &#123; modify(rt1, (1LL*pmin*sb%mod+1LL*pmax*pb%mod)%mod); return rt1; &#125; if (rt2 &amp;&amp; !rt1) &#123; modify(rt2, (1LL*pmin*sa%mod+1LL*pmax*pa%mod)%mod); return rt2; &#125; &#125; pushDown(rt1); pushDown(rt2); sum[rt1] = ((pmin*(1LL*a*sb%mod+1LL*b*sa%mod)%mod+pmax*(1LL*a*pb%mod+1LL*b*pa%mod))%mod-1LL*a*b%mod+mod)%mod; if (l == r) return rt1; int m = (l + r) &gt;&gt; 1; int t1 = (Rp1+sum[rs[rt1]])%mod; int t2 = (Rp2+sum[rs[rt2]])%mod; int t3 = (Lp1+sum[ls[rt1]])%mod; int t4 = (Lp2+sum[ls[rt2]])%mod; ls[rt1] = Merge(l, m, ls[rt1], ls[rt2], p, Lp1, t1, Lp2, t2); rs[rt1] = Merge(m+1, r, rs[rt1], rs[rt2], p, t3, Rp1, t4, Rp2); return rt1;&#125;void update(int p, int l, int r, int &amp;rt) &#123; if (!rt) &#123;rt = ++tot; tag[rt] = 1;&#125; sum[rt] ++; if (l == r) return; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) update(p, l, m, ls[rt]); else update(p, m+1, r, rs[rt]);&#125;int dfs(int u) &#123; int rt = 0; if (tree[u].size() == 0) update(p[u], 1, maxw, rt); if (tree[u].size() == 1) rt = dfs(tree[u][0]); if (tree[u].size() == 2) rt = Merge(1, maxw, dfs(tree[u][0]), dfs(tree[u][1]), 1LL*p[u]*qpow(10000, mod-2)%mod, 0, 0, 0, 0); return rt;&#125;void cal_ans(int l, int r, int rt) &#123; if (l == r) &#123; if (sum[rt]) &#123; ++ _; ans = (ans + 1LL*_*l%mod*sum[rt]%mod*sum[rt]%mod) % mod; &#125; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (ls[rt]) cal_ans(l, m, ls[rt]); if (rs[rt]) cal_ans(m+1, r, rs[rt]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int f = 0; scanf("%d", &amp;f); if (i &gt; 1) addEdge(f, i); &#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); int rt = dfs(1); cal_ans(1, maxw, rt); printf("%d\n", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2302] NOI2017 Êï¥Êï∞]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%5D%2F</url>
    <content type="text"><![CDATA[\(30\) ‰∏™ \(bit\) Âéã‰∏ÄËµ∑ÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥Â∑¶ËæπËøûÁª≠ \(0\) Âíå \(2^{30}-1\) ÁöÑ‰∏™Êï∞„ÄÇ ‰ª£Á†ÅËÉΩÂäõÂ§™Ëèú‰∫ÜË°•Ë°•Ê∞¥È¢ò„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int BASE = 1&lt;&lt;30;const int MX = BASE - 1;const int MAXN = (30000000+29)/30;struct DAT &#123; int len, lc0, lc1, val;&#125; T[MAXN*4+10];bool tag0[MAXN*4+10], tag1[MAXN*4+10];typedef long long ll;DAT operator+(DAT x, DAT y) &#123; DAT ret; ret.len = x.len + y.len; ret.lc0 = x.lc0; ret.lc1 = x.lc1; if (x.lc0 == x.len) ret.lc0 = x.len + y.lc0; if (x.lc1 == x.len) ret.lc1 = x.len + y.lc1; return ret;&#125;void modify0(int rt) &#123; tag0[rt] = 1; tag1[rt] = 0; T[rt].lc1 = T[rt].val = 0; T[rt].lc0 = T[rt].len;&#125;void modify1(int rt) &#123; tag1[rt] = 1; tag0[rt] = 0; T[rt].lc0 = 0; T[rt].val = MX; T[rt].lc1 = T[rt].len;&#125;void pushDown(int rt) &#123; if (tag0[rt]) &#123; modify0(rt&lt;&lt;1); modify0(rt&lt;&lt;1|1); tag0[rt] = 0; &#125; if (tag1[rt]) &#123; modify1(rt&lt;&lt;1); modify1(rt&lt;&lt;1|1); tag1[rt] = 0; &#125;&#125;void pushUp(int rt) &#123; T[rt] = T[rt&lt;&lt;1] + T[rt&lt;&lt;1|1];&#125;void updc0(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify0(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc0(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc0(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void updc1(int L, int R, int l, int r, int rt) &#123; if (L &gt; R) return; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; modify1(rt); return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) updc1(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) updc1(L, R, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;void upd(int p, int v, int l, int r, int rt) &#123; if (l == r) &#123; if (v == MX) &#123; T[rt].lc1 = 1; &#125; else T[rt].lc1 = 0; if (v == 0) &#123; T[rt].lc0 = 1; &#125; else T[rt].lc0 = 0; T[rt].val = v; return; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; if (p &lt;= m) upd(p, v, l, m, rt&lt;&lt;1); else upd(p, v, m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;DAT qrys(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return T[rt]; &#125; pushDown(rt); int m = (l + r) &gt;&gt; 1; DAT ret; ret.len = ret.lc0 = ret.lc1 = 0; if (L &lt;= m) ret = ret + qrys(L, R, l, m, rt&lt;&lt;1); if (R &gt; m) ret = ret + qrys(L, R, m+1, r, rt&lt;&lt;1|1); return ret;&#125;int qry(int p, int l, int r, int rt) &#123; if (l == r) return T[rt].val; int m = (l + r) &gt;&gt; 1; pushDown(rt); if (p &lt;= m) return qry(p, l, m, rt&lt;&lt;1); else return qry(p, m+1, r, rt&lt;&lt;1|1);&#125;void add(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t+v) &gt;= BASE) &#123; upd(p, (t+v)%BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc0(p+1, p+dat.lc1, 0, MAXN, 1); upd(p+1+dat.lc1, qry(p+1+dat.lc1, 0, MAXN, 1) + 1, 0, MAXN, 1); &#125; else upd(p, t+v, 0, MAXN, 1);&#125;void sub(int p, int v) &#123; if (!v) return; int t = qry(p, 0, MAXN, 1); if ((t-v) &lt; 0) &#123; upd(p, t-v+BASE, 0, MAXN, 1); DAT dat = qrys(p+1, MAXN, 0, MAXN, 1); updc1(p+1, p+dat.lc0, 0, MAXN, 1); upd(p+1+dat.lc0, qry(p+1+dat.lc0, 0, MAXN, 1) - 1, 0, MAXN, 1); &#125; else upd(p, t-v, 0, MAXN, 1);&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; T[rt].len = T[rt].lc0 = 1; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, rt&lt;&lt;1); build(m+1, r, rt&lt;&lt;1|1); pushUp(rt);&#125;int n, t1, t2, t3;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;t1, &amp;t2, &amp;t3); build(0, MAXN, 1); for (int i = 1; i &lt;= n; i++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); //b/30*30 //2^&#123;b%30&#125;*b if (a &lt; 0) &#123; a = -a; ll v = (1ll&lt;&lt;(b%30))*a; sub(b/30, v%BASE); sub(b/30+1, v/BASE); &#125; else &#123; ll v = (1ll&lt;&lt;(b%30))*a; add(b/30, v%BASE); add(b/30+1, v/BASE); &#125; &#125; else &#123; int k; scanf("%d", &amp;k); int t = qry(k/30, 0, MAXN, 1); printf("%d\n", (t&gt;&gt;(k%30))&amp;1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Miller-Rabin]]></title>
    <url>%2F2019%2F04%2F16%2F%5B%E6%A8%A1%E6%9D%BF%5D-Miller-Rabin%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ Ë¥®Êï∞Âà§ÂÆö„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll mul(ll a, ll b, ll mod) &#123; return __int128(a)*__int128(b)%mod;&#125;ll qpow(ll a, ll x, ll mod) &#123; ll ret = 1; while (x) &#123; if (x &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); x &gt;&gt;= 1; &#125; return ret;&#125;int prm[12] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;;ll miller_rabin(ll p) &#123; if (p == 2) return 1; if (p == 1 || p % 2 == 0) return 0; ll t = p-1, c = 0; while (t % 2 == 0) &#123; t /= 2; ++ c; &#125; for (int i = 0; i &lt; 12 &amp;&amp; prm[i] &lt; p; i++) &#123; int a = prm[i]; ll v = qpow(a, t, p); for (int j = 0; j &lt; c; j++) &#123; ll nv = mul(v, v, p); if (nv == 1 &amp;&amp; v != 1 &amp;&amp; v != p-1) return 0; v = nv; &#125; if (v != 1) return 0; &#125; return 1;&#125;int T;int main() &#123; ll n; while (scanf("%lld", &amp;n) != EOF) &#123; if (miller_rabin(n)) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2018] ÂèçÂõûÊñá‰∏≤]]></title>
    <url>%2F2019%2F04%2F15%2F%5BSDOI2018%5D-%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄåSDOI2018„ÄçÂèçÂõûÊñá‰∏≤„ÄÇ È¢òËß£ ËÄÉËôë‰ªÄ‰πàÊ†∑ÁöÑÂõûÊñá‰∏≤Âú®Âæ™ÁéØÁßª‰Ωç \(k\) ‰ΩçÂêéËøòÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤„ÄÇ ËÆæ \(s\) ÊòØ‰∏Ä‰∏™Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶‰∏∫ \(n\) ÂõûÊñá‰∏≤„ÄÇ ËÆ∞Â≠óÁ¨¶‰∏≤ \(a\) ÁöÑÂèç‰∏≤‰∏∫ \(a^R\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØÂõûÊñá‰∏≤ÔºåÂØπ‰∫é \(1\le i \le n\)Ôºå\(s[i]=s[n-i+1]\)„ÄÇ ÂèàÂõ†‰∏∫ \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰ΩçÂêé‰ªçÊòØÂõûÊñá‰∏≤Ôºö ÂØπ‰∫é \(1 \le i \le n-2k\)Ôºö \(s[i]=s[n-(i+k)+1-k]=s[n-i+1-2k]=s[i+2k]\) ÂØπ‰∫é \(n-2k &lt; i \le n-k\)Ôºö \(s[i] = s[2n-2k-i+1] = s[i+2k]\) ÂØπ‰∫é \(n-k&lt;i \le n\)Ôºö \(s[i] = s[n-(i+k-n)+1-k]=s[2n-i-2k+1]=s[i+2k-n]\) ÂèØ‰ª•ÁúãÂá∫ \(2k\) ÊòØ \(s\) ÁöÑÂë®ÊúüÔºå‰∏î \(s\) Âæ™ÁéØÂè≥Áßª \(2k\) ‰ΩçÂêéÂæóÂà∞ÁöÑÂ≠óÁ¨¶‰∏≤‰∏é \(s\) Áõ∏Á≠â„ÄÇÂõ†Ê≠§ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÊòØ \(n\) ÁöÑÁ∫¶Êï∞„ÄÇËÆæ \(s\) ÁöÑÊúÄÂ∞èÂë®ÊúüÈïøÂ∫¶‰∏∫ \(t\)Ôºå\(t \mid n\)„ÄÇ ÊòæÁÑ∂ÔºåÂ¶ÇÊûú \(s\) Âæ™ÁéØÂè≥Áßª \(k\) ‰Ωç‰ªçÊòØ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÈÇ£‰πà \(t \mid 2k\)„ÄÇÊúâ \(t\) Áßç‰∏çÂêåÁöÑ‰∏é \(s\) Âæ™ÁéØÂêåÊûÑÁöÑ‰∏≤„ÄÇËã• \(t\) ‰∏∫ÂÅ∂Êï∞ÔºåÈÇ£‰πà \(s\) Âæ™ÁéØÂè≥Áßª \(\frac t 2\) ‰ΩçÊàñÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇÂê¶ÂàôÂè™ÊúâÂæ™ÁéØÂè≥Áßª \(0\) ‰ΩçÊòØÂõûÊñá‰∏≤„ÄÇ ‰∏∫‰∫ÜËÆ°ÁÆó‰∏éÊüê‰∏™ÂõûÊñá‰∏≤Âæ™ÁéØÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÔºåËÄÉËôëÊûö‰∏æÂõûÊñá‰∏≤Âπ∂ËÆ°ÁÆó‰∏éËøô‰∏™ÂõûÊñá‰∏≤ÂêåÊûÑÁöÑÂ≠óÁ¨¶‰∏≤ÊúâÂ§öÂ∞ëÁßçÔºåËøôÊ†∑ÊúÄÂ∞èÂë®ÊúüÊòØÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤‰ºöË¢´ÁÆóÊÅ∞Â•Ω‰∏§Ê¨°ÔºåÂÖ∂‰ªñÂõûÊñá‰∏≤ÁöÑÂæ™ÁéØÂêåÊûÑ‰∏≤Âè™‰ºöË¢´ÁÆó‰∏ÄÊ¨°„ÄÇÁâπÂà§ÊúÄÂ∞èÂë®Êúü‰∏∫ÂÅ∂Êï∞ÁöÑÊÉÖÂÜµÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå‰∏çÂèØËÉΩÊûö‰∏æÊâÄÊúâÁöÑÂõûÊñá‰∏≤„ÄÇËÄÉËôëÊääÊúÄÂ∞èÂë®ÊúüÁõ∏ÂêåÁöÑÂõûÊñá‰∏≤ÊîæÂú®‰∏ÄËµ∑Êûö‰∏æ„ÄÇËÆæÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è‰∏∫ \(K\)ÔºåÊúÄÂ∞èÂë®Êúü‰∏∫ \(i\) ÁöÑÁ∫¶Êï∞ÁöÑÂõûÊñá‰∏≤Êúâ \(K^{\lceil \frac i 2 \rceil}\) ‰∏™„ÄÇËé´ÊØî‰πåÊñØÂèçÊºî‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ ÁÑ∂ËÄå \(n\) ÈùûÂ∏∏ÁöÑÂ§ßÔºåÊ≤°ÊúâÂäûÊ≥ïÁõ¥Êé•ÂèçÊºîÂá∫‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ ÊääÁ≠îÊ°àÂÜôÂá∫Êù•ÂåñÁÆÄÔºö \[ ans=\sum_{i|n} \frac{i}{1+[2\mid i]}\sum_{d|i} K^{\lceil \frac d 2 \rceil}\mu(\frac i d)=\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{d|i,i|n} \frac{i}{1+[2\mid i]} \mu(\frac i d) \] \[ =\sum_{d|n} K^{\lceil \frac d 2 \rceil} \sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i) \] Êûö‰∏æ \(d\)„ÄÇ \(d\) ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=\frac d 2\sum_{i | \frac n d} i \mu(i) = \frac d 2 \prod_{p|\frac n d} (1-p)\)„ÄÇ \(d\) ‰∏∫Â•áÊï∞Êó∂ÔºåËã• \(n\) ‰∏∫Â•áÊï∞Ôºå\(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=d\sum_{i | \frac n d} i \mu(i) = d \prod_{p|\frac n d} (1-p)\)ÔºåÂê¶Âàô \(\sum_{i | \frac n d} \frac{di}{1+[2|di]} \mu(i)=0\)„ÄÇ \(Pollard-Rho\) ÂàÜËß£Á¥†Âõ†Êï∞ÂêéÁÆÄÂçïÁªüËÆ°‰∏Ä‰∏ãÁ≠îÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></title>
    <url>%2F2019%2F04%2F12%2F%5BYNOI2016%5D-%E9%95%9C%E4%B8%AD%E7%9A%84%E6%98%86%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [Ynoi2016]Èïú‰∏≠ÁöÑÊòÜËô´„ÄÇ ËÆ∞ÂΩïÊØè‰∏™ÁÇπ \(i\) ÂâçÈù¢Á¨¨‰∏Ä‰∏™‰∏é‰ªñÂêåËâ≤ÁöÑ‰ΩçÁΩÆ \(pre_i\)„ÄÇËØ¢ÈóÆÂå∫Èó¥È¢úËâ≤Êï∞ÂèòÊàêËØ¢ÈóÆÂå∫Èó¥ÂÜÖÊúâÂ§öÂ∞ë‰∏™ \(pre_i &lt;l\)ÔºåËøôÊòØ‰∏Ä‰∏™‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò„ÄÇÊ≥®ÊÑèÂà∞‰øÆÊîπ \(pre\) Êï∞ÁªÑÊ¨°Êï∞ÂùáÊëä \(\mathcal O (n)\)ÔºåÁî® \(set\) Áª¥Êä§ÊØè‰∏ÄÊÆµÔºåcdqÂàÜÊ≤ªÊàñËÄÖÊ†ëÂ•óÊ†ëÂÅö‰∏Ä‰∏ã‰∫åÁª¥ÂÅèÂ∫èÂç≥ÂèØ„ÄÇ ËøôÈ¢òÊúâ‰∏ÄÁÇπÂç°Â∏∏..cdqÂàÜÊ≤ªÂÜôÂΩíÂπ∂ÈÄüÂ∫¶‰ºöÂø´ÂæàÂ§ö„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int n, m, tot;int a[maxn], _pos[maxn], ans[maxn], sum[maxn], isq[maxn], sc, so;struct seg &#123; int l, r, c; seg(int l_=0, int r_=0, int c_=0) : l(l_), r(r_), c(c_) &#123;&#125;&#125;;struct OPT &#123; int x, y, v, ty, id, pos;&#125; op[maxn*20], ta[maxn*20];bool operator&lt;(OPT x, OPT y) &#123; if (x.x != y.x) return x.x &lt; y.x; return x.ty &lt; y.ty; &#125;typedef set&lt;seg&gt;::iterator iter;map&lt;int, int&gt; val; //Á¶ªÊï£Âåñint pre[maxn];set&lt;int&gt; st; //pre[i] != i-1set&lt;int&gt; bc[maxn*2], ec[maxn*2];set&lt;seg&gt; s;bool operator&lt;(seg x, seg y) &#123; return x.r &lt; y.r;&#125;int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int x, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; sum[i] += v; &#125;&#125;int ask(int x) &#123; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; ret += sum[i]; &#125; return ret;&#125;int getval(int a) &#123; if (val.count(a)) return val[a]; else return val[a] = ++ tot;&#125;void addseg(int l, int r, int v) &#123; s.insert(seg(l, r, v)); bc[v].insert(l); ec[v].insert(r);&#125;void removeseg(iter sg) &#123; bc[sg-&gt;c].erase(sg-&gt;l); ec[sg-&gt;c].erase(sg-&gt;r); s.erase(sg);&#125;void split(int p) &#123; //split p p+1 if (!p) return; iter i = s.lower_bound(seg(0, p)); int l = i-&gt;l, r = i-&gt;r; int r1 = p-1, l2 = p+1; int v = i-&gt;c; removeseg(i); if (l &lt;= r1) addseg(l, r1, v); addseg(p, p, v); if (l2 &lt;= r) addseg(l2, r, v);&#125;void modifypre(int p, int v, int on = 1) &#123; //OPT if (v != p-1) st.insert(p); if (on) &#123; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = -1; op[so].ty = 0; &#125; pre[p] = v; ++ so; op[so].x = p; op[so].y = pre[p]; op[so].v = 1; op[so].ty = 0;&#125;int findpre(int p, int v) &#123; set&lt;int&gt;::iterator t = ec[v].lower_bound(p); if (t == ec[v].begin()) return 0; else return (*(--t));&#125;int findnxt(int p, int v) &#123; set&lt;int&gt;::iterator t = bc[v].upper_bound(p); if (t == bc[v].end()) return -1; else return (*t);&#125;int getcol(int p) &#123; iter t = s.lower_bound(seg(0, p)); return t-&gt;c;&#125;void solve(int l, int r) &#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; solve(l, m); solve(m+1, r); int p1 = l, p2 = m+1, p = l; while (p1 &lt;= m || p2 &lt;= r) &#123; if (p1 &gt; m) ta[p++] = op[p2++]; else if (p2 &gt; r) ta[p++] = op[p1++]; else if (op[p1] &lt; op[p2]) ta[p++] = op[p1++]; else ta[p++] = op[p2++]; &#125; for (int i = l; i &lt;= r; i++) op[i] = ta[i]; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, op[i].v); &#125; &#125; else &#123; if (op[i].pos &gt; m) &#123; ans[op[i].id] += op[i].v*ask(op[i].y+1); &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (op[i].ty == 0) &#123; if (op[i].pos &lt;= m) &#123; add(op[i].y+1, - op[i].v); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] = getval(a[i]); addseg(i, i, a[i]); modifypre(i, _pos[a[i]], 0); _pos[a[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int o, l, r, x; scanf("%d%d%d", &amp;o, &amp;l, &amp;r); if (o == 1) &#123; scanf("%d", &amp;x); x = getval(x); split(l-1); split(r); modifypre(l, findpre(l, x)); iter it = s.lower_bound(seg(0, l)); while (it != s.end() &amp;&amp; it-&gt;r &lt;= r) &#123; int nxt = findnxt(it-&gt;r, it-&gt;c); iter tmp = it; int c = it-&gt;c; ++ it; removeseg(tmp); if (nxt != -1) &#123; if (c == x) modifypre(nxt, r); else modifypre(nxt, findpre(nxt, c)); &#125; &#125; addseg(l, r, x); //ÂØπ l+1-r ÁöÑpreÊõ¥Êñ∞ set&lt;int&gt;::iterator t = st.lower_bound(l+1); while (t != st.end() &amp;&amp; (*t) &lt;= r) &#123; modifypre(*t, (*t)-1); set&lt;int&gt;::iterator tmp = t; ++ t; st.erase(tmp); &#125; int nxt = findnxt(r, x); if (nxt != -1) modifypre(nxt, r); &#125; else &#123; isq[i] = 1; ++ so; op[so].x = l-1; op[so].y = l-1; op[so].v = -1; op[so].ty = 1; op[so].id = i; ++ so; op[so].x = r; op[so].y = l-1; op[so].v = 1; op[so].ty = 1; op[so].id = i; &#125; &#125; for (int i = 1; i &lt;= so; i++) op[i].pos = i; solve(1, so); for (int i = 1; i &lt;= m; i++) &#123; if (isq[i]) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[È¢òËß£] YNOI]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5D-YNOI%2F</url>
    <content type="text"><![CDATA[ËôΩÁÑ∂ÂâçÈù¢ËøòÊúâÂæàÂ§öÂùëÊ≤°Ë°•ÂÆå...‰ΩÜÊòØÊàëÂèëÁé∞Ëá™Â∑±‰ª£Á†ÅËÉΩÂäõÈóÆÈ¢òÊØîËæÉ‰∏•Èáç„ÄÇÊâÄ‰ª•Êù•ÂÅöÂÅöynoi„ÄÇ ÂùëÂÖàÊîæÂú®Ëøô...Ê∏ÖÈÜíÁöÑÊó∂ÂÄôÊÖ¢ÊÖ¢Â°´„ÄÇ [YNOI2016] Èïú‰∏≠ÁöÑÊòÜËô´]]></content>
      <tags>
        <tag>È¢òËß£</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FWT]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-FWT%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢„ÄÇ ÂÖàÂíïÁùÄ„ÄÇ„ÄÇ„ÄÇ‰∏á‰∏ÄÈÅá‰∏äÁé∞Êé®Âêß„ÄÇ]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Êâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÊâ©Â±ï‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ„ÄÇ ËøôÈ¢òÁõÆÊúâÈóÆÈ¢òÂêß....Ê®°Êï∞ÂèØ‰ª•ÁàÜ long long ÁöÑ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a1, b1;ll gcd(ll x, ll y) &#123; if (!y) return x; return gcd(y, x%y);&#125;ll mul(ll x, ll y, ll mod) &#123; ll t = y, ret = 0; for (int i = 0; i &lt; 63; i++) &#123; if (x &amp; (1ll&lt;&lt;i)) ret = (ret + t) % mod; t = t*2%mod; &#125; return ret;&#125;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= (a/b)*x;&#125;int main() &#123; scanf("%d", &amp;n); a1 = 1; b1 = 0; for (int i = 1; i &lt;= n; i++) &#123; ll a2, b2; scanf("%lld%lld", &amp;a2, &amp;b2); ll na = a1/gcd(a1,a2)*a2; ll x, y; exgcd(a1, -a2, x, y); ll k = (b2-b1)/gcd(a1,-a2); int t = 1; if (k &lt; 0) &#123; k = -k; t = -t; &#125; if (x &lt; 0) &#123; x = -x; t = -t; &#125; ll k1 = t*mul(k, x, na); k1 %= na; if (k1 &lt; 0) k1 += na; b1 = (mul(k1%na, a1, na)+b1)%na; a1 = na; &#125; printf("%lld\n", b1); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ÂêéÁºÄËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂêéÁºÄËá™Âä®Êú∫„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1000010;vector&lt;int&gt; tree[maxn*2];typedef long long ll;char s[maxn];int n, tot, last = 0;ll ans = 0;int tr[maxn*2][26], par[maxn*2], len[maxn*2], sum[maxn*2], val[maxn*2];void addchar(int c, int l) &#123; int np = ++tot; len[np] = l; val[np] = 1; while (!tr[last][c]) &#123; tr[last][c] = np; last = par[last]; &#125; if (!last) par[np] = 1; else &#123; int q = tr[last][c]; if (len[q] == len[last] + 1) &#123; par[np] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[last] + 1; par[nq] = par[q]; memcpy(tr[nq], tr[q], sizeof(tr[nq])); par[q] = par[np] = nq; while (tr[last][c] == q) &#123; tr[last][c] = nq; last = par[last]; &#125; &#125; &#125; last = np;&#125;void dfs(int u) &#123; sum[u] = val[u]; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; dfs(v); sum[u] += sum[v]; &#125;&#125;int main() &#123; scanf("%s", s+1); n = int(strlen(s+1)); last = ++tot; for (int i = 1; i &lt;= n; i++) &#123; addchar(s[i]-'a', i); &#125; for (int i = 2; i &lt;= tot; i++) tree[par[i]].push_back(i); dfs(1); for (int i = 2; i &lt;= tot; i++) if (sum[i] &gt; 1) ans = max(ans, 1LL*sum[i]*len[i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Splay(Áª¥Êä§Â∫èÂàó)]]></title>
    <url>%2F2019%2F04%2F05%2F%5B%E6%A8%A1%E6%9D%BF%5D-Splay%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ [NOI2005]Áª¥Êä§Êï∞Âàó„ÄÇ Â∏∏Êï∞ÈùûÂ∏∏ÈùûÂ∏∏Â§ß.....ÂÖàÂΩìÊùøÂ≠êËÉå‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 500010;queue&lt;int&gt; Q;int n, m, rt;char buf[100];int a[maxn];int ch[maxn][2], fa[maxn], rev[maxn], has_tag[maxn], sz[maxn], tag[maxn], val[maxn], lsum[maxn], rsum[maxn], msum[maxn], sum[maxn], mx[maxn];void pushUp(int x) &#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; msum[x] = max(rsum[ch[x][0]] + lsum[ch[x][1]] + val[x], max(msum[ch[x][0]], msum[ch[x][1]])); lsum[x] = max(lsum[ch[x][0]], sum[ch[x][0]] + val[x] + lsum[ch[x][1]]); rsum[x] = max(rsum[ch[x][1]], sum[ch[x][1]] + val[x] + rsum[ch[x][0]]); mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]]));&#125;int newNode(int v) &#123; int ret = Q.front(); Q.pop(); rev[ret] = 0; tag[ret] = has_tag[ret] = 0; fa[ret] = 0; ch[ret][0] = ch[ret][1] = 0; sz[ret] = 1; sum[ret] = val[ret] = v; mx[ret] = v; if (v &gt; 0) lsum[ret] = rsum[ret] = msum[ret] = v; else lsum[ret] = rsum[ret] = msum[ret] = 0; return ret;&#125;void Rev(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; swap(lsum[x], rsum[x]);&#125;void modify(int x, int v) &#123; tag[x] = v; has_tag[x] = 1; sum[x] = sz[x]*v; val[x] = v; mx[x] = v; if (v &gt; 0) lsum[x] = rsum[x] = msum[x] = sz[x]*v; else lsum[x] = rsum[x] = msum[x] = 0;&#125;void pushDown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125; if (has_tag[x]) &#123; if (ch[x][0]) modify(ch[x][0], tag[x]); if (ch[x][1]) modify(ch[x][1], tag[x]); has_tag[x] = 0; &#125;&#125;void delNode(int x) &#123; Q.push(x);&#125;int getson(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; if (!fa[x]) return; int f = fa[x], ff = fa[fa[x]], s = getson(x); if (ff) ch[ff][getson(f)] = x; fa[x] = ff; ch[f][s] = ch[x][s^1]; fa[ch[x][s^1]] = f; ch[x][s^1] = f; fa[f] = x; pushUp(f); pushUp(x);&#125;void PushDown(int x) &#123; if (fa[x]) PushDown(fa[x]); pushDown(x);&#125;void splay(int x) &#123; PushDown(x); for (int f; fa[x]; rotate(x)) &#123; if (fa[f=fa[x]]) &#123; rotate((getson(f) == getson(x)) ? f : x); &#125; &#125; rt = x;&#125;int getRank(int x) &#123; splay(x); return sz[ch[x][0]] + 1;&#125;int kth(int x, int k) &#123; pushDown(x); if (k &lt;= sz[ch[x][0]]) &#123; return kth(ch[x][0], k); &#125; else if (k == sz[ch[x][0]] + 1) &#123; splay(x); return x; &#125; else return kth(ch[x][1], k-1-sz[ch[x][0]]);&#125;void split(int k, int r, int &amp;r1, int &amp;r2) &#123; if (!k) &#123; r1 = 0; r2 = r; return; &#125; if (k == sz[r]) &#123; r1 = r; r2 = 0; return; &#125; int x = kth(r, k); int rs = ch[x][1]; fa[rs] = ch[x][1] = 0; pushUp(x); r1 = x; r2 = rs;&#125;int maxNode(int x) &#123; while (ch[x][1]) &#123; pushDown(x); x = ch[x][1]; &#125; splay(x); return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x+y; splay(x); int mx = maxNode(x); ch[mx][1] = y; fa[y] = mx; pushUp(mx); return mx;&#125;void del(int r) &#123; if (ch[r][0]) del(ch[r][0]); delNode(r); if (ch[r][1]) del(ch[r][1]);&#125;void print(int r) &#123; pushDown(r); if (ch[r][0]) print(ch[r][0]); printf("%d ", val[r]); if (ch[r][1]) print(ch[r][1]);&#125;int main() &#123; mx[0] = -0x3f3f3f3f; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 500000; i++) Q.push(i); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); newNode(a[i]); &#125; for (int i = n; i &gt; 1; i--) &#123; fa[i] = i-1; ch[i-1][1] = i; pushUp(i-1); &#125; rt = 1; for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", buf); if (buf[0] == 'I') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int t_rt = 0; while (cnt --) &#123; int c; scanf("%d", &amp;c); int t = newNode(c); ch[t][0] = t_rt; if (t_rt) fa[t_rt] = t; t_rt = t; pushUp(t); &#125; int r1, r2; split(p, rt, r1, r2); rt = merge(merge(r1, t_rt), r2); &#125; else if (buf[0] == 'D') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); rt = merge(r1, r3); del(r2); &#125; else if (buf[0] == 'M') &#123; if (buf[2] == 'K') &#123; int p, cnt, v; scanf("%d%d%d", &amp;p, &amp;cnt, &amp;v); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); if (r2) modify(r2, v); rt = merge(merge(r1, r2), r3); &#125; else &#123; if (mx[rt] &lt; 0) printf("%d\n", mx[rt]); else printf("%d\n", msum[rt]); &#125; &#125; else if (buf[0] == 'R') &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); Rev(r2); rt = merge(merge(r1, r2), r3); &#125; else &#123; int p, cnt; scanf("%d%d", &amp;p, &amp;cnt); if (!cnt) &#123; puts("0"); &#125; else &#123; int r1, r2, r3; split(p-1, rt, r1, r2); split(cnt, r2, r2, r3); printf("%d\n", sum[r2]); rt = merge(merge(r1, r2), r3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèexp]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[$$]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèln]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÂØπÊï∞ÂáΩÊï∞„ÄÇ ‰ª£Á†ÅÁâπÂà´‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;const int mod = 998244353;const int g = 3;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1LL*ret*x%mod; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int n = 0;struct poly &#123; int *a, len; poly(int l) &#123; len = l; a = new int[l]; for (int i = 0; i &lt; l; i++) a[i] = 0; &#125;&#125;;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[i], a[rev[i]]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; int v1 = a[i], v2 = 1LL*w*a[i+(l&gt;&gt;1)]%mod; a[i] = (v1+v2) % mod; a[i+(l &gt;&gt; 1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly a, poly b) &#123; poly ret(a.len + b.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) ++ t; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; a.len; i++) w_a[i] = a.a[i]; for (int i = 0; i &lt; b.len; i++) w_b[i] = b.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly poly_inverse(poly a) &#123; if (a.len == 1) &#123; poly ret(1); ret.a[0] = qpow(a.a[0], mod-2); return ret; &#125; int nl = (a.len+1)/2; poly na(nl); for (int i = 0; i &lt; nl; i++) na.a[i] = a.a[i]; poly r = poly_inverse(na); poly t = r*a; t.len = a.len; for (int i = 0; i &lt; t.len; i++) t.a[i] = (mod-t.a[i])%mod; t.a[0] = (t.a[0] + 2) % mod; poly ret = t*r; ret.len = a.len; return ret;&#125;poly poly_ln(poly a) &#123; poly t(a.len-1); for (int i = 1; i &lt; a.len; i++) &#123; t.a[i-1] = 1LL * a.a[i] * i % mod; &#125; poly x = poly_inverse(a); poly s = x*t; s.len = a.len; poly ret(a.len); for (int i = 1; i &lt; a.len; i++) &#123; ret.a[i] = 1LL*qpow(i, mod-2)*s.a[i-1]%mod; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly A(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;A.a[i]); poly P = poly_ln(A); for (int i = 0; i &lt; n; i++) printf("%d ", P.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] Â§öÈ°πÂºèÊ±ÇÈÄÜ]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E6%A8%A1%E6%9D%BF%5D-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[Êèê‰∫§Ëá≥ „ÄêÊ®°Êùø„ÄëÂ§öÈ°πÂºèÊ±ÇÈÄÜ„ÄÇ \(F(x)G(x)-1 \equiv 0 \pmod {x^{\lceil \frac n 2 \rceil}}\) \(F(x)^2G(x)^2-2F(x)G(x)+1\equiv 0 \pmod {x^n}\) \(F(x)[2G(x)-F(x)G(x)^2] \equiv 1 \pmod {x^n}\) \(F(x)^{-1} \equiv G(x)[2-F(x)G(x)] \pmod {x^n}\) ‰ª£Á†Å‰∏ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int g = 3;const int maxn = 100010;int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4], rev[maxn*4];int n = 0;struct poly &#123; int *a, len; poly (int l = 0) &#123; a = new int[l]; len = l; for (int i = 0; i &lt; l; i++) &#123; a[i] = 0; &#125; &#125;&#125;;void ntt(int *a, int t, int ty) &#123; int len = (1 &lt;&lt; t); for (int i = 1; i &lt; len; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(t-1)); for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod) % mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) swap(a[i], a[len-i]); int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) a[i] = 1LL*a[i]*r%mod; &#125;&#125;poly operator*(poly A, poly B) &#123; poly ret(A.len + B.len - 1); int t = 0; while ((1&lt;&lt;t) &lt; ret.len) t ++; for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_a[i] = w_b[i] = 0; for (int i = 0; i &lt; A.len; i++) w_a[i] = A.a[i]; for (int i = 0; i &lt; B.len; i++) w_b[i] = B.a[i]; ntt(w_a, t, 1); ntt(w_b, t, 1); for (int i = 0; i &lt; (1&lt;&lt;t); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, t, -1); for (int i = 0; i &lt; ret.len; i++) ret.a[i] = w_c[i]; return ret;&#125;poly inverse(poly A) &#123; if (A.len == 1) &#123; poly ret(1); ret.a[0] = qpow(A.a[0], mod-2); return ret; &#125; int nlen = (A.len+1)/2; poly nA(nlen); for (int i = 0; i &lt; nlen; i++) nA.a[i] = A.a[i]; poly r = inverse(nA); poly tmp = A*r; tmp.len = A.len; for (int i = 0; i &lt; tmp.len; i++) tmp.a[i] = (-tmp.a[i]+mod)%mod; tmp.a[0] = (tmp.a[0]+2) % mod; poly ret = r*tmp; ret.len = A.len; return ret;&#125;int main() &#123; scanf("%d", &amp;n); poly F(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;F.a[i]); poly G = inverse(F); for (int i = 0; i &lt; n; i++) printf("%d ", G.a[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â§öÈ°πÂºè</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] ‰ªªÊÑèÈïøÂ∫¶DFT]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-%2F</url>
    <content type="text"><![CDATA[Bluestein's Algorithm Ê±Ç \(f(\omega_n^i) = \sum_{k=0}^{n-1} a_k \omega_n^{ik} = \sum_{k=0}^{n-1} a_k \omega_{2n}^{i^2+k^2-(i-k)^2}\) ËÆæ \(b_k = a_k\omega_{2n}^{k^2},c_k =w_{2n}^{-k^2}\)„ÄÇ Âàô \(f(\omega_n^i) = \omega_{2n}^{i^2}\sum_{k=0}^{n-1} b_kc_{i-k}\)„ÄÇ \(i-k\) ÂèØËÉΩ‰ºöÂá∫Áé∞Ë¥üÊï∞„ÄÇÂπ≥Áßª‰∏ãÂÅö‰∏™Âç∑ÁßØÂç≥ÂèØ„ÄÇ ÊáíÂæóÂÜôQAQ„ÄÇÔºàÂ•ΩÂÉè‰πüÊ≤°Âï•Â•ΩÂÜôÁöÑÔºâ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] NTTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E6%A8%A1%E6%9D%BF%5D-NTT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[‰∏Ä‰∏™ÊôÆÈÄöÁöÑ NTT Ê®°Êùø„ÄÇ‰ª£Á†ÅÈùûÂ∏∏‰∏ë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int mod = 998244353;const int maxn = 100010;const int g = 3;int n, m;int rev[maxn*4];int w_a[maxn*4], w_b[maxn*4], w_c[maxn*4];int qpow(int x, int y) &#123; int ret = 1; while (y) &#123; if (y &amp; 1) &#123; ret = 1LL*ret*x%mod; &#125; x = 1LL*x*x%mod; y &gt;&gt;= 1; &#125; return ret;&#125;void calrev(int l) &#123; rev[0] = 0; for (int i = 1; i &lt; (1&lt;&lt;l); i++) &#123; rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(l-1)); &#125;&#125;void ntt(int *a, int t, int ty) &#123; int len = 1&lt;&lt;t; for (int i = 0; i &lt; len; i++) &#123; if (rev[i] &gt; i) swap(a[i], a[rev[i]]); &#125; for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; int wn = qpow(g, (mod-1)/l); for (int s = 0; s &lt; len; s += l) &#123; int w = 1; for (int i = s; i &lt; (s + (l &gt;&gt; 1)); i++) &#123; int v1 = a[i], v2 = 1LL*a[i+(l&gt;&gt;1)]*w%mod; a[i] = (v1+v2) % mod; a[i+(l&gt;&gt;1)] = (v1-v2+mod)%mod; w = 1LL*w*wn%mod; &#125; &#125; &#125; if (ty == -1) &#123; for (int i = 1; i &lt; len/2; i++) &#123; swap(a[i], a[len-i]); &#125; int r = qpow(len, mod-2); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1LL*a[i]*r%mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;w_a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;w_b[i]); int l = 0; while ((1&lt;&lt;l) &lt; n+m+1) l ++; calrev(l); ntt(w_a, l, 1); ntt(w_b, l, 1); for (int i = 0; i &lt; (1&lt;&lt;l); i++) w_c[i] = 1LL*w_a[i]*w_b[i]%mod; ntt(w_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", w_c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>NTT</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Ê®°Êùø] FFTÊ®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E6%A8%A1%E6%9D%BF%5DFFT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÁúÅÈÄâÂâçÂ§ç‰π†„ÄÇËøôÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑ fft Ê®°Êùø„ÄÇ ÔºàÂèëÁé∞Ëá™Â∑±Â∑ÆÁÇπfftÊ®°Êùø‰∏ç‰ºöÊâì‰∫ÜÔºâ Âõ†‰∏∫Ê≤°ÊúâÈ¢ÑÂ§ÑÁêÜ&amp;&amp;Áî®‰∫ÜcomplexÁ±ªÂèØËÉΩÂ∏∏Êï∞ÊØîËæÉÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cmath&gt;using namespace std;typedef complex&lt;double&gt; C;const int maxn = 100010;int n, m;int rev[maxn*4];C c_a[maxn*4], c_b[maxn*4], c_c[maxn*4];int a[maxn], b[maxn];void fft(C *a, int len, int t) &#123; rev[0] = 0; int x = 0; while ((1&lt;&lt;x) &lt; len) ++ x; for (int i = 1; i &lt; len; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1); if (i &amp; 1) rev[i] |= (1&lt;&lt;(x-1)); &#125; for (int i = 0; i &lt; len; i++) if (rev[i] &gt; i) swap(a[rev[i]], a[i]); for (int l = 2; l &lt;= len; l &lt;&lt;= 1) &#123; C wn(cos(2*M_PI/l), t*sin(2*M_PI/l)); for (int s = 0; s &lt; len; s += l) &#123; C w(1, 0); for (int i = s; i &lt; (s+(l&gt;&gt;1)); i++) &#123; C v1 = a[i], v2 = a[i+(l&gt;&gt;1)]*w; a[i] = v1+v2; a[i+(l&gt;&gt;1)] = v1-v2; w = w * wn; &#125; &#125; &#125; if (t == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; a[i] /= len; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt;= m; i++) scanf("%d", &amp;b[i]); int l = 1; while (l &lt; n+m+1) l &lt;&lt;= 1; for (int i = 0; i &lt;= n; i++) c_a[i] = a[i]; for (int i = 0; i &lt;= m; i++) c_b[i] = b[i]; fft(c_a, l, 1); fft(c_b, l, 1); for (int i = 0; i &lt; l; i++) c_c[i] = c_a[i]*c_b[i]; fft(c_c, l, -1); for (int i = 0; i &lt;= n+m; i++) &#123; printf("%d ", int(c_c[i].real()+0.5)); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê®°Êùø]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ÊàëÂèëÁé∞Ëá™Â∑±ÁöÑ‰ª£Á†ÅËÉΩÂäõÂ§™Âº±‰∫Ü...... Êúâ‰∫õÊ®°ÊùøÈúÄË¶ÅÂπ≥Êó∂ÂÜô‰∏Ä‰∏ãÔºå‰∏çËÉΩÁé∞Âú∫ÂÜôÔºåÂê¶Âàô‰∏ç‰∏ÄÂÆöË∞ÉÁöÑÂá∫Êù•„ÄÇËøôÈáåÂàóÂá∫‰∏Ä‰∫õÂ∏∏Áî®Ê®°Êùø„ÄÇÔºà‰ºòÂåñÂ∏∏Êï∞&amp;&amp;‰ºòÂåñ‰ª£Á†ÅÂ§çÊùÇÂ∫¶&amp;&amp;ËÉå‰∏ãÊù•Ôºâ„ÄÇ Â§öÈ°πÂºèÔºö FFT NTT Â§öÈ°πÂºèÊ±ÇÈÄÜ Â§öÈ°πÂºèln Â§öÈ°πÂºèexp Â§öÈ°πÂºèÂèñÊ®° Â§öÈ°πÂºèÂ§öÁÇπÊ±ÇÂÄº Â§öÈ°πÂºèÂø´ÈÄüÊèíÂÄº Â§öÈ°πÂºèÂ§çÂêàÈÄÜ Â∏∏Á≥ªÊï∞ÈΩêÊ¨°Á∫øÊÄßÈÄíÊé® Êï∞ËÆ∫Ôºö LucasÂÆöÁêÜ exCRT ÊùúÊïôÁ≠õ Pollard-Rho Miller-Rabin min_25Á≠õ Á±ªÊ¨ßÂá†ÈáåÂæó ‰∫åÊ¨°Ââ©‰Ωô Ë≤å‰ººÊòØÊ¥≤ÈòÅÁ≠õÁöÑÁ≠õÊ≥ï È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºö Á∫øÊÆµÊ†ëÂêàÂπ∂ Ê†ëÁä∂Êï∞ÁªÑ Splay LCT ETT ÁÇπÂàÜÊ†ë Ê†ëÈìæÂâñÂàÜ Âä®ÊÄÅdp Â≠óÁ¨¶‰∏≤Ôºö ÂêéÁºÄËá™Âä®Êú∫ Âª∫ÂêéÁºÄÊ†ë ÂêéÁºÄÊï∞ÁªÑ trieÊ†ëSAM ACËá™Âä®Êú∫ ÂõûÊñáÊ†ë ÂÖ∂‰ªñÔºö FWT ÂçäÂπ≥Èù¢‰∫§ Áü©Èòµ-Ê†ëÂÆöÁêÜ ÂõæËÆ∫Ôºö ÊîØÈÖçÊ†ë ÂúÜÊñπÊ†ë ËæπÂèå]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âè£ËÉ°ÁöÑÈ¢òÁõÆ]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑËøô‰πàËèú‰∫ÜËøòÂè£ËÉ°È¢òÁõÆ...Â§ßÊ¶Ç‰ºöË∂äÊù•Ë∂äËèúÂêß.. 2019.3.29 CF 1097G \(k\) Ê¨°ÊñπÁúã‰ΩúÊòØÈÄâ \(k\) Êù°Ëæπ„ÄÇËÄÉËôëÊâÄÊúâ \(k\) Êù°ËæπÁöÑÊúâÂ∫èÂØπÔºåËÆ°ÁÆóÂåÖÂê´ÂÆÉ‰ª¨ÁöÑÈõÜÂêàÊï∞„ÄÇËÉåÂåÖ \(dp\) ‰∏Ä‰∏ãÂ∞±Â•Ω‰∫Ü„ÄÇÊ†πÊçÆÊüêËÄÉËøáÂæàÂ§öÊ¨°ÁöÑÂ§çÊùÇÂ∫¶ÂàÜÊûêÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÊòØ \(\mathcal O (nk)\)„ÄÇ]]></content>
      <tags>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gym100543G] Virus synthesis]]></title>
    <url>%2F2019%2F03%2F29%2F%5BGym100543G%5D-Virus-synthesis%2F</url>
    <content type="text"><![CDATA[È¢òÈù¢Ôºö https://codeforces.com/gym/100543/attachments/download/2854/20142015-acmicpc-central-europe-regional-contest-cerc-14-en.pdf È¢òÁõÆÂ§ßÊÑè ËæìÂÖ•‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ÁöÑÂ≠óÁ¨¶‰∏≤ \(s\)„ÄÇ‰Ω†Êúâ‰∏Ä‰∏™Á©∫‰∏≤ \(t\)Ôºå‰Ω†Ë¶ÅÊääÂÆÉÂèòÊàêËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂèØ‰ª•ËøõË°å‰ª•‰∏ãÂá†ÁßçÊìç‰ΩúÔºö Âú® \(t\) ÁöÑÂºÄÂ§¥ÊàñËÄÖÊú´Â∞æÊ∑ªÂä†‰∏Ä‰∏™Â≠óÁ¨¶„ÄÇ Êää \(t\) ÁøªËΩ¨ËøáÊù•ÔºåÁÑ∂ÂêéÊé•Âú®ÂéüÊù•ÁöÑ \(t\) ÁöÑÂºÄÂ§¥ÊàñÊú´Â∞æ„ÄÇ Ê±ÇÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ \(n \le 10^5\) Ëß£Ê≥ï Âú®ÊúÄÂêéËøûÁª≠ÁöÑËã•Âπ≤Ê¨°Âä†Â≠óÁ¨¶Êìç‰Ωú‰πãÂâçÔºå\(t\) ‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÂÄíËøáÊù•ËÄÉËôëÔºåÁî®ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞Êää \(s\) ÂèòÊàêÁ©∫‰∏≤„ÄÇÂè™ÈúÄË¶ÅÂàÜÂà´ËÄÉËôëÊØè‰∏™ÂõûÊñá‰∏≤ÁöÑÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Âª∫Á´ãÂõûÊñáÊ†ë„ÄÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏âÁßçËΩ¨ÁßªÔºö ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÁöÑÂõûÊñá‰∏≤Âèò‰∏∫‰ªñÁöÑ‰∏ÄÂçä„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåÂéªÊéâ‰ªñ‰∏§Á´ØÁöÑÂ≠óÁ¨¶„ÄÇ ‰∏Ä‰∏™ÂõûÊñá‰∏≤ÔºåËΩ¨ÁßªÂà∞‰ªñÁöÑÊúÄÈïøÂõûÊñáÂâçÁºÄ„ÄÇ ÊåâÈïøÂ∫¶‰ªéÂ∞èÂà∞Â§ßÈ°∫Â∫è \(dp\)„ÄÇÂêé‰∏§ÁßçËΩ¨ÁßªÂèØ‰ª•Áõ¥Êé•ËÆ°ÁÆó„ÄÇÂØπÁ¨¨‰∏ÄÁßçËΩ¨ÁßªÔºåÂÄçÂ¢û‰∏Ä‰∏ãÂà§Êñ≠ \(fail\) Ê†ë‰∏äÊúâÊ≤°ÊúâÈïøÂ∫¶ÊÅ∞Â•Ω‰∏∫‰∏ÄÂçäÁöÑÁ•ñÂÖàÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØÂÅáÁöÑ„ÄÇË¶ÅÁúÅÈÄâ‰∫Ü..ÂÖàË°•ÁÇπÂà´ÁöÑÂÜçÊù•ÊâìËøôÈ¢òQAQ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â≠óÁ¨¶‰∏≤ÊäÄÂ∑ß„ÄÅÊÄùÊÉ≥„ÄÅÁü•ËØÜÁÇπÊï¥ÁêÜ]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E5%B7%A7%E3%80%81%E6%80%9D%E6%83%B3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ËØ∑ËæìÂÖ•ÂØÜÁ†Å Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>ÊÄªÁªì</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lyndon wordÁöÑ‰∏Ä‰∫õÊÄßË¥®]]></title>
    <url>%2F2019%2F03%2F15%2FLyndon%2F</url>
    <content type="text"><![CDATA[wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Lyndon_word ÂÆö‰πâ Â¶ÇÊûú‰∏Ä‰∏™‰∏≤ÊúÄÂ∞èÂêéÁºÄÊòØÂÆÉÊú¨Ë∫´ÔºåÈÇ£‰πàÁß∞‰ªñ‰∏∫ Lyndon word„ÄÇÔºà‰∏é‰∏•Ê†ºÊúÄÂ∞èÂæ™ÁéØÁßª‰ΩçÁöÑÂÆö‰πâÊòØÁ≠â‰ª∑ÁöÑÔºâ Áõ∏ÂÖ≥ÊÄßË¥®ÂíåÁÆóÊ≥ï ÊÄßË¥®1 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºåÈÇ£‰πà \(s\) ‰∏çÂ≠òÂú® border„ÄÇ ÊÄßË¥®2 Â¶ÇÊûú \(s\) ÊòØ Lyndon wordÔºå\(s=uv\) ‰∏î \(u\) Âíå \(v\) ÈùûÁ©∫ÔºåÈÇ£‰πà \(u&lt;v\)„ÄÇ ÊÄßË¥®3 Â¶ÇÊûú \(s,t\) ÊòØ Lyndon word ‰∏î \(s &lt; t\)ÔºåÈÇ£‰πà \(st\) ‰πüÊòØ Lyndon word„ÄÇ ÊÄßË¥®4 ‰∏Ä‰∏™ÈïøÂ∫¶Â§ß‰∫éÁ≠â‰∫é \(2\) Â≠óÁ¨¶‰∏≤ÁöÑ \(s\) ÊòØ Lyndon word ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå\(s\) ÂèØ‰ª•ÊãÜÊàê‰∏§‰∏™ÈùûÁ©∫‰∏≤ \(u,v\)ÔºåÊª°Ë∂≥ \(u &lt; v\) ‰∏î \(u\) Âíå \(v\) ÈÉΩÊòØ Lyndon word„ÄÇ ËØÅÊòé ÂÖÖÂàÜÊÄßÂç≥‰∏ä‰∏ÄÊù°ÊÄßË¥®ÔºåÂè™ËØÅÂøÖË¶ÅÊÄß„ÄÇ ËÆæ \(s\) ÁöÑÈïøÂ∫¶‰∏∫ \(n\)ÔºåÂêéÁºÄ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄ„ÄÇ ÂÅáËÆæ \(s[1..i-1]\) ÊúâÈïøÂ∫¶‰∏∫ \(k\) ÁöÑ borderÔºåÂç≥ \(s[1..k]=s[i-k..i-1]\)„ÄÇ Âõ†‰∏∫ \(k &lt; i-1\)ÔºåÊâÄ‰ª• \(k+1 \neq i\)„ÄÇ Âõ†‰∏∫ \(s\) ÊòØ Lyndon wordÔºå\(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊâÄ‰ª• \(s[i..n]&lt;s[k+1..n]\)„ÄÇÂèàÂõ†‰∏∫ \(s[i-k..i-1]=s[1..k]\)ÔºåÊâÄ‰ª• \(s[i-k..n]&lt;s[1..n]\)ÔºåËøô‰∏é \(s\) ÊòØ Lyndon word ÁüõÁõæ„ÄÇÊâÄ‰ª• \(s[1..i-1]\) Ê≤°Êúâ border„ÄÇ Ê†πÊçÆ Lyndon word ÁöÑÂÆö‰πâÂèä \(s[1..i-1]\) Ê≤°Êúâ borderÔºåÊúâ \(\forall 1 &lt; j \le i-1\)Ôºå\(\exists j \le k \le i-1\)ÔºåÊª°Ë∂≥ \(s[k] &gt; s[k-j+1]\)ÔºåÂç≥ \(s[j..i-1] &gt; s[1..i-1]\)„ÄÇÊâÄ‰ª• \(s[1..i-1]\) ÊòØ Lyndon word„ÄÇ Âõ†‰∏∫ \(s[i..n]\) ÊòØ \(s\) ÁöÑÊ¨°Â∞èÂêéÁºÄÔºåÊòæÁÑ∂‰∏çÂ≠òÂú® \(j&gt;i\) Êª°Ë∂≥ \(s[j..n]&lt;s[i..n]\)ÔºåÊâÄ‰ª• \(s[i..n]\) ÊòØ Lyndon word„ÄÇ ÊâÄ‰ª• \(u=s[1..i-1],v=s[i..n]\) ÊòØ‰∏ÄÁªÑÂêàÊ≥ïÁöÑÊãÜÂàÜÔºåÂøÖË¶ÅÊÄßÂæóËØÅ„ÄÇ ÊÄßË¥®5 ‰ªªÊÑè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ \(s\) ÈÉΩÂèØ‰ª•ÂîØ‰∏ÄÂú∞ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÂÖ∏Â∫è‰∏çÂ¢ûÁöÑ Lyndon Word„ÄÇ ÊàëÊäΩ‰ª£Â§™Ëèú‰∫Ü...ÂÖ∂‰ªñÁöÑÊÄßË¥®‰ª•ÂêéÂÜçË°•Âêß„ÄÇ]]></content>
      <tags>
        <tag>Áü•ËØÜÁÇπ</tag>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ129] Lyndon ÂàÜËß£]]></title>
    <url>%2F2019%2F03%2F13%2F%5BLOJ129%5D-Lyndon%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ëß£Ê≥ï ÂÖ≥‰∫é Lyndon word ÁöÑ‰∏Ä‰∫õÁªìËÆ∫ÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = (1&lt;&lt;20)+10;int n;char str[maxn];int main() &#123; scanf("%s", str+1); n = int(strlen(str+1)); int s = 1, l = 0, p = 0; while (s &lt; n) &#123; l = 1; p = s+1; for (p = s+1; ; ++p) &#123; if (str[p] &lt; str[p-l]) &#123; while (s+l-1 &lt; p) &#123; printf("%d ", s+l-1); s += l; &#125; break; &#125; else if (str[p] &gt; str[p-l]) &#123; l = p-s+1; &#125; &#125; &#125; if (s &lt;= n) printf("%d ", n); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>Â≠óÁ¨¶‰∏≤</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120D] Power Tree]]></title>
    <url>%2F2019%2F03%2F11%2F%5BCodeforces1120D%5D-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/D È¢òÁõÆÂ§ßÊÑè ÁªôÂÆö‰∏ÄÊ£µ \(n\) ‰∏™ÁÇπÔºå‰ª• \(1\) ‰∏∫Ê†πÁöÑÊ†ëÔºåÁ¨¨ \(i\) ‰∏™ÁÇπÊúâ‰∏Ä‰∏™‰ª∑Ê†º \(c_i\)„ÄÇ ‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™‰∫∫‰ºöÁªôÊØè‰∏™Âè∂ËäÇÁÇπËÆæÁΩÆ‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ‰Ω†Âè™ËÉΩÂØπÂ∑≤ÁªèÈÄâÊã©ÁöÑÁÇπÂÅöÂ≠êÊ†ëÂä†‰ªªÊÑèÊï∞Â≠óÁöÑÊìç‰Ωú„ÄÇ ‰Ω†Ë¶ÅÈÄöËøáËã•Âπ≤Ê¨°Êìç‰ΩúÊääÊâÄÊúâÂè∂Â≠êËäÇÁÇπ‰∏äÁöÑÊï∞Âèò‰∏∫ \(0\)„ÄÇ ÈóÆÔºöË¶ÅÁ°Æ‰øùÂè¶‰∏Ä‰∏™‰∫∫Êó†ËÆ∫ÊÄé‰πàÊìç‰Ωú‰Ω†ÈÉΩËÉΩÊääÂè∂Â≠ê‰∏äÁöÑÊï∞ÂèòÊàê \(0\)Ôºå‰Ω†ÈÄâÊã©ÁöÑÁÇπ‰ª∑Ê†ºÊÄªÂíåÊúÄÂ∞èÊòØ‰ªÄ‰πàÔºüÊúâÂì™‰∫õÁÇπË¢´Ëá≥Â∞ë‰∏ÄÁßçÊúÄÂ∞è‰ª∑Ê†ºÁöÑÊñπÊ°àÂåÖÂê´Ôºü \(n \le 200000\)Ôºå\(0\le c_i \le 10^9\)„ÄÇ Ëß£Ê≥ï Ëøô‰∏™ÈóÆÈ¢òÂèØ‰ª•ÁúãÊàêÔºå‰Ω†Ë¶ÅÈÄâ‰∏Ä‰∫õÁÇπ‰Ωú‰∏∫Êú™Áü•Êï∞ÔºåÊØè‰∏™Âè∂Â≠êÁöÑÈôêÂà∂ÊûÑÊàê‰∫Ü‰∏Ä‰∏™ÊñπÁ®ãÔºå‰Ω†Ë¶ÅËÆ©Ëøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÊª°Ë∂≥ÔºåÊó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåËøô‰∏™Á∫øÊÄßÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Âõ†‰∏∫‰ª∑Ê†ºÊòØÈùûË¥üÊï¥Êï∞ÔºåÂ¶ÇÊûúÁ≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÁõ∏ÂÖ≥ÔºåÂøÖÂèØ‰ª•Âà†Èô§Êüê‰∏ÄÂàóÔºåÂç≥ÂèØ‰ª•Â∞ëÈÄâ‰∏Ä‰∏™ÁÇπÔºåËøôÊ†∑‰∏ÄÂÆö‰∏ç‰ºöÂèòÁöÑÊõ¥Â∑ÆÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥„ÄÇÂõ†‰∏∫Êó†ËÆ∫Â∏∏Êï∞È°πÁöÑÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩË¶ÅÊúâËß£ÔºåÊâÄ‰ª•Ë°åÊï∞Á≠â‰∫éÂàóÊï∞„ÄÇ ÁªìËÆ∫ ËÆæÂè∂ËäÇÁÇπ‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∏Ä‰∏™ÂåÖÂê´ÊÅ∞Â•Ω \(x\) ‰∏™ÁÇπÁöÑÈÄâÂèñÊñπÊ°àËÉΩ‰øùËØÅÂèØ‰ª•Â∞ÜÊâÄÊúâÂè∂Â≠ê‰∏äÁöÑÊï∞Â≠óÂèòÊàê \(0\) ÁöÑÂÖÖË¶ÅÊù°‰ª∂ÊòØÔºå‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞Ê†πÁöÑË∑ØÂæÑ‰∏äÔºåÂ≠òÂú®Ë¢´ÈÄâÂèñÁöÑÁÇπÔºå‰∏îÊ∑±Â∫¶ÊúÄÂ§ßÁöÑË¢´ÈÄâÂèñÁÇπ‰∏çÂêå„ÄÇ ËØÅÊòé ÂøÖË¶ÅÊÄßÊòæÁÑ∂„ÄÇ ÂÖÖÂàÜÊÄßÔºöÊääÊñπÁ®ãÁªÑÁöÑÊú™Áü•Êï∞Êåâ‰ªªÊÑè‰∏ÄÁßç \(dfs\) Â∫èÊéíÂàóÔºåÁ≥ªÊï∞Áü©Èòµ‰∏≠ÔºåÊØè‰∏ÄË°åÁöÑÁ¨¨‰∏Ä‰∏™Èùû \(0\) ÂÖÉÁ¥†ÊâÄÂú®ÁöÑÂàóÈÉΩ‰∏çÂêåÔºåÊâÄ‰ª•Á≥ªÊï∞Áü©ÈòµÁöÑÂàóÂêëÈáèÁªÑÁ∫øÊÄßÊó†ÂÖ≥ÔºåÂèàÂõ†‰∏∫Ë°åÊï∞Á≠â‰∫éÂàóÊï∞ÔºåÊâÄ‰ª•Êó†ËÆ∫Â∏∏Êï∞È°πÂèñÂÄºÊòØ‰ªÄ‰πàÔºåÊñπÁ®ãÁªÑÈÉΩÊúâËß£„ÄÇ Áä∂ÊÄÅ \(dp[i][j][k]\) Ôºö \(i\) Ë°®Á§∫Âè™ËÄÉËôë‰ª• \(i\) ‰∏∫Ê†πÁöÑÂ≠êÊ†ë„ÄÇ \(j\) Ë°®Á§∫ \(i\) ÊòØÂê¶Ë¢´ÈÄâÊã©„ÄÇ \(k\) Ë°®Á§∫ÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Âè∂Â≠êÔºå‰ªñÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏≠Ê≤°ÊúâÁÇπË¢´ÈÄâÊã©„ÄÇ \(dp\) Êï∞ÁªÑ‰∏≠Â≠òÁöÑÊòØÔºåÊª°Ë∂≥‰ªªÊÑè‰∏§‰∏™Âè∂Â≠êÂà∞ \(i\) ÁöÑË∑ØÂæÑ‰∏äÊ∑±Â∫¶ÊúÄÂ§ßÁöÑÁ•ñÂÖà‰∏çÂêåÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÁúã‰Ωú \(0\)ÔºâÁöÑÊúÄÂ∞è‰ª∑Ê†ºÂíå„ÄÇ \(dp\) ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéËÆ∞ÂΩïÂì™‰∫õËΩ¨ÁßªÂèØ‰ª•ÂèñÂà∞ÊúÄ‰ºòÂÄºÔºåÊúÄÂêé‰ªéÊ†πÂºÄÂßã \(dfs\) ‰∏ÄÈÅçÊ±ÇÊñπÊ°àÂç≥ÂèØ„ÄÇ ‰ª£Á†Å ÔºàÂ∑®‰∏ëÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 200010;const ll inf = 1e18;int c[maxn], vis[4*maxn], n;ll dp[maxn][2][2];vector&lt;int&gt; tree[maxn], tran[maxn*4];void dfs1(int u, int f) &#123; dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; dfs1(v, u); &#125; &#125; if (u == 1 || tree[u].size() &gt; 1) &#123; ll s = 0, mn = inf, cm = inf; for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; s += min(dp[v][0][0], dp[v][1][0]); ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t &lt;= mn) &#123; cm = mn; mn = t; &#125; else if (t &lt; cm) cm = t; &#125; &#125; dp[u][0][0] = s; dp[u][0][1] = s+mn; dp[u][1][0] = min(s+c[u]+mn, s+c[u]); for (int i = 0; i &lt; tree[u].size(); i++) &#123; int v = tree[u][i]; if (v != f) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+0].push_back(v*4+2*0+0); tran[u*4+2*0+0].push_back(v*4+2*1+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &gt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; ll t = dp[v][0][1] - min(dp[v][0][0], dp[v][1][0]); if (t == mn) &#123; if (mn == cm) &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; tran[u*4+2*0+1].push_back(v*4+2*0+1); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+1); &#125; else &#123; if (dp[v][0][0] &lt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); &#125; else if (dp[v][0][0] &gt; dp[v][1][0]) &#123; tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; else &#123; tran[u*4+2*0+1].push_back(v*4+2*0+0); tran[u*4+2*0+1].push_back(v*4+2*1+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*0+0); if (mn &lt;= 0) tran[u*4+2*1+0].push_back(v*4+2*1+0); &#125; &#125; &#125; &#125; &#125; else &#123; dp[u][1][0] = c[u]; dp[u][0][1] = 0; &#125;&#125;void dfs2(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; tran[u].size(); i++) &#123; int v = tran[u][i]; if (!vis[v]) dfs2(v); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); tree[u].push_back(v); tree[v].push_back(u); &#125; dfs1(1, 0); int cnt = 0; ll ans = min(dp[1][0][0], dp[1][1][0]); printf("%lld ", ans); if (dp[1][0][0] == ans) dfs2(4*1+2*0+0); if (dp[1][1][0] == ans) dfs2(4*1+2*1+0); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; cnt ++; &#125; &#125; printf("%d\n", cnt); for (int i = 1; i &lt;= n; i++) &#123; if (vis[4*i+2*1+0] || vis[4*i+2*1+1]) &#123; printf("%d ", i); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces1120C] Compress String]]></title>
    <url>%2F2019%2F03%2F11%2F-%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé•Ôºö https://codeforces.com/contest/1120/problem/C È¢òÁõÆÂ§ßÊÑè ‰Ω†Êúâ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ \(n\) ‰∏™Â≠óÁ¨¶‰∏≤ \(s\)„ÄÇ ËØ∑‰Ω†Êää \(s\) ÊãÜÊàêËã•Âπ≤‰∏™Â≠óÁ¨¶‰∏≤ \(s=t_1t_2\cdots t_k\)„ÄÇ ÂØπ‰∫éÁ¨¨ \(i\) ‰∏™‰∏≤ÔºåËã• \(t_i\) ÊòØ \(t_1t_2\cdots t_{i-1}\) ÁöÑÂ≠óÁ¨¶‰∏≤Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(b\) ÁöÑ‰ª£‰ª∑ÔºåÂê¶Âàô \(t_i\) ÈïøÂ∫¶ÂøÖÈ°ª‰∏∫ \(1\)Ôºå‰Ω†ÈúÄË¶Å‰ªòÂá∫ \(a\) ÁöÑ‰ª£‰ª∑„ÄÇÊ±ÇÊúÄÂ∞è‰ª£‰ª∑„ÄÇ \(n \le 5000\)ÔºåÂ≠óÁ¨¶ÈõÜÂ§ßÂ∞è \(26\)„ÄÇ Ëß£Ê≥ï ËÆæ \(dp_i\) Ë°®Á§∫Ââç \(i\) ‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂ∞èÂàíÂàÜÔºåÂú®Ê±ÇÂá∫ \(dp_i\) ÂêéÁî® \(kmp\) ÊâæÊúÄÈïøÂú®ÂâçÈù¢Âá∫Áé∞ËøáÁöÑ‰ªé \(i+1\) ÂºÄÂßãÁöÑ‰∏≤ÔºåÊõ¥Êñ∞ÊâÄÊúâ \(dp_j\)„ÄÇ ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, a, b, fail[maxn], dp[maxn];char s[maxn];int main() &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); scanf("%s", s+1); fail[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; int cur = fail[i-1]; while (cur != -1) &#123; if (s[cur+1] == s[i]) &#123; fail[i] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; for (int i = 1; i &lt;= n; i++) dp[i] = inf; for (int i = 0; i &lt;= n; i++) &#123; fail[0] = -1; for (int j = 1; i+j &lt;= n; j++) &#123; int cur = fail[j-1]; fail[j] = 0; while (cur != -1) &#123; if (s[i+cur+1] == s[i+j]) &#123; fail[j] = cur+1; break; &#125; cur = fail[cur]; &#125; &#125; int p = 0, mx = 0; for (int j = 1; j &lt;= i; j++) &#123; while (p != -1) &#123; if (s[i+p+1] == s[j]) &#123; ++ p; break; &#125; if (p) p = fail[p]; else break; &#125; if (p &gt; mx) mx = p; &#125; for (int j = 1; j &lt;= mx; j++) &#123; dp[i+j] = min(dp[i+j], dp[i]+b); &#125; dp[i+1] = min(dp[i+1], dp[i]+a); &#125; printf("%d\n", dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>È¢òËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçöÂºàÊï¥ÁêÜÔºà‰∏ÄÔºâ]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Impartial game wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Impartial_game impartial game ÊòØÊåáÊª°Ë∂≥Â¶Ç‰∏ãÊù°‰ª∂ÁöÑÊ∏∏ÊàèÔºö - ‰∏§‰∏™Áé©ÂÆ∂ËΩÆÊµÅÊìç‰ΩúÔºåÁõ¥Âà∞ËææÂà∞‰∏çËÉΩÊìç‰ΩúÁöÑÁä∂ÊÄÅÔºàterminal positionÔºâ„ÄÇ - ÂΩì‰∏Ä‰∏™Áé©ÂÆ∂‰∏çËÉΩÊìç‰ΩúÊó∂Ôºåwinner Â∞±Ë¢´Á°ÆÂÆö‰∫Ü„ÄÇ - ÊØè‰∏™Áä∂ÊÄÅÁöÑÊìç‰ΩúÊï∞ÂíåÁä∂ÊÄÅÊÄªÊï∞ÊòØÊúâÈôêÁöÑ„ÄÇ - ÊâÄÊúâÁöÑÊìç‰ΩúÂøÖÈ°ªÂêåÊó∂ËÉΩË¢´‰∏§‰∏™Áé©ÂÆ∂ËøõË°å„ÄÇ - ÊâÄÊúâÊìç‰ΩúÁöÑÁªìÊûúÈÉΩÊòØÁ°ÆÂÆöÊÄßÁöÑ„ÄÇ Normal play convention wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Normal_play_convention Impartial game ÁöÑ Normal play convention ÔºöÊúÄÂêé‰∏Ä‰∏™ÂèØ‰ª•Êìç‰ΩúÁöÑÁé©ÂÆ∂Ëé∑ËÉú„ÄÇ NimÊ∏∏Êàè wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Nim ÊúâËã•Âπ≤Â†ÜÁü≥Â≠êÔºå‰∏§‰∏™‰∫∫ËΩÆÊµÅÂèñÁü≥Â≠ê„ÄÇÊØèÊ¨°ËΩÆÂà∞ÁöÑ‰∫∫ÂèØ‰ª•ÈÄâÊã©‰ªéÊüê‰∏ÄÂ†Ü‰∏≠ÊãøËµ∞Ëã•Âπ≤È¢óÁü≥Â≠êÔºà‰∏çËÉΩ‰∏çÊãøÔºâÔºå‰∏çËÉΩÊåâËßÑÂàôÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ Nim Ê∏∏ÊàèÂ±û‰∫é Impartial game„ÄÇ NimÊ∏∏ÊàèÁöÑËÉúÂà©Êù°‰ª∂ ÂÆöÁêÜÔºöÂΩì‰∏î‰ªÖÂΩìÊØèÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) Êó∂ÔºåÂÖàÊâãÂøÖËÉú„ÄÇ ËØÅÊòéÔºö ÂØπ‰∫é terminal positionÔºåÂç≥Ê≤°ÊúâÁü≥ÁöÑÊÉÖÂÜµÔºåÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåËΩÆÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑ‰∫∫Ëæì„ÄÇÂÆöÁêÜÂØπ terminal position ÊàêÁ´ã„ÄÇ ÂºïÁêÜ1 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\)ÔºåÂàôÂÆÉÂøÖÂÆöÂèØ‰ª•ËΩ¨ÁßªÂà∞‰∏Ä‰∏™Áü≥Â≠ê‰∏™Êï∞‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\)„ÄÇ ËÆæ \(s\) ÊúÄÈ´òÁöÑ‰∫åËøõÂà∂‰ΩçÊòØÁ¨¨ \(k\) ‰ΩçÔºà‰ªé‰ΩéÂà∞È´òÔºåÊúÄ‰Ωé‰Ωç‰∏∫Á¨¨ \(0\) ‰ΩçÔºâ„ÄÇ ‰∏ÄÂÆöÂ≠òÂú®‰∏ÄÂ†ÜÁü≥Â≠ê‰∏™Êï∞‰∏∫ \(x\)Ôºå‰∫åËøõÂà∂‰∏ã \(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)„ÄÇ Èô§‰∫ÜËøôÂ†ÜÁü≥Â≠êÂ§ñÔºåÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏∫ \(s\oplus x\)„ÄÇ \(s\oplus x\) Âíå \(x\) Âú®ÊâÄÊúâÊØîÁ¨¨ \(k\) ‰ΩçÈ´òÁöÑ‰∫åËøõÂà∂‰Ωç‰∏äÁõ∏Á≠âÔºå\(s\oplus x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(0\)Ôºå\(x\) ÁöÑÁ¨¨ \(k\) ‰Ωç‰∏∫ \(1\)ÔºåÊâÄ‰ª• \(s \oplus x &lt; x\)„ÄÇ ÂèØ‰ª•‰ªéËøôÂ†ÜÁü≥Â≠ê‰∏≠ÂèñËµ∞ \(x-s\oplus x\) ‰∏™Áü≥Â≠êÔºå‰ΩøÂºÇÊàñÂíåÂèò‰∏∫ \(0\)„ÄÇ ÂºïÁêÜ2 Ëã•‰∏Ä‰∏™Áä∂ÊÄÅÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏∫ \(0\)ÔºåÊó†ËÆ∫ÊÄé‰πàÊìç‰ΩúÈÉΩ‰ºöËΩ¨ÁßªÂà∞‰∏Ä‰∏™ÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÂºÇÊàñÂíå‰∏ç‰∏∫ \(0\) ÁöÑÁä∂ÊÄÅ„ÄÇ ËØÅÊòéÔºö ËÆæÊìç‰ΩúÁöÑÂ†ÜÂú®Êìç‰ΩúÂâçÊúâ \(x\) È¢óÁü≥Â≠ê„ÄÇ ÈÇ£‰πàÈô§‰∫ÜËøôÂ†Ü‰ª•Â§ñÁöÑÂÖ∂‰ªñÂ†ÜÁü≥Â≠êÊï∞ÂºÇÊàñÂíå‰πü‰∏∫ \(x\)„ÄÇ Âú®ÂèñÁü≥Â≠êÂêéÔºåËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏ÄÂÆö‰∏ç‰∏∫ \(x\)„ÄÇ Âè™ÊúâËøôÂ†ÜÁü≥Â≠êÁöÑ‰∏™Êï∞‰∏∫ \(x\) Êó∂Ôºå‰∏éÂÖ∂‰ªñÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíåÊâç‰ºö‰∏∫ \(0\)„ÄÇ ÊâÄ‰ª•Êìç‰ΩúÂêéÔºåÊØèÂ†ÜÁü≥Â≠ê‰∏™Êï∞ÁöÑÂºÇÊàñÂíå‰∏ÄÂÆöÈùû \(0\)„ÄÇ Ê†πÊçÆÁªìÊûÑÂΩíÁ∫≥Ê≥ïÂèØÁü•ÂÆöÁêÜÊàêÁ´ã„ÄÇ Sprague‚ÄìGrundy ÂÆöÁêÜ wikipediaÈìæÊé•Ôºöhttps://en.wikipedia.org/wiki/Sprague‚ÄìGrundy_theorem ÂÆö‰πâ \(mex\) ËøêÁÆóÔºå‰∏Ä‰∏™ÈõÜÂêàÁöÑ \(mex\) ÂÄºÊòØÊúÄÂ∞èÁöÑÊ≤°ÊúâÂá∫Áé∞Âú®Ëøô‰∏™ÈõÜÂêà‰∏≠ÁöÑËá™ÁÑ∂Êï∞„ÄÇ ÂÆö‰πâ Sprague-Grundy ÂáΩÊï∞ÔºöÂØπ‰∫é‰∏Ä‰∏™Áä∂ÊÄÅ \(x\)ÔºåÂΩì \(x\) ÊòØ terminal position Êó∂Ôºå\(SG(x)=mex\{SG(y)|x\) ÂèØ‰ª•ËΩ¨ÁßªÂà∞ \(y\}\)„ÄÇ ÂèØ‰ª•Áî® Sprague-Grundy ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏™Áä∂ÊÄÅÊòØÂøÖËÉúÁä∂ÊÄÅËøòÊòØÂøÖË¥•Áä∂ÊÄÅÔºåÂõ†‰∏∫ÂøÖËÉúÁä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏ç‰∏∫ \(0\)ÔºåÂøÖË¥•Áä∂ÊÄÅÂáΩÊï∞ÂÄºÂøÖ‰∏∫ \(0\)„ÄÇ ÂÆö‰πâ‰∏§‰∏™Ê∏∏ÊàèÁöÑ disjunctive sum ‰∏∫‰∏Ä‰∏™Ê∏∏ÊàèÔºöËΩÆÂà∞ÊØè‰∏™Áé©ÂÆ∂ÁöÑÊó∂ÂÄôÔºå‰ªñÂèØ‰ª•ÈÄâÊã©‰∏§‰∏™Ê∏∏Êàè‰∏≠ÁöÑ‰∏Ä‰∏™Ê∏∏ÊàèÔºåÁÑ∂ÂêéÂú®Ëøô‰∏™Ê∏∏Êàè‰∏äÊìç‰Ωú‰∏ÄÊ≠•ÔºåÊó†Ê≥ïÊìç‰ΩúÁöÑ‰∫∫Ëæì„ÄÇ ÊòæÁÑ∂ disjunctive sum Êª°Ë∂≥‰∫§Êç¢ÂæãÂíåÁªìÂêàÂæã„ÄÇ ÂÆöÁêÜ Êúâ \(n\) ‰∏™Ê∏∏Êàè \(G_1,G_2,\cdots,G_n\)ÔºåËÆæ‰ªñ‰ª¨ÁöÑ disjunctive sum ‰∏∫ \(G\)„ÄÇÈÇ£‰πà \(SG(G)=SG(G_1)\oplus SG(G_2)\cdots \oplus SG(G_n)\)„ÄÇ ËØÅÊòéÂèØ‰ª•ÁúãËøô‰∏™„ÄÇ Ëøô‰πüËØ¥Êòé‰∫ÜÊØè‰∏Ä‰∏™ normal play convention ‰∏ãÁöÑ impartial game ÈÉΩÁ≠â‰ª∑‰∫é‰∏Ä‰∏™NimÊ∏∏Êàè„ÄÇ]]></content>
      <tags>
        <tag>ÂçöÂºà</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2019%2F03%2F08%2FHello-World%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
